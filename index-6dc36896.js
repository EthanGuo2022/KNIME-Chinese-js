(function () {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
        r(o);
    new MutationObserver(o => {
        for (const i of o)
            if (i.type === "childList")
                for (const s of i.addedNodes)
                    s.tagName === "LINK" && s.rel === "modulepreload" && r(s)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(o) {
        const i = {};
        return o.integrity && (i.integrity = o.integrity),
        o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy),
        o.crossOrigin === "use-credentials" ? i.credentials = "include" : o.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function r(o) {
        if (o.ep)
            return;
        o.ep = !0;
        const i = n(o);
        fetch(o.href, i)
    }
})();
function T1(e, t) {
    const n = Object.create(null),
    r = e.split(",");
    for (let o = 0; o < r.length; o++)
        n[r[o]] = !0;
    return t ? o => !!n[o.toLowerCase()] : o => !!n[o]
}
const xn = {}, Gd = [], Cs = () => {}, HG = () => !1, UG = /^on[^a-z]/, Km = e => UG.test(e), DS = e => e.startsWith("onUpdate:"), jn = Object.assign, NS = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}, qG = Object.prototype.hasOwnProperty, un = (e, t) => qG.call(e, t), st = Array.isArray, Xd = e => Zf(e) === "[object Map]", Wu = e => Zf(e) === "[object Set]", EE = e => Zf(e) === "[object Date]", YG = e => Zf(e) === "[object RegExp]", Ot = e => typeof e == "function", Gn = e => typeof e == "string", Zp = e => typeof e == "symbol", In = e => e !== null && typeof e == "object", RS = e => In(e) && Ot(e.then) && Ot(e.catch), CR = Object.prototype.toString, Zf = e => CR.call(e), KG = e => Zf(e).slice(8, -1), IR = e => Zf(e) === "[object Object]", LS = e => Gn(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, yp = T1(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), M1 = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
}, GG = /-(\w)/g, Uo = M1(e => e.replace(GG, (t, n) => n ? n.toUpperCase() : "")), XG = /\B([A-Z])/g, Hi = M1(e => e.replace(XG, "-$1").toLowerCase()), Gm = M1(e => e.charAt(0).toUpperCase() + e.slice(1)), wp = M1(e => e ? `on${Gm(e)}` : ""), ff = (e, t) => !Object.is(e, t), Jd = (e, t) => {
    for (let n = 0; n < e.length; n++)
        e[n](t)
}, I0 = (e, t, n) => {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        value: n
    })
}, T0 = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}, M0 = e => {
    const t = Gn(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
};
let OE;
const fk = () => OE || (OE = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), JG = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console", ZG = T1(JG);
function Yt(e) {
    if (st(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
            o = Gn(r) ? nX(r) : Yt(r);
            if (o)
                for (const i in o)
                    t[i] = o[i]
        }
        return t
    } else {
        if (Gn(e))
            return e;
        if (In(e))
            return e
    }
}
const QG = /;(?![^(]*\))/g, eX = /:([^]+)/, tX = /\/\*[^]*?\*\//g;
function nX(e) {
    const t = {};
    return e.replace(tX, "").split(QG).forEach(n => {
        if (n) {
            const r = n.split(eX);
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
        }
    }),
    t
}
function he(e) {
    let t = "";
    if (Gn(e))
        t = e;
    else if (st(e))
        for (let n = 0; n < e.length; n++) {
            const r = he(e[n]);
            r && (t += r + " ")
        }
    else if (In(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function wu(e) {
    if (!e)
        return null;
    let {
        class: t,
        style: n
    } = e;
    return t && !Gn(t) && (e.class = he(t)),
    n && (e.style = Yt(n)),
    e
}
const rX = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", oX = T1(rX);
function TR(e) {
    return !!e || e === ""
}
function iX(e, t) {
    if (e.length !== t.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++)
        n = Zl(e[r], t[r]);
    return n
}
function Zl(e, t) {
    if (e === t)
        return !0;
    let n = EE(e),
    r = EE(t);
    if (n || r)
        return n && r ? e.getTime() === t.getTime() : !1;
    if (n = Zp(e), r = Zp(t), n || r)
        return e === t;
    if (n = st(e), r = st(t), n || r)
        return n && r ? iX(e, t) : !1;
    if (n = In(e), r = In(t), n || r) {
        if (!n || !r)
            return !1;
        const o = Object.keys(e).length,
        i = Object.keys(t).length;
        if (o !== i)
            return !1;
        for (const s in e) {
            const a = e.hasOwnProperty(s),
            l = t.hasOwnProperty(s);
            if (a && !l || !a && l || !Zl(e[s], t[s]))
                return !1
        }
    }
    return String(e) === String(t)
}
function P1(e, t) {
    return e.findIndex(n => Zl(n, t))
}
const Re = e => Gn(e) ? e : e == null ? "" : st(e) || In(e) && (e.toString === CR || !Ot(e.toString)) ? JSON.stringify(e, MR, 2) : String(e), MR = (e, t) => t && t.__v_isRef ? MR(e, t.value) : Xd(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, o]) => (n[`${r} =>`] = o, n), {})
}
 : Wu(t) ? {
    [`Set(${t.size})`]: [...t.values()]
}
 : In(t) && !st(t) && !IR(t) ? String(t) : t;
let mi;
class BS {
    constructor(t = !1) {
        this.detached = t,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = mi,
        !t && mi && (this.index = (mi.scopes || (mi.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const n = mi;
            try {
                return mi = this,
                t()
            } finally {
                mi = n
            }
        }
    }
    on() {
        mi = this
    }
    off() {
        mi = this.parent
    }
    stop(t) {
        if (this._active) {
            let n,
            r;
            for (n = 0, r = this.effects.length; n < r; n++)
                this.effects[n].stop();
            for (n = 0, r = this.cleanups.length; n < r; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0, r = this.scopes.length; n < r; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !t) {
                const o = this.parent.scopes.pop();
                o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function PR(e) {
    return new BS(e)
}
function ER(e, t = mi) {
    t && t.active && t.effects.push(e)
}
function E1() {
    return mi
}
function OR(e) {
    mi && mi.cleanups.push(e)
}
const VS = e => {
    const t = new Set(e);
    return t.w = 0,
    t.n = 0,
    t
}, $R = e => (e.w & Ql) > 0, AR = e => (e.n & Ql) > 0, sX = ({
    deps: e
}) => {
    if (e.length)
        for (let t = 0; t < e.length; t++)
            e[t].w |= Ql
}, aX = e => {
    const {
        deps: t
    } = e;
    if (t.length) {
        let n = 0;
        for (let r = 0; r < t.length; r++) {
            const o = t[r];
            $R(o) && !AR(o) ? o.delete(e) : t[n++] = o,
            o.w &= ~Ql,
            o.n &= ~Ql
        }
        t.length = n
    }
}, P0 = new WeakMap;
let op = 0, Ql = 1;
const hk = 30;
let _s;
const nu = Symbol(""), pk = Symbol("");
class Xm {
    constructor(t, n = null, r) {
        this.fn = t,
        this.scheduler = n,
        this.active = !0,
        this.deps = [],
        this.parent = void 0,
        ER(this, r)
    }
    run() {
        if (!this.active)
            return this.fn();
        let t = _s,
        n = zl;
        for (; t; ) {
            if (t === this)
                return;
            t = t.parent
        }
        try {
            return this.parent = _s,
            _s = this,
            zl = !0,
            Ql = 1 << ++op,
            op <= hk ? sX(this) : $E(this),
            this.fn()
        } finally {
            op <= hk && aX(this),
            Ql = 1 << --op,
            _s = this.parent,
            zl = n,
            this.parent = void 0,
            this.deferStop && this.stop()
        }
    }
    stop() {
        _s === this ? this.deferStop = !0 : this.active && ($E(this), this.onStop && this.onStop(), this.active = !1)
    }
}
function $E(e) {
    const {
        deps: t
    } = e;
    if (t.length) {
        for (let n = 0; n < t.length; n++)
            t[n].delete(e);
        t.length = 0
    }
}
function lX(e, t) {
    e.effect && (e = e.effect.fn);
    const n = new Xm(e);
    t && (jn(n, t), t.scope && ER(n, t.scope)),
    (!t || !t.lazy) && n.run();
    const r = n.run.bind(n);
    return r.effect = n,
    r
}
function cX(e) {
    e.effect.stop()
}
let zl = !0;
const DR = [];
function Qf() {
    DR.push(zl),
    zl = !1
}
function eh() {
    const e = DR.pop();
    zl = e === void 0 ? !0 : e
}
function ei(e, t, n) {
    if (zl && _s) {
        let r = P0.get(e);
        r || P0.set(e, r = new Map);
        let o = r.get(n);
        o || r.set(n, o = VS()),
        NR(o)
    }
}
function NR(e, t) {
    let n = !1;
    op <= hk ? AR(e) || (e.n |= Ql, n = !$R(e)) : n = !e.has(_s),
    n && (e.add(_s), _s.deps.push(e))
}
function Ga(e, t, n, r, o, i) {
    const s = P0.get(e);
    if (!s)
        return;
    let a = [];
    if (t === "clear")
        a = [...s.values()];
    else if (n === "length" && st(e)) {
        const l = Number(r);
        s.forEach((c, u) => {
            (u === "length" || u >= l) && a.push(c)
        })
    } else
        switch (n !== void 0 && a.push(s.get(n)), t) {
        case "add":
            st(e) ? LS(n) && a.push(s.get("length")) : (a.push(s.get(nu)), Xd(e) && a.push(s.get(pk)));
            break;
        case "delete":
            st(e) || (a.push(s.get(nu)), Xd(e) && a.push(s.get(pk)));
            break;
        case "set":
            Xd(e) && a.push(s.get(nu));
            break
        }
    if (a.length === 1)
        a[0] && mk(a[0]);
    else {
        const l = [];
        for (const c of a)
            c && l.push(...c);
        mk(VS(l))
    }
}
function mk(e, t) {
    const n = st(e) ? e : [...e];
    for (const r of n)
        r.computed && AE(r);
    for (const r of n)
        r.computed || AE(r)
}
function AE(e, t) {
    (e !== _s || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
}
function uX(e, t) {
    var n;
    return (n = P0.get(e)) == null ? void 0 : n.get(t)
}
const dX = T1("__proto__,__v_isRef,__isVue"), RR = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Zp)), fX = O1(), hX = O1(!1, !0), pX = O1(!0), mX = O1(!0, !0), DE = gX();
function gX() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function (...n) {
            const r = Xt(this);
            for (let i = 0, s = this.length; i < s; i++)
                ei(r, "get", i + "");
            const o = r[t](...n);
            return o === -1 || o === !1 ? r[t](...n.map(Xt)) : o
        }
    }),
    ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function (...n) {
            Qf();
            const r = Xt(this)[t].apply(this, n);
            return eh(),
            r
        }
    }),
    e
}
function vX(e) {
    const t = Xt(this);
    return ei(t, "has", e),
    t.hasOwnProperty(e)
}
function O1(e = !1, t = !1) {
    return function (r, o, i) {
        if (o === "__v_isReactive")
            return !e;
        if (o === "__v_isReadonly")
            return e;
        if (o === "__v_isShallow")
            return t;
        if (o === "__v_raw" && i === (e ? t ? zR : WR : t ? jR : FR).get(r))
            return r;
        const s = st(r);
        if (!e) {
            if (s && un(DE, o))
                return Reflect.get(DE, o, i);
            if (o === "hasOwnProperty")
                return vX
        }
        const a = Reflect.get(r, o, i);
        return (Zp(o) ? RR.has(o) : dX(o)) || (e || ei(r, "get", o), t) ? a : Dr(a) ? s && LS(o) ? a : a.value : In(a) ? e ? jS(a) : es(a) : a
    }
}
const yX = LR(), wX = LR(!0);
function LR(e = !1) {
    return function (n, r, o, i) {
        let s = n[r];
        if (bu(s) && Dr(s) && !Dr(o))
            return !1;
        if (!e && (!Qp(o) && !bu(o) && (s = Xt(s), o = Xt(o)), !st(n) && Dr(s) && !Dr(o)))
            return s.value = o, !0;
        const a = st(n) && LS(r) ? Number(r) < n.length : un(n, r),
        l = Reflect.set(n, r, o, i);
        return n === Xt(i) && (a ? ff(o, s) && Ga(n, "set", r, o) : Ga(n, "add", r, o)),
        l
    }
}
function bX(e, t) {
    const n = un(e, t);
    e[t];
    const r = Reflect.deleteProperty(e, t);
    return r && n && Ga(e, "delete", t, void 0),
    r
}
function _X(e, t) {
    const n = Reflect.has(e, t);
    return (!Zp(t) || !RR.has(t)) && ei(e, "has", t),
    n
}
function kX(e) {
    return ei(e, "iterate", st(e) ? "length" : nu),
    Reflect.ownKeys(e)
}
const BR = {
    get: fX,
    set: yX,
    deleteProperty: bX,
    has: _X,
    ownKeys: kX
}, VR = {
    get: pX,
    set(e, t) {
        return !0
    },
    deleteProperty(e, t) {
        return !0
    }
}, xX = jn({}, BR, {
    get: hX,
    set: wX
}), SX = jn({}, VR, {
    get: mX
}), FS = e => e, $1 = e => Reflect.getPrototypeOf(e);
function hv(e, t, n = !1, r = !1) {
    e = e.__v_raw;
    const o = Xt(e),
    i = Xt(t);
    n || (t !== i && ei(o, "get", t), ei(o, "get", i));
    const {
        has: s
    } = $1(o),
    a = r ? FS : n ? zS : em;
    if (s.call(o, t))
        return a(e.get(t));
    if (s.call(o, i))
        return a(e.get(i));
    e !== o && e.get(t)
}
function pv(e, t = !1) {
    const n = this.__v_raw,
    r = Xt(n),
    o = Xt(e);
    return t || (e !== o && ei(r, "has", e), ei(r, "has", o)),
    e === o ? n.has(e) : n.has(e) || n.has(o)
}
function mv(e, t = !1) {
    return e = e.__v_raw,
    !t && ei(Xt(e), "iterate", nu),
    Reflect.get(e, "size", e)
}
function NE(e) {
    e = Xt(e);
    const t = Xt(this);
    return $1(t).has.call(t, e) || (t.add(e), Ga(t, "add", e, e)),
    this
}
function RE(e, t) {
    t = Xt(t);
    const n = Xt(this), {
        has: r,
        get: o
    } = $1(n);
    let i = r.call(n, e);
    i || (e = Xt(e), i = r.call(n, e));
    const s = o.call(n, e);
    return n.set(e, t),
    i ? ff(t, s) && Ga(n, "set", e, t) : Ga(n, "add", e, t),
    this
}
function LE(e) {
    const t = Xt(this), {
        has: n,
        get: r
    } = $1(t);
    let o = n.call(t, e);
    o || (e = Xt(e), o = n.call(t, e)),
    r && r.call(t, e);
    const i = t.delete(e);
    return o && Ga(t, "delete", e, void 0),
    i
}
function BE() {
    const e = Xt(this),
    t = e.size !== 0,
    n = e.clear();
    return t && Ga(e, "clear", void 0, void 0),
    n
}
function gv(e, t) {
    return function (r, o) {
        const i = this,
        s = i.__v_raw,
        a = Xt(s),
        l = t ? FS : e ? zS : em;
        return !e && ei(a, "iterate", nu),
        s.forEach((c, u) => r.call(o, l(c), l(u), i))
    }
}
function vv(e, t, n) {
    return function (...r) {
        const o = this.__v_raw,
        i = Xt(o),
        s = Xd(i),
        a = e === "entries" || e === Symbol.iterator && s,
        l = e === "keys" && s,
        c = o[e](...r),
        u = n ? FS : t ? zS : em;
        return !t && ei(i, "iterate", l ? pk : nu), {
            next() {
                const {
                    value: f,
                    done: p
                } = c.next();
                return p ? {
                    value: f,
                    done: p
                }
                 : {
                    value: a ? [u(f[0]), u(f[1])] : u(f),
                    done: p
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function yl(e) {
    return function (...t) {
        return e === "delete" ? !1 : this
    }
}
function CX() {
    const e = {
        get(i) {
            return hv(this, i)
        },
        get size() {
            return mv(this)
        },
        has: pv,
        add: NE,
        set: RE,
        delete : LE,
        clear: BE,
        forEach: gv(!1, !1)
    },
    t = {
        get(i) {
            return hv(this, i, !1, !0)
        },
        get size() {
            return mv(this)
        },
        has: pv,
        add: NE,
        set: RE,
        delete : LE,
        clear: BE,
        forEach: gv(!1, !0)
    },
    n = {
        get(i) {
            return hv(this, i, !0)
        },
        get size() {
            return mv(this, !0)
        },
        has(i) {
            return pv.call(this, i, !0)
        },
        add: yl("add"),
        set: yl("set"),
        delete : yl("delete"),
        clear: yl("clear"),
        forEach: gv(!0, !1)
    },
    r = {
        get(i) {
            return hv(this, i, !0, !0)
        },
        get size() {
            return mv(this, !0)
        },
        has(i) {
            return pv.call(this, i, !0)
        },
        add: yl("add"),
        set: yl("set"),
        delete : yl("delete"),
        clear: yl("clear"),
        forEach: gv(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        e[i] = vv(i, !1, !1),
        n[i] = vv(i, !0, !1),
        t[i] = vv(i, !1, !0),
        r[i] = vv(i, !0, !0)
    }),
    [e, n, t, r]
}
const [IX, TX, MX, PX] = CX();
function A1(e, t) {
    const n = t ? e ? PX : MX : e ? TX : IX;
    return (r, o, i) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? r : Reflect.get(un(n, o) && o in r ? n : r, o, i)
}
const EX = {
    get: A1(!1, !1)
}, OX = {
    get: A1(!1, !0)
}, $X = {
    get: A1(!0, !1)
}, AX = {
    get: A1(!0, !0)
}, FR = new WeakMap, jR = new WeakMap, WR = new WeakMap, zR = new WeakMap;
function DX(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function NX(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : DX(KG(e))
}
function es(e) {
    return bu(e) ? e : D1(e, !1, BR, EX, FR)
}
function HR(e) {
    return D1(e, !1, xX, OX, jR)
}
function jS(e) {
    return D1(e, !0, VR, $X, WR)
}
function RX(e) {
    return D1(e, !0, SX, AX, zR)
}
function D1(e, t, n, r, o) {
    if (!In(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const i = o.get(e);
    if (i)
        return i;
    const s = NX(e);
    if (s === 0)
        return e;
    const a = new Proxy(e, s === 2 ? r : n);
    return o.set(e, a),
    a
}
function ru(e) {
    return bu(e) ? ru(e.__v_raw) : !!(e && e.__v_isReactive)
}
function bu(e) {
    return !!(e && e.__v_isReadonly)
}
function Qp(e) {
    return !!(e && e.__v_isShallow)
}
function WS(e) {
    return ru(e) || bu(e)
}
function Xt(e) {
    const t = e && e.__v_raw;
    return t ? Xt(t) : e
}
function oa(e) {
    return I0(e, "__v_skip", !0),
    e
}
const em = e => In(e) ? es(e) : e, zS = e => In(e) ? jS(e) : e;
function HS(e) {
    zl && _s && (e = Xt(e), NR(e.dep || (e.dep = VS())))
}
function N1(e, t) {
    e = Xt(e);
    const n = e.dep;
    n && mk(n)
}
function Dr(e) {
    return !!(e && e.__v_isRef === !0)
}
function De(e) {
    return UR(e, !1)
}
function _u(e) {
    return UR(e, !0)
}
function UR(e, t) {
    return Dr(e) ? e : new LX(e, t)
}
class LX {
    constructor(t, n) {
        this.__v_isShallow = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = n ? t : Xt(t),
        this._value = n ? t : em(t)
    }
    get value() {
        return HS(this),
        this._value
    }
    set value(t) {
        const n = this.__v_isShallow || Qp(t) || bu(t);
        t = n ? t : Xt(t),
        ff(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : em(t), N1(this))
    }
}
function BX(e) {
    N1(e)
}
function ke(e) {
    return Dr(e) ? e.value : e
}
function VX(e) {
    return Ot(e) ? e() : ke(e)
}
const FX = {
    get: (e, t, n) => ke(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
        const o = e[t];
        return Dr(o) && !Dr(n) ? (o.value = n, !0) : Reflect.set(e, t, n, r)
    }
};
function US(e) {
    return ru(e) ? e : new Proxy(e, FX)
}
class jX {
    constructor(t) {
        this.dep = void 0,
        this.__v_isRef = !0;
        const {
            get: n,
            set: r
        } = t(() => HS(this), () => N1(this));
        this._get = n,
        this._set = r
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function qR(e) {
    return new jX(e)
}
function nl(e) {
    const t = st(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = YR(e, n);
    return t
}
class WX {
    constructor(t, n, r) {
        this._object = t,
        this._key = n,
        this._defaultValue = r,
        this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return uX(Xt(this._object), this._key)
    }
}
class zX {
    constructor(t) {
        this._getter = t,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function ca(e, t, n) {
    return Dr(e) ? e : Ot(e) ? new zX(e) : In(e) && arguments.length > 1 ? YR(e, t, n) : De(e)
}
function YR(e, t, n) {
    const r = e[t];
    return Dr(r) ? r : new WX(e, t, n)
}
class HX {
    constructor(t, n, r, o) {
        this._setter = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this.__v_isReadonly = !1,
        this._dirty = !0,
        this.effect = new Xm(t, () => {
            this._dirty || (this._dirty = !0, N1(this))
        }),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !o,
        this.__v_isReadonly = r
    }
    get value() {
        const t = Xt(this);
        return HS(t),
        (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()),
        t._value
    }
    set value(t) {
        this._setter(t)
    }
}
function UX(e, t, n = !1) {
    let r,
    o;
    const i = Ot(e);
    return i ? (r = e, o = Cs) : (r = e.get, o = e.set),
    new HX(r, o, i || !o, n)
}
function qX(e, ...t) {}
function YX(e, t) {}
function qa(e, t, n, r) {
    let o;
    try {
        o = r ? e(...r) : e()
    } catch (i) {
        zu(i, t, n)
    }
    return o
}
function xi(e, t, n, r) {
    if (Ot(e)) {
        const i = qa(e, t, n, r);
        return i && RS(i) && i.catch(s => {
            zu(s, t, n)
        }),
        i
    }
    const o = [];
    for (let i = 0; i < e.length; i++)
        o.push(xi(e[i], t, n, r));
    return o
}
function zu(e, t, n, r = !0) {
    const o = t ? t.vnode : null;
    if (t) {
        let i = t.parent;
        const s = t.proxy,
        a = n;
        for (; i; ) {
            const c = i.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](e, s, a) === !1)
                        return
            }
            i = i.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            qa(l, null, 10, [e, s, a]);
            return
        }
    }
    KX(e, n, o, r)
}
function KX(e, t, n, r = !0) {
    console.error(e)
}
let tm = !1, gk = !1;
const lo = [];
let Ys = 0;
const Zd = [];
let Ba = null, Wc = 0;
const KR = Promise.resolve();
let qS = null;
function Ci(e) {
    const t = qS || KR;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function GX(e) {
    let t = Ys + 1,
    n = lo.length;
    for (; t < n; ) {
        const r = t + n >>> 1;
        nm(lo[r]) < e ? t = r + 1 : n = r
    }
    return t
}
function R1(e) {
    (!lo.length || !lo.includes(e, tm && e.allowRecurse ? Ys + 1 : Ys)) && (e.id == null ? lo.push(e) : lo.splice(GX(e.id), 0, e), GR())
}
function GR() {
    !tm && !gk && (gk = !0, qS = KR.then(XR))
}
function XX(e) {
    const t = lo.indexOf(e);
    t > Ys && lo.splice(t, 1)
}
function YS(e) {
    st(e) ? Zd.push(...e) : (!Ba || !Ba.includes(e, e.allowRecurse ? Wc + 1 : Wc)) && Zd.push(e),
    GR()
}
function VE(e, t = tm ? Ys + 1 : 0) {
    for (; t < lo.length; t++) {
        const n = lo[t];
        n && n.pre && (lo.splice(t, 1), t--, n())
    }
}
function E0(e) {
    if (Zd.length) {
        const t = [...new Set(Zd)];
        if (Zd.length = 0, Ba) {
            Ba.push(...t);
            return
        }
        for (Ba = t, Ba.sort((n, r) => nm(n) - nm(r)), Wc = 0; Wc < Ba.length; Wc++)
            Ba[Wc]();
        Ba = null,
        Wc = 0
    }
}
const nm = e => e.id == null ? 1 / 0 : e.id, JX = (e, t) => {
    const n = nm(e) - nm(t);
    if (n === 0) {
        if (e.pre && !t.pre)
            return -1;
        if (t.pre && !e.pre)
            return 1
    }
    return n
};
function XR(e) {
    gk = !1,
    tm = !0,
    lo.sort(JX);
    const t = Cs;
    try {
        for (Ys = 0; Ys < lo.length; Ys++) {
            const n = lo[Ys];
            n && n.active !== !1 && qa(n, null, 14)
        }
    } finally {
        Ys = 0,
        lo.length = 0,
        E0(),
        tm = !1,
        qS = null,
        (lo.length || Zd.length) && XR()
    }
}
let Pd, yv = [];
function JR(e, t) {
    var n,
    r;
    Pd = e,
    Pd ? (Pd.enabled = !0, yv.forEach(({
                event: o,
                args: i
            }) => Pd.emit(o, ...i)), yv = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(i => {
            JR(i, t)
        }), setTimeout(() => {
            Pd || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, yv = [])
        }, 3e3)) : yv = []
}
function ZX(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const r = e.vnode.props || xn;
    let o = n;
    const i = t.startsWith("update:"),
    s = i && t.slice(7);
    if (s && s in r) {
        const u = `${s === "modelValue" ? "model" : s}Modifiers`, {
            number: f,
            trim: p
        } = r[u] || xn;
        p && (o = n.map(m => Gn(m) ? m.trim() : m)),
        f && (o = n.map(T0))
    }
    let a,
    l = r[a = wp(t)] || r[a = wp(Uo(t))];
    !l && i && (l = r[a = wp(Hi(t))]),
    l && xi(l, e, 6, o);
    const c = r[a + "Once"];
    if (c) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[a])
            return;
        e.emitted[a] = !0,
        xi(c, e, 6, o)
    }
}
function ZR(e, t, n = !1) {
    const r = t.emitsCache,
    o = r.get(e);
    if (o !== void 0)
        return o;
    const i = e.emits;
    let s = {},
    a = !1;
    if (!Ot(e)) {
        const l = c => {
            const u = ZR(c, t, !0);
            u && (a = !0, jn(s, u))
        };
        !n && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    return !i && !a ? (In(e) && r.set(e, null), null) : (st(i) ? i.forEach(l => s[l] = null) : jn(s, i), In(e) && r.set(e, s), s)
}
function L1(e, t) {
    return !e || !Km(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), un(e, t[0].toLowerCase() + t.slice(1)) || un(e, Hi(t)) || un(e, t))
}
let Fr = null, B1 = null;
function rm(e) {
    const t = Fr;
    return Fr = e,
    B1 = e && e.type.__scopeId || null,
    t
}
function ir(e) {
    B1 = e
}
function sr() {
    B1 = null
}
const QX = e => oe;
function oe(e, t = Fr, n) {
    if (!t || e._n)
        return e;
    const r = (...o) => {
        r._d && xk(-1);
        const i = rm(t);
        let s;
        try {
            s = e(...o)
        } finally {
            rm(i),
            r._d && xk(1)
        }
        return s
    };
    return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function t0(e) {
    const {
        type: t,
        vnode: n,
        proxy: r,
        withProxy: o,
        props: i,
        propsOptions: [s],
        slots: a,
        attrs: l,
        emit: c,
        render: u,
        renderCache: f,
        data: p,
        setupState: m,
        ctx: v,
        inheritAttrs: y
    } = e;
    let b,
    w;
    const k = rm(e);
    try {
        if (n.shapeFlag & 4) {
            const x = o || r;
            b = yi(u.call(x, x, f, i, m, p, v)),
            w = l
        } else {
            const x = t;
            b = yi(x.length > 1 ? x(i, {
                        attrs: l,
                        slots: a,
                        emit: c
                    }) : x(i, null)),
            w = t.props ? l : tJ(l)
        }
    } catch (x) {
        kp.length = 0,
        zu(x, e, 1),
        b = z(Qr)
    }
    let C = b;
    if (w && y !== !1) {
        const x = Object.keys(w), {
            shapeFlag: S
        } = C;
        x.length && S & 7 && (s && x.some(DS) && (w = nJ(w, s)), C = Ps(C, w))
    }
    return n.dirs && (C = Ps(C), C.dirs = C.dirs ? C.dirs.concat(n.dirs) : n.dirs),
    n.transition && (C.transition = n.transition),
    b = C,
    rm(k),
    b
}
function eJ(e) {
    let t;
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (ec(r)) {
            if (r.type !== Qr || r.children === "v-if") {
                if (t)
                    return;
                t = r
            }
        } else
            return
    }
    return t
}
const tJ = e => {
    let t;
    for (const n in e)
        (n === "class" || n === "style" || Km(n)) && ((t || (t = {}))[n] = e[n]);
    return t
}, nJ = (e, t) => {
    const n = {};
    for (const r in e)
        (!DS(r) || !(r.slice(9)in t)) && (n[r] = e[r]);
    return n
};
function rJ(e, t, n) {
    const {
        props: r,
        children: o,
        component: i
    } = e, {
        props: s,
        children: a,
        patchFlag: l
    } = t,
    c = i.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (n && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return r ? FE(r, s, c) : !!s;
        if (l & 8) {
            const u = t.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                const p = u[f];
                if (s[p] !== r[p] && !L1(c, p))
                    return !0
            }
        }
    } else
        return (o || a) && (!a || !a.$stable) ? !0 : r === s ? !1 : r ? s ? FE(r, s, c) : !0 : !!s;
    return !1
}
function FE(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length)
        return !0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        if (t[i] !== e[i] && !L1(n, i))
            return !0
    }
    return !1
}
function KS({
    vnode: e,
    parent: t
}, n) {
    for (; t && t.subTree === e; )
        (e = t.vnode).el = n, t = t.parent
}
const QR = e => e.__isSuspense, oJ = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, r, o, i, s, a, l, c) {
        e == null ? sJ(t, n, r, o, i, s, a, l, c) : aJ(e, t, n, r, o, s, a, l, c)
    },
    hydrate: lJ,
    create: GS,
    normalize: cJ
}, iJ = oJ;
function om(e, t) {
    const n = e.props && e.props[t];
    Ot(n) && n()
}
function sJ(e, t, n, r, o, i, s, a, l) {
    const {
        p: c,
        o: {
            createElement: u
        }
    } = l,
    f = u("div"),
    p = e.suspense = GS(e, o, r, t, f, n, i, s, a, l);
    c(null, p.pendingBranch = e.ssContent, f, null, r, p, i, s),
    p.deps > 0 ? (om(e, "onPending"), om(e, "onFallback"), c(null, e.ssFallback, t, n, r, null, i, s), Qd(p, e.ssFallback)) : p.resolve(!1, !0)
}
function aJ(e, t, n, r, o, i, s, a, {
    p: l,
    um: c,
    o: {
        createElement: u
    }
}) {
    const f = t.suspense = e.suspense;
    f.vnode = t,
    t.el = e.el;
    const p = t.ssContent,
    m = t.ssFallback, {
        activeBranch: v,
        pendingBranch: y,
        isInFallback: b,
        isHydrating: w
    } = f;
    if (y)
        f.pendingBranch = p, ks(p, y) ? (l(y, p, f.hiddenContainer, null, o, f, i, s, a), f.deps <= 0 ? f.resolve() : b && (l(v, m, n, r, o, null, i, s, a), Qd(f, m))) : (f.pendingId++, w ? (f.isHydrating = !1, f.activeBranch = y) : c(y, o, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = u("div"), b ? (l(null, p, f.hiddenContainer, null, o, f, i, s, a), f.deps <= 0 ? f.resolve() : (l(v, m, n, r, o, null, i, s, a), Qd(f, m))) : v && ks(p, v) ? (l(v, p, n, r, o, f, i, s, a), f.resolve(!0)) : (l(null, p, f.hiddenContainer, null, o, f, i, s, a), f.deps <= 0 && f.resolve()));
    else if (v && ks(p, v))
        l(v, p, n, r, o, f, i, s, a), Qd(f, p);
    else if (om(t, "onPending"), f.pendingBranch = p, f.pendingId++, l(null, p, f.hiddenContainer, null, o, f, i, s, a), f.deps <= 0)
        f.resolve();
    else {
        const {
            timeout: k,
            pendingId: C
        } = f;
        k > 0 ? setTimeout(() => {
            f.pendingId === C && f.fallback(m)
        }, k) : k === 0 && f.fallback(m)
    }
}
function GS(e, t, n, r, o, i, s, a, l, c, u = !1) {
    const {
        p: f,
        m: p,
        um: m,
        n: v,
        o: {
            parentNode: y,
            remove: b
        }
    } = c;
    let w;
    const k = uJ(e);
    k && t?.pendingBranch && (w = t.pendingId, t.deps++);
    const C = e.props ? M0(e.props.timeout) : void 0,
    x = {
        vnode: e,
        parent: t,
        parentComponent: n,
        isSVG: s,
        container: r,
        hiddenContainer: o,
        anchor: i,
        deps: 0,
        pendingId: 0,
        timeout: typeof C == "number" ? C : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !0,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(S = !1, T = !1) {
            const {
                vnode: E,
                activeBranch: M,
                pendingBranch: N,
                pendingId: F,
                effects: K,
                parentComponent: j,
                container: G
            } = x;
            if (x.isHydrating)
                x.isHydrating = !1;
            else if (!S) {
                const re = M && N.transition && N.transition.mode === "out-in";
                re && (M.transition.afterLeave = () => {
                    F === x.pendingId && p(N, G, de, 0)
                });
                let {
                    anchor: de
                } = x;
                M && (de = v(M), m(M, j, x, !0)),
                re || p(N, G, de, 0)
            }
            Qd(x, N),
            x.pendingBranch = null,
            x.isInFallback = !1;
            let Y = x.parent,
            ue = !1;
            for (; Y; ) {
                if (Y.pendingBranch) {
                    Y.effects.push(...K),
                    ue = !0;
                    break
                }
                Y = Y.parent
            }
            ue || YS(K),
            x.effects = [],
            k && t && t.pendingBranch && w === t.pendingId && (t.deps--, t.deps === 0 && !T && t.resolve()),
            om(E, "onResolve")
        },
        fallback(S) {
            if (!x.pendingBranch)
                return;
            const {
                vnode: T,
                activeBranch: E,
                parentComponent: M,
                container: N,
                isSVG: F
            } = x;
            om(T, "onFallback");
            const K = v(E),
            j = () => {
                x.isInFallback && (f(null, S, N, K, M, null, F, a, l), Qd(x, S))
            },
            G = S.transition && S.transition.mode === "out-in";
            G && (E.transition.afterLeave = j),
            x.isInFallback = !0,
            m(E, M, null, !0),
            G || j()
        },
        move(S, T, E) {
            x.activeBranch && p(x.activeBranch, S, T, E),
            x.container = S
        },
        next() {
            return x.activeBranch && v(x.activeBranch)
        },
        registerDep(S, T) {
            const E = !!x.pendingBranch;
            E && x.deps++;
            const M = S.vnode.el;
            S.asyncDep.catch(N => {
                zu(N, S, 0)
            }).then(N => {
                if (S.isUnmounted || x.isUnmounted || x.pendingId !== S.suspenseId)
                    return;
                S.asyncResolved = !0;
                const {
                    vnode: F
                } = S;
                Sk(S, N, !1),
                M && (F.el = M);
                const K = !M && S.subTree.el;
                T(S, F, y(M || S.subTree.el), M ? null : v(S.subTree), x, s, l),
                K && b(K),
                KS(S, F.el),
                E && --x.deps === 0 && x.resolve()
            })
        },
        unmount(S, T) {
            x.isUnmounted = !0,
            x.activeBranch && m(x.activeBranch, n, S, T),
            x.pendingBranch && m(x.pendingBranch, n, S, T)
        }
    };
    return x
}
function lJ(e, t, n, r, o, i, s, a, l) {
    const c = t.suspense = GS(t, r, n, e.parentNode, document.createElement("div"), null, o, i, s, a, !0),
    u = l(e, c.pendingBranch = t.ssContent, n, c, i, s);
    return c.deps === 0 && c.resolve(!1, !0),
    u
}
function cJ(e) {
    const {
        shapeFlag: t,
        children: n
    } = e,
    r = t & 32;
    e.ssContent = jE(r ? n.default : n),
    e.ssFallback = r ? jE(n.fallback) : z(Qr)
}
function jE(e) {
    let t;
    if (Ot(e)) {
        const n = Su && e._c;
        n && (e._d = !1, _()),
        e = e(),
        n && (e._d = !0, t = Ho, M4())
    }
    return st(e) && (e = eJ(e)),
    e = yi(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)),
    e
}
function e4(e, t) {
    t && t.pendingBranch ? st(e) ? t.effects.push(...e) : t.effects.push(e) : YS(e)
}
function Qd(e, t) {
    e.activeBranch = t;
    const {
        vnode: n,
        parentComponent: r
    } = e,
    o = n.el = t.el;
    r && r.subTree === n && (r.vnode.el = o, KS(r, o))
}
function uJ(e) {
    var t;
    return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
function t4(e, t) {
    return Jm(e, null, t)
}
function n4(e, t) {
    return Jm(e, null, {
        flush: "post"
    })
}
function dJ(e, t) {
    return Jm(e, null, {
        flush: "sync"
    })
}
const wv = {};
function Ht(e, t, n) {
    return Jm(e, t, n)
}
function Jm(e, t, {
    immediate: n,
    deep: r,
    flush: o,
    onTrack: i,
    onTrigger: s
} = xn) {
    var a;
    const l = E1() === ((a = Mr) == null ? void 0 : a.scope) ? Mr : null;
    let c,
    u = !1,
    f = !1;
    if (Dr(e) ? (c = () => e.value, u = Qp(e)) : ru(e) ? (c = () => e, r = !0) : st(e) ? (f = !0, u = e.some(x => ru(x) || Qp(x)), c = () => e.map(x => {
                if (Dr(x))
                    return x.value;
                if (ru(x))
                    return Jc(x);
                    if (Ot(x))
                        return qa(x, l, 2)
                })) : Ot(e) ? t ? c = () => qa(e, l, 2) : c = () => {
            if (!(l && l.isUnmounted))
                return p && p(), xi(e, l, 3, [m])
        }
             : c = Cs, t && r) {
            const x = c;
            c = () => Jc(x())
        }
    let p,
    m = x => {
        p = k.onStop = () => {
            qa(x, l, 4)
        }
    },
    v;
    if (pf)
        if (m = Cs, t ? n && xi(t, l, 3, [c(), f ? [] : void 0, m]) : c(), o === "sync") {
            const x = L4();
            v = x.__watcherHandles || (x.__watcherHandles = [])
        } else
            return Cs;
    let y = f ? new Array(e.length).fill(wv) : wv;
    const b = () => {
        if (k.active)
            if (t) {
                const x = k.run();
                (r || u || (f ? x.some((S, T) => ff(S, y[T])) : ff(x, y))) && (p && p(), xi(t, l, 3, [x, y === wv ? void 0 : f && y[0] === wv ? [] : y, m]), y = x)
            } else
                k.run()
    };
    b.allowRecurse = !!t;
    let w;
    o === "sync" ? w = b : o === "post" ? w = () => Gr(b, l && l.suspense) : (b.pre = !0, l && (b.id = l.uid), w = () => R1(b));
    const k = new Xm(c, w);
    t ? n ? b() : y = k.run() : o === "post" ? Gr(k.run.bind(k), l && l.suspense) : k.run();
    const C = () => {
        k.stop(),
        l && l.scope && NS(l.scope.effects, k)
    };
    return v && v.push(C),
    C
}
function fJ(e, t, n) {
    const r = this.proxy,
    o = Gn(e) ? e.includes(".") ? r4(r, e) : () => r[e] : e.bind(r, r);
    let i;
    Ot(t) ? i = t : (i = t.handler, n = t);
    const s = Mr;
    nc(this);
    const a = Jm(o, i.bind(r), n);
    return s ? nc(s) : Hl(),
    a
}
function r4(e, t) {
    const n = t.split(".");
    return () => {
        let r = e;
        for (let o = 0; o < n.length && r; o++)
            r = r[n[o]];
        return r
    }
}
function Jc(e, t) {
    if (!In(e) || e.__v_skip || (t = t || new Set, t.has(e)))
        return e;
    if (t.add(e), Dr(e))
        Jc(e.value, t);
    else if (st(e))
        for (let n = 0; n < e.length; n++)
            Jc(e[n], t);
    else if (Wu(e) || Xd(e))
        e.forEach(n => {
            Jc(n, t)
        });
    else if (IR(e))
        for (const n in e)
            Jc(e[n], t);
    return e
}
function Cn(e, t) {
    const n = Fr;
    if (n === null)
        return e;
    const r = q1(n) || n.proxy,
    o = e.dirs || (e.dirs = []);
    for (let i = 0; i < t.length; i++) {
        let [s, a, l, c = xn] = t[i];
        s && (Ot(s) && (s = {
                    mounted: s,
                    updated: s
                }), s.deep && Jc(a), o.push({
                dir: s,
                instance: r,
                value: a,
                oldValue: void 0,
                arg: l,
                modifiers: c
            }))
    }
    return e
}
function Us(e, t, n, r) {
    const o = e.dirs,
    i = t && t.dirs;
    for (let s = 0; s < o.length; s++) {
        const a = o[s];
        i && (a.oldValue = i[s].value);
        let l = a.dir[r];
        l && (Qf(), xi(l, n, 8, [e.el, a, e, t]), eh())
    }
}
function XS() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ur(() => {
        e.isMounted = !0
    }),
    Rs(() => {
        e.isUnmounting = !0
    }),
    e
}
const Vi = [Function, Array], JS = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Vi,
    onEnter: Vi,
    onAfterEnter: Vi,
    onEnterCancelled: Vi,
    onBeforeLeave: Vi,
    onLeave: Vi,
    onAfterLeave: Vi,
    onLeaveCancelled: Vi,
    onBeforeAppear: Vi,
    onAppear: Vi,
    onAfterAppear: Vi,
    onAppearCancelled: Vi
}, hJ = {
    name: "BaseTransition",
    props: JS,
    setup(e, {
        slots: t
    }) {
        const n = ii(),
        r = XS();
        let o;
        return () => {
            const i = t.default && V1(t.default(), !0);
            if (!i || !i.length)
                return;
            let s = i[0];
            if (i.length > 1) {
                for (const y of i)
                    if (y.type !== Qr) {
                        s = y;
                        break
                    }
            }
            const a = Xt(e), {
                mode: l
            } = a;
            if (r.isLeaving)
                return k_(s);
            const c = WE(s);
            if (!c)
                return k_(s);
            const u = hf(c, a, r, n);
            ku(c, u);
            const f = n.subTree,
            p = f && WE(f);
            let m = !1;
            const {
                getTransitionKey: v
            } = c.type;
            if (v) {
                const y = v();
                o === void 0 ? o = y : y !== o && (o = y, m = !0)
            }
            if (p && p.type !== Qr && (!ks(c, p) || m)) {
                const y = hf(p, a, r, n);
                if (ku(p, y), l === "out-in")
                    return r.isLeaving = !0, y.afterLeave = () => {
                        r.isLeaving = !1,
                        n.update.active !== !1 && n.update()
                    },
                k_(s);
                l === "in-out" && c.type !== Qr && (y.delayLeave = (b, w, k) => {
                    const C = i4(r, p);
                    C[String(p.key)] = p,
                    b._leaveCb = () => {
                        w(),
                        b._leaveCb = void 0,
                        delete u.delayedLeave
                    },
                    u.delayedLeave = k
                })
            }
            return s
        }
    }
}, o4 = hJ;
function i4(e, t) {
    const {
        leavingVNodes: n
    } = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null), n.set(t.type, r)),
    r
}
function hf(e, t, n, r) {
    const {
        appear: o,
        mode: i,
        persisted: s = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: u,
        onBeforeLeave: f,
        onLeave: p,
        onAfterLeave: m,
        onLeaveCancelled: v,
        onBeforeAppear: y,
        onAppear: b,
        onAfterAppear: w,
        onAppearCancelled: k
    } = t,
    C = String(e.key),
    x = i4(n, e),
    S = (M, N) => {
        M && xi(M, r, 9, N)
    },
    T = (M, N) => {
        const F = N[1];
        S(M, N),
        st(M) ? M.every(K => K.length <= 1) && F() : M.length <= 1 && F()
    },
    E = {
        mode: i,
        persisted: s,
        beforeEnter(M) {
            let N = a;
            if (!n.isMounted)
                if (o)
                    N = y || a;
                else
                    return;
            M._leaveCb && M._leaveCb(!0);
            const F = x[C];
            F && ks(e, F) && F.el._leaveCb && F.el._leaveCb(),
            S(N, [M])
        },
        enter(M) {
            let N = l,
            F = c,
            K = u;
            if (!n.isMounted)
                if (o)
                    N = b || l, F = w || c, K = k || u;
                else
                    return;
            let j = !1;
            const G = M._enterCb = Y => {
                j || (j = !0, Y ? S(K, [M]) : S(F, [M]), E.delayedLeave && E.delayedLeave(), M._enterCb = void 0)
            };
            N ? T(N, [M, G]) : G()
        },
        leave(M, N) {
            const F = String(e.key);
            if (M._enterCb && M._enterCb(!0), n.isUnmounting)
                return N();
            S(f, [M]);
            let K = !1;
            const j = M._leaveCb = G => {
                K || (K = !0, N(), G ? S(v, [M]) : S(m, [M]), M._leaveCb = void 0, x[F] === e && delete x[F])
            };
            x[F] = e,
            p ? T(p, [M, j]) : j()
        },
        clone(M) {
            return hf(M, t, n, r)
        }
    };
    return E
}
function k_(e) {
    if (Zm(e))
        return e = Ps(e), e.children = null, e
}
function WE(e) {
    return Zm(e) ? e.children ? e.children[0] : void 0 : e
}
function ku(e, t) {
    e.shapeFlag & 6 && e.component ? ku(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function V1(e, t = !1, n) {
    let r = [],
    o = 0;
    for (let i = 0; i < e.length; i++) {
        let s = e[i];
        const a = n == null ? s.key : String(n) + String(s.key != null ? s.key : i);
        s.type === Le ? (s.patchFlag & 128 && o++, r = r.concat(V1(s.children, t, a))) : (t || s.type !== Qr) && r.push(a != null ? Ps(s, {
                key: a
            }) : s)
    }
    if (o > 1)
        for (let i = 0; i < r.length; i++)
            r[i].patchFlag = -2;
    return r
}
function Fe(e, t) {
    return Ot(e) ? (() => jn({
            name: e.name
        }, t, {
            setup: e
        }))() : e
}
const ou = e => !!e.type.__asyncLoader;
function Ha(e) {
    Ot(e) && (e = {
            loader: e
        });
    const {
        loader: t,
        loadingComponent: n,
        errorComponent: r,
        delay: o = 200,
        timeout: i,
        suspensible: s = !0,
        onError: a
    } = e;
    let l = null,
    c,
    u = 0;
    const f = () => (u++, l = null, p()),
    p = () => {
        let m;
        return l || (m = l = t().catch(v => {
                if (v = v instanceof Error ? v : new Error(String(v)), a)
                    return new Promise((y, b) => {
                        a(v, () => y(f()), () => b(v), u + 1)
                    });
                throw v
            }).then(v => m !== l && l ? l : (v && (v.__esModule || v[Symbol.toStringTag] === "Module") && (v = v.default), c = v, v)))
    };
    return Fe({
        name: "AsyncComponentWrapper",
        __asyncLoader: p,
        get __asyncResolved() {
            return c
        },
        setup() {
            const m = Mr;
            if (c)
                return () => x_(c, m);
            const v = k => {
                l = null,
                zu(k, m, 13, !r)
            };
            if (s && m.suspense || pf)
                return p().then(k => () => x_(k, m)).catch(k => (v(k), () => r ? z(r, {
                            error: k
                        }) : null));
            const y = De(!1),
            b = De(),
            w = De(!!o);
            return o && setTimeout(() => {
                w.value = !1
            }, o),
            i != null && setTimeout(() => {
                if (!y.value && !b.value) {
                    const k = new Error(`Async component timed out after ${i}ms.`);
                    v(k),
                    b.value = k
                }
            }, i),
            p().then(() => {
                y.value = !0,
                m.parent && Zm(m.parent.vnode) && R1(m.parent.update)
            }).catch(k => {
                v(k),
                b.value = k
            }),
            () => {
                if (y.value && c)
                    return x_(c, m);
                if (b.value && r)
                    return z(r, {
                        error: b.value
                    });
                if (n && !w.value)
                    return z(n)
            }
        }
    })
}
function x_(e, t) {
    const {
        ref: n,
        props: r,
        children: o,
        ce: i
    } = t.vnode,
    s = z(e, r, o);
    return s.ref = n,
    s.ce = i,
    delete t.vnode.ce,
    s
}
const Zm = e => e.type.__isKeepAlive, pJ = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {
        slots: t
    }) {
        const n = ii(),
        r = n.ctx;
        if (!r.renderer)
            return () => {
                const k = t.default && t.default();
                return k && k.length === 1 ? k[0] : k
            };
        const o = new Map,
        i = new Set;
        let s = null;
        const a = n.suspense, {
            renderer: {
                p: l,
                m: c,
                um: u,
                o: {
                    createElement: f
                }
            }
        } = r,
        p = f("div");
        r.activate = (k, C, x, S, T) => {
            const E = k.component;
            c(k, C, x, 0, a),
            l(E.vnode, k, C, x, E, a, S, k.slotScopeIds, T),
            Gr(() => {
                E.isDeactivated = !1,
                E.a && Jd(E.a);
                const M = k.props && k.props.onVnodeMounted;
                M && Bo(M, E.parent, k)
            }, a)
        },
        r.deactivate = k => {
            const C = k.component;
            c(k, p, null, 1, a),
            Gr(() => {
                C.da && Jd(C.da);
                const x = k.props && k.props.onVnodeUnmounted;
                x && Bo(x, C.parent, k),
                C.isDeactivated = !0
            }, a)
        };
        function m(k) {
            S_(k),
            u(k, n, a, !0)
        }
        function v(k) {
            o.forEach((C, x) => {
                const S = Ik(C.type);
                S && (!k || !k(S)) && y(x)
            })
        }
        function y(k) {
            const C = o.get(k);
            !s || !ks(C, s) ? m(C) : s && S_(s),
            o.delete(k),
            i.delete(k)
        }
        Ht(() => [e.include, e.exclude], ([k, C]) => {
            k && v(x => ip(k, x)),
            C && v(x => !ip(C, x))
        }, {
            flush: "post",
            deep: !0
        });
        let b = null;
        const w = () => {
            b != null && o.set(b, C_(n.subTree))
        };
        return Ur(w),
        j1(w),
        Rs(() => {
            o.forEach(k => {
                const {
                    subTree: C,
                    suspense: x
                } = n,
                S = C_(C);
                if (k.type === S.type && k.key === S.key) {
                    S_(S);
                    const T = S.component.da;
                    T && Gr(T, x);
                    return
                }
                m(k)
            })
        }),
        () => {
            if (b = null, !t.default)
                return null;
            const k = t.default(),
            C = k[0];
            if (k.length > 1)
                return s = null, k;
            if (!ec(C) || !(C.shapeFlag & 4) && !(C.shapeFlag & 128))
                return s = null, C;
            let x = C_(C);
            const S = x.type,
            T = Ik(ou(x) ? x.type.__asyncResolved || {}
                     : S), {
                include: E,
                exclude: M,
                max: N
            } = e;
            if (E && (!T || !ip(E, T)) || M && T && ip(M, T))
                return s = x, C;
            const F = x.key == null ? S : x.key,
            K = o.get(F);
            return x.el && (x = Ps(x), C.shapeFlag & 128 && (C.ssContent = x)),
            b = F,
            K ? (x.el = K.el, x.component = K.component, x.transition && ku(x, x.transition), x.shapeFlag |= 512, i.delete(F), i.add(F)) : (i.add(F), N && i.size > parseInt(N, 10) && y(i.values().next().value)),
            x.shapeFlag |= 256,
            s = x,
            QR(C.type) ? C : x
        }
    }
}, mJ = pJ;
function ip(e, t) {
    return st(e) ? e.some(n => ip(n, t)) : Gn(e) ? e.split(",").includes(t) : YG(e) ? e.test(t) : !1
}
function s4(e, t) {
    l4(e, "a", t)
}
function a4(e, t) {
    l4(e, "da", t)
}
function l4(e, t, n = Mr) {
    const r = e.__wdc || (e.__wdc = () => {
            let o = n;
            for (; o; ) {
                if (o.isDeactivated)
                    return;
                o = o.parent
            }
            return e()
        });
    if (F1(t, r, n), n) {
        let o = n.parent;
        for (; o && o.parent; )
            Zm(o.parent.vnode) && gJ(r, t, n, o), o = o.parent
    }
}
function gJ(e, t, n, r) {
    const o = F1(t, e, r, !0);
    cc(() => {
        NS(r[t], o)
    }, n)
}
function S_(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function C_(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function F1(e, t, n = Mr, r = !1) {
    if (n) {
        const o = n[e] || (n[e] = []),
        i = t.__weh || (t.__weh = (...s) => {
                if (n.isUnmounted)
                    return;
                Qf(),
                nc(n);
                const a = xi(t, n, e, s);
                return Hl(),
                eh(),
                a
            });
        return r ? o.unshift(i) : o.push(i),
        i
    }
}
const rl = e => (t, n = Mr) => (!pf || e === "sp") && F1(e, (...r) => t(...r), n), c4 = rl("bm"), Ur = rl("m"), ZS = rl("bu"), j1 = rl("u"), Rs = rl("bum"), cc = rl("um"), u4 = rl("sp"), d4 = rl("rtg"), f4 = rl("rtc");
function h4(e, t = Mr) {
    F1("ec", e, t)
}
const QS = "components", vJ = "directives";
function B(e, t) {
    return eC(QS, e, !0, t) || e
}
const p4 = Symbol.for("v-ndc");
function Kt(e) {
    return Gn(e) ? eC(QS, e, !1) || e : e || p4
}
function W1(e) {
    return eC(vJ, e)
}
function eC(e, t, n = !0, r = !1) {
    const o = Fr || Mr;
    if (o) {
        const i = o.type;
        if (e === QS) {
            const a = Ik(i, !1);
            if (a && (a === t || a === Uo(t) || a === Gm(Uo(t))))
                return i
        }
        const s = zE(o[e] || i[e], t) || zE(o.appContext[e], t);
        return !s && r ? i : s
    }
}
function zE(e, t) {
    return e && (e[t] || e[Uo(t)] || e[Gm(Uo(t))])
}
function $t(e, t, n, r) {
    let o;
    const i = n && n[r];
    if (st(e) || Gn(e)) {
        o = new Array(e.length);
        for (let s = 0, a = e.length; s < a; s++)
            o[s] = t(e[s], s, void 0, i && i[s])
    } else if (typeof e == "number") {
        o = new Array(e);
        for (let s = 0; s < e; s++)
            o[s] = t(s + 1, s, void 0, i && i[s])
    } else if (In(e))
        if (e[Symbol.iterator])
            o = Array.from(e, (s, a) => t(s, a, void 0, i && i[a]));
        else {
            const s = Object.keys(e);
            o = new Array(s.length);
            for (let a = 0, l = s.length; a < l; a++) {
                const c = s[a];
                o[a] = t(e[c], c, a, i && i[a])
            }
        }
    else
        o = [];
    return n && (n[r] = o),
    o
}
function tC(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (st(r))
            for (let o = 0; o < r.length; o++)
                e[r[o].name] = r[o].fn;
        else
            r && (e[r.name] = r.key ? (...o) => {
                    const i = r.fn(...o);
                    return i && (i.key = r.key),
                    i
                }
                 : r.fn)
    }
    return e
}
function Ye(e, t, n = {}, r, o) {
    if (Fr.isCE || Fr.parent && ou(Fr.parent) && Fr.parent.isCE)
        return t !== "default" && (n.name = t), z("slot", n, r && r());
    let i = e[t];
    i && i._c && (i._d = !1),
    _();
    const s = i && m4(i(n)),
    a = H(Le, {
        key: n.key || s && s.key || `_${t}`
    }, s || (r ? r() : []), s && e._ === 1 ? 64 : -2);
    return !o && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
    i && i._c && (i._d = !0),
    a
}
function m4(e) {
    return e.some(t => ec(t) ? !(t.type === Qr || t.type === Le && !m4(t.children)) : !0) ? e : null
}
function O0(e, t) {
    const n = {};
    for (const r in e)
        n[t && /[A-Z]/.test(r) ? `on:${r}` : wp(r)] = e[r];
    return n
}
const vk = e => e ? $4(e) ? q1(e) || e.proxy : vk(e.parent) : null, bp = jn(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => vk(e.parent),
    $root: e => vk(e.root),
    $emit: e => e.emit,
    $options: e => nC(e),
    $forceUpdate: e => e.f || (e.f = () => R1(e.update)),
    $nextTick: e => e.n || (e.n = Ci.bind(e.proxy)),
    $watch: e => fJ.bind(e)
}), I_ = (e, t) => e !== xn && !e.__isScriptSetup && un(e, t), yk = {
    get({
        _: e
    }, t) {
        const {
            ctx: n,
            setupState: r,
            data: o,
            props: i,
            accessCache: s,
            type: a,
            appContext: l
        } = e;
        let c;
        if (t[0] !== "$") {
            const m = s[t];
            if (m !== void 0)
                switch (m) {
                case 1:
                    return r[t];
                case 2:
                    return o[t];
                case 4:
                    return n[t];
                case 3:
                    return i[t]
                }
            else {
                if (I_(r, t))
                    return s[t] = 1, r[t];
                if (o !== xn && un(o, t))
                    return s[t] = 2, o[t];
                if ((c = e.propsOptions[0]) && un(c, t))
                    return s[t] = 3, i[t];
                if (n !== xn && un(n, t))
                    return s[t] = 4, n[t];
                wk && (s[t] = 0)
            }
        }
        const u = bp[t];
        let f,
        p;
        if (u)
            return t === "$attrs" && ei(e, "get", t), u(e);
        if ((f = a.__cssModules) && (f = f[t]))
            return f;
        if (n !== xn && un(n, t))
            return s[t] = 4, n[t];
        if (p = l.config.globalProperties, un(p, t))
            return p[t]
    },
    set({
        _: e
    }, t, n) {
        const {
            data: r,
            setupState: o,
            ctx: i
        } = e;
        return I_(o, t) ? (o[t] = n, !0) : r !== xn && un(r, t) ? (r[t] = n, !0) : un(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (i[t] = n, !0)
    },
    has({
        _: {
            data: e,
            setupState: t,
            accessCache: n,
            ctx: r,
            appContext: o,
            propsOptions: i
        }
    }, s) {
        let a;
        return !!n[s] || e !== xn && un(e, s) || I_(t, s) || (a = i[0]) && un(a, s) || un(r, s) || un(bp, s) || un(o.config.globalProperties, s)
    },
    defineProperty(e, t, n) {
        return n.get != null ? e._.accessCache[t] = 0 : un(n, "value") && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
    }
}, yJ = jn({}, yk, {
    get(e, t) {
        if (t !== Symbol.unscopables)
            return yk.get(e, t, e)
    },
    has(e, t) {
        return t[0] !== "_" && !ZG(t)
    }
});
function wJ() {
    return null
}
function bJ() {
    return null
}
function _J(e) {}
function kJ(e) {}
function xJ() {
    return null
}
function SJ() {}
function CJ(e, t) {
    return null
}
function z1() {
    return g4().slots
}
function IJ() {
    return g4().attrs
}
function TJ(e, t, n) {
    const r = ii();
    if (n && n.local) {
        const o = De(e[t]);
        return Ht(() => e[t], i => o.value = i),
        Ht(o, i => {
            i !== e[t] && r.emit(`update:${t}`, i)
        }),
        o
    } else
        return {
            __v_isRef: !0,
            get value() {
                return e[t]
            },
            set value(o) {
                r.emit(`update:${t}`, o)
            }
        }
}
function g4() {
    const e = ii();
    return e.setupContext || (e.setupContext = N4(e))
}
function im(e) {
    return st(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e
}
function MJ(e, t) {
    const n = im(e);
    for (const r in t) {
        if (r.startsWith("__skip"))
            continue;
        let o = n[r];
        o ? st(o) || Ot(o) ? o = n[r] = {
            type: o,
        default:
            t[r]
        }
         : o.default = t[r] : o === null && (o = n[r] = {
                default:
                    t[r]
                }),
        o && t[`__skip_${r}`] && (o.skipFactory = !0)
    }
    return n
}
function PJ(e, t) {
    return !e || !t ? e || t : st(e) && st(t) ? e.concat(t) : jn({}, im(e), im(t))
}
function EJ(e, t) {
    const n = {};
    for (const r in e)
        t.includes(r) || Object.defineProperty(n, r, {
            enumerable: !0,
            get: () => e[r]
        });
    return n
}
function OJ(e) {
    const t = ii();
    let n = e();
    return Hl(),
    RS(n) && (n = n.catch(r => {
            throw nc(t),
            r
        })),
    [n, () => nc(t)]
}
let wk = !0;
function $J(e) {
    const t = nC(e),
    n = e.proxy,
    r = e.ctx;
    wk = !1,
    t.beforeCreate && HE(t.beforeCreate, e, "bc");
    const {
        data: o,
        computed: i,
        methods: s,
        watch: a,
        provide: l,
        inject: c,
        created: u,
        beforeMount: f,
        mounted: p,
        beforeUpdate: m,
        updated: v,
        activated: y,
        deactivated: b,
        beforeDestroy: w,
        beforeUnmount: k,
        destroyed: C,
        unmounted: x,
        render: S,
        renderTracked: T,
        renderTriggered: E,
        errorCaptured: M,
        serverPrefetch: N,
        expose: F,
        inheritAttrs: K,
        components: j,
        directives: G,
        filters: Y
    } = t;
    if (c && AJ(c, r, null), s)
        for (const de in s) {
            const Se = s[de];
            Ot(Se) && (r[de] = Se.bind(n))
        }
    if (o) {
        const de = o.call(n, n);
        In(de) && (e.data = es(de))
    }
    if (wk = !0, i)
        for (const de in i) {
            const Se = i[de],
            Pe = Ot(Se) ? Se.bind(n, n) : Ot(Se.get) ? Se.get.bind(n, n) : Cs,
            je = !Ot(Se) && Ot(Se.set) ? Se.set.bind(n) : Cs,
            Ke = ne({
                get: Pe,
                set: je
            });
            Object.defineProperty(r, de, {
                enumerable: !0,
                configurable: !0,
                get: () => Ke.value,
                set: Ue => Ke.value = Ue
            })
        }
    if (a)
        for (const de in a)
            v4(a[de], r, n, de);
    if (l) {
        const de = Ot(l) ? l.call(n) : l;
        Reflect.ownKeys(de).forEach(Se => {
            iu(Se, de[Se])
        })
    }
    u && HE(u, e, "c");
    function re(de, Se) {
        st(Se) ? Se.forEach(Pe => de(Pe.bind(n))) : Se && de(Se.bind(n))
    }
    if (re(c4, f), re(Ur, p), re(ZS, m), re(j1, v), re(s4, y), re(a4, b), re(h4, M), re(f4, T), re(d4, E), re(Rs, k), re(cc, x), re(u4, N), st(F))
        if (F.length) {
            const de = e.exposed || (e.exposed = {});
            F.forEach(Se => {
                Object.defineProperty(de, Se, {
                    get: () => n[Se],
                    set: Pe => n[Se] = Pe
                })
            })
        } else
            e.exposed || (e.exposed = {});
    S && e.render === Cs && (e.render = S),
    K != null && (e.inheritAttrs = K),
    j && (e.components = j),
    G && (e.directives = G)
}
function AJ(e, t, n = Cs) {
    st(e) && (e = bk(e));
    for (const r in e) {
        const o = e[r];
        let i;
        In(o) ? "default" in o ? i = Mo(o.from || r, o.default, !0) : i = Mo(o.from || r) : i = Mo(o),
        Dr(i) ? Object.defineProperty(t, r, {
            enumerable: !0,
            configurable: !0,
            get: () => i.value,
            set: s => i.value = s
        }) : t[r] = i
    }
}
function HE(e, t, n) {
    xi(st(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function v4(e, t, n, r) {
    const o = r.includes(".") ? r4(n, r) : () => n[r];
    if (Gn(e)) {
        const i = t[e];
        Ot(i) && Ht(o, i)
    } else if (Ot(e))
        Ht(o, e.bind(n));
    else if (In(e))
        if (st(e))
            e.forEach(i => v4(i, t, n, r));
        else {
            const i = Ot(e.handler) ? e.handler.bind(n) : t[e.handler];
            Ot(i) && Ht(o, i, e)
        }
}
function nC(e) {
    const t = e.type, {
        mixins: n,
        extends: r
    } = t, {
        mixins: o,
        optionsCache: i,
        config: {
            optionMergeStrategies: s
        }
    } = e.appContext,
    a = i.get(t);
    let l;
    return a ? l = a : !o.length && !n && !r ? l = t : (l = {}, o.length && o.forEach(c => $0(l, c, s, !0)), $0(l, t, s)),
    In(t) && i.set(t, l),
    l
}
function $0(e, t, n, r = !1) {
    const {
        mixins: o,
        extends: i
    } = t;
    i && $0(e, i, n, !0),
    o && o.forEach(s => $0(e, s, n, !0));
    for (const s in t)
        if (!(r && s === "expose")) {
            const a = DJ[s] || n && n[s];
            e[s] = a ? a(e[s], t[s]) : t[s]
        }
    return e
}
const DJ = {
    data: UE,
    props: qE,
    emits: qE,
    methods: sp,
    computed: sp,
    beforeCreate: ko,
    created: ko,
    beforeMount: ko,
    mounted: ko,
    beforeUpdate: ko,
    updated: ko,
    beforeDestroy: ko,
    beforeUnmount: ko,
    destroyed: ko,
    unmounted: ko,
    activated: ko,
    deactivated: ko,
    errorCaptured: ko,
    serverPrefetch: ko,
    components: sp,
    directives: sp,
    watch: RJ,
    provide: UE,
    inject: NJ
};
function UE(e, t) {
    return t ? e ? function () {
        return jn(Ot(e) ? e.call(this, this) : e, Ot(t) ? t.call(this, this) : t)
    }
     : t : e
}
function NJ(e, t) {
    return sp(bk(e), bk(t))
}
function bk(e) {
    if (st(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function ko(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function sp(e, t) {
    return e ? jn(Object.create(null), e, t) : t
}
function qE(e, t) {
    return e ? st(e) && st(t) ? [...new Set([...e, ...t])] : jn(Object.create(null), im(e), im(t ?? {})) : t
}
function RJ(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const n = jn(Object.create(null), e);
    for (const r in t)
        n[r] = ko(e[r], t[r]);
    return n
}
function y4() {
    return {
        app: null,
        config: {
            isNativeTag: HG,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let LJ = 0;
function BJ(e, t) {
    return function (r, o = null) {
        Ot(r) || (r = jn({}, r)),
        o != null && !In(o) && (o = null);
        const i = y4(),
        s = new Set;
        let a = !1;
        const l = i.app = {
            _uid: LJ++,
            _component: r,
            _props: o,
            _container: null,
            _context: i,
            _instance: null,
            version: V4,
            get config() {
                return i.config
            },
            set config(c) {},
            use(c, ...u) {
                return s.has(c) || (c && Ot(c.install) ? (s.add(c), c.install(l, ...u)) : Ot(c) && (s.add(c), c(l, ...u))),
                l
            },
            mixin(c) {
                return i.mixins.includes(c) || i.mixins.push(c),
                l
            },
            component(c, u) {
                return u ? (i.components[c] = u, l) : i.components[c]
            },
            directive(c, u) {
                return u ? (i.directives[c] = u, l) : i.directives[c]
            },
            mount(c, u, f) {
                if (!a) {
                    const p = z(r, o);
                    return p.appContext = i,
                    u && t ? t(p, c) : e(p, c, f),
                    a = !0,
                    l._container = c,
                    c.__vue_app__ = l,
                    q1(p.component) || p.component.proxy
                }
            },
            unmount() {
                a && (e(null, l._container), delete l._container.__vue_app__)
            },
            provide(c, u) {
                return i.provides[c] = u,
                l
            },
            runWithContext(c) {
                sm = l;
                try {
                    return c()
                } finally {
                    sm = null
                }
            }
        };
        return l
    }
}
let sm = null;
function iu(e, t) {
    if (Mr) {
        let n = Mr.provides;
        const r = Mr.parent && Mr.parent.provides;
        r === n && (n = Mr.provides = Object.create(r)),
        n[e] = t
    }
}
function Mo(e, t, n = !1) {
    const r = Mr || Fr;
    if (r || sm) {
        const o = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : sm._context.provides;
        if (o && e in o)
            return o[e];
        if (arguments.length > 1)
            return n && Ot(t) ? t.call(r && r.proxy) : t
    }
}
function VJ() {
    return !!(Mr || Fr || sm)
}
function FJ(e, t, n, r = !1) {
    const o = {},
    i = {};
    I0(i, U1, 1),
    e.propsDefaults = Object.create(null),
    w4(e, t, o, i);
    for (const s in e.propsOptions[0])
        s in o || (o[s] = void 0);
    n ? e.props = r ? o : HR(o) : e.type.props ? e.props = o : e.props = i,
    e.attrs = i
}
function jJ(e, t, n, r) {
    const {
        props: o,
        attrs: i,
        vnode: {
            patchFlag: s
        }
    } = e,
    a = Xt(o),
    [l] = e.propsOptions;
    let c = !1;
    if ((r || s > 0) && !(s & 16)) {
        if (s & 8) {
            const u = e.vnode.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                let p = u[f];
                if (L1(e.emitsOptions, p))
                    continue;
                const m = t[p];
                if (l)
                    if (un(i, p))
                        m !== i[p] && (i[p] = m, c = !0);
                    else {
                        const v = Uo(p);
                        o[v] = _k(l, a, v, m, e, !1)
                    }
                else
                    m !== i[p] && (i[p] = m, c = !0)
            }
        }
    } else {
        w4(e, t, o, i) && (c = !0);
        let u;
        for (const f in a)
            (!t || !un(t, f) && ((u = Hi(f)) === f || !un(t, u))) && (l ? n && (n[f] !== void 0 || n[u] !== void 0) && (o[f] = _k(l, a, f, void 0, e, !0)) : delete o[f]);
        if (i !== a)
            for (const f in i)
                (!t || !un(t, f)) && (delete i[f], c = !0)
    }
    c && Ga(e, "set", "$attrs")
}
function w4(e, t, n, r) {
    const [o, i] = e.propsOptions;
    let s = !1,
    a;
    if (t)
        for (let l in t) {
            if (yp(l))
                continue;
            const c = t[l];
            let u;
            o && un(o, u = Uo(l)) ? !i || !i.includes(u) ? n[u] = c : (a || (a = {}))[u] = c : L1(e.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, s = !0)
        }
    if (i) {
        const l = Xt(n),
        c = a || xn;
        for (let u = 0; u < i.length; u++) {
            const f = i[u];
            n[f] = _k(o, l, f, c[f], e, !un(c, f))
        }
    }
    return s
}
function _k(e, t, n, r, o, i) {
    const s = e[n];
    if (s != null) {
        const a = un(s, "default");
        if (a && r === void 0) {
            const l = s.default;
            if (s.type !== Function && !s.skipFactory && Ot(l)) {
                const {
                    propsDefaults: c
                } = o;
                n in c ? r = c[n] : (nc(o), r = c[n] = l.call(null, t), Hl())
            } else
                r = l
        }
        s[0] && (i && !a ? r = !1 : s[1] && (r === "" || r === Hi(n)) && (r = !0))
    }
    return r
}
function b4(e, t, n = !1) {
    const r = t.propsCache,
    o = r.get(e);
    if (o)
        return o;
    const i = e.props,
    s = {},
    a = [];
    let l = !1;
    if (!Ot(e)) {
        const u = f => {
            l = !0;
            const [p, m] = b4(f, t, !0);
            jn(s, p),
            m && a.push(...m)
        };
        !n && t.mixins.length && t.mixins.forEach(u),
        e.extends && u(e.extends),
        e.mixins && e.mixins.forEach(u)
    }
    if (!i && !l)
        return In(e) && r.set(e, Gd), Gd;
    if (st(i))
        for (let u = 0; u < i.length; u++) {
            const f = Uo(i[u]);
            YE(f) && (s[f] = xn)
        }
    else if (i)
        for (const u in i) {
            const f = Uo(u);
            if (YE(f)) {
                const p = i[u],
                m = s[f] = st(p) || Ot(p) ? {
                    type: p
                }
                 : jn({}, p);
                if (m) {
                    const v = XE(Boolean, m.type),
                    y = XE(String, m.type);
                    m[0] = v > -1,
                    m[1] = y < 0 || v < y,
                    (v > -1 || un(m, "default")) && a.push(f)
                }
            }
        }
    const c = [s, a];
    return In(e) && r.set(e, c),
    c
}
function YE(e) {
    return e[0] !== "$"
}
function KE(e) {
    const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
    return t ? t[2] : e === null ? "null" : ""
}
function GE(e, t) {
    return KE(e) === KE(t)
}
function XE(e, t) {
    return st(t) ? t.findIndex(n => GE(n, e)) : Ot(t) && GE(t, e) ? 0 : -1
}
const _4 = e => e[0] === "_" || e === "$stable", rC = e => st(e) ? e.map(yi) : [yi(e)], WJ = (e, t, n) => {
    if (t._n)
        return t;
    const r = oe((...o) => rC(t(...o)), n);
    return r._c = !1,
    r
}, k4 = (e, t, n) => {
    const r = e._ctx;
    for (const o in e) {
        if (_4(o))
            continue;
        const i = e[o];
        if (Ot(i))
            t[o] = WJ(o, i, r);
        else if (i != null) {
            const s = rC(i);
            t[o] = () => s
        }
    }
}, x4 = (e, t) => {
    const n = rC(t);
    e.slots.default = () => n
}, zJ = (e, t) => {
    if (e.vnode.shapeFlag & 32) {
        const n = t._;
        n ? (e.slots = Xt(t), I0(t, "_", n)) : k4(t, e.slots = {})
    } else
        e.slots = {},
    t && x4(e, t);
    I0(e.slots, U1, 1)
}, HJ = (e, t, n) => {
    const {
        vnode: r,
        slots: o
    } = e;
    let i = !0,
    s = xn;
    if (r.shapeFlag & 32) {
        const a = t._;
        a ? n && a === 1 ? i = !1 : (jn(o, t), !n && a === 1 && delete o._) : (i = !t.$stable, k4(t, o)),
        s = t
    } else
        t && (x4(e, t), s = {
            default:
                1
            });
    if (i)
        for (const a in o)
            !_4(a) && !(a in s) && delete o[a]
};
function A0(e, t, n, r, o = !1) {
    if (st(e)) {
        e.forEach((p, m) => A0(p, t && (st(t) ? t[m] : t), n, r, o));
        return
    }
    if (ou(r) && !o)
        return;
    const i = r.shapeFlag & 4 ? q1(r.component) || r.component.proxy : r.el,
    s = o ? null : i, {
        i: a,
        r: l
    } = e,
    c = t && t.r,
    u = a.refs === xn ? a.refs = {}
     : a.refs,
    f = a.setupState;
    if (c != null && c !== l && (Gn(c) ? (u[c] = null, un(f, c) && (f[c] = null)) : Dr(c) && (c.value = null)), Ot(l))
        qa(l, a, 12, [s, u]);
    else {
        const p = Gn(l),
        m = Dr(l);
        if (p || m) {
            const v = () => {
                if (e.f) {
                    const y = p ? un(f, l) ? f[l] : u[l] : l.value;
                    o ? st(y) && NS(y, i) : st(y) ? y.includes(i) || y.push(i) : p ? (u[l] = [i], un(f, l) && (f[l] = u[l])) : (l.value = [i], e.k && (u[e.k] = l.value))
                } else
                    p ? (u[l] = s, un(f, l) && (f[l] = s)) : m && (l.value = s, e.k && (u[e.k] = s))
            };
            s ? (v.id = -1, Gr(v, n)) : v()
        }
    }
}
let wl = !1;
const bv = e => /svg/.test(e.namespaceURI) && e.tagName !== "foreignObject", _v = e => e.nodeType === 8;
function UJ(e) {
    const {
        mt: t,
        p: n,
        o: {
            patchProp: r,
            createText: o,
            nextSibling: i,
            parentNode: s,
            remove: a,
            insert: l,
            createComment: c
        }
    } = e,
    u = (w, k) => {
        if (!k.hasChildNodes()) {
            n(null, w, k),
            E0(),
            k._vnode = w;
            return
        }
        wl = !1,
        f(k.firstChild, w, null, null, null),
        E0(),
        k._vnode = w,
        wl && console.error("Hydration completed but contains mismatches.")
    },
    f = (w, k, C, x, S, T = !1) => {
        const E = _v(w) && w.data === "[",
        M = () => y(w, k, C, x, S, E), {
            type: N,
            ref: F,
            shapeFlag: K,
            patchFlag: j
        } = k;
        let G = w.nodeType;
        k.el = w,
        j === -2 && (T = !1, k.dynamicChildren = null);
        let Y = null;
        switch (N) {
        case xu:
            G !== 3 ? k.children === "" ? (l(k.el = o(""), s(w), w), Y = w) : Y = M() : (w.data !== k.children && (wl = !0, w.data = k.children), Y = i(w));
            break;
        case Qr:
            G !== 8 || E ? Y = M() : Y = i(w);
            break;
        case su:
            if (E && (w = i(w), G = w.nodeType), G === 1 || G === 3) {
                Y = w;
                const ue = !k.children.length;
                for (let re = 0; re < k.staticCount; re++)
                    ue && (k.children += Y.nodeType === 1 ? Y.outerHTML : Y.data), re === k.staticCount - 1 && (k.anchor = Y), Y = i(Y);
                return E ? i(Y) : Y
            } else
                M();
            break;
        case Le:
            E ? Y = v(w, k, C, x, S, T) : Y = M();
            break;
        default:
            if (K & 1)
                G !== 1 || k.type.toLowerCase() !== w.tagName.toLowerCase() ? Y = M() : Y = p(w, k, C, x, S, T);
            else if (K & 6) {
                k.slotScopeIds = S;
                const ue = s(w);
                if (t(k, ue, null, C, x, bv(ue), T), Y = E ? b(w) : i(w), Y && _v(Y) && Y.data === "teleport end" && (Y = i(Y)), ou(k)) {
                    let re;
                    E ? (re = z(Le), re.anchor = Y ? Y.previousSibling : ue.lastChild) : re = w.nodeType === 3 ? mt("") : z("div"),
                    re.el = w,
                    k.component.subTree = re
                }
            } else
                K & 64 ? G !== 8 ? Y = M() : Y = k.type.hydrate(w, k, C, x, S, T, e, m) : K & 128 && (Y = k.type.hydrate(w, k, C, x, bv(s(w)), S, T, e, f))
        }
        return F != null && A0(F, null, x, k),
        Y
    },
    p = (w, k, C, x, S, T) => {
        T = T || !!k.dynamicChildren;
        const {
            type: E,
            props: M,
            patchFlag: N,
            shapeFlag: F,
            dirs: K
        } = k,
        j = E === "input" && K || E === "option";
        if (j || N !== -1) {
            if (K && Us(k, null, C, "created"), M)
                if (j || !T || N & 48)
                    for (const Y in M)
                        (j && Y.endsWith("value") || Km(Y) && !yp(Y)) && r(w, Y, null, M[Y], !1, void 0, C);
                else
                    M.onClick && r(w, "onClick", null, M.onClick, !1, void 0, C);
            let G;
            if ((G = M && M.onVnodeBeforeMount) && Bo(G, C, k), K && Us(k, null, C, "beforeMount"), ((G = M && M.onVnodeMounted) || K) && e4(() => {
                    G && Bo(G, C, k),
                    K && Us(k, null, C, "mounted")
                }, x), F & 16 && !(M && (M.innerHTML || M.textContent))) {
                let Y = m(w.firstChild, k, w, C, x, S, T);
                for (; Y; ) {
                    wl = !0;
                    const ue = Y;
                    Y = Y.nextSibling,
                    a(ue)
                }
            } else
                F & 8 && w.textContent !== k.children && (wl = !0, w.textContent = k.children)
        }
        return w.nextSibling
    },
    m = (w, k, C, x, S, T, E) => {
        E = E || !!k.dynamicChildren;
        const M = k.children,
        N = M.length;
        for (let F = 0; F < N; F++) {
            const K = E ? M[F] : M[F] = yi(M[F]);
            if (w)
                w = f(w, K, x, S, T, E);
            else {
                if (K.type === xu && !K.children)
                    continue;
                wl = !0,
                n(null, K, C, null, x, S, bv(C), T)
            }
        }
        return w
    },
    v = (w, k, C, x, S, T) => {
        const {
            slotScopeIds: E
        } = k;
        E && (S = S ? S.concat(E) : E);
        const M = s(w),
        N = m(i(w), k, M, C, x, S, T);
        return N && _v(N) && N.data === "]" ? i(k.anchor = N) : (wl = !0, l(k.anchor = c("]"), M, N), N)
    },
    y = (w, k, C, x, S, T) => {
        if (wl = !0, k.el = null, T) {
            const N = b(w);
            for (; ; ) {
                const F = i(w);
                if (F && F !== N)
                    a(F);
                else
                    break
            }
        }
        const E = i(w),
        M = s(w);
        return a(w),
        n(null, k, M, E, C, x, bv(M), S),
        E
    },
    b = w => {
        let k = 0;
        for (; w; )
            if (w = i(w), w && _v(w) && (w.data === "[" && k++, w.data === "]")) {
                if (k === 0)
                    return i(w);
                k--
            }
        return w
    };
    return [u, f]
}
const Gr = e4;
function S4(e) {
    return I4(e)
}
function C4(e) {
    return I4(e, UJ)
}
function I4(e, t) {
    const n = fk();
    n.__VUE__ = !0;
    const {
        insert: r,
        remove: o,
        patchProp: i,
        createElement: s,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: f,
        nextSibling: p,
        setScopeId: m = Cs,
        insertStaticContent: v
    } = e,
    y = (W, R, X, Q = null, Z = null, fe = null, be = !1, Ee = null, Me = !!R.dynamicChildren) => {
        if (W === R)
            return;
        W && !ks(W, R) && (Q = ge(W), Ue(W, Z, fe, !0), W = null),
        R.patchFlag === -2 && (Me = !1, R.dynamicChildren = null);
        const {
            type: we,
            ref: He,
            shapeFlag: We
        } = R;
        switch (we) {
        case xu:
            b(W, R, X, Q);
            break;
        case Qr:
            w(W, R, X, Q);
            break;
        case su:
            W == null && k(R, X, Q, be);
            break;
        case Le:
            j(W, R, X, Q, Z, fe, be, Ee, Me);
            break;
        default:
            We & 1 ? S(W, R, X, Q, Z, fe, be, Ee, Me) : We & 6 ? G(W, R, X, Q, Z, fe, be, Ee, Me) : (We & 64 || We & 128) && we.process(W, R, X, Q, Z, fe, be, Ee, Me, xe)
        }
        He != null && Z && A0(He, W && W.ref, fe, R || W, !R)
    },
    b = (W, R, X, Q) => {
        if (W == null)
            r(R.el = a(R.children), X, Q);
        else {
            const Z = R.el = W.el;
            R.children !== W.children && c(Z, R.children)
        }
    },
    w = (W, R, X, Q) => {
        W == null ? r(R.el = l(R.children || ""), X, Q) : R.el = W.el
    },
    k = (W, R, X, Q) => {
        [W.el, W.anchor] = v(W.children, R, X, Q, W.el, W.anchor)
    },
    C = ({
        el: W,
        anchor: R
    }, X, Q) => {
        let Z;
        for (; W && W !== R; )
            Z = p(W), r(W, X, Q), W = Z;
        r(R, X, Q)
    },
    x = ({
        el: W,
        anchor: R
    }) => {
        let X;
        for (; W && W !== R; )
            X = p(W), o(W), W = X;
        o(R)
    },
    S = (W, R, X, Q, Z, fe, be, Ee, Me) => {
        be = be || R.type === "svg",
        W == null ? T(R, X, Q, Z, fe, be, Ee, Me) : N(W, R, Z, fe, be, Ee, Me)
    },
    T = (W, R, X, Q, Z, fe, be, Ee) => {
        let Me,
        we;
        const {
            type: He,
            props: We,
            shapeFlag: Je,
            transition: qe,
            dirs: wt
        } = W;
        if (Me = W.el = s(W.type, fe, We && We.is, We), Je & 8 ? u(Me, W.children) : Je & 16 && M(W.children, Me, null, Q, Z, fe && He !== "foreignObject", be, Ee), wt && Us(W, null, Q, "created"), E(Me, W, W.scopeId, be, Q), We) {
            for (const bt in We)
                bt !== "value" && !yp(bt) && i(Me, bt, null, We[bt], fe, W.children, Q, Z, ye);
            "value" in We && i(Me, "value", null, We.value),
            (we = We.onVnodeBeforeMount) && Bo(we, Q, W)
        }
        wt && Us(W, null, Q, "beforeMount");
        const Et = (!Z || Z && !Z.pendingBranch) && qe && !qe.persisted;
        Et && qe.beforeEnter(Me),
        r(Me, R, X),
        ((we = We && We.onVnodeMounted) || Et || wt) && Gr(() => {
            we && Bo(we, Q, W),
            Et && qe.enter(Me),
            wt && Us(W, null, Q, "mounted")
        }, Z)
    },
    E = (W, R, X, Q, Z) => {
        if (X && m(W, X), Q)
            for (let fe = 0; fe < Q.length; fe++)
                m(W, Q[fe]);
        if (Z) {
            let fe = Z.subTree;
            if (R === fe) {
                const be = Z.vnode;
                E(W, be, be.scopeId, be.slotScopeIds, Z.parent)
            }
        }
    },
    M = (W, R, X, Q, Z, fe, be, Ee, Me = 0) => {
        for (let we = Me; we < W.length; we++) {
            const He = W[we] = Ee ? El(W[we]) : yi(W[we]);
            y(null, He, R, X, Q, Z, fe, be, Ee)
        }
    },
    N = (W, R, X, Q, Z, fe, be) => {
        const Ee = R.el = W.el;
        let {
            patchFlag: Me,
            dynamicChildren: we,
            dirs: He
        } = R;
        Me |= W.patchFlag & 16;
        const We = W.props || xn,
        Je = R.props || xn;
        let qe;
        X && $c(X, !1),
        (qe = Je.onVnodeBeforeUpdate) && Bo(qe, X, R, W),
        He && Us(R, W, X, "beforeUpdate"),
        X && $c(X, !0);
        const wt = Z && R.type !== "foreignObject";
        if (we ? F(W.dynamicChildren, we, Ee, X, Q, wt, fe) : be || Se(W, R, Ee, null, X, Q, wt, fe, !1), Me > 0) {
            if (Me & 16)
                K(Ee, R, We, Je, X, Q, Z);
            else if (Me & 2 && We.class !== Je.class && i(Ee, "class", null, Je.class, Z), Me & 4 && i(Ee, "style", We.style, Je.style, Z), Me & 8) {
                const Et = R.dynamicProps;
                for (let bt = 0; bt < Et.length; bt++) {
                    const ze = Et[bt],
                    Ze = We[ze],
                    Lt = Je[ze];
                    (Lt !== Ze || ze === "value") && i(Ee, ze, Ze, Lt, Z, W.children, X, Q, ye)
                }
            }
            Me & 1 && W.children !== R.children && u(Ee, R.children)
        } else !be && we == null && K(Ee, R, We, Je, X, Q, Z);
        ((qe = Je.onVnodeUpdated) || He) && Gr(() => {
            qe && Bo(qe, X, R, W),
            He && Us(R, W, X, "updated")
        }, Q)
    },
    F = (W, R, X, Q, Z, fe, be) => {
        for (let Ee = 0; Ee < R.length; Ee++) {
            const Me = W[Ee],
            we = R[Ee],
            He = Me.el && (Me.type === Le || !ks(Me, we) || Me.shapeFlag & 70) ? f(Me.el) : X;
            y(Me, we, He, null, Q, Z, fe, be, !0)
        }
    },
    K = (W, R, X, Q, Z, fe, be) => {
        if (X !== Q) {
            if (X !== xn)
                for (const Ee in X)
                    !yp(Ee) && !(Ee in Q) && i(W, Ee, X[Ee], null, be, R.children, Z, fe, ye);
            for (const Ee in Q) {
                if (yp(Ee))
                    continue;
                const Me = Q[Ee],
                we = X[Ee];
                Me !== we && Ee !== "value" && i(W, Ee, we, Me, be, R.children, Z, fe, ye)
            }
            "value" in Q && i(W, "value", X.value, Q.value)
        }
    },
    j = (W, R, X, Q, Z, fe, be, Ee, Me) => {
        const we = R.el = W ? W.el : a(""),
        He = R.anchor = W ? W.anchor : a("");
        let {
            patchFlag: We,
            dynamicChildren: Je,
            slotScopeIds: qe
        } = R;
        qe && (Ee = Ee ? Ee.concat(qe) : qe),
        W == null ? (r(we, X, Q), r(He, X, Q), M(R.children, X, He, Z, fe, be, Ee, Me)) : We > 0 && We & 64 && Je && W.dynamicChildren ? (F(W.dynamicChildren, Je, X, Z, fe, be, Ee), (R.key != null || Z && R === Z.subTree) && oC(W, R, !0)) : Se(W, R, X, He, Z, fe, be, Ee, Me)
    },
    G = (W, R, X, Q, Z, fe, be, Ee, Me) => {
        R.slotScopeIds = Ee,
        W == null ? R.shapeFlag & 512 ? Z.ctx.activate(R, X, Q, be, Me) : Y(R, X, Q, Z, fe, be, Me) : ue(W, R, Me)
    },
    Y = (W, R, X, Q, Z, fe, be) => {
        const Ee = W.component = O4(W, Q, Z);
        if (Zm(W) && (Ee.ctx.renderer = xe), A4(Ee), Ee.asyncDep) {
            if (Z && Z.registerDep(Ee, re), !W.el) {
                const Me = Ee.subTree = z(Qr);
                w(null, Me, R, X)
            }
            return
        }
        re(Ee, W, R, X, Z, fe, be)
    },
    ue = (W, R, X) => {
        const Q = R.component = W.component;
        if (rJ(W, R, X))
            if (Q.asyncDep && !Q.asyncResolved) {
                de(Q, R, X);
                return
            } else
                Q.next = R, XX(Q.update), Q.update();
        else
            R.el = W.el, Q.vnode = R
    },
    re = (W, R, X, Q, Z, fe, be) => {
        const Ee = () => {
            if (W.isMounted) {
                let {
                    next: He,
                    bu: We,
                    u: Je,
                    parent: qe,
                    vnode: wt
                } = W,
                Et = He,
                bt;
                $c(W, !1),
                He ? (He.el = wt.el, de(W, He, be)) : He = wt,
                We && Jd(We),
                (bt = He.props && He.props.onVnodeBeforeUpdate) && Bo(bt, qe, He, wt),
                $c(W, !0);
                const ze = t0(W),
                Ze = W.subTree;
                W.subTree = ze,
                y(Ze, ze, f(Ze.el), ge(Ze), W, Z, fe),
                He.el = ze.el,
                Et === null && KS(W, ze.el),
                Je && Gr(Je, Z),
                (bt = He.props && He.props.onVnodeUpdated) && Gr(() => Bo(bt, qe, He, wt), Z)
            } else {
                let He;
                const {
                    el: We,
                    props: Je
                } = R, {
                    bm: qe,
                    m: wt,
                    parent: Et
                } = W,
                bt = ou(R);
                if ($c(W, !1), qe && Jd(qe), !bt && (He = Je && Je.onVnodeBeforeMount) && Bo(He, Et, R), $c(W, !0), We && Xe) {
                    const ze = () => {
                        W.subTree = t0(W),
                        Xe(We, W.subTree, W, Z, null)
                    };
                    bt ? R.type.__asyncLoader().then(() => !W.isUnmounted && ze()) : ze()
                } else {
                    const ze = W.subTree = t0(W);
                    y(null, ze, X, Q, W, Z, fe),
                    R.el = ze.el
                }
                if (wt && Gr(wt, Z), !bt && (He = Je && Je.onVnodeMounted)) {
                    const ze = R;
                    Gr(() => Bo(He, Et, ze), Z)
                }
                (R.shapeFlag & 256 || Et && ou(Et.vnode) && Et.vnode.shapeFlag & 256) && W.a && Gr(W.a, Z),
                W.isMounted = !0,
                R = X = Q = null
            }
        },
        Me = W.effect = new Xm(Ee, () => R1(we), W.scope),
        we = W.update = () => Me.run();
        we.id = W.uid,
        $c(W, !0),
        we()
    },
    de = (W, R, X) => {
        R.component = W;
        const Q = W.vnode.props;
        W.vnode = R,
        W.next = null,
        jJ(W, R.props, Q, X),
        HJ(W, R.children, X),
        Qf(),
        VE(),
        eh()
    },
    Se = (W, R, X, Q, Z, fe, be, Ee, Me = !1) => {
        const we = W && W.children,
        He = W ? W.shapeFlag : 0,
        We = R.children, {
            patchFlag: Je,
            shapeFlag: qe
        } = R;
        if (Je > 0) {
            if (Je & 128) {
                je(we, We, X, Q, Z, fe, be, Ee, Me);
                return
            } else if (Je & 256) {
                Pe(we, We, X, Q, Z, fe, be, Ee, Me);
                return
            }
        }
        qe & 8 ? (He & 16 && ye(we, Z, fe), We !== we && u(X, We)) : He & 16 ? qe & 16 ? je(we, We, X, Q, Z, fe, be, Ee, Me) : ye(we, Z, fe, !0) : (He & 8 && u(X, ""), qe & 16 && M(We, X, Q, Z, fe, be, Ee, Me))
    },
    Pe = (W, R, X, Q, Z, fe, be, Ee, Me) => {
        W = W || Gd,
        R = R || Gd;
        const we = W.length,
        He = R.length,
        We = Math.min(we, He);
        let Je;
        for (Je = 0; Je < We; Je++) {
            const qe = R[Je] = Me ? El(R[Je]) : yi(R[Je]);
            y(W[Je], qe, X, null, Z, fe, be, Ee, Me)
        }
        we > He ? ye(W, Z, fe, !0, !1, We) : M(R, X, Q, Z, fe, be, Ee, Me, We)
    },
    je = (W, R, X, Q, Z, fe, be, Ee, Me) => {
        let we = 0;
        const He = R.length;
        let We = W.length - 1,
        Je = He - 1;
        for (; we <= We && we <= Je; ) {
            const qe = W[we],
            wt = R[we] = Me ? El(R[we]) : yi(R[we]);
            if (ks(qe, wt))
                y(qe, wt, X, null, Z, fe, be, Ee, Me);
            else
                break;
            we++
        }
        for (; we <= We && we <= Je; ) {
            const qe = W[We],
            wt = R[Je] = Me ? El(R[Je]) : yi(R[Je]);
            if (ks(qe, wt))
                y(qe, wt, X, null, Z, fe, be, Ee, Me);
            else
                break;
            We--,
            Je--
        }
        if (we > We) {
            if (we <= Je) {
                const qe = Je + 1,
                wt = qe < He ? R[qe].el : Q;
                for (; we <= Je; )
                    y(null, R[we] = Me ? El(R[we]) : yi(R[we]), X, wt, Z, fe, be, Ee, Me), we++
            }
        } else if (we > Je)
            for (; we <= We; )
                Ue(W[we], Z, fe, !0), we++;
        else {
            const qe = we,
            wt = we,
            Et = new Map;
            for (we = wt; we <= Je; we++) {
                const Pn = R[we] = Me ? El(R[we]) : yi(R[we]);
                Pn.key != null && Et.set(Pn.key, we)
            }
            let bt,
            ze = 0;
            const Ze = Je - wt + 1;
            let Lt = !1,
            pn = 0;
            const mr = new Array(Ze);
            for (we = 0; we < Ze; we++)
                mr[we] = 0;
            for (we = qe; we <= We; we++) {
                const Pn = W[we];
                if (ze >= Ze) {
                    Ue(Pn, Z, fe, !0);
                    continue
                }
                let Jn;
                if (Pn.key != null)
                    Jn = Et.get(Pn.key);
                else
                    for (bt = wt; bt <= Je; bt++)
                        if (mr[bt - wt] === 0 && ks(Pn, R[bt])) {
                            Jn = bt;
                            break
                        }
                Jn === void 0 ? Ue(Pn, Z, fe, !0) : (mr[Jn - wt] = we + 1, Jn >= pn ? pn = Jn : Lt = !0, y(Pn, R[Jn], X, null, Z, fe, be, Ee, Me), ze++)
            }
            const vo = Lt ? qJ(mr) : Gd;
            for (bt = vo.length - 1, we = Ze - 1; we >= 0; we--) {
                const Pn = wt + we,
                Jn = R[Pn],
                $o = Pn + 1 < He ? R[Pn + 1].el : Q;
                mr[we] === 0 ? y(null, Jn, X, $o, Z, fe, be, Ee, Me) : Lt && (bt < 0 || we !== vo[bt] ? Ke(Jn, X, $o, 2) : bt--)
            }
        }
    },
    Ke = (W, R, X, Q, Z = null) => {
        const {
            el: fe,
            type: be,
            transition: Ee,
            children: Me,
            shapeFlag: we
        } = W;
        if (we & 6) {
            Ke(W.component.subTree, R, X, Q);
            return
        }
        if (we & 128) {
            W.suspense.move(R, X, Q);
            return
        }
        if (we & 64) {
            be.move(W, R, X, xe);
            return
        }
        if (be === Le) {
            r(fe, R, X);
            for (let We = 0; We < Me.length; We++)
                Ke(Me[We], R, X, Q);
            r(W.anchor, R, X);
            return
        }
        if (be === su) {
            C(W, R, X);
            return
        }
        if (Q !== 2 && we & 1 && Ee)
            if (Q === 0)
                Ee.beforeEnter(fe), r(fe, R, X), Gr(() => Ee.enter(fe), Z);
            else {
                const {
                    leave: We,
                    delayLeave: Je,
                    afterLeave: qe
                } = Ee,
                wt = () => r(fe, R, X),
                Et = () => {
                    We(fe, () => {
                        wt(),
                        qe && qe()
                    })
                };
                Je ? Je(fe, wt, Et) : Et()
            }
        else
            r(fe, R, X)
    },
    Ue = (W, R, X, Q = !1, Z = !1) => {
        const {
            type: fe,
            props: be,
            ref: Ee,
            children: Me,
            dynamicChildren: we,
            shapeFlag: He,
            patchFlag: We,
            dirs: Je
        } = W;
        if (Ee != null && A0(Ee, null, X, W, !0), He & 256) {
            R.ctx.deactivate(W);
            return
        }
        const qe = He & 1 && Je,
        wt = !ou(W);
        let Et;
        if (wt && (Et = be && be.onVnodeBeforeUnmount) && Bo(Et, R, W), He & 6)
            le(W.component, X, Q);
        else {
            if (He & 128) {
                W.suspense.unmount(X, Q);
                return
            }
            qe && Us(W, null, R, "beforeUnmount"),
            He & 64 ? W.type.remove(W, R, X, Z, xe, Q) : we && (fe !== Le || We > 0 && We & 64) ? ye(we, R, X, !1, !0) : (fe === Le && We & 384 || !Z && He & 16) && ye(Me, R, X),
            Q && yt(W)
        }
        (wt && (Et = be && be.onVnodeUnmounted) || qe) && Gr(() => {
            Et && Bo(Et, R, W),
            qe && Us(W, null, R, "unmounted")
        }, X)
    },
    yt = W => {
        const {
            type: R,
            el: X,
            anchor: Q,
            transition: Z
        } = W;
        if (R === Le) {
            at(X, Q);
            return
        }
        if (R === su) {
            x(W);
            return
        }
        const fe = () => {
            o(X),
            Z && !Z.persisted && Z.afterLeave && Z.afterLeave()
        };
        if (W.shapeFlag & 1 && Z && !Z.persisted) {
            const {
                leave: be,
                delayLeave: Ee
            } = Z,
            Me = () => be(X, fe);
            Ee ? Ee(W.el, fe, Me) : Me()
        } else
            fe()
    },
    at = (W, R) => {
        let X;
        for (; W !== R; )
            X = p(W), o(W), W = X;
        o(R)
    },
    le = (W, R, X) => {
        const {
            bum: Q,
            scope: Z,
            update: fe,
            subTree: be,
            um: Ee
        } = W;
        Q && Jd(Q),
        Z.stop(),
        fe && (fe.active = !1, Ue(be, W, R, X)),
        Ee && Gr(Ee, R),
        Gr(() => {
            W.isUnmounted = !0
        }, R),
        R && R.pendingBranch && !R.isUnmounted && W.asyncDep && !W.asyncResolved && W.suspenseId === R.pendingId && (R.deps--, R.deps === 0 && R.resolve())
    },
    ye = (W, R, X, Q = !1, Z = !1, fe = 0) => {
        for (let be = fe; be < W.length; be++)
            Ue(W[be], R, X, Q, Z)
    },
    ge = W => W.shapeFlag & 6 ? ge(W.component.subTree) : W.shapeFlag & 128 ? W.suspense.next() : p(W.anchor || W.el),
    pe = (W, R, X) => {
        W == null ? R._vnode && Ue(R._vnode, null, null, !0) : y(R._vnode || null, W, R, null, null, null, X),
        VE(),
        E0(),
        R._vnode = W
    },
    xe = {
        p: y,
        um: Ue,
        m: Ke,
        r: yt,
        mt: Y,
        mc: M,
        pc: Se,
        pbc: F,
        n: ge,
        o: e
    };
    let et,
    Xe;
    return t && ([et, Xe] = t(xe)), {
        render: pe,
        hydrate: et,
        createApp: BJ(pe, et)
    }
}
function $c({
    effect: e,
    update: t
}, n) {
    e.allowRecurse = t.allowRecurse = n
}
function oC(e, t, n = !1) {
    const r = e.children,
    o = t.children;
    if (st(r) && st(o))
        for (let i = 0; i < r.length; i++) {
            const s = r[i];
            let a = o[i];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = o[i] = El(o[i]), a.el = s.el), n || oC(s, a)),
            a.type === xu && (a.el = s.el)
        }
}
function qJ(e) {
    const t = e.slice(),
    n = [0];
    let r,
    o,
    i,
    s,
    a;
    const l = e.length;
    for (r = 0; r < l; r++) {
        const c = e[r];
        if (c !== 0) {
            if (o = n[n.length - 1], e[o] < c) {
                t[r] = o,
                n.push(r);
                continue
            }
            for (i = 0, s = n.length - 1; i < s; )
                a = i + s >> 1, e[n[a]] < c ? i = a + 1 : s = a;
            c < e[n[i]] && (i > 0 && (t[r] = n[i - 1]), n[i] = r)
        }
    }
    for (i = n.length, s = n[i - 1]; i-- > 0; )
        n[i] = s, s = t[s];
    return n
}
const YJ = e => e.__isTeleport, _p = e => e && (e.disabled || e.disabled === ""), JE = e => typeof SVGElement < "u" && e instanceof SVGElement, kk = (e, t) => {
    const n = e && e.to;
    return Gn(n) ? t ? t(n) : null : n
}, KJ = {
    __isTeleport: !0,
    process(e, t, n, r, o, i, s, a, l, c) {
        const {
            mc: u,
            pc: f,
            pbc: p,
            o: {
                insert: m,
                querySelector: v,
                createText: y,
                createComment: b
            }
        } = c,
        w = _p(t.props);
        let {
            shapeFlag: k,
            children: C,
            dynamicChildren: x
        } = t;
        if (e == null) {
            const S = t.el = y(""),
            T = t.anchor = y("");
            m(S, n, r),
            m(T, n, r);
            const E = t.target = kk(t.props, v),
            M = t.targetAnchor = y("");
            E && (m(M, E), s = s || JE(E));
            const N = (F, K) => {
                k & 16 && u(C, F, K, o, i, s, a, l)
            };
            w ? N(n, T) : E && N(E, M)
        } else {
            t.el = e.el;
            const S = t.anchor = e.anchor,
            T = t.target = e.target,
            E = t.targetAnchor = e.targetAnchor,
            M = _p(e.props),
            N = M ? n : T,
            F = M ? S : E;
            if (s = s || JE(T), x ? (p(e.dynamicChildren, x, N, o, i, s, a), oC(e, t, !0)) : l || f(e, t, N, F, o, i, s, a, !1), w)
                M || kv(t, n, S, c, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const K = t.target = kk(t.props, v);
                K && kv(t, K, null, c, 0)
            } else
                M && kv(t, T, E, c, 1)
        }
        T4(t)
    },
    remove(e, t, n, r, {
        um: o,
        o: {
            remove: i
        }
    }, s) {
        const {
            shapeFlag: a,
            children: l,
            anchor: c,
            targetAnchor: u,
            target: f,
            props: p
        } = e;
        if (f && i(u), (s || !_p(p)) && (i(c), a & 16))
            for (let m = 0; m < l.length; m++) {
                const v = l[m];
                o(v, t, n, !0, !!v.dynamicChildren)
            }
    },
    move: kv,
    hydrate: GJ
};
function kv(e, t, n, {
    o: {
        insert: r
    },
    m: o
}, i = 2) {
    i === 0 && r(e.targetAnchor, t, n);
    const {
        el: s,
        anchor: a,
        shapeFlag: l,
        children: c,
        props: u
    } = e,
    f = i === 2;
    if (f && r(s, t, n), (!f || _p(u)) && l & 16)
        for (let p = 0; p < c.length; p++)
            o(c[p], t, n, 2);
    f && r(a, t, n)
}
function GJ(e, t, n, r, o, i, {
    o: {
        nextSibling: s,
        parentNode: a,
        querySelector: l
    }
}, c) {
    const u = t.target = kk(t.props, l);
    if (u) {
        const f = u._lpa || u.firstChild;
        if (t.shapeFlag & 16)
            if (_p(t.props))
                t.anchor = c(s(e), t, a(e), n, r, o, i), t.targetAnchor = f;
            else {
                t.anchor = s(e);
                let p = f;
                for (; p; )
                    if (p = s(p), p && p.nodeType === 8 && p.data === "teleport anchor") {
                        t.targetAnchor = p,
                        u._lpa = t.targetAnchor && s(t.targetAnchor);
                        break
                    }
                c(f, t, u, n, r, o, i)
            }
        T4(t)
    }
    return t.anchor && s(t.anchor)
}
const H1 = KJ;
function T4(e) {
    const t = e.ctx;
    if (t && t.ut) {
        let n = e.children[0].el;
        for (; n !== e.targetAnchor; )
            n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling;
        t.ut()
    }
}
const Le = Symbol.for("v-fgt"), xu = Symbol.for("v-txt"), Qr = Symbol.for("v-cmt"), su = Symbol.for("v-stc"), kp = [];
let Ho = null;
function _(e = !1) {
    kp.push(Ho = e ? null : [])
}
function M4() {
    kp.pop(),
    Ho = kp[kp.length - 1] || null
}
let Su = 1;
function xk(e) {
    Su += e
}
function P4(e) {
    return e.dynamicChildren = Su > 0 ? Ho || Gd : null,
    M4(),
    Su > 0 && Ho && Ho.push(e),
    e
}
function O(e, t, n, r, o, i) {
    return P4(P(e, t, n, r, o, i, !0))
}
function H(e, t, n, r, o) {
    return P4(z(e, t, n, r, o, !0))
}
function ec(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function ks(e, t) {
    return e.type === t.type && e.key === t.key
}
function XJ(e) {}
const U1 = "__vInternal", E4 = ({
    key: e
}) => e ?? null, n0 = ({
    ref: e,
    ref_key: t,
    ref_for: n
}) => (typeof e == "number" && (e = "" + e), e != null ? Gn(e) || Dr(e) || Ot(e) ? {
    i: Fr,
    r: e,
    k: t,
    f: !!n
}
     : e : null);
function P(e, t = null, n = null, r = 0, o = null, i = e === Le ? 0 : 1, s = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && E4(t),
        ref: t && n0(t),
        scopeId: B1,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: r,
        dynamicProps: o,
        dynamicChildren: null,
        appContext: null,
        ctx: Fr
    };
    return a ? (sC(l, n), i & 128 && e.normalize(l)) : n && (l.shapeFlag |= Gn(n) ? 8 : 16),
    Su > 0 && !s && Ho && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && Ho.push(l),
    l
}
const z = JJ;
function JJ(e, t = null, n = null, r = 0, o = null, i = !1) {
    if ((!e || e === p4) && (e = Qr), ec(e)) {
        const a = Ps(e, t, !0);
        return n && sC(a, n),
        Su > 0 && !i && Ho && (a.shapeFlag & 6 ? Ho[Ho.indexOf(e)] = a : Ho.push(a)),
        a.patchFlag |= -2,
        a
    }
    if (oZ(e) && (e = e.__vccOpts), t) {
        t = tc(t);
        let {
            class: a,
            style: l
        } = t;
        a && !Gn(a) && (t.class = he(a)),
        In(l) && (WS(l) && !st(l) && (l = jn({}, l)), t.style = Yt(l))
    }
    const s = Gn(e) ? 1 : QR(e) ? 128 : YJ(e) ? 64 : In(e) ? 4 : Ot(e) ? 2 : 0;
    return P(e, t, n, r, o, s, i, !0)
}
function tc(e) {
    return e ? WS(e) || U1 in e ? jn({}, e) : e : null
}
function Ps(e, t, n = !1) {
    const {
        props: r,
        ref: o,
        patchFlag: i,
        children: s
    } = e,
    a = t ? Bt(r || {}, t) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && E4(a),
        ref: t && t.ref ? n && o ? st(o) ? o.concat(n0(t)) : [o, n0(t)] : n0(t) : o,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: s,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Le ? i === -1 ? 16 : i | 16 : i,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Ps(e.ssContent),
        ssFallback: e.ssFallback && Ps(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}
function mt(e = " ", t = 0) {
    return z(xu, null, e, t)
}
function iC(e, t) {
    const n = z(su, null, e);
    return n.staticCount = t,
    n
}
function J(e = "", t = !1) {
    return t ? (_(), H(Qr, null, e)) : z(Qr, null, e)
}
function yi(e) {
    return e == null || typeof e == "boolean" ? z(Qr) : st(e) ? z(Le, null, e.slice()) : typeof e == "object" ? El(e) : z(xu, null, String(e))
}
function El(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : Ps(e)
}
function sC(e, t) {
    let n = 0;
    const {
        shapeFlag: r
    } = e;
    if (t == null)
        t = null;
    else if (st(t))
        n = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const o = t.default;
            o && (o._c && (o._d = !1), sC(e, o()), o._c && (o._d = !0));
            return
        } else {
            n = 32;
            const o = t._;
            !o && !(U1 in t) ? t._ctx = Fr : o === 3 && Fr && (Fr.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
        }
    else
        Ot(t) ? (t = {
            default:
                t,
                _ctx: Fr
            }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [mt(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function Bt(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const o in r)
            if (o === "class")
                t.class !== r.class && (t.class = he([t.class, r.class]));
            else if (o === "style")
                t.style = Yt([t.style, r.style]);
            else if (Km(o)) {
                const i = t[o],
                s = r[o];
                s && i !== s && !(st(i) && i.includes(s)) && (t[o] = i ? [].concat(i, s) : s)
            } else
                o !== "" && (t[o] = r[o])
    }
    return t
}
function Bo(e, t, n, r = null) {
    xi(e, t, 7, [n, r])
}
const ZJ = y4();
let QJ = 0;
function O4(e, t, n) {
    const r = e.type,
    o = (t ? t.appContext : e.appContext) || ZJ,
    i = {
        uid: QJ++,
        vnode: e,
        type: r,
        parent: t,
        appContext: o,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new BS(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(o.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: b4(r, o),
        emitsOptions: ZR(r, o),
        emit: null,
        emitted: null,
        propsDefaults: xn,
        inheritAttrs: r.inheritAttrs,
        ctx: xn,
        data: xn,
        props: xn,
        attrs: xn,
        slots: xn,
        refs: xn,
        setupState: xn,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return i.ctx = {
        _: i
    },
    i.root = t ? t.root : i,
    i.emit = ZX.bind(null, i),
    e.ce && e.ce(i),
    i
}
let Mr = null;
const ii = () => Mr || Fr;
let aC, vd, ZE = "__VUE_INSTANCE_SETTERS__";
(vd = fk()[ZE]) || (vd = fk()[ZE] = []), vd.push(e => Mr = e), aC = e => {
    vd.length > 1 ? vd.forEach(t => t(e)) : vd[0](e)
};
const nc = e => {
    aC(e),
    e.scope.on()
}, Hl = () => {
    Mr && Mr.scope.off(),
    aC(null)
};
function $4(e) {
    return e.vnode.shapeFlag & 4
}
let pf = !1;
function A4(e, t = !1) {
    pf = t;
    const {
        props: n,
        children: r
    } = e.vnode,
    o = $4(e);
    FJ(e, n, o, t),
    zJ(e, r);
    const i = o ? eZ(e, t) : void 0;
    return pf = !1,
    i
}
function eZ(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null),
    e.proxy = oa(new Proxy(e.ctx, yk));
    const {
        setup: r
    } = n;
    if (r) {
        const o = e.setupContext = r.length > 1 ? N4(e) : null;
        nc(e),
        Qf();
        const i = qa(r, e, 0, [e.props, o]);
        if (eh(), Hl(), RS(i)) {
            if (i.then(Hl, Hl), t)
                return i.then(s => {
                    Sk(e, s, t)
                }).catch(s => {
                    zu(s, e, 0)
                });
            e.asyncDep = i
        } else
            Sk(e, i, t)
    } else
        D4(e, t)
}
function Sk(e, t, n) {
    Ot(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : In(t) && (e.setupState = US(t)),
    D4(e, n)
}
let D0, Ck;
function tZ(e) {
    D0 = e,
    Ck = t => {
        t.render._rc && (t.withProxy = new Proxy(t.ctx, yJ))
    }
}
const nZ = () => !D0;
function D4(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && D0 && !r.render) {
            const o = r.template || nC(e).template;
            if (o) {
                const {
                    isCustomElement: i,
                    compilerOptions: s
                } = e.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = r,
                c = jn(jn({
                            isCustomElement: i,
                            delimiters: a
                        }, s), l);
                r.render = D0(o, c)
            }
        }
        e.render = r.render || Cs,
        Ck && Ck(e)
    }
    nc(e),
    Qf(),
    $J(e),
    eh(),
    Hl()
}
function rZ(e) {
    return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs, {
            get(t, n) {
                return ei(e, "get", "$attrs"),
                t[n]
            }
        }))
}
function N4(e) {
    const t = n => {
        e.exposed = n || {}
    };
    return {
        get attrs() {
            return rZ(e)
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function q1(e) {
    if (e.exposed)
        return e.exposeProxy || (e.exposeProxy = new Proxy(US(oa(e.exposed)), {
                get(t, n) {
                    if (n in t)
                        return t[n];
                    if (n in bp)
                        return bp[n](e)
                },
                has(t, n) {
                    return n in t || n in bp
                }
            }))
}
function Ik(e, t = !0) {
    return Ot(e) ? e.displayName || e.name : e.name || t && e.__name
}
function oZ(e) {
    return Ot(e) && "__vccOpts" in e
}
const ne = (e, t) => UX(e, t, pf);
function dt(e, t, n) {
    const r = arguments.length;
    return r === 2 ? In(t) && !st(t) ? ec(t) ? z(e, null, [t]) : z(e, t) : z(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && ec(n) && (n = [n]), z(e, t, n))
}
const R4 = Symbol.for("v-scx"), L4 = () => Mo(R4);
function iZ() {}
function sZ(e, t, n, r) {
    const o = n[r];
    if (o && B4(o, e))
        return o;
    const i = t();
    return i.memo = e.slice(),
    n[r] = i
}
function B4(e, t) {
    const n = e.memo;
    if (n.length != t.length)
        return !1;
    for (let r = 0; r < n.length; r++)
        if (ff(n[r], t[r]))
            return !1;
    return Su > 0 && Ho && Ho.push(e),
    !0
}
const V4 = "3.3.4", aZ = {
    createComponentInstance: O4,
    setupComponent: A4,
    renderComponentRoot: t0,
    setCurrentRenderingInstance: rm,
    isVNode: ec,
    normalizeVNode: yi
}, lZ = aZ, cZ = null, uZ = null, dZ = "http://www.w3.org/2000/svg", zc = typeof document < "u" ? document : null, QE = zc && zc.createElement("template"), fZ = {
    insert: (e, t, n) => {
        t.insertBefore(e, n || null)
    },
    remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
    },
    createElement: (e, t, n, r) => {
        const o = t ? zc.createElementNS(dZ, e) : zc.createElement(e, n ? {
            is: n
        }
                 : void 0);
        return e === "select" && r && r.multiple != null && o.setAttribute("multiple", r.multiple),
        o
    },
    createText: e => zc.createTextNode(e),
    createComment: e => zc.createComment(e),
    setText: (e, t) => {
        e.nodeValue = t
    },
    setElementText: (e, t) => {
        e.textContent = t
    },
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => zc.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, r, o, i) {
        const s = n ? n.previousSibling : t.lastChild;
        if (o && (o === i || o.nextSibling))
            for (; t.insertBefore(o.cloneNode(!0), n), !(o === i || !(o = o.nextSibling)); );
        else {
            QE.innerHTML = r ? `<svg>${e}</svg>` : e;
            const a = QE.content;
            if (r) {
                const l = a.firstChild;
                for (; l.firstChild; )
                    a.appendChild(l.firstChild);
                a.removeChild(l)
            }
            t.insertBefore(a, n)
        }
        return [s ? s.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
};
function hZ(e, t, n) {
    const r = e._vtc;
    r && (t = (t ? [t, ...r] : [...r]).join(" ")),
    t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
function pZ(e, t, n) {
    const r = e.style,
    o = Gn(n);
    if (n && !o) {
        if (t && !Gn(t))
            for (const i in t)
                n[i] == null && Tk(r, i, "");
        for (const i in n)
            Tk(r, i, n[i])
    } else {
        const i = r.display;
        o ? t !== n && (r.cssText = n) : t && e.removeAttribute("style"),
        "_vod" in e && (r.display = i)
    }
}
const e3 = /\s*!important$/;
function Tk(e, t, n) {
    if (st(n))
        n.forEach(r => Tk(e, t, r));
    else if (n == null && (n = ""), t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const r = mZ(e, t);
        e3.test(n) ? e.setProperty(Hi(r), n.replace(e3, ""), "important") : e[r] = n
    }
}
const t3 = ["Webkit", "Moz", "ms"], T_ = {};
function mZ(e, t) {
    const n = T_[t];
    if (n)
        return n;
    let r = Uo(t);
    if (r !== "filter" && r in e)
        return T_[t] = r;
    r = Gm(r);
    for (let o = 0; o < t3.length; o++) {
        const i = t3[o] + r;
        if (i in e)
            return T_[t] = i
    }
    return t
}
const n3 = "http://www.w3.org/1999/xlink";
function gZ(e, t, n, r, o) {
    if (r && t.startsWith("xlink:"))
        n == null ? e.removeAttributeNS(n3, t.slice(6, t.length)) : e.setAttributeNS(n3, t, n);
    else {
        const i = oX(t);
        n == null || i && !TR(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : n)
    }
}
function vZ(e, t, n, r, o, i, s) {
    if (t === "innerHTML" || t === "textContent") {
        r && s(r, o, i),
        e[t] = n ?? "";
        return
    }
    const a = e.tagName;
    if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
        e._value = n;
        const c = a === "OPTION" ? e.getAttribute("value") : e.value,
        u = n ?? "";
        c !== u && (e.value = u),
        n == null && e.removeAttribute(t);
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const c = typeof e[t];
        c === "boolean" ? n = TR(n) : n == null && c === "string" ? (n = "", l = !0) : c === "number" && (n = 0, l = !0)
    }
    try {
        e[t] = n
    } catch {}
    l && e.removeAttribute(t)
}
function Ua(e, t, n, r) {
    e.addEventListener(t, n, r)
}
function yZ(e, t, n, r) {
    e.removeEventListener(t, n, r)
}
function wZ(e, t, n, r, o = null) {
    const i = e._vei || (e._vei = {}),
    s = i[t];
    if (r && s)
        s.value = r;
    else {
        const [a, l] = bZ(t);
        if (r) {
            const c = i[t] = xZ(r, o);
            Ua(e, a, c, l)
        } else
            s && (yZ(e, a, s, l), i[t] = void 0)
    }
}
const r3 = /(?:Once|Passive|Capture)$/;
function bZ(e) {
    let t;
    if (r3.test(e)) {
        t = {};
        let r;
        for (; r = e.match(r3); )
            e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Hi(e.slice(2)), t]
}
let M_ = 0;
const _Z = Promise.resolve(), kZ = () => M_ || (_Z.then(() => M_ = 0), M_ = Date.now());
function xZ(e, t) {
    const n = r => {
        if (!r._vts)
            r._vts = Date.now();
        else if (r._vts <= n.attached)
            return;
        xi(SZ(r, n.value), t, 5, [r])
    };
    return n.value = e,
    n.attached = kZ(),
    n
}
function SZ(e, t) {
    if (st(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e),
            e._stopped = !0
        },
        t.map(r => o => !o._stopped && r && r(o))
    } else
        return t
}
const o3 = /^on[a-z]/, CZ = (e, t, n, r, o = !1, i, s, a, l) => {
    t === "class" ? hZ(e, r, o) : t === "style" ? pZ(e, n, r) : Km(t) ? DS(t) || wZ(e, t, n, r, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : IZ(e, t, r, o)) ? vZ(e, t, r, i, s, a, l) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), gZ(e, t, r, o))
};
function IZ(e, t, n, r) {
    return r ? !!(t === "innerHTML" || t === "textContent" || t in e && o3.test(t) && Ot(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || o3.test(t) && Gn(n) ? !1 : t in e
}
function F4(e, t) {
    const n = Fe(e);
    class r extends Y1 {
        constructor(i) {
            super(n, i, t)
        }
    }
    return r.def = n,
    r
}
const TZ = e => F4(e, tL), MZ = typeof HTMLElement < "u" ? HTMLElement : class {};
class Y1 extends MZ {
    constructor(t, n = {}, r) {
        super(),
        this._def = t,
        this._props = n,
        this._instance = null,
        this._connected = !1,
        this._resolved = !1,
        this._numberProps = null,
        this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : (this.attachShadow({
                mode: "open"
            }), this._def.__asyncLoader || this._resolveProps(this._def))
    }
    connectedCallback() {
        this._connected = !0,
        this._instance || (this._resolved ? this._update() : this._resolveDef())
    }
    disconnectedCallback() {
        this._connected = !1,
        Ci(() => {
            this._connected || (Ek(null, this.shadowRoot), this._instance = null)
        })
    }
    _resolveDef() {
        this._resolved = !0;
        for (let r = 0; r < this.attributes.length; r++)
            this._setAttr(this.attributes[r].name);
        new MutationObserver(r => {
            for (const o of r)
                this._setAttr(o.attributeName)
        }).observe(this, {
            attributes: !0
        });
        const t = (r, o = !1) => {
            const {
                props: i,
                styles: s
            } = r;
            let a;
            if (i && !st(i))
                for (const l in i) {
                    const c = i[l];
                    (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = M0(this._props[l])), (a || (a = Object.create(null)))[Uo(l)] = !0)
                }
            this._numberProps = a,
            o && this._resolveProps(r),
            this._applyStyles(s),
            this._update()
        },
        n = this._def.__asyncLoader;
        n ? n().then(r => t(r, !0)) : t(this._def)
    }
    _resolveProps(t) {
        const {
            props: n
        } = t,
        r = st(n) ? n : Object.keys(n || {});
        for (const o of Object.keys(this))
            o[0] !== "_" && r.includes(o) && this._setProp(o, this[o], !0, !1);
        for (const o of r.map(Uo))
            Object.defineProperty(this, o, {
                get() {
                    return this._getProp(o)
                },
                set(i) {
                    this._setProp(o, i)
                }
            })
    }
    _setAttr(t) {
        let n = this.getAttribute(t);
        const r = Uo(t);
        this._numberProps && this._numberProps[r] && (n = M0(n)),
        this._setProp(r, n, !1)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, r = !0, o = !0) {
        n !== this._props[t] && (this._props[t] = n, o && this._instance && this._update(), r && (n === !0 ? this.setAttribute(Hi(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(Hi(t), n + "") : n || this.removeAttribute(Hi(t))))
    }
    _update() {
        Ek(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const t = z(this._def, jn({}, this._props));
        return this._instance || (t.ce = n => {
                this._instance = n,
                n.isCE = !0;
                const r = (i, s) => {
                    this.dispatchEvent(new CustomEvent(i, {
                            detail: s
                        }))
                };
                n.emit = (i, ...s) => {
                    r(i, s),
                    Hi(i) !== i && r(Hi(i), s)
                };
                let o = this;
                for (; o = o && (o.parentNode || o.host); )
                    if (o instanceof Y1) {
                        n.parent = o._instance,
                        n.provides = o._instance.provides;
                        break
                    }
            }),
        t
    }
    _applyStyles(t) {
        t && t.forEach(n => {
            const r = document.createElement("style");
            r.textContent = n,
            this.shadowRoot.appendChild(r)
        })
    }
}
function PZ(e = "$style") { {
        const t = ii();
        if (!t)
            return xn;
        const n = t.type.__cssModules;
        if (!n)
            return xn;
        const r = n[e];
        return r || xn
    }
}
function to(e) {
    const t = ii();
    if (!t)
        return;
    const n = t.ut = (o = e(t.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(i => Pk(i, o))
    },
    r = () => {
        const o = e(t.proxy);
        Mk(t.subTree, o),
        n(o)
    };
    n4(r),
    Ur(() => {
        const o = new MutationObserver(r);
        o.observe(t.subTree.el.parentNode, {
            childList: !0
        }),
        cc(() => o.disconnect())
    })
}
function Mk(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch,
        n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            Mk(n.activeBranch, t)
        })
    }
    for (; e.component; )
        e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el)
        Pk(e.el, t);
    else if (e.type === Le)
        e.children.forEach(n => Mk(n, t));
    else if (e.type === su) {
        let {
            el: n,
            anchor: r
        } = e;
        for (; n && (Pk(n, t), n !== r); )
            n = n.nextSibling
    }
}
function Pk(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        for (const r in t)
            n.setProperty(`--${r}`, t[r])
    }
}
const bl = "transition", Dh = "animation", ho = (e, {
    slots: t
}) => dt(o4, W4(e), t);
ho.displayName = "Transition";
const j4 = {
    name: String,
    type: String,
    css: {
        type: Boolean,
    default:
        !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}, EZ = ho.props = jn({}, JS, j4), Ac = (e, t = []) => {
    st(e) ? e.forEach(n => n(...t)) : e && e(...t)
}, i3 = e => e ? st(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;
function W4(e) {
    const t = {};
    for (const j in e)
        j in j4 || (t[j] = e[j]);
    if (e.css === !1)
        return t;
    const {
        name: n = "v",
        type: r,
        duration: o,
        enterFromClass: i = `${n}-enter-from`,
        enterActiveClass: s = `${n}-enter-active`,
        enterToClass: a = `${n}-enter-to`,
        appearFromClass: l = i,
        appearActiveClass: c = s,
        appearToClass: u = a,
        leaveFromClass: f = `${n}-leave-from`,
        leaveActiveClass: p = `${n}-leave-active`,
        leaveToClass: m = `${n}-leave-to`
    } = e,
    v = OZ(o),
    y = v && v[0],
    b = v && v[1], {
        onBeforeEnter: w,
        onEnter: k,
        onEnterCancelled: C,
        onLeave: x,
        onLeaveCancelled: S,
        onBeforeAppear: T = w,
        onAppear: E = k,
        onAppearCancelled: M = C
    } = t,
    N = (j, G, Y) => {
        Tl(j, G ? u : a),
        Tl(j, G ? c : s),
        Y && Y()
    },
    F = (j, G) => {
        j._isLeaving = !1,
        Tl(j, f),
        Tl(j, m),
        Tl(j, p),
        G && G()
    },
    K = j => (G, Y) => {
        const ue = j ? E : k,
        re = () => N(G, j, Y);
        Ac(ue, [G, re]),
        s3(() => {
            Tl(G, j ? l : i),
            Ra(G, j ? u : a),
            i3(ue) || a3(G, r, y, re)
        })
    };
    return jn(t, {
        onBeforeEnter(j) {
            Ac(w, [j]),
            Ra(j, i),
            Ra(j, s)
        },
        onBeforeAppear(j) {
            Ac(T, [j]),
            Ra(j, l),
            Ra(j, c)
        },
        onEnter: K(!1),
        onAppear: K(!0),
        onLeave(j, G) {
            j._isLeaving = !0;
            const Y = () => F(j, G);
            Ra(j, f),
            H4(),
            Ra(j, p),
            s3(() => {
                j._isLeaving && (Tl(j, f), Ra(j, m), i3(x) || a3(j, r, b, Y))
            }),
            Ac(x, [j, Y])
        },
        onEnterCancelled(j) {
            N(j, !1),
            Ac(C, [j])
        },
        onAppearCancelled(j) {
            N(j, !0),
            Ac(M, [j])
        },
        onLeaveCancelled(j) {
            F(j),
            Ac(S, [j])
        }
    })
}
function OZ(e) {
    if (e == null)
        return null;
    if (In(e))
        return [P_(e.enter), P_(e.leave)]; {
        const t = P_(e);
        return [t, t]
    }
}
function P_(e) {
    return M0(e)
}
function Ra(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)),
    (e._vtc || (e._vtc = new Set)).add(t)
}
function Tl(e, t) {
    t.split(/\s+/).forEach(r => r && e.classList.remove(r));
    const {
        _vtc: n
    } = e;
    n && (n.delete(t), n.size || (e._vtc = void 0))
}
function s3(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e)
    })
}
let $Z = 0;
function a3(e, t, n, r) {
    const o = e._endId = ++$Z,
    i = () => {
        o === e._endId && r()
    };
    if (n)
        return setTimeout(i, n);
    const {
        type: s,
        timeout: a,
        propCount: l
    } = z4(e, t);
    if (!s)
        return r();
    const c = s + "end";
    let u = 0;
    const f = () => {
        e.removeEventListener(c, p),
        i()
    },
    p = m => {
        m.target === e && ++u >= l && f()
    };
    setTimeout(() => {
        u < l && f()
    }, a + 1),
    e.addEventListener(c, p)
}
function z4(e, t) {
    const n = window.getComputedStyle(e),
    r = v => (n[v] || "").split(", "),
    o = r(`${bl}Delay`),
    i = r(`${bl}Duration`),
    s = l3(o, i),
    a = r(`${Dh}Delay`),
    l = r(`${Dh}Duration`),
    c = l3(a, l);
    let u = null,
    f = 0,
    p = 0;
    t === bl ? s > 0 && (u = bl, f = s, p = i.length) : t === Dh ? c > 0 && (u = Dh, f = c, p = l.length) : (f = Math.max(s, c), u = f > 0 ? s > c ? bl : Dh : null, p = u ? u === bl ? i.length : l.length : 0);
    const m = u === bl && /\b(transform|all)(,|$)/.test(r(`${bl}Property`).toString());
    return {
        type: u,
        timeout: f,
        propCount: p,
        hasTransform: m
    }
}
function l3(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map((n, r) => c3(n) + c3(e[r])))
}
function c3(e) {
    return Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function H4() {
    return document.body.offsetHeight
}
const U4 = new WeakMap, q4 = new WeakMap, Y4 = {
    name: "TransitionGroup",
    props: jn({}, EZ, {
        tag: String,
        moveClass: String
    }),
    setup(e, {
        slots: t
    }) {
        const n = ii(),
        r = XS();
        let o,
        i;
        return j1(() => {
            if (!o.length)
                return;
            const s = e.moveClass || `${e.name || "v"}-move`;
            if (!LZ(o[0].el, n.vnode.el, s))
                return;
            o.forEach(DZ),
            o.forEach(NZ);
            const a = o.filter(RZ);
            H4(),
            a.forEach(l => {
                const c = l.el,
                u = c.style;
                Ra(c, s),
                u.transform = u.webkitTransform = u.transitionDuration = "";
                const f = c._moveCb = p => {
                    p && p.target !== c || (!p || /transform$/.test(p.propertyName)) && (c.removeEventListener("transitionend", f), c._moveCb = null, Tl(c, s))
                };
                c.addEventListener("transitionend", f)
            })
        }),
        () => {
            const s = Xt(e),
            a = W4(s);
            let l = s.tag || Le;
            o = i,
            i = t.default ? V1(t.default()) : [];
            for (let c = 0; c < i.length; c++) {
                const u = i[c];
                u.key != null && ku(u, hf(u, a, r, n))
            }
            if (o)
                for (let c = 0; c < o.length; c++) {
                    const u = o[c];
                    ku(u, hf(u, a, r, n)),
                    U4.set(u, u.el.getBoundingClientRect())
                }
            return z(l, null, i)
        }
    }
}, AZ = e => delete e.mode;
Y4.props;
const Qm = Y4;
function DZ(e) {
    const t = e.el;
    t._moveCb && t._moveCb(),
    t._enterCb && t._enterCb()
}
function NZ(e) {
    q4.set(e, e.el.getBoundingClientRect())
}
function RZ(e) {
    const t = U4.get(e),
    n = q4.get(e),
    r = t.left - n.left,
    o = t.top - n.top;
    if (r || o) {
        const i = e.el.style;
        return i.transform = i.webkitTransform = `translate(${r}px,${o}px)`,
        i.transitionDuration = "0s",
        e
    }
}
function LZ(e, t, n) {
    const r = e.cloneNode();
    e._vtc && e._vtc.forEach(s => {
        s.split(/\s+/).forEach(a => a && r.classList.remove(a))
    }),
    n.split(/\s+/).forEach(s => s && r.classList.add(s)),
    r.style.display = "none";
    const o = t.nodeType === 1 ? t : t.parentNode;
    o.appendChild(r);
    const {
        hasTransform: i
    } = z4(r);
    return o.removeChild(r),
    i
}
const rc = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return st(t) ? n => Jd(t, n) : t
};
function BZ(e) {
    e.target.composing = !0
}
function u3(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const am = {
    created(e, {
        modifiers: {
            lazy: t,
            trim: n,
            number: r
        }
    }, o) {
        e._assign = rc(o);
        const i = r || o.props && o.props.type === "number";
        Ua(e, t ? "change" : "input", s => {
            if (s.target.composing)
                return;
            let a = e.value;
            n && (a = a.trim()),
            i && (a = T0(a)),
            e._assign(a)
        }),
        n && Ua(e, "change", () => {
            e.value = e.value.trim()
        }),
        t || (Ua(e, "compositionstart", BZ), Ua(e, "compositionend", u3), Ua(e, "change", u3))
    },
    mounted(e, {
        value: t
    }) {
        e.value = t ?? ""
    },
    beforeUpdate(e, {
        value: t,
        modifiers: {
            lazy: n,
            trim: r,
            number: o
        }
    }, i) {
        if (e._assign = rc(i), e.composing || document.activeElement === e && e.type !== "range" && (n || r && e.value.trim() === t || (o || e.type === "number") && T0(e.value) === t))
            return;
        const s = t ?? "";
        e.value !== s && (e.value = s)
    }
}, lC = {
    deep: !0,
    created(e, t, n) {
        e._assign = rc(n),
        Ua(e, "change", () => {
            const r = e._modelValue,
            o = mf(e),
            i = e.checked,
            s = e._assign;
            if (st(r)) {
                const a = P1(r, o),
                l = a !== -1;
                if (i && !l)
                    s(r.concat(o));
                else if (!i && l) {
                    const c = [...r];
                    c.splice(a, 1),
                    s(c)
                }
            } else if (Wu(r)) {
                const a = new Set(r);
                i ? a.add(o) : a.delete(o),
                s(a)
            } else
                s(G4(e, i))
        })
    },
    mounted: d3,
    beforeUpdate(e, t, n) {
        e._assign = rc(n),
        d3(e, t, n)
    }
};
function d3(e, {
    value: t,
    oldValue: n
}, r) {
    e._modelValue = t,
    st(t) ? e.checked = P1(t, r.props.value) > -1 : Wu(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = Zl(t, G4(e, !0)))
}
const cC = {
    created(e, {
        value: t
    }, n) {
        e.checked = Zl(t, n.props.value),
        e._assign = rc(n),
        Ua(e, "change", () => {
            e._assign(mf(e))
        })
    },
    beforeUpdate(e, {
        value: t,
        oldValue: n
    }, r) {
        e._assign = rc(r),
        t !== n && (e.checked = Zl(t, r.props.value))
    }
}, K4 = {
    deep: !0,
    created(e, {
        value: t,
        modifiers: {
            number: n
        }
    }, r) {
        const o = Wu(t);
        Ua(e, "change", () => {
            const i = Array.prototype.filter.call(e.options, s => s.selected).map(s => n ? T0(mf(s)) : mf(s));
            e._assign(e.multiple ? o ? new Set(i) : i : i[0])
        }),
        e._assign = rc(r)
    },
    mounted(e, {
        value: t
    }) {
        f3(e, t)
    },
    beforeUpdate(e, t, n) {
        e._assign = rc(n)
    },
    updated(e, {
        value: t
    }) {
        f3(e, t)
    }
};
function f3(e, t) {
    const n = e.multiple;
    if (!(n && !st(t) && !Wu(t))) {
        for (let r = 0, o = e.options.length; r < o; r++) {
            const i = e.options[r],
            s = mf(i);
            if (n)
                st(t) ? i.selected = P1(t, s) > -1 : i.selected = t.has(s);
            else if (Zl(mf(i), t)) {
                e.selectedIndex !== r && (e.selectedIndex = r);
                return
            }
        }
        !n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}
function mf(e) {
    return "_value" in e ? e._value : e.value
}
function G4(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const X4 = {
    created(e, t, n) {
        xv(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        xv(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, r) {
        xv(e, t, n, r, "beforeUpdate")
    },
    updated(e, t, n, r) {
        xv(e, t, n, r, "updated")
    }
};
function J4(e, t) {
    switch (e) {
    case "SELECT":
        return K4;
    case "TEXTAREA":
        return am;
    default:
        switch (t) {
        case "checkbox":
            return lC;
        case "radio":
            return cC;
        default:
            return am
        }
    }
}
function xv(e, t, n, r, o) {
    const s = J4(e.tagName, n.props && n.props.type)[o];
    s && s(e, t, n, r)
}
function VZ() {
    am.getSSRProps = ({
        value: e
    }) => ({
        value: e
    }),
    cC.getSSRProps = ({
        value: e
    }, t) => {
        if (t.props && Zl(t.props.value, e))
            return {
                checked: !0
            }
    },
    lC.getSSRProps = ({
        value: e
    }, t) => {
        if (st(e)) {
            if (t.props && P1(e, t.props.value) > -1)
                return {
                    checked: !0
                }
        } else if (Wu(e)) {
            if (t.props && e.has(t.props.value))
                return {
                    checked: !0
                }
        } else if (e)
            return {
                checked: !0
            }
    },
    X4.getSSRProps = (e, t) => {
        if (typeof t.type != "string")
            return;
        const n = J4(t.type.toUpperCase(), t.props && t.props.type);
        if (n.getSSRProps)
            return n.getSSRProps(e, t)
    }
}
const FZ = ["ctrl", "shift", "alt", "meta"], jZ = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button" in e && e.button !== 0,
    middle: e => "button" in e && e.button !== 1,
    right: e => "button" in e && e.button !== 2,
    exact: (e, t) => FZ.some(n => e[`${n}Key`] && !t.includes(n))
}, ve = (e, t) => (n, ...r) => {
    for (let o = 0; o < t.length; o++) {
        const i = jZ[t[o]];
        if (i && i(n, t))
            return
    }
    return e(n, ...r)
}, WZ = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete : "backspace"
}, Rt = (e, t) => n => {
    if (!("key" in n))
        return;
    const r = Hi(n.key);
    if (t.some(o => o === r || WZ[o] === r))
        return e(n)
}, Kn = {
    beforeMount(e, {
        value: t
    }, {
        transition: n
    }) {
        e._vod = e.style.display === "none" ? "" : e.style.display,
        n && t ? n.beforeEnter(e) : Nh(e, t)
    },
    mounted(e, {
        value: t
    }, {
        transition: n
    }) {
        n && t && n.enter(e)
    },
    updated(e, {
        value: t,
        oldValue: n
    }, {
        transition: r
    }) {
        !t != !n && (r ? t ? (r.beforeEnter(e), Nh(e, !0), r.enter(e)) : r.leave(e, () => {
                Nh(e, !1)
            }) : Nh(e, t))
    },
    beforeUnmount(e, {
        value: t
    }) {
        Nh(e, t)
    }
};
function Nh(e, t) {
    e.style.display = t ? e._vod : "none"
}
function zZ() {
    Kn.getSSRProps = ({
        value: e
    }) => {
        if (!e)
            return {
                style: {
                    display: "none"
                }
            }
    }
}
const Z4 = jn({
    patchProp: CZ
}, fZ);
let xp, h3 = !1;
function Q4() {
    return xp || (xp = S4(Z4))
}
function eL() {
    return xp = h3 ? xp : C4(Z4),
    h3 = !0,
    xp
}
const Ek = (...e) => {
    Q4().render(...e)
}, tL = (...e) => {
    eL().hydrate(...e)
}, nL = (...e) => {
    const t = Q4().createApp(...e), {
        mount: n
    } = t;
    return t.mount = r => {
        const o = rL(r);
        if (!o)
            return;
        const i = t._component;
        !Ot(i) && !i.render && !i.template && (i.template = o.innerHTML),
        o.innerHTML = "";
        const s = n(o, !1, o instanceof SVGElement);
        return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")),
        s
    },
    t
}, HZ = (...e) => {
    const t = eL().createApp(...e), {
        mount: n
    } = t;
    return t.mount = r => {
        const o = rL(r);
        if (o)
            return n(o, !0, o instanceof SVGElement)
    },
    t
};
function rL(e) {
    return Gn(e) ? document.querySelector(e) : e
}
let p3 = !1;
const UZ = () => {
    p3 || (p3 = !0, VZ(), zZ())
}, qZ = () => {}, oL = Object.freeze(Object.defineProperty({
            __proto__: null,
            BaseTransition: o4,
            BaseTransitionPropsValidators: JS,
            Comment: Qr,
            EffectScope: BS,
            Fragment: Le,
            KeepAlive: mJ,
            ReactiveEffect: Xm,
            Static: su,
            Suspense: iJ,
            Teleport: H1,
            Text: xu,
            Transition: ho,
            TransitionGroup: Qm,
            VueElement: Y1,
            assertNumber: YX,
            callWithAsyncErrorHandling: xi,
            callWithErrorHandling: qa,
            camelize: Uo,
            capitalize: Gm,
            cloneVNode: Ps,
            compatUtils: uZ,
            compile: qZ,
            computed: ne,
            createApp: nL,
            createBlock: H,
            createCommentVNode: J,
            createElementBlock: O,
            createElementVNode: P,
            createHydrationRenderer: C4,
            createPropsRestProxy: EJ,
            createRenderer: S4,
            createSSRApp: HZ,
            createSlots: tC,
            createStaticVNode: iC,
            createTextVNode: mt,
            createVNode: z,
            customRef: qR,
            defineAsyncComponent: Ha,
            defineComponent: Fe,
            defineCustomElement: F4,
            defineEmits: bJ,
            defineExpose: _J,
            defineModel: SJ,
            defineOptions: kJ,
            defineProps: wJ,
            defineSSRCustomElement: TZ,
            defineSlots: xJ,
            get devtools() {
                return Pd
            },
            effect: lX,
            effectScope: PR,
            getCurrentInstance: ii,
            getCurrentScope: E1,
            getTransitionRawChildren: V1,
            guardReactiveProps: tc,
            h: dt,
            handleError: zu,
            hasInjectionContext: VJ,
            hydrate: tL,
            initCustomFormatter: iZ,
            initDirectivesForSSR: UZ,
            inject: Mo,
            isMemoSame: B4,
            isProxy: WS,
            isReactive: ru,
            isReadonly: bu,
            isRef: Dr,
            isRuntimeOnly: nZ,
            isShallow: Qp,
            isVNode: ec,
            markRaw: oa,
            mergeDefaults: MJ,
            mergeModels: PJ,
            mergeProps: Bt,
            nextTick: Ci,
            normalizeClass: he,
            normalizeProps: wu,
            normalizeStyle: Yt,
            onActivated: s4,
            onBeforeMount: c4,
            onBeforeUnmount: Rs,
            onBeforeUpdate: ZS,
            onDeactivated: a4,
            onErrorCaptured: h4,
            onMounted: Ur,
            onRenderTracked: f4,
            onRenderTriggered: d4,
            onScopeDispose: OR,
            onServerPrefetch: u4,
            onUnmounted: cc,
            onUpdated: j1,
            openBlock: _,
            popScopeId: sr,
            provide: iu,
            proxyRefs: US,
            pushScopeId: ir,
            queuePostFlushCb: YS,
            reactive: es,
            readonly: jS,
            ref: De,
            registerRuntimeCompiler: tZ,
            render: Ek,
            renderList: $t,
            renderSlot: Ye,
            resolveComponent: B,
            resolveDirective: W1,
            resolveDynamicComponent: Kt,
            resolveFilter: cZ,
            resolveTransitionHooks: hf,
            setBlockTracking: xk,
            setDevtoolsHook: JR,
            setTransitionHooks: ku,
            shallowReactive: HR,
            shallowReadonly: RX,
            shallowRef: _u,
            ssrContextKey: R4,
            ssrUtils: lZ,
            stop: cX,
            toDisplayString: Re,
            toHandlerKey: wp,
            toHandlers: O0,
            toRaw: Xt,
            toRef: ca,
            toRefs: nl,
            toValue: VX,
            transformVNodeArgs: XJ,
            triggerRef: BX,
            unref: ke,
            useAttrs: IJ,
            useCssModule: PZ,
            useCssVars: to,
            useModel: TJ,
            useSSRContext: L4,
            useSlots: z1,
            useTransitionState: XS,
            vModelCheckbox: lC,
            vModelDynamic: X4,
            vModelRadio: cC,
            vModelSelect: K4,
            vModelText: am,
            vShow: Kn,
            version: V4,
            warn: qX,
            watch: Ht,
            watchEffect: t4,
            watchPostEffect: n4,
            watchSyncEffect: dJ,
            withAsyncContext: OJ,
            withCtx: oe,
            withDefaults: CJ,
            withDirectives: Cn,
            withKeys: Rt,
            withMemo: sZ,
            withModifiers: ve,
            withScopeId: QX
        }, Symbol.toStringTag, {
            value: "Module"
        })), YZ = "modulepreload", KZ = function (e, t) {
    return new URL(e, t).href
}, m3 = {}, Ks = function (t, n, r) {
    if (!n || n.length === 0)
        return t();
    const o = document.getElementsByTagName("link");
    return Promise.all(n.map(i => {
            if (i = KZ(i, r), i in m3)
                return;
            m3[i] = !0;
            const s = i.endsWith(".css"),
            a = s ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let u = o.length - 1; u >= 0; u--) {
                    const f = o[u];
                    if (f.href === i && (!s || f.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${i}"]${a}`))
                return;
            const c = document.createElement("link");
            if (c.rel = s ? "stylesheet" : YZ, s || (c.as = "script", c.crossOrigin = ""), c.href = i, document.head.appendChild(c), s)
                return new Promise((u, f) => {
                    c.addEventListener("load", u),
                    c.addEventListener("error", () => f(new Error(`Unable to preload CSS for ${i}`)))
                })
        })).then(() => t())
};
function GZ() {
    return iL().__VUE_DEVTOOLS_GLOBAL_HOOK__
}
function iL() {
    return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {}
}
const XZ = typeof Proxy == "function", JZ = "devtools-plugin:setup", ZZ = "plugin:settings:set";
let yd, Ok;
function QZ() {
    var e;
    return yd !== void 0 || (typeof window < "u" && window.performance ? (yd = !0, Ok = window.performance) : typeof global < "u" && (!((e = global.perf_hooks) === null || e === void 0) && e.performance) ? (yd = !0, Ok = global.perf_hooks.performance) : yd = !1),
    yd
}
function eQ() {
    return QZ() ? Ok.now() : Date.now()
}
class tQ {
    constructor(t, n) {
        this.target = null,
        this.targetQueue = [],
        this.onQueue = [],
        this.plugin = t,
        this.hook = n;
        const r = {};
        if (t.settings)
            for (const s in t.settings) {
                const a = t.settings[s];
                r[s] = a.defaultValue
            }
        const o = `__vue-devtools-plugin-settings__${t.id}`;
        let i = Object.assign({}, r);
        try {
            const s = localStorage.getItem(o),
            a = JSON.parse(s);
            Object.assign(i, a)
        } catch {}
        this.fallbacks = {
            getSettings() {
                return i
            },
            setSettings(s) {
                try {
                    localStorage.setItem(o, JSON.stringify(s))
                } catch {}
                i = s
            },
            now() {
                return eQ()
            }
        },
        n && n.on(ZZ, (s, a) => {
            s === this.plugin.id && this.fallbacks.setSettings(a)
        }),
        this.proxiedOn = new Proxy({}, {
            get: (s, a) => this.target ? this.target.on[a] : (...l) => {
                this.onQueue.push({
                    method: a,
                    args: l
                })
            }
        }),
        this.proxiedTarget = new Proxy({}, {
            get: (s, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
                    method: a,
                    args: l,
                    resolve: () => {}
                }), this.fallbacks[a](...l)) : (...l) => new Promise(c => {
                this.targetQueue.push({
                    method: a,
                    args: l,
                    resolve: c
                })
            })
        })
    }
    async setRealTarget(t) {
        this.target = t;
        for (const n of this.onQueue)
            this.target.on[n.method](...n.args);
        for (const n of this.targetQueue)
            n.resolve(await this.target[n.method](...n.args))
    }
}
function nQ(e, t) {
    const n = e,
    r = iL(),
    o = GZ(),
    i = XZ && n.enableEarlyProxy;
    if (o && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !i))
        o.emit(JZ, e, t);
    else {
        const s = i ? new tQ(n, o) : null;
        (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
            pluginDescriptor: n,
            setupFn: t,
            proxy: s
        }),
        s && t(s.proxiedTarget)
    }
}
/*!
 * vuex v4.1.0
 * (c) 2022 Evan You
 * @license MIT
 */
var sL = "store";
function wa(e) {
    return e === void 0 && (e = null),
    Mo(e !== null ? e : sL)
}
function th(e, t) {
    Object.keys(e).forEach(function (n) {
        return t(e[n], n)
    })
}
function aL(e) {
    return e !== null && typeof e == "object"
}
function rQ(e) {
    return e && typeof e.then == "function"
}
function oQ(e, t) {
    return function () {
        return e(t)
    }
}
function lL(e, t, n) {
    return t.indexOf(e) < 0 && (n && n.prepend ? t.unshift(e) : t.push(e)),
    function () {
        var r = t.indexOf(e);
        r > -1 && t.splice(r, 1)
    }
}
function cL(e, t) {
    e._actions = Object.create(null),
    e._mutations = Object.create(null),
    e._wrappedGetters = Object.create(null),
    e._modulesNamespaceMap = Object.create(null);
    var n = e.state;
    K1(e, n, [], e._modules.root, !0),
    uC(e, n, t)
}
function uC(e, t, n) {
    var r = e._state,
    o = e._scope;
    e.getters = {},
    e._makeLocalGettersCache = Object.create(null);
    var i = e._wrappedGetters,
    s = {},
    a = {},
    l = PR(!0);
    l.run(function () {
        th(i, function (c, u) {
            s[u] = oQ(c, e),
            a[u] = ne(function () {
                return s[u]()
            }),
            Object.defineProperty(e.getters, u, {
                get: function () {
                    return a[u].value
                },
                enumerable: !0
            })
        })
    }),
    e._state = es({
        data: t
    }),
    e._scope = l,
    e.strict && cQ(e),
    r && n && e._withCommit(function () {
        r.data = null
    }),
    o && o.stop()
}
function K1(e, t, n, r, o) {
    var i = !n.length,
    s = e._modules.getNamespace(n);
    if (r.namespaced && (e._modulesNamespaceMap[s], e._modulesNamespaceMap[s] = r), !i && !o) {
        var a = dC(t, n.slice(0, -1)),
        l = n[n.length - 1];
        e._withCommit(function () {
            a[l] = r.state
        })
    }
    var c = r.context = iQ(e, s, n);
    r.forEachMutation(function (u, f) {
        var p = s + f;
        sQ(e, p, u, c)
    }),
    r.forEachAction(function (u, f) {
        var p = u.root ? f : s + f,
        m = u.handler || u;
        aQ(e, p, m, c)
    }),
    r.forEachGetter(function (u, f) {
        var p = s + f;
        lQ(e, p, u, c)
    }),
    r.forEachChild(function (u, f) {
        K1(e, t, n.concat(f), u, o)
    })
}
function iQ(e, t, n) {
    var r = t === "",
    o = {
        dispatch: r ? e.dispatch : function (i, s, a) {
            var l = N0(i, s, a),
            c = l.payload,
            u = l.options,
            f = l.type;
            return (!u || !u.root) && (f = t + f),
            e.dispatch(f, c)
        },
        commit: r ? e.commit : function (i, s, a) {
            var l = N0(i, s, a),
            c = l.payload,
            u = l.options,
            f = l.type;
            (!u || !u.root) && (f = t + f),
            e.commit(f, c, u)
        }
    };
    return Object.defineProperties(o, {
        getters: {
            get: r ? function () {
                return e.getters
            }
             : function () {
                return uL(e, t)
            }
        },
        state: {
            get: function () {
                return dC(e.state, n)
            }
        }
    }),
    o
}
function uL(e, t) {
    if (!e._makeLocalGettersCache[t]) {
        var n = {},
        r = t.length;
        Object.keys(e.getters).forEach(function (o) {
            if (o.slice(0, r) === t) {
                var i = o.slice(r);
                Object.defineProperty(n, i, {
                    get: function () {
                        return e.getters[o]
                    },
                    enumerable: !0
                })
            }
        }),
        e._makeLocalGettersCache[t] = n
    }
    return e._makeLocalGettersCache[t]
}
function sQ(e, t, n, r) {
    var o = e._mutations[t] || (e._mutations[t] = []);
    o.push(function (s) {
        n.call(e, r.state, s)
    })
}
function aQ(e, t, n, r) {
    var o = e._actions[t] || (e._actions[t] = []);
    o.push(function (s) {
        var a = n.call(e, {
            dispatch: r.dispatch,
            commit: r.commit,
            getters: r.getters,
            state: r.state,
            rootGetters: e.getters,
            rootState: e.state
        }, s);
        return rQ(a) || (a = Promise.resolve(a)),
        e._devtoolHook ? a.catch(function (l) {
            throw e._devtoolHook.emit("vuex:error", l),
            l
        }) : a
    })
}
function lQ(e, t, n, r) {
    e._wrappedGetters[t] || (e._wrappedGetters[t] = function (i) {
        return n(r.state, r.getters, i.state, i.getters)
    })
}
function cQ(e) {
    Ht(function () {
        return e._state.data
    }, function () {}, {
        deep: !0,
        flush: "sync"
    })
}
function dC(e, t) {
    return t.reduce(function (n, r) {
        return n[r]
    }, e)
}
function N0(e, t, n) {
    return aL(e) && e.type && (n = t, t = e, e = e.type), {
        type: e,
        payload: t,
        options: n
    }
}
var uQ = "vuex bindings", g3 = "vuex:mutations", E_ = "vuex:actions", wd = "vuex", dQ = 0;
function fQ(e, t) {
    nQ({
        id: "org.vuejs.vuex",
        app: e,
        label: "Vuex",
        homepage: "https://next.vuex.vuejs.org/",
        logo: "https://vuejs.org/images/icons/favicon-96x96.png",
        packageName: "vuex",
        componentStateTypes: [uQ]
    }, function (n) {
        n.addTimelineLayer({
            id: g3,
            label: "Vuex Mutations",
            color: v3
        }),
        n.addTimelineLayer({
            id: E_,
            label: "Vuex Actions",
            color: v3
        }),
        n.addInspector({
            id: wd,
            label: "Vuex",
            icon: "storage",
            treeFilterPlaceholder: "Filter stores..."
        }),
        n.on.getInspectorTree(function (r) {
            if (r.app === e && r.inspectorId === wd)
                if (r.filter) {
                    var o = [];
                    pL(o, t._modules.root, r.filter, ""),
                    r.rootNodes = o
                } else
                    r.rootNodes = [hL(t._modules.root, "")]
        }),
        n.on.getInspectorState(function (r) {
            if (r.app === e && r.inspectorId === wd) {
                var o = r.nodeId;
                uL(t, o),
                r.state = mQ(vQ(t._modules, o), o === "root" ? t.getters : t._makeLocalGettersCache, o)
            }
        }),
        n.on.editInspectorState(function (r) {
            if (r.app === e && r.inspectorId === wd) {
                var o = r.nodeId,
                i = r.path;
                o !== "root" && (i = o.split("/").filter(Boolean).concat(i)),
                t._withCommit(function () {
                    r.set(t._state.data, i, r.state.value)
                })
            }
        }),
        t.subscribe(function (r, o) {
            var i = {};
            r.payload && (i.payload = r.payload),
            i.state = o,
            n.notifyComponentUpdate(),
            n.sendInspectorTree(wd),
            n.sendInspectorState(wd),
            n.addTimelineEvent({
                layerId: g3,
                event: {
                    time: Date.now(),
                    title: r.type,
                    data: i
                }
            })
        }),
        t.subscribeAction({
            before: function (r, o) {
                var i = {};
                r.payload && (i.payload = r.payload),
                r._id = dQ++,
                r._time = Date.now(),
                i.state = o,
                n.addTimelineEvent({
                    layerId: E_,
                    event: {
                        time: r._time,
                        title: r.type,
                        groupId: r._id,
                        subtitle: "start",
                        data: i
                    }
                })
            },
            after: function (r, o) {
                var i = {},
                s = Date.now() - r._time;
                i.duration = {
                    _custom: {
                        type: "duration",
                        display: s + "ms",
                        tooltip: "Action duration",
                        value: s
                    }
                },
                r.payload && (i.payload = r.payload),
                i.state = o,
                n.addTimelineEvent({
                    layerId: E_,
                    event: {
                        time: Date.now(),
                        title: r.type,
                        groupId: r._id,
                        subtitle: "end",
                        data: i
                    }
                })
            }
        })
    })
}
var v3 = 8702998, hQ = 6710886, pQ = 16777215, dL = {
    label: "namespaced",
    textColor: pQ,
    backgroundColor: hQ
};
function fL(e) {
    return e && e !== "root" ? e.split("/").slice(-2, -1)[0] : "Root"
}
function hL(e, t) {
    return {
        id: t || "root",
        label: fL(t),
        tags: e.namespaced ? [dL] : [],
        children: Object.keys(e._children).map(function (n) {
            return hL(e._children[n], t + n + "/")
        })
    }
}
function pL(e, t, n, r) {
    r.includes(n) && e.push({
        id: r || "root",
        label: r.endsWith("/") ? r.slice(0, r.length - 1) : r || "Root",
        tags: t.namespaced ? [dL] : []
    }),
    Object.keys(t._children).forEach(function (o) {
        pL(e, t._children[o], n, r + o + "/")
    })
}
function mQ(e, t, n) {
    t = n === "root" ? t : t[n];
    var r = Object.keys(t),
    o = {
        state: Object.keys(e.state).map(function (s) {
            return {
                key: s,
                editable: !0,
                value: e.state[s]
            }
        })
    };
    if (r.length) {
        var i = gQ(t);
        o.getters = Object.keys(i).map(function (s) {
            return {
                key: s.endsWith("/") ? fL(s) : s,
                editable: !1,
                value: $k(function () {
                    return i[s]
                })
            }
        })
    }
    return o
}
function gQ(e) {
    var t = {};
    return Object.keys(e).forEach(function (n) {
        var r = n.split("/");
        if (r.length > 1) {
            var o = t,
            i = r.pop();
            r.forEach(function (s) {
                o[s] || (o[s] = {
                        _custom: {
                            value: {},
                            display: s,
                            tooltip: "Module",
                            abstract: !0
                        }
                    }),
                o = o[s]._custom.value
            }),
            o[i] = $k(function () {
                return e[n]
            })
        } else
            t[n] = $k(function () {
                return e[n]
            })
    }),
    t
}
function vQ(e, t) {
    var n = t.split("/").filter(function (r) {
        return r
    });
    return n.reduce(function (r, o, i) {
        var s = r[o];
        if (!s)
            throw new Error('Missing module "' + o + '" for path "' + t + '".');
        return i === n.length - 1 ? s : s._children
    }, t === "root" ? e : e.root._children)
}
function $k(e) {
    try {
        return e()
    } catch (t) {
        return t
    }
}
var Ls = function (t, n) {
    this.runtime = n,
    this._children = Object.create(null),
    this._rawModule = t;
    var r = t.state;
    this.state = (typeof r == "function" ? r() : r) || {}
}, mL = {
    namespaced: {
        configurable: !0
    }
};
mL.namespaced.get = function () {
    return !!this._rawModule.namespaced
};
Ls.prototype.addChild = function (t, n) {
    this._children[t] = n
};
Ls.prototype.removeChild = function (t) {
    delete this._children[t]
};
Ls.prototype.getChild = function (t) {
    return this._children[t]
};
Ls.prototype.hasChild = function (t) {
    return t in this._children
};
Ls.prototype.update = function (t) {
    this._rawModule.namespaced = t.namespaced,
    t.actions && (this._rawModule.actions = t.actions),
    t.mutations && (this._rawModule.mutations = t.mutations),
    t.getters && (this._rawModule.getters = t.getters)
};
Ls.prototype.forEachChild = function (t) {
    th(this._children, t)
};
Ls.prototype.forEachGetter = function (t) {
    this._rawModule.getters && th(this._rawModule.getters, t)
};
Ls.prototype.forEachAction = function (t) {
    this._rawModule.actions && th(this._rawModule.actions, t)
};
Ls.prototype.forEachMutation = function (t) {
    this._rawModule.mutations && th(this._rawModule.mutations, t)
};
Object.defineProperties(Ls.prototype, mL);
var Hu = function (t) {
    this.register([], t, !1)
};
Hu.prototype.get = function (t) {
    return t.reduce(function (n, r) {
        return n.getChild(r)
    }, this.root)
};
Hu.prototype.getNamespace = function (t) {
    var n = this.root;
    return t.reduce(function (r, o) {
        return n = n.getChild(o),
        r + (n.namespaced ? o + "/" : "")
    }, "")
};
Hu.prototype.update = function (t) {
    gL([], this.root, t)
};
Hu.prototype.register = function (t, n, r) {
    var o = this;
    r === void 0 && (r = !0);
    var i = new Ls(n, r);
    if (t.length === 0)
        this.root = i;
    else {
        var s = this.get(t.slice(0, -1));
        s.addChild(t[t.length - 1], i)
    }
    n.modules && th(n.modules, function (a, l) {
        o.register(t.concat(l), a, r)
    })
};
Hu.prototype.unregister = function (t) {
    var n = this.get(t.slice(0, -1)),
    r = t[t.length - 1],
    o = n.getChild(r);
    o && o.runtime && n.removeChild(r)
};
Hu.prototype.isRegistered = function (t) {
    var n = this.get(t.slice(0, -1)),
    r = t[t.length - 1];
    return n ? n.hasChild(r) : !1
};
function gL(e, t, n) {
    if (t.update(n), n.modules)
        for (var r in n.modules) {
            if (!t.getChild(r))
                return;
            gL(e.concat(r), t.getChild(r), n.modules[r])
        }
}
function yQ(e) {
    return new si(e)
}
var si = function (t) {
    var n = this;
    t === void 0 && (t = {});
    var r = t.plugins;
    r === void 0 && (r = []);
    var o = t.strict;
    o === void 0 && (o = !1);
    var i = t.devtools;
    this._committing = !1,
    this._actions = Object.create(null),
    this._actionSubscribers = [],
    this._mutations = Object.create(null),
    this._wrappedGetters = Object.create(null),
    this._modules = new Hu(t),
    this._modulesNamespaceMap = Object.create(null),
    this._subscribers = [],
    this._makeLocalGettersCache = Object.create(null),
    this._scope = null,
    this._devtools = i;
    var s = this,
    a = this,
    l = a.dispatch,
    c = a.commit;
    this.dispatch = function (p, m) {
        return l.call(s, p, m)
    },
    this.commit = function (p, m, v) {
        return c.call(s, p, m, v)
    },
    this.strict = o;
    var u = this._modules.root.state;
    K1(this, u, [], this._modules.root),
    uC(this, u),
    r.forEach(function (f) {
        return f(n)
    })
}, fC = {
    state: {
        configurable: !0
    }
};
si.prototype.install = function (t, n) {
    t.provide(n || sL, this),
    t.config.globalProperties.$store = this;
    var r = this._devtools !== void 0 ? this._devtools : !1;
    r && fQ(t, this)
};
fC.state.get = function () {
    return this._state.data
};
fC.state.set = function (e) {};
si.prototype.commit = function (t, n, r) {
    var o = this,
    i = N0(t, n, r),
    s = i.type,
    a = i.payload,
    l = {
        type: s,
        payload: a
    },
    c = this._mutations[s];
    c && (this._withCommit(function () {
            c.forEach(function (f) {
                f(a)
            })
        }), this._subscribers.slice().forEach(function (u) {
            return u(l, o.state)
        }))
};
si.prototype.dispatch = function (t, n) {
    var r = this,
    o = N0(t, n),
    i = o.type,
    s = o.payload,
    a = {
        type: i,
        payload: s
    },
    l = this._actions[i];
    if (l) {
        try {
            this._actionSubscribers.slice().filter(function (u) {
                return u.before
            }).forEach(function (u) {
                return u.before(a, r.state)
            })
        } catch {}
        var c = l.length > 1 ? Promise.all(l.map(function (u) {
                    return u(s)
                })) : l[0](s);
        return new Promise(function (u, f) {
            c.then(function (p) {
                try {
                    r._actionSubscribers.filter(function (m) {
                        return m.after
                    }).forEach(function (m) {
                        return m.after(a, r.state)
                    })
                } catch {}
                u(p)
            }, function (p) {
                try {
                    r._actionSubscribers.filter(function (m) {
                        return m.error
                    }).forEach(function (m) {
                        return m.error(a, r.state, p)
                    })
                } catch {}
                f(p)
            })
        })
    }
};
si.prototype.subscribe = function (t, n) {
    return lL(t, this._subscribers, n)
};
si.prototype.subscribeAction = function (t, n) {
    var r = typeof t == "function" ? {
        before: t
    }
     : t;
    return lL(r, this._actionSubscribers, n)
};
si.prototype.watch = function (t, n, r) {
    var o = this;
    return Ht(function () {
        return t(o.state, o.getters)
    }, n, Object.assign({}, r))
};
si.prototype.replaceState = function (t) {
    var n = this;
    this._withCommit(function () {
        n._state.data = t
    })
};
si.prototype.registerModule = function (t, n, r) {
    r === void 0 && (r = {}),
    typeof t == "string" && (t = [t]),
    this._modules.register(t, n),
    K1(this, this.state, t, this._modules.get(t), r.preserveState),
    uC(this, this.state)
};
si.prototype.unregisterModule = function (t) {
    var n = this;
    typeof t == "string" && (t = [t]),
    this._modules.unregister(t),
    this._withCommit(function () {
        var r = dC(n.state, t.slice(0, -1));
        delete r[t[t.length - 1]]
    }),
    cL(this)
};
si.prototype.hasModule = function (t) {
    return typeof t == "string" && (t = [t]),
    this._modules.isRegistered(t)
};
si.prototype.hotUpdate = function (t) {
    this._modules.update(t),
    cL(this, !0)
};
si.prototype._withCommit = function (t) {
    var n = this._committing;
    this._committing = !0,
    t(),
    this._committing = n
};
Object.defineProperties(si.prototype, fC);
var ut = X1(function (e, t) {
    var n = {};
    return G1(t).forEach(function (r) {
        var o = r.key,
        i = r.val;
        n[o] = function () {
            var a = this.$store.state,
            l = this.$store.getters;
            if (e) {
                var c = J1(this.$store, "mapState", e);
                if (!c)
                    return;
                a = c.context.state,
                l = c.context.getters
            }
            return typeof i == "function" ? i.call(this, a, l) : a[i]
        },
        n[o].vuex = !0
    }),
    n
}), eg = X1(function (e, t) {
    var n = {};
    return G1(t).forEach(function (r) {
        var o = r.key,
        i = r.val;
        n[o] = function () {
            for (var a = [], l = arguments.length; l--; )
                a[l] = arguments[l];
            var c = this.$store.commit;
            if (e) {
                var u = J1(this.$store, "mapMutations", e);
                if (!u)
                    return;
                c = u.context.commit
            }
            return typeof i == "function" ? i.apply(this, [c].concat(a)) : c.apply(this.$store, [i].concat(a))
        }
    }),
    n
}), zt = X1(function (e, t) {
    var n = {};
    return G1(t).forEach(function (r) {
        var o = r.key,
        i = r.val;
        i = e + i,
        n[o] = function () {
            if (!(e && !J1(this.$store, "mapGetters", e)))
                return this.$store.getters[i]
        },
        n[o].vuex = !0
    }),
    n
}), Er = X1(function (e, t) {
    var n = {};
    return G1(t).forEach(function (r) {
        var o = r.key,
        i = r.val;
        n[o] = function () {
            for (var a = [], l = arguments.length; l--; )
                a[l] = arguments[l];
            var c = this.$store.dispatch;
            if (e) {
                var u = J1(this.$store, "mapActions", e);
                if (!u)
                    return;
                c = u.context.dispatch
            }
            return typeof i == "function" ? i.apply(this, [c].concat(a)) : c.apply(this.$store, [i].concat(a))
        }
    }),
    n
});
function G1(e) {
    return wQ(e) ? Array.isArray(e) ? e.map(function (t) {
        return {
            key: t,
            val: t
        }
    }) : Object.keys(e).map(function (t) {
        return {
            key: t,
            val: e[t]
        }
    }) : []
}
function wQ(e) {
    return Array.isArray(e) || aL(e)
}
function X1(e) {
    return function (t, n) {
        return typeof t != "string" ? (n = t, t = "") : t.charAt(t.length - 1) !== "/" && (t += "/"),
        e(t, n)
    }
}
function J1(e, t, n) {
    var r = e._modulesNamespaceMap[n];
    return r
}
function vL(e) {
    return E1() ? (OR(e), !0) : !1
}
function yL(e) {
    return typeof e == "function" ? e() : ke(e)
}
const wL = typeof window < "u" && typeof document < "u", bQ = Object.prototype.toString, _Q = e => bQ.call(e) === "[object Object]", Ak = () => {}, kQ = xQ();
function xQ() {
    var e;
    return wL && ((e = window?.navigator) == null ? void 0 : e.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent)
}
function Ss(e) {
    var t;
    const n = yL(e);
    return (t = n?.$el) != null ? t : n
}
const Uu = wL ? window : void 0;
function Qs(...e) {
    let t,
    n,
    r,
    o;
    if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, r, o] = e, t = Uu) : [t, n, r, o] = e, !t)
        return Ak;
    Array.isArray(n) || (n = [n]),
    Array.isArray(r) || (r = [r]);
    const i = [],
    s = () => {
        i.forEach(u => u()),
        i.length = 0
    },
    a = (u, f, p, m) => (u.addEventListener(f, p, m), () => u.removeEventListener(f, p, m)),
    l = Ht(() => [Ss(t), yL(o)], ([u, f]) => {
        if (s(), !u)
            return;
        const p = _Q(f) ? {
            ...f
        }
         : f;
        i.push(...n.flatMap(m => r.map(v => a(u, m, v, p))))
    }, {
        immediate: !0,
        flush: "post"
    }),
    c = () => {
        l(),
        s()
    };
    return vL(c),
    c
}
let y3 = !1;
function SQ(e, t, n = {}) {
    const {
        window: r = Uu,
        ignore: o = [],
        capture: i = !0,
        detectIframe: s = !1
    } = n;
    if (!r)
        return;
    kQ && !y3 && (y3 = !0, Array.from(r.document.body.children).forEach(p => p.addEventListener("click", Ak)), r.document.documentElement.addEventListener("click", Ak));
    let a = !0;
    const l = p => o.some(m => {
        if (typeof m == "string")
            return Array.from(r.document.querySelectorAll(m)).some(v => v === p.target || p.composedPath().includes(v)); {
            const v = Ss(m);
            return v && (p.target === v || p.composedPath().includes(v))
        }
    }),
    u = [Qs(r, "click", p => {
            const m = Ss(e);
            if (!(!m || m === p.target || p.composedPath().includes(m))) {
                if (p.detail === 0 && (a = !l(p)), !a) {
                    a = !0;
                    return
                }
                t(p)
            }
        }, {
            passive: !0,
            capture: i
        }), Qs(r, "pointerdown", p => {
            const m = Ss(e);
            m && (a = !p.composedPath().includes(m) && !l(p))
        }, {
            passive: !0
        }), s && Qs(r, "blur", p => {
            setTimeout(() => {
                var m;
                const v = Ss(e);
                ((m = r.document.activeElement) == null ? void 0 : m.tagName) === "IFRAME" && !v?.contains(r.document.activeElement) && t(p)
            }, 0)
        })].filter(Boolean);
    return () => u.forEach(p => p())
}
function CQ() {
    const e = De(!1);
    return ii() && Ur(() => {
        e.value = !0
    }),
    e
}
function IQ(e) {
    const t = CQ();
    return ne(() => (t.value, Boolean(e())))
}
function TQ(e, t, n = {}) {
    const {
        window: r = Uu,
        ...o
    } = n;
    let i;
    const s = IQ(() => r && "ResizeObserver" in r),
    a = () => {
        i && (i.disconnect(), i = void 0)
    },
    l = ne(() => Array.isArray(e) ? e.map(f => Ss(f)) : [Ss(e)]),
    c = Ht(l, f => {
        if (a(), s.value && r) {
            i = new ResizeObserver(t);
            for (const p of f)
                p && i.observe(p, o)
        }
    }, {
        immediate: !0,
        flush: "post",
        deep: !0
    }),
    u = () => {
        a(),
        c()
    };
    return vL(u), {
        isSupported: s,
        stop: u
    }
}
function MQ(e, t = {
        width: 0,
        height: 0
    }, n = {}) {
    const {
        window: r = Uu,
        box: o = "content-box"
    } = n,
    i = ne(() => {
        var l,
        c;
        return (c = (l = Ss(e)) == null ? void 0 : l.namespaceURI) == null ? void 0 : c.includes("svg")
    }),
    s = De(t.width),
    a = De(t.height);
    return TQ(e, ([l]) => {
        const c = o === "border-box" ? l.borderBoxSize : o === "content-box" ? l.contentBoxSize : l.devicePixelContentBoxSize;
        if (r && i.value) {
            const u = Ss(e);
            if (u) {
                const f = r.getComputedStyle(u);
                s.value = Number.parseFloat(f.width),
                a.value = Number.parseFloat(f.height)
            }
        } else if (c) {
            const u = Array.isArray(c) ? c : [c];
            s.value = u.reduce((f, {
                        inlineSize: p
                    }) => f + p, 0),
            a.value = u.reduce((f, {
                        blockSize: p
                    }) => f + p, 0)
        } else
            s.value = l.contentRect.width, a.value = l.contentRect.height
    }, n),
    Ht(() => Ss(e), l => {
        s.value = l ? t.width : 0,
        a.value = l ? t.height : 0
    }), {
        width: s,
        height: a
    }
}
const Rh = new Map;
function PQ(e) {
    const t = E1();
    function n(a) {
        var l;
        const c = Rh.get(e) || new Set;
        c.add(a),
        Rh.set(e, c);
        const u = () => o(a);
        return (l = t?.cleanups) == null || l.push(u),
        u
    }
    function r(a) {
        function l(...c) {
            o(l),
            a(...c)
        }
        return n(l)
    }
    function o(a) {
        const l = Rh.get(e);
        l && (l.delete(a), l.size || i())
    }
    function i() {
        Rh.delete(e)
    }
    function s(a, l) {
        var c;
        (c = Rh.get(e)) == null || c.forEach(u => u(a, l))
    }
    return {
        on: n,
        once: r,
        off: o,
        emit: s,
        reset: i
    }
}
const EQ = {
    page: e => [e.pageX, e.pageY],
    client: e => [e.clientX, e.clientY],
    screen: e => [e.screenX, e.screenY],
    movement: e => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function OQ(e = {}) {
    const {
        type: t = "page",
        touch: n = !0,
        resetOnTouchEnds: r = !1,
        initialValue: o = {
            x: 0,
            y: 0
        },
        window: i = Uu,
        target: s = i,
        scroll: a = !0,
        eventFilter: l
    } = e;
    let c = null;
    const u = De(o.x),
    f = De(o.y),
    p = De(null),
    m = typeof t == "function" ? t : EQ[t],
    v = S => {
        const T = m(S);
        c = S,
        T && ([u.value, f.value] = T, p.value = "mouse")
    },
    y = S => {
        if (S.touches.length > 0) {
            const T = m(S.touches[0]);
            T && ([u.value, f.value] = T, p.value = "touch")
        }
    },
    b = () => {
        if (!c || !i)
            return;
        const S = m(c);
        c instanceof MouseEvent && S && (u.value = S[0] + i.scrollX, f.value = S[1] + i.scrollY)
    },
    w = () => {
        u.value = o.x,
        f.value = o.y
    },
    k = l ? S => l(() => v(S), {}) : S => v(S),
    C = l ? S => l(() => y(S), {}) : S => y(S),
    x = l ? () => l(() => b(), {}) : () => b();
    if (s) {
        const S = {
            passive: !0
        };
        Qs(s, ["mousemove", "dragover"], k, S),
        n && t !== "movement" && (Qs(s, ["touchstart", "touchmove"], C, S), r && Qs(s, "touchend", w, S)),
        a && t === "page" && Qs(i, "scroll", x, {
            passive: !0
        })
    }
    return {
        x: u,
        y: f,
        sourceType: p
    }
}
function $Q(e, t = {}) {
    const {
        handleOutside: n = !0,
        window: r = Uu
    } = t, {
        x: o,
        y: i,
        sourceType: s
    } = OQ(t),
    a = De(e ?? r?.document.body),
    l = De(0),
    c = De(0),
    u = De(0),
    f = De(0),
    p = De(0),
    m = De(0),
    v = De(!0);
    let y = () => {};
    return r && (y = Ht([a, o, i], () => {
            const b = Ss(a);
            if (!b)
                return;
            const {
                left: w,
                top: k,
                width: C,
                height: x
            } = b.getBoundingClientRect();
            u.value = w + r.pageXOffset,
            f.value = k + r.pageYOffset,
            p.value = x,
            m.value = C;
            const S = o.value - u.value,
            T = i.value - f.value;
            v.value = C === 0 || x === 0 || S < 0 || T < 0 || S > C || T > x,
            (n || !v.value) && (l.value = S, c.value = T)
        }, {
            immediate: !0
        }), Qs(document, "mouseleave", () => {
            v.value = !0
        })), {
        x: o,
        y: i,
        sourceType: s,
        elementX: l,
        elementY: c,
        elementPositionX: u,
        elementPositionY: f,
        elementHeight: p,
        elementWidth: m,
        isOutside: v,
        stop: y
    }
}
function AQ(e, t) {
    const {
        containerStyle: n,
        wrapperProps: r,
        scrollTo: o,
        calculateRange: i,
        currentList: s,
        containerRef: a
    } = "itemHeight" in t ? RQ(t, e) : NQ(t, e);
    return {
        list: s,
        scrollTo: o,
        containerProps: {
            ref: a,
            onScroll: () => {
                i()
            },
            style: n
        },
        wrapperProps: r
    }
}
function bL(e) {
    const t = De(null),
    n = MQ(t),
    r = De([]),
    o = _u(e);
    return {
        state: De({
            start: 0,
            end: 10
        }),
        source: o,
        currentList: r,
        size: n,
        containerRef: t
    }
}
function _L(e, t, n) {
    return r => {
        if (typeof n == "number")
            return Math.ceil(r / n);
        const {
            start: o = 0
        } = e.value;
        let i = 0,
        s = 0;
        for (let a = o; a < t.value.length; a++) {
            const l = n(a);
            if (i += l, s = a, i > r)
                break
        }
        return s - o
    }
}
function kL(e, t) {
    return n => {
        if (typeof t == "number")
            return Math.floor(n / t) + 1;
        let r = 0,
        o = 0;
        for (let i = 0; i < e.value.length; i++) {
            const s = t(i);
            if (r += s, r >= n) {
                o = i;
                break
            }
        }
        return o + 1
    }
}
function xL(e, t, n, r, {
    containerRef: o,
    state: i,
    currentList: s,
    source: a
}) {
    return () => {
        const l = o.value;
        if (l) {
            const c = n(e === "vertical" ? l.scrollTop : l.scrollLeft),
            u = r(e === "vertical" ? l.clientHeight : l.clientWidth),
            f = c - t,
            p = c + u + t;
            i.value = {
                start: f < 0 ? 0 : f,
                end: p > a.value.length ? a.value.length : p
            },
            s.value = a.value.slice(i.value.start, i.value.end).map((m, v) => ({
                        data: m,
                        index: v + i.value.start
                    }))
        }
    }
}
function SL(e, t) {
    return n => typeof e == "number" ? n * e : t.value.slice(0, n).reduce((o, i, s) => o + e(s), 0)
}
function CL(e, t, n) {
    Ht([e.width, e.height, t], () => {
        n()
    })
}
function IL(e, t) {
    return ne(() => typeof e == "number" ? t.value.length * e : t.value.reduce((n, r, o) => n + e(o), 0))
}
const DQ = {
    horizontal: "scrollLeft",
    vertical: "scrollTop"
};
function TL(e, t, n, r) {
    return o => {
        r.value && (r.value[DQ[e]] = n(o), t())
    }
}
function NQ(e, t) {
    const n = bL(t), {
        state: r,
        source: o,
        currentList: i,
        size: s,
        containerRef: a
    } = n,
    l = {
        overflowX: "auto"
    }, {
        itemWidth: c,
        overscan: u = 5
    } = e,
    f = _L(r, o, c),
    p = kL(o, c),
    m = xL("horizontal", u, p, f, n),
    v = SL(c, o),
    y = ne(() => v(r.value.start)),
    b = IL(c, o);
    CL(s, t, m);
    const w = TL("horizontal", m, v, a),
    k = ne(() => ({
                style: {
                    height: "100%",
                    width: `${b.value - y.value}px`,
                    marginLeft: `${y.value}px`,
                    display: "flex"
                }
            }));
    return {
        scrollTo: w,
        calculateRange: m,
        wrapperProps: k,
        containerStyle: l,
        currentList: i,
        containerRef: a
    }
}
function RQ(e, t) {
    const n = bL(t), {
        state: r,
        source: o,
        currentList: i,
        size: s,
        containerRef: a
    } = n,
    l = {
        overflowY: "auto"
    }, {
        itemHeight: c,
        overscan: u = 5
    } = e,
    f = _L(r, o, c),
    p = kL(o, c),
    m = xL("vertical", u, p, f, n),
    v = SL(c, o),
    y = ne(() => v(r.value.start)),
    b = IL(c, o);
    CL(s, t, m);
    const w = TL("vertical", m, v, a),
    k = ne(() => ({
                style: {
                    width: "100%",
                    height: `${b.value - y.value}px`,
                    marginTop: `${y.value}px`
                }
            }));
    return {
        calculateRange: m,
        scrollTo: w,
        containerStyle: l,
        wrapperProps: k,
        currentList: i,
        containerRef: a
    }
}
function LQ({
    window: e = Uu
} = {}) {
    if (!e)
        return De(!1);
    const t = De(e.document.hasFocus());
    return Qs(e, "blur", () => {
        t.value = !1
    }),
    Qs(e, "focus", () => {
        t.value = !0
    }),
    t
}
const ML = () => ii()?.appContext.app, BQ = () => {
    const t = ML()?.component("ClientOnly");
    return t || Fe({
        render() {
            return z1().default?.()
        }
    })
}, hC = () => {
    const e = ML(),
    t = e?.component("NuxtLink");
    if (t)
        return t;
    const n = e?.component("RouterLink");
    return n || Fe({
        props: {
            to: {
                type: String,
            default:
                ""
            }
        },
        render() {
            return dt("a", {
                href: this.to
            }, [z1().default?.()])
        }
    })
}, VQ = Fe({
    props: {
        href: {
            type: String,
        default:
            ""
        },
        to: {
            type: String,
        default:
            ""
        },
        preventDefault: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["click"],
    computed: {
        component() {
            return this.to ? hC() : this.href ? "a" : "button"
        },
        dynamicProps() {
            return this.to ? {
                to: this.to,
                event: this.preventDefault ? [] : "click"
            }
             : this.href ? {
                href: this.href
            }
             : {}
        }
    },
    methods: {
        onClick(e) {
            this.$emit("click", e),
            this.preventDefault && e.preventDefault()
        },
        focus() {
            this.getComponent()?.focus()
        },
        getComponent() {
            return this.$refs.button
        }
    }
}), te = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r, o] of t)
        n[r] = o;
    return n
};
function FQ(e, t, n, r, o, i) {
    return _(),
    H(Kt(e.component), Bt(e.dynamicProps, {
            ref: "button",
            disabled: e.disabled ? "disabled" : null,
            onClick: e.onClick
        }), {
    default:
        oe(() => [Ye(e.$slots, "default")]),
        _: 3
    }, 16, ["disabled", "onClick"])
}
const Z1 = te(VQ, [["render", FQ]]);
const jQ = {
    components: {
        BaseButton: Z1
    },
    props: {
        active: {
            type: Boolean,
        default:
            !1
        },
        primary: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        single() {
            return this.$slots.default().length === 1
        }
    },
    methods: {
        focus() {
            this.$refs.baseButton.focus()
        },
        getComponent() {
            return this.$refs.baseButton.getComponent()
        }
    }
};
function WQ(e, t, n, r, o, i) {
    const s = B("BaseButton");
    return _(),
    H(s, {
        ref: "baseButton",
        disabled: n.disabled,
        class: he(["function-button", {
                    single: i.single,
                    active: n.active,
                    primary: n.primary,
                    disabled: n.disabled
                }
            ])
    }, {
    default:
        oe(() => [Ye(e.$slots, "default", {}, void 0, !0)]),
        _: 3
    }, 8, ["disabled", "class"])
}
const ti = te(jQ, [["render", WQ], ["__scopeId", "data-v-555324d3"]]), zQ = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, HQ = P("path", {
    d: "M5 27 27 5M5 5l22 22"
}, null, -1), UQ = [HQ];
function qQ(e, t) {
    return _(),
    O("svg", zQ, UQ)
}
const qu = {
    render: qQ
}, YQ = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, KQ = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), GQ = P("path", {
    d: "M16 22v-8.2h-2.8m-.7 8.2h7"
}, null, -1), XQ = P("path", {
    "stroke-linecap": "round",
    "stroke-width": "1.6",
    d: "M16 9.6h0"
}, null, -1), JQ = [KQ, GQ, XQ];
function ZQ(e, t) {
    return _(),
    O("svg", YQ, JQ)
}
const Dk = {
    render: ZQ
}, QQ = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, eee = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), tee = P("path", {
    d: "M9.9 10.1 22 22m-.1-12L10 22.1"
}, null, -1), nee = [eee, tee];
function ree(e, t) {
    return _(),
    O("svg", QQ, nee)
}
const oee = {
    render: ree
}, iee = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, see = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), aee = P("path", {
    d: "m8.8 16 5.8 5.4 8.9-10.6"
}, null, -1), lee = [see, aee];
function cee(e, t) {
    return _(),
    O("svg", iee, lee)
}
const PL = {
    render: cee
}, uee = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, dee = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), fee = P("path", {
    d: "m16 7.307-.001 10.325"
}, null, -1), hee = P("path", {
    "stroke-linecap": "round",
    "stroke-width": "1.6",
    d: "M16 21.8h0"
}, null, -1), pee = [dee, fee, hee];
function mee(e, t) {
    return _(),
    O("svg", uee, pee)
}
const Q1 = {
    render: mee
}, gee = 160, vee = (e = "", t = gee) => {
    const n = e.length > t ? "…" : "";
    return `${e.substring(0, t - 1)}${n}`
}, Sp = e => e.charAt(0).toUpperCase() + e.substring(1), Cp = {
    customFormat: (e, t) => Sp(e.replace(t, " ").toLowerCase()),
    kebabFormat: e => Cp.customFormat(e, "-"),
    snakeFormat: e => Cp.customFormat(e, "_"),
    camelPascalCase: e => Sp(e.match(/([A-Z]?[^A-Z]*)/g).slice(0, -1).join(" ").toLowerCase()),
    [void 0]: e => Sp(e)
}, cgt = ({
    string: e,
    delimiter: t,
    format: n
}) => t ? Cp.customFormat(e, t) : Cp ? Cp[n](e) : Sp(e), yee = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    viewBox: "0 0 32 32"
}, wee = P("path", {
    d: "M17 4.8h10.5v10.5m0-10.5L15.9 16.4m11.5 10.8H4.5V5.1"
}, null, -1), bee = [wee];
function _ee(e, t) {
    return _(),
    O("svg", yee, bee)
}
const kee = {
    render: _ee
}, xee = Fe({
    __name: "ToastButton",
    props: {
        callback: {
            type: Function
        },
        to: {},
        href: {},
        icon: {},
        text: {}
    },
    setup(e) {
        const t = e,
        n = ne(() => t.href ? "_blank" : null),
        r = ne(() => typeof t.callback == "function" ? t.callback : null);
        return (o, i) => (_(), H(Z1, {
                class: "toast-button",
                to: o.to,
                href: o.href,
                target: n.value,
                onClick: r.value
            }, {
            default:
                oe(() => [o.to || o.href ? (_(), H(Kt(o.icon || ke(kee)), {
                                key: 0
                            })) : o.icon ? (_(), H(Kt(o.icon), {
                                key: 1
                            })) : J("", !0), mt(" " + Re(o.text), 1)]),
                _: 1
            }, 8, ["to", "href", "target", "onClick"]))
    }
});
const See = te(xee, [["__scopeId", "data-v-4eb64430"]]);
var Cee = typeof global == "object" && global && global.Object === Object && global;
const EL = Cee;
var Iee = typeof self == "object" && self && self.Object === Object && self, Tee = EL || Iee || Function("return this")();
const ba = Tee;
var Mee = ba.Symbol;
const oc = Mee;
var OL = Object.prototype, Pee = OL.hasOwnProperty, Eee = OL.toString, Lh = oc ? oc.toStringTag : void 0;
function Oee(e) {
    var t = Pee.call(e, Lh),
    n = e[Lh];
    try {
        e[Lh] = void 0;
        var r = !0
    } catch {}
    var o = Eee.call(e);
    return r && (t ? e[Lh] = n : delete e[Lh]),
    o
}
var $ee = Object.prototype, Aee = $ee.toString;
function Dee(e) {
    return Aee.call(e)
}
var Nee = "[object Null]", Ree = "[object Undefined]", w3 = oc ? oc.toStringTag : void 0;
function Yu(e) {
    return e == null ? e === void 0 ? Ree : Nee : w3 && w3 in Object(e) ? Oee(e) : Dee(e)
}
function uc(e) {
    return e != null && typeof e == "object"
}
var Lee = "[object Symbol]";
function Bee(e) {
    return typeof e == "symbol" || uc(e) && Yu(e) == Lee
}
function Vee(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = Array(r); ++n < r; )
        o[n] = t(e[n], n, e);
    return o
}
var Fee = Array.isArray;
const Cu = Fee;
var jee = 1 / 0, b3 = oc ? oc.prototype : void 0, _3 = b3 ? b3.toString : void 0;
function $L(e) {
    if (typeof e == "string")
        return e;
    if (Cu(e))
        return Vee(e, $L) + "";
    if (Bee(e))
        return _3 ? _3.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -jee ? "-0" : t
}
function dc(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
function AL(e) {
    return e
}
var Wee = "[object AsyncFunction]", zee = "[object Function]", Hee = "[object GeneratorFunction]", Uee = "[object Proxy]";
function pC(e) {
    if (!dc(e))
        return !1;
    var t = Yu(e);
    return t == zee || t == Hee || t == Wee || t == Uee
}
var qee = ba["__core-js_shared__"];
const O_ = qee;
var k3 = function () {
    var e = /[^.]+$/.exec(O_ && O_.keys && O_.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : ""
}
();
function Yee(e) {
    return !!k3 && k3 in e
}
var Kee = Function.prototype, Gee = Kee.toString;
function Ku(e) {
    if (e != null) {
        try {
            return Gee.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var Xee = /[\\^$.*+?()[\]{}|]/g, Jee = /^\[object .+?Constructor\]$/, Zee = Function.prototype, Qee = Object.prototype, ete = Zee.toString, tte = Qee.hasOwnProperty, nte = RegExp("^" + ete.call(tte).replace(Xee, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function rte(e) {
    if (!dc(e) || Yee(e))
        return !1;
    var t = pC(e) ? nte : Jee;
    return t.test(Ku(e))
}
function ote(e, t) {
    return e?.[t]
}
function Gu(e, t) {
    var n = ote(e, t);
    return rte(n) ? n : void 0
}
var ite = Gu(ba, "WeakMap");
const Nk = ite;
var x3 = Object.create, ste = function () {
    function e() {}
    return function (t) {
        if (!dc(t))
            return {};
        if (x3)
            return x3(t);
        e.prototype = t;
        var n = new e;
        return e.prototype = void 0,
        n
    }
}
();
const ate = ste;
function lte(e, t, n) {
    switch (n.length) {
    case 0:
        return e.call(t);
    case 1:
        return e.call(t, n[0]);
    case 2:
        return e.call(t, n[0], n[1]);
    case 3:
        return e.call(t, n[0], n[1], n[2])
    }
    return e.apply(t, n)
}
function cte() {}
function DL(e, t) {
    var n = -1,
    r = e.length;
    for (t || (t = Array(r)); ++n < r; )
        t[n] = e[n];
    return t
}
var ute = 800, dte = 16, fte = Date.now;
function hte(e) {
    var t = 0,
    n = 0;
    return function () {
        var r = fte(),
        o = dte - (r - n);
        if (n = r, o > 0) {
            if (++t >= ute)
                return arguments[0]
        } else
            t = 0;
        return e.apply(void 0, arguments)
    }
}
function pte(e) {
    return function () {
        return e
    }
}
var mte = function () {
    try {
        var e = Gu(Object, "defineProperty");
        return e({}, "", {}),
        e
    } catch {}
}
();
const R0 = mte;
var gte = R0 ? function (e, t) {
    return R0(e, "toString", {
        configurable: !0,
        enumerable: !1,
        value: pte(t),
        writable: !0
    })
}
 : AL;
const vte = gte;
var yte = hte(vte);
const wte = yte;
function bte(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; );
    return e
}
function _te(e, t, n, r) {
    for (var o = e.length, i = n + (r ? 1 : -1); r ? i-- : ++i < o; )
        if (t(e[i], i, e))
            return i;
    return -1
}
function kte(e) {
    return e !== e
}
function xte(e, t, n) {
    for (var r = n - 1, o = e.length; ++r < o; )
        if (e[r] === t)
            return r;
    return -1
}
function Ste(e, t, n) {
    return t === t ? xte(e, t, n) : _te(e, kte, n)
}
function Cte(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && Ste(e, t, 0) > -1
}
var Ite = 9007199254740991, Tte = /^(?:0|[1-9]\d*)$/;
function NL(e, t) {
    var n = typeof e;
    return t = t ?? Ite,
    !!t && (n == "number" || n != "symbol" && Tte.test(e)) && e > -1 && e % 1 == 0 && e < t
}
function mC(e, t, n) {
    t == "__proto__" && R0 ? R0(e, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
    }) : e[t] = n
}
function ew(e, t) {
    return e === t || e !== e && t !== t
}
var Mte = Object.prototype, Pte = Mte.hasOwnProperty;
function RL(e, t, n) {
    var r = e[t];
    (!(Pte.call(e, t) && ew(r, n)) || n === void 0 && !(t in e)) && mC(e, t, n)
}
function tg(e, t, n, r) {
    var o = !n;
    n || (n = {});
    for (var i = -1, s = t.length; ++i < s; ) {
        var a = t[i],
        l = r ? r(n[a], e[a], a, n, e) : void 0;
        l === void 0 && (l = e[a]),
        o ? mC(n, a, l) : RL(n, a, l)
    }
    return n
}
var S3 = Math.max;
function Ete(e, t, n) {
    return t = S3(t === void 0 ? e.length - 1 : t, 0),
    function () {
        for (var r = arguments, o = -1, i = S3(r.length - t, 0), s = Array(i); ++o < i; )
            s[o] = r[t + o];
        o = -1;
        for (var a = Array(t + 1); ++o < t; )
            a[o] = r[o];
        return a[t] = n(s),
        lte(e, this, a)
    }
}
function Ote(e, t) {
    return wte(Ete(e, t, AL), e + "")
}
var $te = 9007199254740991;
function LL(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= $te
}
function ng(e) {
    return e != null && LL(e.length) && !pC(e)
}
function Ate(e, t, n) {
    if (!dc(n))
        return !1;
    var r = typeof t;
    return (r == "number" ? ng(n) && NL(t, n.length) : r == "string" && t in n) ? ew(n[t], e) : !1
}
function Dte(e) {
    return Ote(function (t, n) {
        var r = -1,
        o = n.length,
        i = o > 1 ? n[o - 1] : void 0,
        s = o > 2 ? n[2] : void 0;
        for (i = e.length > 3 && typeof i == "function" ? (o--, i) : void 0, s && Ate(n[0], n[1], s) && (i = o < 3 ? void 0 : i, o = 1), t = Object(t); ++r < o; ) {
            var a = n[r];
            a && e(t, a, r, i)
        }
        return t
    })
}
var Nte = Object.prototype;
function tw(e) {
    var t = e && e.constructor,
    n = typeof t == "function" && t.prototype || Nte;
    return e === n
}
function Rte(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
        r[n] = t(n);
    return r
}
var Lte = "[object Arguments]";
function C3(e) {
    return uc(e) && Yu(e) == Lte
}
var BL = Object.prototype, Bte = BL.hasOwnProperty, Vte = BL.propertyIsEnumerable, Fte = C3(function () {
    return arguments
}
    ()) ? C3 : function (e) {
    return uc(e) && Bte.call(e, "callee") && !Vte.call(e, "callee")
};
const L0 = Fte;
function jte() {
    return !1
}
var VL = typeof exports == "object" && exports && !exports.nodeType && exports, I3 = VL && typeof module == "object" && module && !module.nodeType && module, Wte = I3 && I3.exports === VL, T3 = Wte ? ba.Buffer : void 0, zte = T3 ? T3.isBuffer : void 0, Hte = zte || jte;
const nw = Hte;
var Ute = "[object Arguments]", qte = "[object Array]", Yte = "[object Boolean]", Kte = "[object Date]", Gte = "[object Error]", Xte = "[object Function]", Jte = "[object Map]", Zte = "[object Number]", Qte = "[object Object]", ene = "[object RegExp]", tne = "[object Set]", nne = "[object String]", rne = "[object WeakMap]", one = "[object ArrayBuffer]", ine = "[object DataView]", sne = "[object Float32Array]", ane = "[object Float64Array]", lne = "[object Int8Array]", cne = "[object Int16Array]", une = "[object Int32Array]", dne = "[object Uint8Array]", fne = "[object Uint8ClampedArray]", hne = "[object Uint16Array]", pne = "[object Uint32Array]", zn = {};
zn[sne] = zn[ane] = zn[lne] = zn[cne] = zn[une] = zn[dne] = zn[fne] = zn[hne] = zn[pne] = !0;
zn[Ute] = zn[qte] = zn[one] = zn[Yte] = zn[ine] = zn[Kte] = zn[Gte] = zn[Xte] = zn[Jte] = zn[Zte] = zn[Qte] = zn[ene] = zn[tne] = zn[nne] = zn[rne] = !1;
function mne(e) {
    return uc(e) && LL(e.length) && !!zn[Yu(e)]
}
function gC(e) {
    return function (t) {
        return e(t)
    }
}
var FL = typeof exports == "object" && exports && !exports.nodeType && exports, Ip = FL && typeof module == "object" && module && !module.nodeType && module, gne = Ip && Ip.exports === FL, $_ = gne && EL.process, vne = function () {
    try {
        var e = Ip && Ip.require && Ip.require("util").types;
        return e || $_ && $_.binding && $_.binding("util")
    } catch {}
}
();
const gf = vne;
var M3 = gf && gf.isTypedArray, yne = M3 ? gC(M3) : mne;
const vC = yne;
var wne = Object.prototype, bne = wne.hasOwnProperty;
function jL(e, t) {
    var n = Cu(e),
    r = !n && L0(e),
    o = !n && !r && nw(e),
    i = !n && !r && !o && vC(e),
    s = n || r || o || i,
    a = s ? Rte(e.length, String) : [],
    l = a.length;
    for (var c in e)
        (t || bne.call(e, c)) && !(s && (c == "length" || o && (c == "offset" || c == "parent") || i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || NL(c, l))) && a.push(c);
    return a
}
function WL(e, t) {
    return function (n) {
        return e(t(n))
    }
}
var _ne = WL(Object.keys, Object);
const kne = _ne;
var xne = Object.prototype, Sne = xne.hasOwnProperty;
function zL(e) {
    if (!tw(e))
        return kne(e);
    var t = [];
    for (var n in Object(e))
        Sne.call(e, n) && n != "constructor" && t.push(n);
    return t
}
function yC(e) {
    return ng(e) ? jL(e) : zL(e)
}
function Cne(e) {
    var t = [];
    if (e != null)
        for (var n in Object(e))
            t.push(n);
    return t
}
var Ine = Object.prototype, Tne = Ine.hasOwnProperty;
function Mne(e) {
    if (!dc(e))
        return Cne(e);
    var t = tw(e),
    n = [];
    for (var r in e)
        r == "constructor" && (t || !Tne.call(e, r)) || n.push(r);
    return n
}
function rg(e) {
    return ng(e) ? jL(e, !0) : Mne(e)
}
var Pne = Gu(Object, "create");
const lm = Pne;
function Ene() {
    this.__data__ = lm ? lm(null) : {},
    this.size = 0
}
function One(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
    t
}
var $ne = "__lodash_hash_undefined__", Ane = Object.prototype, Dne = Ane.hasOwnProperty;
function Nne(e) {
    var t = this.__data__;
    if (lm) {
        var n = t[e];
        return n === $ne ? void 0 : n
    }
    return Dne.call(t, e) ? t[e] : void 0
}
var Rne = Object.prototype, Lne = Rne.hasOwnProperty;
function Bne(e) {
    var t = this.__data__;
    return lm ? t[e] !== void 0 : Lne.call(t, e)
}
var Vne = "__lodash_hash_undefined__";
function Fne(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
    n[e] = lm && t === void 0 ? Vne : t,
    this
}
function Iu(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Iu.prototype.clear = Ene;
Iu.prototype.delete = One;
Iu.prototype.get = Nne;
Iu.prototype.has = Bne;
Iu.prototype.set = Fne;
function jne() {
    this.__data__ = [],
    this.size = 0
}
function rw(e, t) {
    for (var n = e.length; n--; )
        if (ew(e[n][0], t))
            return n;
    return -1
}
var Wne = Array.prototype, zne = Wne.splice;
function Hne(e) {
    var t = this.__data__,
    n = rw(t, e);
    if (n < 0)
        return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : zne.call(t, n, 1),
    --this.size,
    !0
}
function Une(e) {
    var t = this.__data__,
    n = rw(t, e);
    return n < 0 ? void 0 : t[n][1]
}
function qne(e) {
    return rw(this.__data__, e) > -1
}
function Yne(e, t) {
    var n = this.__data__,
    r = rw(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t,
    this
}
function ol(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
ol.prototype.clear = jne;
ol.prototype.delete = Hne;
ol.prototype.get = Une;
ol.prototype.has = qne;
ol.prototype.set = Yne;
var Kne = Gu(ba, "Map");
const cm = Kne;
function Gne() {
    this.size = 0,
    this.__data__ = {
        hash: new Iu,
        map: new(cm || ol),
        string: new Iu
    }
}
function Xne(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
function ow(e, t) {
    var n = e.__data__;
    return Xne(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
}
function Jne(e) {
    var t = ow(this, e).delete(e);
    return this.size -= t ? 1 : 0,
    t
}
function Zne(e) {
    return ow(this, e).get(e)
}
function Qne(e) {
    return ow(this, e).has(e)
}
function ere(e, t) {
    var n = ow(this, e),
    r = n.size;
    return n.set(e, t),
    this.size += n.size == r ? 0 : 1,
    this
}
function Xu(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Xu.prototype.clear = Gne;
Xu.prototype.delete = Jne;
Xu.prototype.get = Zne;
Xu.prototype.has = Qne;
Xu.prototype.set = ere;
function wC(e) {
    return e == null ? "" : $L(e)
}
function HL(e, t) {
    for (var n = -1, r = t.length, o = e.length; ++n < r; )
        e[o + n] = t[n];
    return e
}
var tre = WL(Object.getPrototypeOf, Object);
const bC = tre;
var nre = "[object Object]", rre = Function.prototype, ore = Object.prototype, UL = rre.toString, ire = ore.hasOwnProperty, sre = UL.call(Object);
function are(e) {
    if (!uc(e) || Yu(e) != nre)
        return !1;
    var t = bC(e);
    if (t === null)
        return !0;
    var n = ire.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && UL.call(n) == sre
}
function lre(e, t, n, r) {
    var o = -1,
    i = e == null ? 0 : e.length;
    for (r && i && (n = e[++o]); ++o < i; )
        n = t(n, e[o], o, e);
    return n
}
function cre(e) {
    return function (t) {
        return e?.[t]
    }
}
var ure = {
    À: "A",
    Á: "A",
    Â: "A",
    Ã: "A",
    Ä: "A",
    Å: "A",
    à: "a",
    á: "a",
    â: "a",
    ã: "a",
    ä: "a",
    å: "a",
    Ç: "C",
    ç: "c",
    Ð: "D",
    ð: "d",
    È: "E",
    É: "E",
    Ê: "E",
    Ë: "E",
    è: "e",
    é: "e",
    ê: "e",
    ë: "e",
    Ì: "I",
    Í: "I",
    Î: "I",
    Ï: "I",
    ì: "i",
    í: "i",
    î: "i",
    ï: "i",
    Ñ: "N",
    ñ: "n",
    Ò: "O",
    Ó: "O",
    Ô: "O",
    Õ: "O",
    Ö: "O",
    Ø: "O",
    ò: "o",
    ó: "o",
    ô: "o",
    õ: "o",
    ö: "o",
    ø: "o",
    Ù: "U",
    Ú: "U",
    Û: "U",
    Ü: "U",
    ù: "u",
    ú: "u",
    û: "u",
    ü: "u",
    Ý: "Y",
    ý: "y",
    ÿ: "y",
    Æ: "Ae",
    æ: "ae",
    Þ: "Th",
    þ: "th",
    ß: "ss",
    Ā: "A",
    Ă: "A",
    Ą: "A",
    ā: "a",
    ă: "a",
    ą: "a",
    Ć: "C",
    Ĉ: "C",
    Ċ: "C",
    Č: "C",
    ć: "c",
    ĉ: "c",
    ċ: "c",
    č: "c",
    Ď: "D",
    Đ: "D",
    ď: "d",
    đ: "d",
    Ē: "E",
    Ĕ: "E",
    Ė: "E",
    Ę: "E",
    Ě: "E",
    ē: "e",
    ĕ: "e",
    ė: "e",
    ę: "e",
    ě: "e",
    Ĝ: "G",
    Ğ: "G",
    Ġ: "G",
    Ģ: "G",
    ĝ: "g",
    ğ: "g",
    ġ: "g",
    ģ: "g",
    Ĥ: "H",
    Ħ: "H",
    ĥ: "h",
    ħ: "h",
    Ĩ: "I",
    Ī: "I",
    Ĭ: "I",
    Į: "I",
    İ: "I",
    ĩ: "i",
    ī: "i",
    ĭ: "i",
    į: "i",
    ı: "i",
    Ĵ: "J",
    ĵ: "j",
    Ķ: "K",
    ķ: "k",
    ĸ: "k",
    Ĺ: "L",
    Ļ: "L",
    Ľ: "L",
    Ŀ: "L",
    Ł: "L",
    ĺ: "l",
    ļ: "l",
    ľ: "l",
    ŀ: "l",
    ł: "l",
    Ń: "N",
    Ņ: "N",
    Ň: "N",
    Ŋ: "N",
    ń: "n",
    ņ: "n",
    ň: "n",
    ŋ: "n",
    Ō: "O",
    Ŏ: "O",
    Ő: "O",
    ō: "o",
    ŏ: "o",
    ő: "o",
    Ŕ: "R",
    Ŗ: "R",
    Ř: "R",
    ŕ: "r",
    ŗ: "r",
    ř: "r",
    Ś: "S",
    Ŝ: "S",
    Ş: "S",
    Š: "S",
    ś: "s",
    ŝ: "s",
    ş: "s",
    š: "s",
    Ţ: "T",
    Ť: "T",
    Ŧ: "T",
    ţ: "t",
    ť: "t",
    ŧ: "t",
    Ũ: "U",
    Ū: "U",
    Ŭ: "U",
    Ů: "U",
    Ű: "U",
    Ų: "U",
    ũ: "u",
    ū: "u",
    ŭ: "u",
    ů: "u",
    ű: "u",
    ų: "u",
    Ŵ: "W",
    ŵ: "w",
    Ŷ: "Y",
    ŷ: "y",
    Ÿ: "Y",
    Ź: "Z",
    Ż: "Z",
    Ž: "Z",
    ź: "z",
    ż: "z",
    ž: "z",
    Ĳ: "IJ",
    ĳ: "ij",
    Œ: "Oe",
    œ: "oe",
    ŉ: "'n",
    ſ: "s"
}, dre = cre(ure);
const fre = dre;
var hre = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, pre = "\\u0300-\\u036f", mre = "\\ufe20-\\ufe2f", gre = "\\u20d0-\\u20ff", vre = pre + mre + gre, yre = "[" + vre + "]", wre = RegExp(yre, "g");
function bre(e) {
    return e = wC(e),
    e && e.replace(hre, fre).replace(wre, "")
}
var _re = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function kre(e) {
    return e.match(_re) || []
}
var xre = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Sre(e) {
    return xre.test(e)
}
var qL = "\\ud800-\\udfff", Cre = "\\u0300-\\u036f", Ire = "\\ufe20-\\ufe2f", Tre = "\\u20d0-\\u20ff", Mre = Cre + Ire + Tre, YL = "\\u2700-\\u27bf", KL = "a-z\\xdf-\\xf6\\xf8-\\xff", Pre = "\\xac\\xb1\\xd7\\xf7", Ere = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ore = "\\u2000-\\u206f", $re = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", GL = "A-Z\\xc0-\\xd6\\xd8-\\xde", Are = "\\ufe0e\\ufe0f", XL = Pre + Ere + Ore + $re, JL = "['’]", P3 = "[" + XL + "]", Dre = "[" + Mre + "]", ZL = "\\d+", Nre = "[" + YL + "]", QL = "[" + KL + "]", e6 = "[^" + qL + XL + ZL + YL + KL + GL + "]", Rre = "\\ud83c[\\udffb-\\udfff]", Lre = "(?:" + Dre + "|" + Rre + ")", Bre = "[^" + qL + "]", t6 = "(?:\\ud83c[\\udde6-\\uddff]){2}", n6 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ed = "[" + GL + "]", Vre = "\\u200d", E3 = "(?:" + QL + "|" + e6 + ")", Fre = "(?:" + Ed + "|" + e6 + ")", O3 = "(?:" + JL + "(?:d|ll|m|re|s|t|ve))?", $3 = "(?:" + JL + "(?:D|LL|M|RE|S|T|VE))?", r6 = Lre + "?", o6 = "[" + Are + "]?", jre = "(?:" + Vre + "(?:" + [Bre, t6, n6].join("|") + ")" + o6 + r6 + ")*", Wre = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", zre = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Hre = o6 + r6 + jre, Ure = "(?:" + [Nre, t6, n6].join("|") + ")" + Hre, qre = RegExp([Ed + "?" + QL + "+" + O3 + "(?=" + [P3, Ed, "$"].join("|") + ")", Fre + "+" + $3 + "(?=" + [P3, Ed + E3, "$"].join("|") + ")", Ed + "?" + E3 + "+" + O3, Ed + "+" + $3, zre, Wre, ZL, Ure].join("|"), "g");
function Yre(e) {
    return e.match(qre) || []
}
function Kre(e, t, n) {
    return e = wC(e),
    t = n ? void 0 : t,
    t === void 0 ? Sre(e) ? Yre(e) : kre(e) : e.match(t) || []
}
var Gre = "['’]", Xre = RegExp(Gre, "g");
function Jre(e) {
    return function (t) {
        return lre(Kre(bre(t).replace(Xre, "")), e, "")
    }
}
function Zre() {
    this.__data__ = new ol,
    this.size = 0
}
function Qre(e) {
    var t = this.__data__,
    n = t.delete(e);
    return this.size = t.size,
    n
}
function eoe(e) {
    return this.__data__.get(e)
}
function toe(e) {
    return this.__data__.has(e)
}
var noe = 200;
function roe(e, t) {
    var n = this.__data__;
    if (n instanceof ol) {
        var r = n.__data__;
        if (!cm || r.length < noe - 1)
            return r.push([e, t]), this.size = ++n.size, this;
        n = this.__data__ = new Xu(r)
    }
    return n.set(e, t),
    this.size = n.size,
    this
}
function Ju(e) {
    var t = this.__data__ = new ol(e);
    this.size = t.size
}
Ju.prototype.clear = Zre;
Ju.prototype.delete = Qre;
Ju.prototype.get = eoe;
Ju.prototype.has = toe;
Ju.prototype.set = roe;
function ooe(e, t) {
    return e && tg(t, yC(t), e)
}
function ioe(e, t) {
    return e && tg(t, rg(t), e)
}
var i6 = typeof exports == "object" && exports && !exports.nodeType && exports, A3 = i6 && typeof module == "object" && module && !module.nodeType && module, soe = A3 && A3.exports === i6, D3 = soe ? ba.Buffer : void 0, N3 = D3 ? D3.allocUnsafe : void 0;
function s6(e, t) {
    if (t)
        return e.slice();
    var n = e.length,
    r = N3 ? N3(n) : new e.constructor(n);
    return e.copy(r),
    r
}
function aoe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = 0, i = []; ++n < r; ) {
        var s = e[n];
        t(s, n, e) && (i[o++] = s)
    }
    return i
}
function a6() {
    return []
}
var loe = Object.prototype, coe = loe.propertyIsEnumerable, R3 = Object.getOwnPropertySymbols, uoe = R3 ? function (e) {
    return e == null ? [] : (e = Object(e), aoe(R3(e), function (t) {
            return coe.call(e, t)
        }))
}
 : a6;
const _C = uoe;
function doe(e, t) {
    return tg(e, _C(e), t)
}
var foe = Object.getOwnPropertySymbols, hoe = foe ? function (e) {
    for (var t = []; e; )
        HL(t, _C(e)), e = bC(e);
    return t
}
 : a6;
const l6 = hoe;
function poe(e, t) {
    return tg(e, l6(e), t)
}
function c6(e, t, n) {
    var r = t(e);
    return Cu(e) ? r : HL(r, n(e))
}
function moe(e) {
    return c6(e, yC, _C)
}
function goe(e) {
    return c6(e, rg, l6)
}
var voe = Gu(ba, "DataView");
const Rk = voe;
var yoe = Gu(ba, "Promise");
const Lk = yoe;
var woe = Gu(ba, "Set");
const ef = woe;
var L3 = "[object Map]", boe = "[object Object]", B3 = "[object Promise]", V3 = "[object Set]", F3 = "[object WeakMap]", j3 = "[object DataView]", _oe = Ku(Rk), koe = Ku(cm), xoe = Ku(Lk), Soe = Ku(ef), Coe = Ku(Nk), Lc = Yu;
(Rk && Lc(new Rk(new ArrayBuffer(1))) != j3 || cm && Lc(new cm) != L3 || Lk && Lc(Lk.resolve()) != B3 || ef && Lc(new ef) != V3 || Nk && Lc(new Nk) != F3) && (Lc = function (e) {
    var t = Yu(e),
    n = t == boe ? e.constructor : void 0,
    r = n ? Ku(n) : "";
    if (r)
        switch (r) {
        case _oe:
            return j3;
        case koe:
            return L3;
        case xoe:
            return B3;
        case Soe:
            return V3;
        case Coe:
            return F3
        }
    return t
});
const iw = Lc;
var Ioe = Object.prototype, Toe = Ioe.hasOwnProperty;
function Moe(e) {
    var t = e.length,
    n = new e.constructor(t);
    return t && typeof e[0] == "string" && Toe.call(e, "index") && (n.index = e.index, n.input = e.input),
    n
}
var Poe = ba.Uint8Array;
const W3 = Poe;
function kC(e) {
    var t = new e.constructor(e.byteLength);
    return new W3(t).set(new W3(e)),
    t
}
function Eoe(e, t) {
    var n = t ? kC(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength)
}
var Ooe = /\w*$/;
function $oe(e) {
    var t = new e.constructor(e.source, Ooe.exec(e));
    return t.lastIndex = e.lastIndex,
    t
}
var z3 = oc ? oc.prototype : void 0, H3 = z3 ? z3.valueOf : void 0;
function Aoe(e) {
    return H3 ? Object(H3.call(e)) : {}
}
function u6(e, t) {
    var n = t ? kC(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length)
}
var Doe = "[object Boolean]", Noe = "[object Date]", Roe = "[object Map]", Loe = "[object Number]", Boe = "[object RegExp]", Voe = "[object Set]", Foe = "[object String]", joe = "[object Symbol]", Woe = "[object ArrayBuffer]", zoe = "[object DataView]", Hoe = "[object Float32Array]", Uoe = "[object Float64Array]", qoe = "[object Int8Array]", Yoe = "[object Int16Array]", Koe = "[object Int32Array]", Goe = "[object Uint8Array]", Xoe = "[object Uint8ClampedArray]", Joe = "[object Uint16Array]", Zoe = "[object Uint32Array]";
function Qoe(e, t, n) {
    var r = e.constructor;
    switch (t) {
    case Woe:
        return kC(e);
    case Doe:
    case Noe:
        return new r(+e);
    case zoe:
        return Eoe(e, n);
    case Hoe:
    case Uoe:
    case qoe:
    case Yoe:
    case Koe:
    case Goe:
    case Xoe:
    case Joe:
    case Zoe:
        return u6(e, n);
    case Roe:
        return new r;
    case Loe:
    case Foe:
        return new r(e);
    case Boe:
        return $oe(e);
    case Voe:
        return new r;
    case joe:
        return Aoe(e)
    }
}
function d6(e) {
    return typeof e.constructor == "function" && !tw(e) ? ate(bC(e)) : {}
}
var eie = "[object Map]";
function tie(e) {
    return uc(e) && iw(e) == eie
}
var U3 = gf && gf.isMap, nie = U3 ? gC(U3) : tie;
const rie = nie;
var oie = "[object Set]";
function iie(e) {
    return uc(e) && iw(e) == oie
}
var q3 = gf && gf.isSet, sie = q3 ? gC(q3) : iie;
const aie = sie;
var lie = 1, cie = 2, uie = 4, f6 = "[object Arguments]", die = "[object Array]", fie = "[object Boolean]", hie = "[object Date]", pie = "[object Error]", h6 = "[object Function]", mie = "[object GeneratorFunction]", gie = "[object Map]", vie = "[object Number]", p6 = "[object Object]", yie = "[object RegExp]", wie = "[object Set]", bie = "[object String]", _ie = "[object Symbol]", kie = "[object WeakMap]", xie = "[object ArrayBuffer]", Sie = "[object DataView]", Cie = "[object Float32Array]", Iie = "[object Float64Array]", Tie = "[object Int8Array]", Mie = "[object Int16Array]", Pie = "[object Int32Array]", Eie = "[object Uint8Array]", Oie = "[object Uint8ClampedArray]", $ie = "[object Uint16Array]", Aie = "[object Uint32Array]", Vn = {};
Vn[f6] = Vn[die] = Vn[xie] = Vn[Sie] = Vn[fie] = Vn[hie] = Vn[Cie] = Vn[Iie] = Vn[Tie] = Vn[Mie] = Vn[Pie] = Vn[gie] = Vn[vie] = Vn[p6] = Vn[yie] = Vn[wie] = Vn[bie] = Vn[_ie] = Vn[Eie] = Vn[Oie] = Vn[$ie] = Vn[Aie] = !0;
Vn[pie] = Vn[h6] = Vn[kie] = !1;
function r0(e, t, n, r, o, i) {
    var s,
    a = t & lie,
    l = t & cie,
    c = t & uie;
    if (n && (s = o ? n(e, r, o, i) : n(e)), s !== void 0)
        return s;
    if (!dc(e))
        return e;
    var u = Cu(e);
    if (u) {
        if (s = Moe(e), !a)
            return DL(e, s)
    } else {
        var f = iw(e),
        p = f == h6 || f == mie;
        if (nw(e))
            return s6(e, a);
        if (f == p6 || f == f6 || p && !o) {
            if (s = l || p ? {}
                 : d6(e), !a)
                return l ? poe(e, ioe(s, e)) : doe(e, ooe(s, e))
        } else {
            if (!Vn[f])
                return o ? e : {};
            s = Qoe(e, f, a)
        }
    }
    i || (i = new Ju);
    var m = i.get(e);
    if (m)
        return m;
    i.set(e, s),
    aie(e) ? e.forEach(function (b) {
        s.add(r0(b, t, n, b, e, i))
    }) : rie(e) && e.forEach(function (b, w) {
        s.set(w, r0(b, t, n, w, e, i))
    });
    var v = c ? l ? goe : moe : l ? rg : yC,
    y = u ? void 0 : v(e);
    return bte(y || e, function (b, w) {
        y && (w = b, b = e[w]),
        RL(s, w, r0(b, t, n, w, e, i))
    }),
    s
}
var Die = 1, Nie = 4;
function Rie(e) {
    return r0(e, Die | Nie)
}
var Lie = "__lodash_hash_undefined__";
function Bie(e) {
    return this.__data__.set(e, Lie),
    this
}
function Vie(e) {
    return this.__data__.has(e)
}
function B0(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.__data__ = new Xu; ++t < n; )
        this.add(e[t])
}
B0.prototype.add = B0.prototype.push = Bie;
B0.prototype.has = Vie;
function Fie(e, t) {
    return e.has(t)
}
function m6(e) {
    var t = -1,
    n = Array(e.size);
    return e.forEach(function (r) {
        n[++t] = r
    }),
    n
}
function jie(e) {
    return function (t, n, r) {
        for (var o = -1, i = Object(t), s = r(t), a = s.length; a--; ) {
            var l = s[e ? a : ++o];
            if (n(i[l], l, i) === !1)
                break
        }
        return t
    }
}
var Wie = jie();
const zie = Wie;
function Bk(e, t, n) {
    (n !== void 0 && !ew(e[t], n) || n === void 0 && !(t in e)) && mC(e, t, n)
}
function Hie(e) {
    return uc(e) && ng(e)
}
function Vk(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
        return e[t]
}
function Uie(e) {
    return tg(e, rg(e))
}
function qie(e, t, n, r, o, i, s) {
    var a = Vk(e, n),
    l = Vk(t, n),
    c = s.get(l);
    if (c) {
        Bk(e, n, c);
        return
    }
    var u = i ? i(a, l, n + "", e, t, s) : void 0,
    f = u === void 0;
    if (f) {
        var p = Cu(l),
        m = !p && nw(l),
        v = !p && !m && vC(l);
        u = l,
        p || m || v ? Cu(a) ? u = a : Hie(a) ? u = DL(a) : m ? (f = !1, u = s6(l, !0)) : v ? (f = !1, u = u6(l, !0)) : u = [] : are(l) || L0(l) ? (u = a, L0(a) ? u = Uie(a) : (!dc(a) || pC(a)) && (u = d6(l))) : f = !1
    }
    f && (s.set(l, u), o(u, l, r, i, s), s.delete(l)),
    Bk(e, n, u)
}
function g6(e, t, n, r, o) {
    e !== t && zie(t, function (i, s) {
        if (o || (o = new Ju), dc(i))
            qie(e, t, s, n, g6, r, o);
        else {
            var a = r ? r(Vk(e, s), i, s + "", e, t, o) : void 0;
            a === void 0 && (a = i),
            Bk(e, s, a)
        }
    }, rg)
}
function Yie(e, t, n) {
    for (var r = -1, o = e == null ? 0 : e.length; ++r < o; )
        if (n(t, e[r]))
            return !0;
    return !1
}
var Kie = "[object Map]", Gie = "[object Set]", Xie = Object.prototype, Jie = Xie.hasOwnProperty;
function Zie(e) {
    if (e == null)
        return !0;
    if (ng(e) && (Cu(e) || typeof e == "string" || typeof e.splice == "function" || nw(e) || vC(e) || L0(e)))
        return !e.length;
    var t = iw(e);
    if (t == Kie || t == Gie)
        return !e.size;
    if (tw(e))
        return !zL(e).length;
    for (var n in e)
        if (Jie.call(e, n))
            return !1;
    return !0
}
var Qie = Jre(function (e, t, n) {
    return e + (n ? "-" : "") + t.toLowerCase()
});
const ese = Qie;
var tse = Dte(function (e, t, n) {
    g6(e, t, n)
});
const nse = tse;
var rse = 1 / 0, ose = ef && 1 / m6(new ef([, -0]))[1] == rse ? function (e) {
    return new ef(e)
}
 : cte;
const ise = ose;
var sse = 200;
function ase(e, t, n) {
    var r = -1,
    o = Cte,
    i = e.length,
    s = !0,
    a = [],
    l = a;
    if (n)
        s = !1, o = Yie;
    else if (i >= sse) {
        var c = t ? null : ise(e);
        if (c)
            return m6(c);
        s = !1,
        o = Fie,
        l = new B0
    } else
        l = t ? [] : a;
    e: for (; ++r < i; ) {
        var u = e[r],
        f = t ? t(u) : u;
        if (u = n || u !== 0 ? u : 0, s && f === f) {
            for (var p = l.length; p--; )
                if (l[p] === f)
                    continue e;
            t && l.push(f),
            a.push(u)
        } else
            o(l, f, n) || (l !== a && l.push(f), a.push(u))
    }
    return a
}
function lse(e) {
    return e && e.length ? ase(e) : []
}
var cse = 0;
function V0(e) {
    var t = ++cse;
    return wC(e) + t
}
function use(e, t, {
    callback: n = () => {},
    animationOptions: r = {},
    immediate: o = !1
} = {}) {
    const s = nse({}, {
        duration: 1e3,
        fill: "forwards"
    }, r),
    a = De(null),
    l = () => {
        !a.value && e.value ? (a.value = e.value.animate(t, s), a.value.onfinish = () => {
            n()
        }) : a.value && (a.value.playState === "paused" || a.value.playState === "idle") && a.value.play()
    },
    c = () => {
        a.value?.playState === "running" && a.value.pause()
    },
    u = () => {
        a.value && (a.value.cancel(), a.value = null)
    };
    return Ur(() => {
        o && l()
    }), {
        play: l,
        pause: c,
        reset: u
    }
}
const dse = e => (ir("data-v-7ec7851a"), e = e(), sr(), e), fse = {
    class: "type-indicator"
}, hse = {
    class: "content"
}, pse = {
    class: "headline"
}, mse = {
    class: "message"
}, gse = {
    key: 0,
    class: "buttons"
}, vse = dse(() => P("div", {
            class: "progress-bar-inner"
        }, null, -1)), yse = [vse], wse = 160, bse = Fe({
        __name: "Toast",
        props: {
            type: {
            default:
                "info"
            },
            headline: {
            default:
                ""
            },
            message: {
            default:
                ""
            },
            buttons: {
            default:
                () => []
            },
            autoRemove: {
                type: Boolean,
            default:
                !0
            },
            active: {
                type: Boolean,
            default:
                !0
            },
            id: {},
            stackId: {
            default:
                "default"
            }
        },
        emits: ["remove", "auto-remove"],
        setup(e, {
            emit: t
        }) {
            const n = e,
            r = ne(() => n.headline ? n.headline : Sp(n.type)),
            o = {
                info: Dk,
                error: oee,
                success: PL,
                warning: Q1
            },
            i = ne(() => o[n.type]),
            s = De(null),
            a = LQ(), {
                isOutside: l
            } = $Q(s),
            c = ne(() => !a.value || !l.value),
            u = De(null),
            f = [{
                    transform: "scaleX(0)"
                }
            ],
            p = {
                callback: () => t("auto-remove"),
                animationOptions: {
                    duration: 7e3
                }
            }, {
                play: m,
                pause: v,
                reset: y
            } = use(u, f, p),
            b = ne(() => vee(n.message, wse)),
            w = b.value !== n.message,
            k = De(w),
            C = () => {
                k.value = !1
            },
            x = De(null),
            S = De(null),
            T = PQ(`new-stack-height-${n.stackId}`),
            E = M => {
                s.value !== null && (s.value.style.height = `${M}px`),
                S.value = M
            };
            return T.on(M => {
                typeof M == "number" && S.value !== M && E(M)
            }),
            Ur(() => {
                s.value !== null && (x.value = s.value.clientHeight, S.value = s.value.clientHeight),
                T.emit(S.value),
                n.autoRemove && n.active && m()
            }),
            Ht(c, M => {
                !n.autoRemove || !n.active || (M ? v() : m())
            }),
            Ht(ca(n, "active"), M => {
                if (M) {
                    x.value !== null && (E(x.value), T.emit(S.value)),
                    n.autoRemove && !c.value && m();
                    return
                }
                w && (k.value = !0),
                n.autoRemove && y()
            }),
            (M, N) => (_(), O("div", {
                    ref_key: "toastRef",
                    ref: s,
                    class: he(["toast", M.type])
                }, [Cn(P("div", {
                                class: he(["container", {
                                            "auto-remove": M.autoRemove
                                        }
                                    ])
                            }, [P("div", fse, [(_(), H(Kt(i.value), {
                                                    class: "type-indicator-icon"
                                                }))]), P("div", hse, [P("div", pse, Re(r.value), 1), P("div", mse, [k.value ? (_(), O(Le, {
                                                            key: 0
                                                        }, [mt(Re(b.value) + " ", 1), P("button", {
                                                                    class: "show-more",
                                                                    onClick: C
                                                                }, "show more")], 64)) : (_(), O(Le, {
                                                            key: 1
                                                        }, [mt(Re(M.message), 1)], 64))]), M.buttons.length ? (_(), O("div", gse, [(_(!0), O(Le, null, $t(M.buttons, (F, K) => (_(), H(See, Bt(F, {
                                                                                key: K
                                                                            }), null, 16))), 128))])) : J("", !0), z(ti, {
                                                class: "close-button",
                                                title: "关闭消息",
                                                onClick: N[0] || (N[0] = F => t("remove")),
                                                onKeydown: N[1] || (N[1] = Rt(ve(F => t("remove"), ["stop", "prevent"]), ["space"]))
                                            }, {
                                            default:
                                                oe(() => [z(ke(qu))]),
                                                _: 1
                                            })]), P("div", {
                                        ref_key: "progressBar",
                                        ref: u,
                                        class: "progress-bar"
                                    }, yse, 512)], 2), [[Kn, M.active]])], 2))
        }
    });
const _se = te(bse, [["__scopeId", "data-v-7ec7851a"]]), v6 = Symbol("toast"), y6 = "$toast";
class F0 extends Error {
    constructor(t) {
        super(t),
        this.name = "ToastServiceError"
    }
}
class kse {
    toasts = De([]);
    show = t => {
        const n = Rie(t);
        return n.id = n.id ? `${n.id}-${V0()}` : V0(),
        n.autoRemove = n.autoRemove ?? !0,
        this.toasts.value.unshift(n),
        n.id
    };
    remove = t => {
        this.toasts.value = this.toasts.value.filter(n => n.id !== t)
    };
    autoRemove = () => {
        this.toasts.value = this.toasts.value.filter(t => !t.autoRemove)
    };
    removeAll = () => {
        this.toasts.value = []
    };
    readonlyToasts = ne(() => this.toasts.value);
    toastServiceObject = {
        toasts: this.readonlyToasts,
        show: this.show,
        remove: this.remove,
        autoRemove: this.autoRemove,
        removeAll: this.removeAll
    };
    useToastService = ({
        serviceSymbol: t = v6
    } = {}) => {
        iu(t, this.toastServiceObject)
    };
    getToastServicePlugin = () => ({
        install: (t, n) => {
            const r = n?.propertyName ?? y6;
            t.config.globalProperties[r] = this.toastServiceObject
        }
    });
    getToastServiceObject = () => this.toastServiceObject
}
const Y3 = e => {
    const t = Mo(e, null);
    if (!t)
        throw new F0(`No toast service found using the symbol ${e.toString()}.`);
    return t
}, K3 = e => {
    const t = ii()?.appContext.config.globalProperties[e];
    if (!t)
        throw new F0(`No toast service found using the global property name '${e}'.`);
    return t
}, w6 = ({
    serviceSymbol: e,
    propertyName: t
} = {}) => {
    if (e && t)
        throw new F0("Please provide either a custom injection key symbol or a custom global property name, but not both.");
    if (!e && !t)
        try {
            return Y3(v6)
        } catch {
            return K3(y6)
        }
    if (e)
        return Y3(e);
    if (t)
        return K3(t);
    throw new F0("No toast service found.")
}, A_ = 5, xse = 4, Sse = Fe({
    __name: "ToastStack",
    props: {
        serviceSymbol: {
        default:
            null
        },
        propertyName: {
        default:
            null
        }
    },
    setup(e) {
        const t = e,
        n = ne(() => t.serviceSymbol ? t.serviceSymbol.toString() : t.propertyName ? t.propertyName : "default"), {
            toasts: r,
            remove: o,
            autoRemove: i
        } = w6({
            serviceSymbol: t.serviceSymbol,
            propertyName: t.propertyName
        }),
        s = l => {
            const c = l < A_ ? xse : A_,
            u = l < A_ ? null : 0;
            return {
                zIndex: -l,
                bottom: `${ - c * l}px`,
                right: `${ - c * l}px`,
                ...u !== null && {
                    opacity: u
                }
            }
        },
        a = l => l === 0;
        return (l, c) => (_(), H(Qm, {
                class: "toast-stack",
                tag: "div",
                name: "toast-stack"
            }, {
            default:
                oe(() => [(_(!0), O(Le, null, $t(ke(r), (u, f) => (_(), H(_se, Bt(u, {
                                                key: u.id,
                                                active: a(f),
                                                class: "toast",
                                                style: s(f),
                                                "stack-id": n.value,
                                                onRemove: p => ke(o)(u.id),
                                                onAutoRemove: c[0] || (c[0] = p => ke(i)())
                                            }), null, 16, ["active", "style", "stack-id", "onRemove"]))), 128))]),
                _: 1
            }))
    }
});
const Cse = te(Sse, [["__scopeId", "data-v-3447d9e1"]]), Ise = Fe({
    __name: "DynamicEnvRenderer",
    props: {
        value: {}
    },
    setup(e) {
        const t = e,
        n = ne(() => t.value === hc);
        return (r, o) => n.value ? Ye(r.$slots, "default", {
            key: 0
        }) : J("", !0)
    }
});
var Mt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function og(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function b6(e) {
    if (e.__esModule)
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var n = function r() {
            if (this instanceof r) {
                var o = [null];
                o.push.apply(o, arguments);
                var i = Function.bind.apply(t, o);
                return new i
            }
            return t.apply(this, arguments)
        };
        n.prototype = t.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    Object.keys(e).forEach(function (r) {
        var o = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(n, r, o.get ? o : {
            enumerable: !0,
            get: function () {
                return e[r]
            }
        })
    }),
    n
}
var Tu = {}, _6 = {}, um = {}, Tse = {
    get exports() {
        return um
    },
    set exports(e) {
        um = e
    }
}, tf = typeof Reflect == "object" ? Reflect : null, G3 = tf && typeof tf.apply == "function" ? tf.apply : function (t, n, r) {
    return Function.prototype.apply.call(t, n, r)
}, o0;
tf && typeof tf.ownKeys == "function" ? o0 = tf.ownKeys : Object.getOwnPropertySymbols ? o0 = function (t) {
    return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
}
 : o0 = function (t) {
    return Object.getOwnPropertyNames(t)
};
function Mse(e) {
    console && console.warn && console.warn(e)
}
var k6 = Number.isNaN || function (t) {
    return t !== t
};
function Tn() {
    Tn.init.call(this)
}
Tse.exports = Tn;
um.once = $se;
Tn.EventEmitter = Tn;
Tn.prototype._events = void 0;
Tn.prototype._eventsCount = 0;
Tn.prototype._maxListeners = void 0;
var X3 = 10;
function sw(e) {
    if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
}
Object.defineProperty(Tn, "defaultMaxListeners", {
    enumerable: !0,
    get: function () {
        return X3
    },
    set: function (e) {
        if (typeof e != "number" || e < 0 || k6(e))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
        X3 = e
    }
});
Tn.init = function () {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0),
    this._maxListeners = this._maxListeners || void 0
};
Tn.prototype.setMaxListeners = function (t) {
    if (typeof t != "number" || t < 0 || k6(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
    return this._maxListeners = t,
    this
};
function x6(e) {
    return e._maxListeners === void 0 ? Tn.defaultMaxListeners : e._maxListeners
}
Tn.prototype.getMaxListeners = function () {
    return x6(this)
};
Tn.prototype.emit = function (t) {
    for (var n = [], r = 1; r < arguments.length; r++)
        n.push(arguments[r]);
    var o = t === "error",
    i = this._events;
    if (i !== void 0)
        o = o && i.error === void 0;
    else if (!o)
        return !1;
    if (o) {
        var s;
        if (n.length > 0 && (s = n[0]), s instanceof Error)
            throw s;
        var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
        throw a.context = s,
        a
    }
    var l = i[t];
    if (l === void 0)
        return !1;
    if (typeof l == "function")
        G3(l, this, n);
    else
        for (var c = l.length, u = M6(l, c), r = 0; r < c; ++r)
            G3(u[r], this, n);
    return !0
};
function S6(e, t, n, r) {
    var o,
    i,
    s;
    if (sw(n), i = e._events, i === void 0 ? (i = e._events = Object.create(null), e._eventsCount = 0) : (i.newListener !== void 0 && (e.emit("newListener", t, n.listener ? n.listener : n), i = e._events), s = i[t]), s === void 0)
        s = i[t] = n, ++e._eventsCount;
    else if (typeof s == "function" ? s = i[t] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), o = x6(e), o > 0 && s.length > o && !s.warned) {
        s.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning",
        a.emitter = e,
        a.type = t,
        a.count = s.length,
        Mse(a)
    }
    return e
}
Tn.prototype.addListener = function (t, n) {
    return S6(this, t, n, !1)
};
Tn.prototype.on = Tn.prototype.addListener;
Tn.prototype.prependListener = function (t, n) {
    return S6(this, t, n, !0)
};
function Pse() {
    if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}
function C6(e, t, n) {
    var r = {
        fired: !1,
        wrapFn: void 0,
        target: e,
        type: t,
        listener: n
    },
    o = Pse.bind(r);
    return o.listener = n,
    r.wrapFn = o,
    o
}
Tn.prototype.once = function (t, n) {
    return sw(n),
    this.on(t, C6(this, t, n)),
    this
};
Tn.prototype.prependOnceListener = function (t, n) {
    return sw(n),
    this.prependListener(t, C6(this, t, n)),
    this
};
Tn.prototype.removeListener = function (t, n) {
    var r,
    o,
    i,
    s,
    a;
    if (sw(n), o = this._events, o === void 0)
        return this;
    if (r = o[t], r === void 0)
        return this;
    if (r === n || r.listener === n)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete o[t], o.removeListener && this.emit("removeListener", t, r.listener || n));
    else if (typeof r != "function") {
        for (i = -1, s = r.length - 1; s >= 0; s--)
            if (r[s] === n || r[s].listener === n) {
                a = r[s].listener,
                i = s;
                break
            }
        if (i < 0)
            return this;
        i === 0 ? r.shift() : Ese(r, i),
        r.length === 1 && (o[t] = r[0]),
        o.removeListener !== void 0 && this.emit("removeListener", t, a || n)
    }
    return this
};
Tn.prototype.off = Tn.prototype.removeListener;
Tn.prototype.removeAllListeners = function (t) {
    var n,
    r,
    o;
    if (r = this._events, r === void 0)
        return this;
    if (r.removeListener === void 0)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[t]), this;
    if (arguments.length === 0) {
        var i = Object.keys(r),
        s;
        for (o = 0; o < i.length; ++o)
            s = i[o], s !== "removeListener" && this.removeAllListeners(s);
        return this.removeAllListeners("removeListener"),
        this._events = Object.create(null),
        this._eventsCount = 0,
        this
    }
    if (n = r[t], typeof n == "function")
        this.removeListener(t, n);
    else if (n !== void 0)
        for (o = n.length - 1; o >= 0; o--)
            this.removeListener(t, n[o]);
    return this
};
function I6(e, t, n) {
    var r = e._events;
    if (r === void 0)
        return [];
    var o = r[t];
    return o === void 0 ? [] : typeof o == "function" ? n ? [o.listener || o] : [o] : n ? Ose(o) : M6(o, o.length)
}
Tn.prototype.listeners = function (t) {
    return I6(this, t, !0)
};
Tn.prototype.rawListeners = function (t) {
    return I6(this, t, !1)
};
Tn.listenerCount = function (e, t) {
    return typeof e.listenerCount == "function" ? e.listenerCount(t) : T6.call(e, t)
};
Tn.prototype.listenerCount = T6;
function T6(e) {
    var t = this._events;
    if (t !== void 0) {
        var n = t[e];
        if (typeof n == "function")
            return 1;
        if (n !== void 0)
            return n.length
    }
    return 0
}
Tn.prototype.eventNames = function () {
    return this._eventsCount > 0 ? o0(this._events) : []
};
function M6(e, t) {
    for (var n = new Array(t), r = 0; r < t; ++r)
        n[r] = e[r];
    return n
}
function Ese(e, t) {
    for (; t + 1 < e.length; t++)
        e[t] = e[t + 1];
    e.pop()
}
function Ose(e) {
    for (var t = new Array(e.length), n = 0; n < t.length; ++n)
        t[n] = e[n].listener || e[n];
    return t
}
function $se(e, t) {
    return new Promise(function (n, r) {
        function o(s) {
            e.removeListener(t, i),
            r(s)
        }
        function i() {
            typeof e.removeListener == "function" && e.removeListener("error", o),
            n([].slice.call(arguments))
        }
        P6(e, t, i, {
            once: !0
        }),
        t !== "error" && Ase(e, o, {
            once: !0
        })
    })
}
function Ase(e, t, n) {
    typeof e.on == "function" && P6(e, "error", t, n)
}
function P6(e, t, n, r) {
    if (typeof e.on == "function")
        r.once ? e.once(t, n) : e.on(t, n);
    else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function o(i) {
            r.once && e.removeEventListener(t, o),
            n(i)
        });
    else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e)
}
(function (e) {
    var t = Mt && Mt.__awaiter || function (i, s, a, l) {
        function c(u) {
            return u instanceof a ? u : new a(function (f) {
                f(u)
            })
        }
        return new(a || (a = Promise))(function (u, f) {
            function p(y) {
                try {
                    v(l.next(y))
                } catch (b) {
                    f(b)
                }
            }
            function m(y) {
                try {
                    v(l.throw(y))
                } catch (b) {
                    f(b)
                }
            }
            function v(y) {
                y.done ? u(y.value) : c(y.value).then(p, m)
            }
            v((l = l.apply(i, s || [])).next())
        })
    },
    n = Mt && Mt.__generator || function (i, s) {
        var a = {
            label: 0,
            sent: function () {
                if (u[0] & 1)
                    throw u[1];
                return u[1]
            },
            trys: [],
            ops: []
        },
        l,
        c,
        u,
        f;
        return f = {
            next: p(0),
            throw : p(1),
            return : p(2)
        },
        typeof Symbol == "function" && (f[Symbol.iterator] = function () {
            return this
        }),
        f;
        function p(v) {
            return function (y) {
                return m([v, y])
            }
        }
        function m(v) {
            if (l)
                throw new TypeError("Generator is already executing.");
            for (; a; )
                try {
                    if (l = 1, c && (u = v[0] & 2 ? c.return : v[0] ? c.throw || ((u = c.return) && u.call(c), 0) : c.next) && !(u = u.call(c, v[1])).done)
                        return u;
                    switch (c = 0, u && (v = [v[0] & 2, u.value]), v[0]) {
                    case 0:
                    case 1:
                        u = v;
                        break;
                    case 4:
                        return a.label++, {
                            value: v[1],
                            done: !1
                        };
                    case 5:
                        a.label++,
                        c = v[1],
                        v = [0];
                        continue;
                    case 7:
                        v = a.ops.pop(),
                        a.trys.pop();
                        continue;
                    default:
                        if (u = a.trys, !(u = u.length > 0 && u[u.length - 1]) && (v[0] === 6 || v[0] === 2)) {
                            a = 0;
                            continue
                        }
                        if (v[0] === 3 && (!u || v[1] > u[0] && v[1] < u[3])) {
                            a.label = v[1];
                            break
                        }
                        if (v[0] === 6 && a.label < u[1]) {
                            a.label = u[1],
                            u = v;
                            break
                        }
                        if (u && a.label < u[2]) {
                            a.label = u[2],
                            a.ops.push(v);
                            break
                        }
                        u[2] && a.ops.pop(),
                        a.trys.pop();
                        continue
                    }
                    v = s.call(i, a)
                } catch (y) {
                    v = [6, y],
                    c = 0
                } finally {
                l = u = 0
            }
            if (v[0] & 5)
                throw v[1];
            return {
                value: v[0] ? v[1] : void 0,
                done: !0
            }
        }
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.defaultNextRequest = void 0;
    var r = um;
    e.defaultNextRequest = function () {
        var i = -1;
        return function () {
            return ++i
        }
    };
    var o = function () {
        function i(s, a) {
            a === void 0 && (a = e.defaultNextRequest()),
            this.batch = [],
            this.batchStarted = !1,
            this.lastId = -1,
            this.transports = s,
            this.requests = {},
            this.connectPromise = this.connect(),
            this.requestChannel = new r.EventEmitter,
            this.nextID = a
        }
        return i.prototype.connect = function () {
            var s = this;
            return Promise.all(this.transports.map(function (a) {
                    return t(s, void 0, void 0, function () {
                        return n(this, function (l) {
                            switch (l.label) {
                            case 0:
                                return a.subscribe("error", this.handleError.bind(this)),
                                a.subscribe("notification", this.handleNotification.bind(this)),
                                [4, a.connect()];
                            case 1:
                                return l.sent(),
                                [2]
                            }
                        })
                    })
                }))
        },
        i.prototype.getPrimaryTransport = function () {
            return this.transports[0]
        },
        i.prototype.request = function (s, a, l) {
            return a === void 0 && (a = !1),
            t(this, void 0, void 0, function () {
                var c,
                u,
                f,
                p,
                m = this;
                return n(this, function (v) {
                    return c = this.nextID().toString(),
                    u = a ? null : c,
                    f = {
                        request: this.makeRequest(s.method, s.params || [], u),
                        internalID: c
                    },
                    this.batchStarted ? (p = new Promise(function (y, b) {
                            m.batch.push({
                                resolve: y,
                                reject: b,
                                request: f
                            })
                        }), [2, p]) : [2, this.getPrimaryTransport().sendData(f, l)]
                })
            })
        },
        i.prototype.close = function () {
            this.requestChannel.removeAllListeners(),
            this.transports.forEach(function (s) {
                s.unsubscribe(),
                s.close()
            })
        },
        i.prototype.startBatch = function () {
            this.batchStarted = !0
        },
        i.prototype.stopBatch = function () {
            if (this.batchStarted === !1)
                throw new Error("cannot end that which has never started");
            if (this.batch.length === 0) {
                this.batchStarted = !1;
                return
            }
            this.getPrimaryTransport().sendData(this.batch),
            this.batch = [],
            this.batchStarted = !1
        },
        i.prototype.makeRequest = function (s, a, l) {
            return l ? {
                jsonrpc: "2.0",
                id: l,
                method: s,
                params: a
            }
             : {
                jsonrpc: "2.0",
                method: s,
                params: a
            }
        },
        i.prototype.handleError = function (s) {
            this.requestChannel.emit("error", s)
        },
        i.prototype.handleNotification = function (s) {
            this.requestChannel.emit("notification", s)
        },
        i
    }
    ();
    e.default = o
})(_6);
var xC = {}, fc = {}, aw = {}, Zu = {};
(function (e) {
    var t = Mt && Mt.__extends || function () {
        var r = function (o, i) {
            return r = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function (s, a) {
                s.__proto__ = a
            }
             || function (s, a) {
                for (var l in a)
                    a.hasOwnProperty(l) && (s[l] = a[l])
            },
            r(o, i)
        };
        return function (o, i) {
            r(o, i);
            function s() {
                this.constructor = o
            }
            o.prototype = i === null ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }
    ();
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.convertJSONToRPCError = e.JSONRPCError = e.ERR_UNKNOWN = e.ERR_MISSIING_ID = e.ERR_TIMEOUT = void 0,
    e.ERR_TIMEOUT = 7777,
    e.ERR_MISSIING_ID = 7878,
    e.ERR_UNKNOWN = 7979;
    var n = function (r) {
        t(o, r);
        function o(i, s, a) {
            var l = this.constructor,
            c = r.call(this, i) || this;
            return c.message = i,
            c.code = s,
            c.data = a,
            Object.setPrototypeOf(c, l.prototype),
            c
        }
        return o
    }
    (Error);
    e.JSONRPCError = n,
    e.convertJSONToRPCError = function (r) {
        if (r.error) {
            var o = r.error,
            i = o.message,
            s = o.code,
            a = o.data;
            return new n(i, s, a)
        }
        return new n("Unknown error", e.ERR_UNKNOWN, r)
    }
})(Zu);
Object.defineProperty(aw, "__esModule", {
    value: !0
});
aw.TransportRequestManager = void 0;
var Dse = um, bd = Zu, Nse = function () {
    function e() {
        this.pendingRequest = {},
        this.pendingBatchRequest = {},
        this.transportEventChannel = new Dse.EventEmitter
    }
    return e.prototype.addRequest = function (t, n) {
        return this.transportEventChannel.emit("pending", t),
        t instanceof Array ? (this.addBatchReq(t, n), Promise.resolve()) : this.addReq(t.internalID, n)
    },
    e.prototype.settlePendingRequest = function (t, n) {
        var r = this;
        t.forEach(function (o) {
            var i = r.pendingRequest[o.internalID];
            if (delete r.pendingBatchRequest[o.internalID], i !== void 0) {
                if (n) {
                    i.reject(n);
                    return
                }
                i.resolve(),
                (o.request.id === null || o.request.id === void 0) && delete r.pendingRequest[o.internalID]
            }
        })
    },
    e.prototype.isPendingRequest = function (t) {
        return this.pendingRequest.hasOwnProperty(t)
    },
    e.prototype.resolveResponse = function (t, n) {
        n === void 0 && (n = !0);
        var r = t;
        try {
            return r = JSON.parse(t),
            this.checkJSONRPC(r) === !1 ? void 0 : r instanceof Array ? this.resolveBatch(r, n) : this.resolveRes(r, n)
        } catch {
            var o = new bd.JSONRPCError("Bad response format", bd.ERR_UNKNOWN, t);
            return n && this.transportEventChannel.emit("error", o),
            o
        }
    },
    e.prototype.addBatchReq = function (t, n) {
        var r = this;
        return t.forEach(function (o) {
            var i = o.resolve,
            s = o.reject,
            a = o.request.internalID;
            r.pendingBatchRequest[a] = !0,
            r.pendingRequest[a] = {
                resolve: i,
                reject: s
            }
        }),
        Promise.resolve()
    },
    e.prototype.addReq = function (t, n) {
        var r = this;
        return new Promise(function (o, i) {
            n !== null && n && r.setRequestTimeout(t, n, i),
            r.pendingRequest[t] = {
                resolve: o,
                reject: i
            }
        })
    },
    e.prototype.checkJSONRPC = function (t) {
        var n = [t];
        return t instanceof Array && (n = t),
        n.every(function (r) {
            return r.result !== void 0 || r.error !== void 0 || r.method !== void 0
        })
    },
    e.prototype.processResult = function (t, n) {
        if (t.error) {
            var r = bd.convertJSONToRPCError(t);
            n.reject(r);
            return
        }
        n.resolve(t.result)
    },
    e.prototype.resolveBatch = function (t, n) {
        var r = this,
        o = t.map(function (s) {
            return r.resolveRes(s, n)
        }),
        i = o.filter(function (s) {
            return s
        });
        if (i.length > 0)
            return i[0]
    },
    e.prototype.resolveRes = function (t, n) {
        var r = t.id,
        o = t.error,
        i = this.pendingRequest[r];
        if (i) {
            delete this.pendingRequest[r],
            this.processResult(t, i),
            this.transportEventChannel.emit("response", t);
            return
        }
        if (r === void 0 && o === void 0) {
            this.transportEventChannel.emit("notification", t);
            return
        }
        var s;
        return o && (s = bd.convertJSONToRPCError(t)),
        n && o && s && this.transportEventChannel.emit("error", s),
        s
    },
    e.prototype.setRequestTimeout = function (t, n, r) {
        var o = this;
        setTimeout(function () {
            delete o.pendingRequest[t],
            r(new bd.JSONRPCError("Request timeout request took longer than " + n + " ms to resolve", bd.ERR_TIMEOUT))
        }, n)
    },
    e
}
();
aw.TransportRequestManager = Nse;
Object.defineProperty(fc, "__esModule", {
    value: !0
});
var E6 = fc.Transport = void 0, Rse = aw, Lse = function () {
    function e() {
        this.transportRequestManager = new Rse.TransportRequestManager,
        this.transportRequestManager.transportEventChannel.on("error", function () {})
    }
    return e.prototype.subscribe = function (t, n) {
        this.transportRequestManager.transportEventChannel.addListener(t, n)
    },
    e.prototype.unsubscribe = function (t, n) {
        if (!t)
            return this.transportRequestManager.transportEventChannel.removeAllListeners();
        t && n && this.transportRequestManager.transportEventChannel.removeListener(t, n)
    },
    e.prototype.parseData = function (t) {
        return t instanceof Array ? t.map(function (n) {
            return n.request.request
        }) : t.request
    },
    e
}
();
E6 = fc.Transport = Lse;
var nh = {};
(function (e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.getNotifications = e.getBatchRequests = e.isNotification = void 0,
    e.isNotification = function (t) {
        return t.request.id === void 0 || t.request.id === null
    },
    e.getBatchRequests = function (t) {
        return t instanceof Array ? t.filter(function (n) {
            var r = n.request.request.id;
            return r != null
        }).map(function (n) {
            return n.request
        }) : []
    },
    e.getNotifications = function (t) {
        return t instanceof Array ? t.filter(function (n) {
            return e.isNotification(n.request)
        }).map(function (n) {
            return n.request
        }) : e.isNotification(t) ? [t] : []
    }
})(nh);
var Bse = Mt && Mt.__extends || function () {
    var e = function (t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function (r, o) {
            r.__proto__ = o
        }
         || function (r, o) {
            for (var i in o)
                o.hasOwnProperty(i) && (r[i] = o[i])
        },
        e(t, n)
    };
    return function (t, n) {
        e(t, n);
        function r() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}
();
Object.defineProperty(xC, "__esModule", {
    value: !0
});
var Vse = fc, Fse = nh, J3 = Zu, jse = function (e) {
    Bse(t, e);
    function t(n, r, o) {
        var i = e.call(this) || this;
        return i.connection = n,
        i.reqUri = r,
        i.resUri = o,
        i
    }
    return t.prototype.connect = function () {
        var n = this;
        return this.connection.on(this.resUri, function (r) {
            n.transportRequestManager.resolveResponse(r)
        }),
        Promise.resolve()
    },
    t.prototype.sendData = function (n, r) {
        r === void 0 && (r = null);
        var o = this.transportRequestManager.addRequest(n, r),
        i = Fse.getNotifications(n),
        s = this.parseData(n);
        try {
            return this.connection.emit(this.reqUri, s),
            this.transportRequestManager.settlePendingRequest(i),
            o
        } catch (l) {
            var a = new J3.JSONRPCError(l.message, J3.ERR_UNKNOWN, l);
            return this.transportRequestManager.settlePendingRequest(i, a),
            Promise.reject(a)
        }
    },
    t.prototype.close = function () {
        this.connection.removeAllListeners()
    },
    t
}
(Vse.Transport);
xC.default = jse;
var ig = {}, so = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof so < "u" && so, Vo = {
    searchParams: "URLSearchParams" in so,
    iterable: "Symbol" in so && "iterator" in Symbol,
    blob: "FileReader" in so && "Blob" in so && function () {
        try {
            return new Blob,
            !0
        } catch {
            return !1
        }
    }
    (),
    formData: "FormData" in so,
    arrayBuffer: "ArrayBuffer" in so
};
function Wse(e) {
    return e && DataView.prototype.isPrototypeOf(e)
}
if (Vo.arrayBuffer)
    var zse = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], Hse = ArrayBuffer.isView || function (e) {
        return e && zse.indexOf(Object.prototype.toString.call(e)) > -1
    };
function sg(e) {
    if (typeof e != "string" && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || e === "")
        throw new TypeError('Invalid character in header field name: "' + e + '"');
    return e.toLowerCase()
}
function SC(e) {
    return typeof e != "string" && (e = String(e)),
    e
}
function CC(e) {
    var t = {
        next: function () {
            var n = e.shift();
            return {
                done: n === void 0,
                value: n
            }
        }
    };
    return Vo.iterable && (t[Symbol.iterator] = function () {
        return t
    }),
    t
}
function Rr(e) {
    this.map = {},
    e instanceof Rr ? e.forEach(function (t, n) {
        this.append(n, t)
    }, this) : Array.isArray(e) ? e.forEach(function (t) {
        this.append(t[0], t[1])
    }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) {
        this.append(t, e[t])
    }, this)
}
Rr.prototype.append = function (e, t) {
    e = sg(e),
    t = SC(t);
    var n = this.map[e];
    this.map[e] = n ? n + ", " + t : t
};
Rr.prototype.delete = function (e) {
    delete this.map[sg(e)]
};
Rr.prototype.get = function (e) {
    return e = sg(e),
    this.has(e) ? this.map[e] : null
};
Rr.prototype.has = function (e) {
    return this.map.hasOwnProperty(sg(e))
};
Rr.prototype.set = function (e, t) {
    this.map[sg(e)] = SC(t)
};
Rr.prototype.forEach = function (e, t) {
    for (var n in this.map)
        this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this)
};
Rr.prototype.keys = function () {
    var e = [];
    return this.forEach(function (t, n) {
        e.push(n)
    }),
    CC(e)
};
Rr.prototype.values = function () {
    var e = [];
    return this.forEach(function (t) {
        e.push(t)
    }),
    CC(e)
};
Rr.prototype.entries = function () {
    var e = [];
    return this.forEach(function (t, n) {
        e.push([n, t])
    }),
    CC(e)
};
Vo.iterable && (Rr.prototype[Symbol.iterator] = Rr.prototype.entries);
function D_(e) {
    if (e.bodyUsed)
        return Promise.reject(new TypeError("Already read"));
    e.bodyUsed = !0
}
function O6(e) {
    return new Promise(function (t, n) {
        e.onload = function () {
            t(e.result)
        },
        e.onerror = function () {
            n(e.error)
        }
    })
}
function Use(e) {
    var t = new FileReader,
    n = O6(t);
    return t.readAsArrayBuffer(e),
    n
}
function qse(e) {
    var t = new FileReader,
    n = O6(t);
    return t.readAsText(e),
    n
}
function Yse(e) {
    for (var t = new Uint8Array(e), n = new Array(t.length), r = 0; r < t.length; r++)
        n[r] = String.fromCharCode(t[r]);
    return n.join("")
}
function Z3(e) {
    if (e.slice)
        return e.slice(0);
    var t = new Uint8Array(e.byteLength);
    return t.set(new Uint8Array(e)),
    t.buffer
}
function $6() {
    return this.bodyUsed = !1,
    this._initBody = function (e) {
        this.bodyUsed = this.bodyUsed,
        this._bodyInit = e,
        e ? typeof e == "string" ? this._bodyText = e : Vo.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : Vo.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : Vo.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : Vo.arrayBuffer && Vo.blob && Wse(e) ? (this._bodyArrayBuffer = Z3(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Vo.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || Hse(e)) ? this._bodyArrayBuffer = Z3(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "",
        this.headers.get("content-type") || (typeof e == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Vo.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
    },
    Vo.blob && (this.blob = function () {
        var e = D_(this);
        if (e)
            return e;
        if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
        if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
        return Promise.resolve(new Blob([this._bodyText]))
    }, this.arrayBuffer = function () {
        if (this._bodyArrayBuffer) {
            var e = D_(this);
            return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
        } else
            return this.blob().then(Use)
    }),
    this.text = function () {
        var e = D_(this);
        if (e)
            return e;
        if (this._bodyBlob)
            return qse(this._bodyBlob);
        if (this._bodyArrayBuffer)
            return Promise.resolve(Yse(this._bodyArrayBuffer));
        if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText)
    },
    Vo.formData && (this.formData = function () {
        return this.text().then(Xse)
    }),
    this.json = function () {
        return this.text().then(JSON.parse)
    },
    this
}
var Kse = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
function Gse(e) {
    var t = e.toUpperCase();
    return Kse.indexOf(t) > -1 ? t : e
}
function Mu(e, t) {
    if (!(this instanceof Mu))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    t = t || {};
    var n = t.body;
    if (e instanceof Mu) {
        if (e.bodyUsed)
            throw new TypeError("Already read");
        this.url = e.url,
        this.credentials = e.credentials,
        t.headers || (this.headers = new Rr(e.headers)),
        this.method = e.method,
        this.mode = e.mode,
        this.signal = e.signal,
        !n && e._bodyInit != null && (n = e._bodyInit, e.bodyUsed = !0)
    } else
        this.url = String(e);
    if (this.credentials = t.credentials || this.credentials || "same-origin", (t.headers || !this.headers) && (this.headers = new Rr(t.headers)), this.method = Gse(t.method || this.method || "GET"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && n)
        throw new TypeError("Body not allowed for GET or HEAD requests");
    if (this._initBody(n), (this.method === "GET" || this.method === "HEAD") && (t.cache === "no-store" || t.cache === "no-cache")) {
        var r = /([?&])_=[^&]*/;
        if (r.test(this.url))
            this.url = this.url.replace(r, "$1_=" + new Date().getTime());
        else {
            var o = /\?/;
            this.url += (o.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
        }
    }
}
Mu.prototype.clone = function () {
    return new Mu(this, {
        body: this._bodyInit
    })
};
function Xse(e) {
    var t = new FormData;
    return e.trim().split("&").forEach(function (n) {
        if (n) {
            var r = n.split("="),
            o = r.shift().replace(/\+/g, " "),
            i = r.join("=").replace(/\+/g, " ");
            t.append(decodeURIComponent(o), decodeURIComponent(i))
        }
    }),
    t
}
function Jse(e) {
    var t = new Rr,
    n = e.replace(/\r?\n[\t ]+/g, " ");
    return n.split("\r").map(function (r) {
        return r.indexOf(`
`) === 0 ? r.substr(1, r.length) : r
    }).forEach(function (r) {
        var o = r.split(":"),
        i = o.shift().trim();
        if (i) {
            var s = o.join(":").trim();
            t.append(i, s)
        }
    }),
    t
}
$6.call(Mu.prototype);
function ua(e, t) {
    if (!(this instanceof ua))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    t || (t = {}),
    this.type = "default",
    this.status = t.status === void 0 ? 200 : t.status,
    this.ok = this.status >= 200 && this.status < 300,
    this.statusText = t.statusText === void 0 ? "" : "" + t.statusText,
    this.headers = new Rr(t.headers),
    this.url = t.url || "",
    this._initBody(e)
}
$6.call(ua.prototype);
ua.prototype.clone = function () {
    return new ua(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Rr(this.headers),
        url: this.url
    })
};
ua.error = function () {
    var e = new ua(null, {
        status: 0,
        statusText: ""
    });
    return e.type = "error",
    e
};
var Zse = [301, 302, 303, 307, 308];
ua.redirect = function (e, t) {
    if (Zse.indexOf(t) === -1)
        throw new RangeError("Invalid status code");
    return new ua(null, {
        status: t,
        headers: {
            location: e
        }
    })
};
var Hc = so.DOMException;
try {
    new Hc
} catch {
    Hc = function (t, n) {
        this.message = t,
        this.name = n;
        var r = Error(t);
        this.stack = r.stack
    },
    Hc.prototype = Object.create(Error.prototype),
    Hc.prototype.constructor = Hc
}
function A6(e, t) {
    return new Promise(function (n, r) {
        var o = new Mu(e, t);
        if (o.signal && o.signal.aborted)
            return r(new Hc("Aborted", "AbortError"));
        var i = new XMLHttpRequest;
        function s() {
            i.abort()
        }
        i.onload = function () {
            var l = {
                status: i.status,
                statusText: i.statusText,
                headers: Jse(i.getAllResponseHeaders() || "")
            };
            l.url = "responseURL" in i ? i.responseURL : l.headers.get("X-Request-URL");
            var c = "response" in i ? i.response : i.responseText;
            setTimeout(function () {
                n(new ua(c, l))
            }, 0)
        },
        i.onerror = function () {
            setTimeout(function () {
                r(new TypeError("Network request failed"))
            }, 0)
        },
        i.ontimeout = function () {
            setTimeout(function () {
                r(new TypeError("Network request failed"))
            }, 0)
        },
        i.onabort = function () {
            setTimeout(function () {
                r(new Hc("Aborted", "AbortError"))
            }, 0)
        };
        function a(l) {
            try {
                return l === "" && so.location.href ? so.location.href : l
            } catch {
                return l
            }
        }
        i.open(o.method, a(o.url), !0),
        o.credentials === "include" ? i.withCredentials = !0 : o.credentials === "omit" && (i.withCredentials = !1),
        "responseType" in i && (Vo.blob ? i.responseType = "blob" : Vo.arrayBuffer && o.headers.get("Content-Type") && o.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (i.responseType = "arraybuffer")),
        t && typeof t.headers == "object" && !(t.headers instanceof Rr) ? Object.getOwnPropertyNames(t.headers).forEach(function (l) {
            i.setRequestHeader(l, SC(t.headers[l]))
        }) : o.headers.forEach(function (l, c) {
            i.setRequestHeader(c, l)
        }),
        o.signal && (o.signal.addEventListener("abort", s), i.onreadystatechange = function () {
            i.readyState === 4 && o.signal.removeEventListener("abort", s)
        }),
        i.send(typeof o._bodyInit > "u" ? null : o._bodyInit)
    })
}
A6.polyfill = !0;
so.fetch || (so.fetch = A6, so.Headers = Rr, so.Request = Mu, so.Response = ua);
var Qse = self.fetch.bind(self), eae = Mt && Mt.__extends || function () {
    var e = function (t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function (r, o) {
            r.__proto__ = o
        }
         || function (r, o) {
            for (var i in o)
                o.hasOwnProperty(i) && (r[i] = o[i])
        },
        e(t, n)
    };
    return function (t, n) {
        e(t, n);
        function r() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}
(), tae = Mt && Mt.__awaiter || function (e, t, n, r) {
    function o(i) {
        return i instanceof n ? i : new n(function (s) {
            s(i)
        })
    }
    return new(n || (n = Promise))(function (i, s) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                s(f)
            }
        }
        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                s(f)
            }
        }
        function c(u) {
            u.done ? i(u.value) : o(u.value).then(a, l)
        }
        c((r = r.apply(e, t || [])).next())
    })
}, nae = Mt && Mt.__generator || function (e, t) {
    var n = {
        label: 0,
        sent: function () {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    },
    r,
    o,
    i,
    s;
    return s = {
        next: a(0),
        throw : a(1),
        return : a(2)
    },
    typeof Symbol == "function" && (s[Symbol.iterator] = function () {
        return this
    }),
    s;
    function a(c) {
        return function (u) {
            return l([c, u])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; n; )
            try {
                if (r = 1, o && (i = c[0] & 2 ? o.return : c[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, c[1])).done)
                    return i;
                switch (o = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++,
                    o = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(),
                    n.trys.pop();
                    continue;
                default:
                    if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < i[1]) {
                        n.label = i[1],
                        i = c;
                        break
                    }
                    if (i && n.label < i[2]) {
                        n.label = i[2],
                        n.ops.push(c);
                        break
                    }
                    i[2] && n.ops.pop(),
                    n.trys.pop();
                    continue
                }
                c = t.call(e, n)
            } catch (u) {
                c = [6, u],
                o = 0
            } finally {
            r = i = 0
        }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}, rae = Mt && Mt.__importDefault || function (e) {
    return e && e.__esModule ? e : {
    default:
        e
    }
};
Object.defineProperty(ig, "__esModule", {
    value: !0
});
ig.HTTPTransport = void 0;
var oae = rae(Qse), iae = fc, N_ = nh, Q3 = Zu, D6 = function (e) {
    eae(t, e);
    function t(n, r) {
        var o = e.call(this) || this;
        return o.onlyNotifications = function (i) {
            return i instanceof Array ? i.every(function (s) {
                return s.request.request.id === null || s.request.request.id === void 0
            }) : i.request.id === null || i.request.id === void 0
        },
        o.uri = n,
        o.credentials = r && r.credentials,
        o.headers = t.setupHeaders(r && r.headers),
        o.injectedFetcher = r?.fetcher,
        o
    }
    return t.prototype.connect = function () {
        return Promise.resolve()
    },
    t.prototype.sendData = function (n, r) {
        return r === void 0 && (r = null),
        tae(this, void 0, void 0, function () {
            var o,
            i,
            s,
            a,
            l,
            c,
            f,
            u,
            f;
            return nae(this, function (p) {
                switch (p.label) {
                case 0:
                    o = this.transportRequestManager.addRequest(n, r),
                    i = N_.getNotifications(n),
                    s = N_.getBatchRequests(n),
                    a = this.injectedFetcher || oae.default,
                    p.label = 1;
                case 1:
                    return p.trys.push([1, 4, , 5]),
                    [4, a(this.uri, {
                            method: "POST",
                            headers: this.headers,
                            body: JSON.stringify(this.parseData(n)),
                            credentials: this.credentials
                        })];
                case 2:
                    return l = p.sent(),
                    this.transportRequestManager.settlePendingRequest(i),
                    this.onlyNotifications(n) ? [2, Promise.resolve()] : [4, l.text()];
                case 3:
                    return c = p.sent(),
                    f = this.transportRequestManager.resolveResponse(c),
                    f ? (this.transportRequestManager.settlePendingRequest(s, f), [2, Promise.reject(f)]) : [3, 5];
                case 4:
                    return u = p.sent(),
                    f = new Q3.JSONRPCError(u.message, Q3.ERR_UNKNOWN, u),
                    this.transportRequestManager.settlePendingRequest(i, f),
                    this.transportRequestManager.settlePendingRequest(N_.getBatchRequests(n), f),
                    [2, Promise.reject(f)];
                case 5:
                    return [2, o]
                }
            })
        })
    },
    t.prototype.close = function () {},
    t.setupHeaders = function (n) {
        var r = new Headers(n);
        return r.set("Content-Type", "application/json"),
        r
    },
    t
}
(iae.Transport);
ig.HTTPTransport = D6;
ig.default = D6;
var IC = {}, Od = null;
typeof WebSocket < "u" ? Od = WebSocket : typeof MozWebSocket < "u" ? Od = MozWebSocket : typeof global < "u" ? Od = global.WebSocket || global.MozWebSocket : typeof window < "u" ? Od = window.WebSocket || window.MozWebSocket : typeof self < "u" && (Od = self.WebSocket || self.MozWebSocket);
const sae = Od, aae = Object.freeze(Object.defineProperty({
            __proto__: null,
        default:
            sae
        }, Symbol.toStringTag, {
            value: "Module"
        })), lae = b6(aae);
var cae = Mt && Mt.__extends || function () {
    var e = function (t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function (r, o) {
            r.__proto__ = o
        }
         || function (r, o) {
            for (var i in o)
                o.hasOwnProperty(i) && (r[i] = o[i])
        },
        e(t, n)
    };
    return function (t, n) {
        e(t, n);
        function r() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}
(), uae = Mt && Mt.__awaiter || function (e, t, n, r) {
    function o(i) {
        return i instanceof n ? i : new n(function (s) {
            s(i)
        })
    }
    return new(n || (n = Promise))(function (i, s) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                s(f)
            }
        }
        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                s(f)
            }
        }
        function c(u) {
            u.done ? i(u.value) : o(u.value).then(a, l)
        }
        c((r = r.apply(e, t || [])).next())
    })
}, dae = Mt && Mt.__generator || function (e, t) {
    var n = {
        label: 0,
        sent: function () {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    },
    r,
    o,
    i,
    s;
    return s = {
        next: a(0),
        throw : a(1),
        return : a(2)
    },
    typeof Symbol == "function" && (s[Symbol.iterator] = function () {
        return this
    }),
    s;
    function a(c) {
        return function (u) {
            return l([c, u])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; n; )
            try {
                if (r = 1, o && (i = c[0] & 2 ? o.return : c[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, c[1])).done)
                    return i;
                switch (o = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++,
                    o = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(),
                    n.trys.pop();
                    continue;
                default:
                    if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < i[1]) {
                        n.label = i[1],
                        i = c;
                        break
                    }
                    if (i && n.label < i[2]) {
                        n.label = i[2],
                        n.ops.push(c);
                        break
                    }
                    i[2] && n.ops.pop(),
                    n.trys.pop();
                    continue
                }
                c = t.call(e, n)
            } catch (u) {
                c = [6, u],
                o = 0
            } finally {
            r = i = 0
        }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}, fae = Mt && Mt.__importDefault || function (e) {
    return e && e.__esModule ? e : {
    default:
        e
    }
};
Object.defineProperty(IC, "__esModule", {
    value: !0
});
var hae = fae(lae), pae = fc, eO = nh, tO = Zu, mae = function (e) {
    cae(t, e);
    function t(n) {
        var r = e.call(this) || this;
        return r.uri = n,
        r.connection = new hae.default(n),
        r
    }
    return t.prototype.connect = function () {
        var n = this;
        return new Promise(function (r, o) {
            var i = function () {
                n.connection.removeEventListener("open", i),
                r()
            };
            n.connection.addEventListener("open", i),
            n.connection.addEventListener("message", function (s) {
                var a = s.data;
                n.transportRequestManager.resolveResponse(a)
            })
        })
    },
    t.prototype.sendData = function (n, r) {
        return r === void 0 && (r = 5e3),
        uae(this, void 0, void 0, function () {
            var o,
            i,
            s;
            return dae(this, function (a) {
                o = this.transportRequestManager.addRequest(n, r),
                i = eO.getNotifications(n);
                try {
                    this.connection.send(JSON.stringify(this.parseData(n))),
                    this.transportRequestManager.settlePendingRequest(i)
                } catch (l) {
                    s = new tO.JSONRPCError(l.message, tO.ERR_UNKNOWN, l),
                    this.transportRequestManager.settlePendingRequest(i, s),
                    this.transportRequestManager.settlePendingRequest(eO.getBatchRequests(n), s),
                    o = Promise.reject(s)
                }
                return [2, o]
            })
        })
    },
    t.prototype.close = function () {
        this.connection.close()
    },
    t
}
(pae.Transport);
IC.default = mae;
var TC = {}, gae = Mt && Mt.__extends || function () {
    var e = function (t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function (r, o) {
            r.__proto__ = o
        }
         || function (r, o) {
            for (var i in o)
                o.hasOwnProperty(i) && (r[i] = o[i])
        },
        e(t, n)
    };
    return function (t, n) {
        e(t, n);
        function r() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}
(), nO = Mt && Mt.__awaiter || function (e, t, n, r) {
    function o(i) {
        return i instanceof n ? i : new n(function (s) {
            s(i)
        })
    }
    return new(n || (n = Promise))(function (i, s) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                s(f)
            }
        }
        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                s(f)
            }
        }
        function c(u) {
            u.done ? i(u.value) : o(u.value).then(a, l)
        }
        c((r = r.apply(e, t || [])).next())
    })
}, rO = Mt && Mt.__generator || function (e, t) {
    var n = {
        label: 0,
        sent: function () {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    },
    r,
    o,
    i,
    s;
    return s = {
        next: a(0),
        throw : a(1),
        return : a(2)
    },
    typeof Symbol == "function" && (s[Symbol.iterator] = function () {
        return this
    }),
    s;
    function a(c) {
        return function (u) {
            return l([c, u])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; n; )
            try {
                if (r = 1, o && (i = c[0] & 2 ? o.return : c[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, c[1])).done)
                    return i;
                switch (o = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++,
                    o = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(),
                    n.trys.pop();
                    continue;
                default:
                    if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < i[1]) {
                        n.label = i[1],
                        i = c;
                        break
                    }
                    if (i && n.label < i[2]) {
                        n.label = i[2],
                        n.ops.push(c);
                        break
                    }
                    i[2] && n.ops.pop(),
                    n.trys.pop();
                    continue
                }
                c = t.call(e, n)
            } catch (u) {
                c = [6, u],
                o = 0
            } finally {
            r = i = 0
        }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
};
Object.defineProperty(TC, "__esModule", {
    value: !0
});
var vae = fc, yae = nh, wae = function (e) {
    var t = 400,
    n = window.screen.height,
    r = 0,
    o = 0;
    return window.open(e, "inspector:popup", "left=" + r + ",top=" + o + ",width=" + t + ",height=" + n + ",resizable,scrollbars=yes,status=1")
}, bae = function (e) {
    gae(t, e);
    function t(n) {
        var r = e.call(this) || this;
        return r.messageHandler = function (o) {
            r.transportRequestManager.resolveResponse(JSON.stringify(o.data))
        },
        r.uri = n,
        r.postMessageID = "post-message-transport-" + Math.random(),
        r
    }
    return t.prototype.createWindow = function (n) {
        return new Promise(function (r, o) {
            var i;
            i = wae(n),
            setTimeout(function () {
                r(i)
            }, 3e3)
        })
    },
    t.prototype.connect = function () {
        var n = this,
        r = /^(http|https):\/\/.*$/;
        return new Promise(function (o, i) {
            return nO(n, void 0, void 0, function () {
                var s;
                return rO(this, function (a) {
                    switch (a.label) {
                    case 0:
                        return r.test(this.uri) || i(new Error("Bad URI")),
                        s = this,
                        [4, this.createWindow(this.uri)];
                    case 1:
                        return s.frame = a.sent(),
                        window.addEventListener("message", this.messageHandler),
                        o(),
                        [2]
                    }
                })
            })
        })
    },
    t.prototype.sendData = function (n, r) {
        return nO(this, void 0, void 0, function () {
            var o,
            i;
            return rO(this, function (s) {
                return o = this.transportRequestManager.addRequest(n, null),
                i = yae.getNotifications(n),
                this.frame && (this.frame.postMessage(n.request, this.uri), this.transportRequestManager.settlePendingRequest(i)),
                [2, o]
            })
        })
    },
    t.prototype.close = function () {
        this.frame && (window.removeEventListener("message", this.messageHandler), this.frame.close())
    },
    t
}
(vae.Transport);
TC.default = bae;
var MC = {}, _ae = Mt && Mt.__extends || function () {
    var e = function (t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function (r, o) {
            r.__proto__ = o
        }
         || function (r, o) {
            for (var i in o)
                o.hasOwnProperty(i) && (r[i] = o[i])
        },
        e(t, n)
    };
    return function (t, n) {
        e(t, n);
        function r() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}
(), oO = Mt && Mt.__awaiter || function (e, t, n, r) {
    function o(i) {
        return i instanceof n ? i : new n(function (s) {
            s(i)
        })
    }
    return new(n || (n = Promise))(function (i, s) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                s(f)
            }
        }
        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                s(f)
            }
        }
        function c(u) {
            u.done ? i(u.value) : o(u.value).then(a, l)
        }
        c((r = r.apply(e, t || [])).next())
    })
}, iO = Mt && Mt.__generator || function (e, t) {
    var n = {
        label: 0,
        sent: function () {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    },
    r,
    o,
    i,
    s;
    return s = {
        next: a(0),
        throw : a(1),
        return : a(2)
    },
    typeof Symbol == "function" && (s[Symbol.iterator] = function () {
        return this
    }),
    s;
    function a(c) {
        return function (u) {
            return l([c, u])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; n; )
            try {
                if (r = 1, o && (i = c[0] & 2 ? o.return : c[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, c[1])).done)
                    return i;
                switch (o = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++,
                    o = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(),
                    n.trys.pop();
                    continue;
                default:
                    if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < i[1]) {
                        n.label = i[1],
                        i = c;
                        break
                    }
                    if (i && n.label < i[2]) {
                        n.label = i[2],
                        n.ops.push(c);
                        break
                    }
                    i[2] && n.ops.pop(),
                    n.trys.pop();
                    continue
                }
                c = t.call(e, n)
            } catch (u) {
                c = [6, u],
                o = 0
            } finally {
            r = i = 0
        }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
};
Object.defineProperty(MC, "__esModule", {
    value: !0
});
var kae = fc, xae = nh, Sae = function (e) {
    _ae(t, e);
    function t(n) {
        var r = e.call(this) || this;
        return r.messageHandler = function (o) {
            r.transportRequestManager.resolveResponse(JSON.stringify(o.data))
        },
        r.uri = n,
        r.postMessageID = "post-message-transport-" + Math.random(),
        r
    }
    return t.prototype.createWindow = function (n) {
        var r = this;
        return new Promise(function (o, i) {
            var s,
            a = document.createElement("iframe");
            a.setAttribute("id", r.postMessageID),
            a.setAttribute("width", "0px"),
            a.setAttribute("height", "0px"),
            a.setAttribute("style", "visiblity:hidden;border:none;outline:none;"),
            a.addEventListener("load", function () {
                o(s)
            }),
            a.setAttribute("src", n),
            window.document.body.appendChild(a),
            s = a.contentWindow
        })
    },
    t.prototype.connect = function () {
        var n = this,
        r = /^(http|https):\/\/.*$/;
        return new Promise(function (o, i) {
            return oO(n, void 0, void 0, function () {
                var s;
                return iO(this, function (a) {
                    switch (a.label) {
                    case 0:
                        return r.test(this.uri) || i(new Error("Bad URI")),
                        s = this,
                        [4, this.createWindow(this.uri)];
                    case 1:
                        return s.frame = a.sent(),
                        window.addEventListener("message", this.messageHandler),
                        o(),
                        [2]
                    }
                })
            })
        })
    },
    t.prototype.sendData = function (n, r) {
        return oO(this, void 0, void 0, function () {
            var o,
            i;
            return iO(this, function (s) {
                return o = this.transportRequestManager.addRequest(n, null),
                i = xae.getNotifications(n),
                this.frame && (this.frame.postMessage(n.request, "*"), this.transportRequestManager.settlePendingRequest(i)),
                [2, o]
            })
        })
    },
    t.prototype.close = function () {
        var n = document.getElementById(this.postMessageID);
        n?.remove(),
        window.removeEventListener("message", this.messageHandler)
    },
    t
}
(kae.Transport);
MC.default = Sae;
var PC = {}, sO = Mt && Mt.__awaiter || function (e, t, n, r) {
    function o(i) {
        return i instanceof n ? i : new n(function (s) {
            s(i)
        })
    }
    return new(n || (n = Promise))(function (i, s) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                s(f)
            }
        }
        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                s(f)
            }
        }
        function c(u) {
            u.done ? i(u.value) : o(u.value).then(a, l)
        }
        c((r = r.apply(e, t || [])).next())
    })
}, aO = Mt && Mt.__generator || function (e, t) {
    var n = {
        label: 0,
        sent: function () {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    },
    r,
    o,
    i,
    s;
    return s = {
        next: a(0),
        throw : a(1),
        return : a(2)
    },
    typeof Symbol == "function" && (s[Symbol.iterator] = function () {
        return this
    }),
    s;
    function a(c) {
        return function (u) {
            return l([c, u])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; n; )
            try {
                if (r = 1, o && (i = c[0] & 2 ? o.return : c[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, c[1])).done)
                    return i;
                switch (o = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++,
                    o = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(),
                    n.trys.pop();
                    continue;
                default:
                    if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < i[1]) {
                        n.label = i[1],
                        i = c;
                        break
                    }
                    if (i && n.label < i[2]) {
                        n.label = i[2],
                        n.ops.push(c);
                        break
                    }
                    i[2] && n.ops.pop(),
                    n.trys.pop();
                    continue
                }
                c = t.call(e, n)
            } catch (u) {
                c = [6, u],
                o = 0
            } finally {
            r = i = 0
        }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
};
Object.defineProperty(PC, "__esModule", {
    value: !0
});
var Cae = function () {
    function e(t) {
        this.requestManager = t
    }
    return e.prototype.startBatch = function () {
        return this.requestManager.startBatch()
    },
    e.prototype.stopBatch = function () {
        return this.requestManager.stopBatch()
    },
    e.prototype.request = function (t, n) {
        return sO(this, void 0, void 0, function () {
            return aO(this, function (r) {
                switch (r.label) {
                case 0:
                    return this.requestManager.connectPromise ? [4, this.requestManager.connectPromise] : [3, 2];
                case 1:
                    r.sent(),
                    r.label = 2;
                case 2:
                    return [2, this.requestManager.request(t, !1, n)]
                }
            })
        })
    },
    e.prototype.notify = function (t) {
        return sO(this, void 0, void 0, function () {
            return aO(this, function (n) {
                switch (n.label) {
                case 0:
                    return this.requestManager.connectPromise ? [4, this.requestManager.connectPromise] : [3, 2];
                case 1:
                    n.sent(),
                    n.label = 2;
                case 2:
                    return [2, this.requestManager.request(t, !0, null)]
                }
            })
        })
    },
    e.prototype.onNotification = function (t) {
        this.requestManager.requestChannel.addListener("notification", t)
    },
    e.prototype.onError = function (t) {
        this.requestManager.requestChannel.addListener("error", t)
    },
    e.prototype.close = function () {
        this.requestManager.close()
    },
    e
}
();
PC.default = Cae;
(function (e) {
    var t = Mt && Mt.__importDefault || function (u) {
        return u && u.__esModule ? u : {
        default:
            u
        }
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.PostMessageIframeTransport = e.PostMessageWindowTransport = e.JSONRPCError = e.WebSocketTransport = e.EventEmitterTransport = e.HTTPTransport = e.RequestManager = e.Client = void 0;
    var n = t(_6);
    e.RequestManager = n.default;
    var r = t(xC);
    e.EventEmitterTransport = r.default;
    var o = t(ig);
    e.HTTPTransport = o.default;
    var i = t(IC);
    e.WebSocketTransport = i.default;
    var s = t(TC);
    e.PostMessageWindowTransport = s.default;
    var a = t(MC);
    e.PostMessageIframeTransport = a.default;
    var l = Zu;
    Object.defineProperty(e, "JSONRPCError", {
        enumerable: !0,
        get: function () {
            return l.JSONRPCError
        }
    });
    var c = t(PC);
    e.Client = c.default,
    e.default = c.default
})(Tu);
let Sv = null;
const ag = () => Sv || (Sv = {
        ...new kse,
        removeBy(t) {
            this.toasts.value = this.toasts.value.filter(n => !t(n))
        }
    }, Sv), lO = "Argument must be a JSON serialized event object", Fk = "CompositeEvent", Pu = new Map, Iae = e => {
    try {
        return {
            isValid: !0,
            response: JSON.parse(e)
        }
    } catch (t) {
        return {
            isValid: !1,
            response: {
                message: "Server event could not be parsed",
                error: t
            }
        }
    }
}, jk = e => e.includes(":"), N6 = e => e.split(":"), Tae = e => {
    const t = N6(e),
    n = i => Boolean(Pu.get(i)),
    r = i => typeof Pu.get(i) == "function";
    return n(Fk) && r(Fk) && t.every(i => n(i) && r(i))
}, Mae = e => {
    if (!e.isValid)
        return e;
    const {
        eventType: t
    } = e.response,
    n = jk(t) ? Tae(t) : Boolean(Pu.get(t)) && typeof Pu.get(t) == "function",
    r = n ? e.response : {
        message: `Method handler for "${t}" not found`
    };
    return {
        isValid: n,
        response: r
    }
}, Pae = e => {
    const t = Iae(e);
    return Mae(t)
}, R6 = (e, t) => {
    Pu.set(e, t)
}, L6 = function (e) {
    if (typeof e != "string")
        throw consola.error(lO), new TypeError(lO);
    consola.log("server event", e);
    const {
        isValid: t,
        response: n
    } = Pae(e);
    if (!t)
        throw n;
    const {
        eventType: r,
        payload: o
    } = n;
    try {
        const i = jk(r) ? Fk : r,
        s = jk(r) ? {
            events: N6(r),
            params: o.events,
            eventHandlers: Pu
        }
         : o;
        Pu.get(i)(s)
    } catch (i) {
        consola.error("Server event handler error", i)
    }
};
class Eae extends E6 {
    rpcActionId;
    constructor(t) {
        super(),
        this.rpcActionId = t
    }
    connect() {
        return Promise.resolve()
    }
    async sendData(t, n = null) {
        const r = this.transportRequestManager.addRequest(t, n);
        try {
            const o = await window.EquoCommService.send(this.rpcActionId, JSON.stringify(this.parseData(t))),
            i = this.transportRequestManager.resolveResponse(o);
            if (i)
                return Promise.reject(i)
        } catch (o) {
            const i = new Tu.JSONRPCError(o.message, Zu.ERR_UNKNOWN, o);
            return Promise.reject(i)
        }
        return r
    }
    close() {}
}
const Oae = 5e3;
class $ae extends Tu.WebSocketTransport {
    sendData(t, n = Oae) {
        const r = super.sendData(t, n);
        return r.then(o => {
            if (Array.isArray(t)) {
                consola.log({
                    requests: t.map(({
                            request: i
                        }) => i),
                    response: o
                });
                return
            }
            consola.log({
                request: t.request,
                response: o
            })
        }).catch(o => {
            throw consola.error(o.data),
            o
        }),
        r
    }
}
let dm;
const R_ = ag(), Aae = () => {
    if (!window.EquoCommService) {
        const i = "Could not access EquoComm service. Aborting";
        return consola.error(i),
        Promise.reject(new Error(i))
    }
    const e = "org.knime.ui.java.jsonrpc",
    t = "org.knime.ui.java.event";
    if (window.EquoCommService.on(t, i => L6(i), i => consola.error(i)), dm)
        return Promise.resolve();
    const n = new Eae(e),
    r = new Tu.RequestManager([n]);
    return dm = new Tu.Client(r),
    Promise.resolve()
}, Dae = e => {
    e.addEventListener("message", t => {
        const {
            data: n
        } = t;
        if (typeof n == "string")
            try {
                JSON.parse(n).eventType && L6(n)
            } catch {
                consola.log(n)
            }
    })
}, Nae = (e, t) => {
    const n = "__CONNECTION_LOST",
    r = (i, s) => {
        t.dispatch("application/updateGlobalLoader", {
            loading: !0,
            config: {
                displayMode: "transparent"
            }
        }),
        R_.show({
            id: n,
            headline: i,
            message: s,
            type: "error",
            autoRemove: !1
        })
    },
    o = () => {
        t.dispatch("application/updateGlobalLoader", {
            loading: !1
        }),
        R_.removeBy(i => (i.id ?? "").startsWith(n)),
        R_.show({
            type: "success",
            headline: "Connection restored"
        })
    };
    e.addEventListener("close", i => {
        consola.error("Websocket closed: ", i);
        const s = i.reason?.toLowerCase() === "proxy close";
        r(s ? "Session expired" : "Connection lost", s ? "Refresh the page to reactivate the session" : "Server is unreachable")
    }),
    window.addEventListener("offline", () => {
        r("Connection lost", "Please, check your internet connection and try refreshing the page")
    }),
    window.addEventListener("online", () => {
        o()
    })
}, Rae = e => {
    let t;
    const n = () => {
        t = window.setInterval(() => {
            consola.trace("Sending Heartbeat to Websocket at: ", new Date),
            e.send("")
        }, 3e4)
    };
    e.addEventListener("open", () => {
        n()
    }),
    e.addEventListener("close", () => {
        t && clearInterval(t)
    })
}, Lae = (e, t) => new Promise((n, r) => {
    try {
        if (!e) {
            r(new Error("Missing connection info"));
            return
        }
        if (dm) {
            n("SUCCESS");
            return
        }
        const o = new $ae(e.url),
        i = o.connection;
        Rae(i),
        Dae(i),
        Nae(i, t);
        const s = new Tu.RequestManager([o]);
        dm = new Tu.Client(s),
        n("SUCCESS")
    } catch (o) {
        consola.error(o),
        r(o)
    }
}), Bae = () => dm, Vae = async(e, t, n) => {
    try {
        return await(e === "DESKTOP" ? Aae() : Lae(t, n)),
        Promise.resolve()
    } catch (r) {
        return Promise.reject(r)
    }
}, Fae = {
    jsonrpc: "2.0",
    id: 0
}, jae = e => ({
    async call(n, r) {
        try {
            return await Bae().request({
                ...Fae,
                method: n,
                params: r
            })
        } catch (o) {
            throw consola.error("Error making RPC call", o),
            o
        }
    },
    registerEventHandlers(n) {
        Object.entries(n).forEach(([r, o]) => {
            R6(r, o)
        })
    }
});
var cO;
(e => {
    (t => {
        t.True = "true",
        t.ResetRequired = "resetRequired",
        t.False = "false"
    })(e.CanExpandEnum || (e.CanExpandEnum = {})),
    (t => {
        t.True = "true",
        t.ResetRequired = "resetRequired",
        t.False = "false"
    })(e.CanCollapseEnum || (e.CanCollapseEnum = {}))
})(cO || (cO = {}));
var uO;
(e => {
    (t => {
        t.Left = "left",
        t.Center = "center",
        t.Right = "right"
    })(e.TextAlignEnum || (e.TextAlignEnum = {}))
})(uO || (uO = {}));
var dO;
(e => {
    (t => {
        t.Metanode = "metanode",
        t.Component = "component"
    })(e.ContainerTypeEnum || (e.ContainerTypeEnum = {}))
})(dO || (dO = {}));
var fO;
(e => {
    (t => {
        t.CollapseResult = "collapse_result",
        t.ExpandResult = "expand_result",
        t.ConvertContainerResult = "convert_container_result",
        t.CopyResult = "copy_result",
        t.PasteResult = "paste_result",
        t.AddNodeResult = "add_node_result",
        t.AddPortResult = "add_port_result",
        t.AddAnnotationResult = "add_annotation_result",
        t.UpdateLinkedComponentsResult = "update_linked_components_result"
    })(e.KindEnum || (e.KindEnum = {}))
})(fO || (fO = {}));
var hO;
(e => {
    (t => {
        t.Source = "Source",
        t.Sink = "Sink",
        t.Learner = "Learner",
        t.Predictor = "Predictor",
        t.Manipulator = "Manipulator",
        t.Visualizer = "Visualizer",
        t.Other = "Other"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(hO || (hO = {}));
var pO;
(e => {
    (t => {
        t.Streaming = "streaming",
        t.Other = "other"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(pO || (pO = {}));
var mO;
(e => {
    (t => {
        t.RUNNING = "RUNNING",
        t.PAUSED = "PAUSED",
        t.FINISHED = "FINISHED"
    })(e.StatusEnum || (e.StatusEnum = {}))
})(mO || (mO = {}));
var j0;
(e => {
    (t => {
        t.IDLE = "IDLE",
        t.CONFIGURED = "CONFIGURED",
        t.EXECUTED = "EXECUTED",
        t.EXECUTING = "EXECUTING",
        t.QUEUED = "QUEUED",
        t.HALTED = "HALTED"
    })(e.NodeStateEnum || (e.NodeStateEnum = {}))
})(j0 || (j0 = {}));
var gO;
(e => {
    (t => {
        t.IDLE = "IDLE",
        t.EXECUTING = "EXECUTING",
        t.EXECUTED = "EXECUTED"
    })(e.ExecutionStateEnum || (e.ExecutionStateEnum = {}))
})(gO || (gO = {}));
var vO;
(e => {
    (t => {
        t.Source = "Source",
        t.Sink = "Sink",
        t.Learner = "Learner",
        t.Predictor = "Predictor",
        t.Manipulator = "Manipulator",
        t.Visualizer = "Visualizer",
        t.Widget = "Widget",
        t.LoopStart = "LoopStart",
        t.LoopEnd = "LoopEnd",
        t.ScopeStart = "ScopeStart",
        t.ScopeEnd = "ScopeEnd",
        t.QuickForm = "QuickForm",
        t.Configuration = "Configuration",
        t.Other = "Other",
        t.Missing = "Missing",
        t.Unknown = "Unknown",
        t.Subnode = "Subnode",
        t.VirtualIn = "VirtualIn",
        t.VirtualOut = "VirtualOut",
        t.Container = "Container"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(vO || (vO = {}));
var vf;
(e => {
    (t => {
        t.Node = "node",
        t.Component = "component",
        t.Metanode = "metanode"
    })(e.KindEnum || (e.KindEnum = {}))
})(vf || (vf = {}));
var Wk;
(e => {
    (t => {
        t.IDLE = "IDLE",
        t.CONFIGURED = "CONFIGURED",
        t.EXECUTED = "EXECUTED",
        t.EXECUTING = "EXECUTING",
        t.QUEUED = "QUEUED",
        t.HALTED = "HALTED"
    })(e.ExecutionStateEnum || (e.ExecutionStateEnum = {}))
})(Wk || (Wk = {}));
var yO;
(e => {
    (t => {
        t.Add = "add",
        t.Remove = "remove",
        t.Replace = "replace",
        t.Move = "move",
        t.Copy = "copy",
        t.Test = "test"
    })(e.OpEnum || (e.OpEnum = {}))
})(yO || (yO = {}));
var wO;
(e => {
    (t => {
        t.Input = "input",
        t.Output = "output"
    })(e.SideEnum || (e.SideEnum = {}))
})(wO || (wO = {}));
var bO;
(e => {
    (t => {
        t.Table = "table",
        t.FlowVariable = "flowVariable",
        t.Generic = "generic",
        t.Other = "other"
    })(e.KindEnum || (e.KindEnum = {}))
})(bO || (bO = {}));
var Vd;
(e => {
    (t => {
        t.BringForward = "bring_forward",
        t.BringToFront = "bring_to_front",
        t.SendBackward = "send_backward",
        t.SendToBack = "send_to_back"
    })(e.ActionEnum || (e.ActionEnum = {}))
})(Vd || (Vd = {}));
var _O;
(e => {
    (t => {
        t.Error = "error",
        t.Warning = "warning",
        t.Success = "success",
        t.Info = "info"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(_O || (_O = {}));
var W0;
(e => {
    (t => {
        t.WorkflowGroup = "WorkflowGroup",
        t.Workflow = "Workflow",
        t.Component = "Component",
        t.WorkflowTemplate = "WorkflowTemplate",
        t.Data = "Data"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(W0 || (W0 = {}));
var kO;
(e => {
    (t => {
        t.Workflow = "Workflow",
        t.Component = "Component"
    })(e.ProjectTypeEnum || (e.ProjectTypeEnum = {}))
})(kO || (kO = {}));
var zk;
(e => {
    (t => {
        t.LOCAL = "LOCAL",
        t.HUB = "HUB",
        t.SERVER = "SERVER"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(zk || (zk = {}));
var xO;
(e => {
    (t => {
        t.UPTODATE = "UP_TO_DATE",
        t.HASUPDATE = "HAS_UPDATE",
        t.ERROR = "ERROR"
    })(e.UpdateStatusEnum || (e.UpdateStatusEnum = {}))
})(xO || (xO = {}));
var SO;
(e => {
    (t => {
        t.In = "in",
        t.Out = "out"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(SO || (SO = {}));
var z0;
(e => {
    (t => {
        t.Plain = "text/plain",
        t.Html = "text/html"
    })(e.ContentTypeEnum || (e.ContentTypeEnum = {}))
})(z0 || (z0 = {}));
var CO;
(e => {
    (t => {
        t.Source = "Source",
        t.Sink = "Sink",
        t.Learner = "Learner",
        t.Predictor = "Predictor",
        t.Manipulator = "Manipulator",
        t.Visualizer = "Visualizer",
        t.Other = "Other"
    })(e.TypeEnum || (e.TypeEnum = {}))
})(CO || (CO = {}));
var Tp;
(e => {
    (t => {
        t.Success = "success",
        t.Error = "error",
        t.Unchanged = "unchanged"
    })(e.StatusEnum || (e.StatusEnum = {}))
})(Tp || (Tp = {}));
var IO;
(e => {
    (t => {
        t.Translate = "translate",
        t.Delete = "delete",
        t.Connect = "connect",
        t.AddNode = "add_node",
        t.ReplaceNode = "replace_node",
        t.InsertNode = "insert_node",
        t.UpdateComponentOrMetanodeName = "update_component_or_metanode_name",
        t.UpdateNodeLabel = "update_node_label",
        t.Collapse = "collapse",
        t.Expand = "expand",
        t.AddPort = "add_port",
        t.RemovePort = "remove_port",
        t.Copy = "copy",
        t.Cut = "cut",
        t.Paste = "paste",
        t.TransformWorkflowAnnotation = "transform_workflow_annotation",
        t.UpdateWorkflowAnnotation = "update_workflow_annotation",
        t.ReorderWorkflowAnnotations = "reorder_workflow_annotations",
        t.AddWorkflowAnnotation = "add_workflow_annotation",
        t.UpdateProjectMetadata = "update_project_metadata",
        t.UpdateComponentMetadata = "update_component_metadata",
        t.AddBendpoint = "add_bendpoint",
        t.UpdateComponentLinkInformation = "update_component_link_information",
        t.TransformMetanodePortsBar = "transform_metanode_ports_bar",
        t.UpdateLinkedComponents = "update_linked_components"
    })(e.KindEnum || (e.KindEnum = {}))
})(IO || (IO = {}));
var Hk;
(e => {
    (t => {
        t.Component = "component",
        t.Metanode = "metanode",
        t.Project = "project"
    })(e.ContainerTypeEnum || (e.ContainerTypeEnum = {})),
    (t => {
        t.LOCAL = "LOCAL",
        t.HUB = "HUB",
        t.SERVER = "SERVER"
    })(e.ProviderTypeEnum || (e.ProviderTypeEnum = {}))
})(Hk || (Hk = {}));
const Wae = function (e) {
    return {
        getState(t) {
            const n = {};
            return e.call("ApplicationService.getState", {
                ...n,
                ...t
            })
        }
    }
}, Uk = function (e) {
    return {
        addEventListener(t) {
            const n = {
                eventType: null
            };
            return e.call("EventService.addEventListener", {
                ...n,
                ...t
            })
        },
        removeEventListener(t) {
            const n = {
                eventType: null
            };
            return e.call("EventService.removeEventListener", {
                ...n,
                ...t
            })
        }
    }
}, zae = function (e) {
    return {
        callNodeDataService(t) {
            const n = {
                dataServiceRequest: null
            };
            return e.call("NodeService.callNodeDataService", {
                ...n,
                ...t
            })
        },
        changeLoopState(t) {
            const n = {
                action: null
            };
            return e.call("NodeService.changeLoopState", {
                ...n,
                ...t
            })
        },
        changeNodeStates(t) {
            const n = {
                nodeIds: null,
                action: null
            };
            return e.call("NodeService.changeNodeStates", {
                ...n,
                ...t
            })
        },
        getComponentDescription(t) {
            const n = {};
            return e.call("NodeService.getComponentDescription", {
                ...n,
                ...t
            })
        },
        getNodeDescription(t) {
            const n = {};
            return e.call("NodeService.getNodeDescription", {
                ...n,
                ...t
            })
        },
        getNodeDialog(t) {
            const n = {};
            return e.call("NodeService.getNodeDialog", {
                ...n,
                ...t
            })
        },
        getNodeView(t) {
            const n = {};
            return e.call("NodeService.getNodeView", {
                ...n,
                ...t
            })
        },
        updateDataPointSelection(t) {
            const n = {
                selections: null
            };
            return e.call("NodeService.updateDataPointSelection", {
                ...n,
                ...t
            })
        }
    }
}, Hae = function (e) {
    return {
        getNodeRecommendations(t) {
            const n = {
                nodeId: null,
                portIdx: null,
                nodesLimit: null,
                fullTemplateInfo: null
            };
            return e.call("NodeRepositoryService.getNodeRecommendations", {
                ...n,
                ...t
            })
        },
        getNodeTemplates(t) {
            const n = {
                nodeTemplateIds: null
            };
            return e.call("NodeRepositoryService.getNodeTemplates", {
                ...n,
                ...t
            })
        },
        getNodesGroupedByTags(t) {
            const n = {
                numNodesPerTag: null,
                tagsOffset: null,
                tagsLimit: null,
                fullTemplateInfo: null
            };
            return e.call("NodeRepositoryService.getNodesGroupedByTags", {
                ...n,
                ...t
            })
        },
        searchNodes(t) {
            const n = {
                q: null,
                tags: null,
                allTagsMatch: null,
                offset: null,
                limit: null,
                fullTemplateInfo: null,
                nodesPartition: null,
                portTypeId: null
            };
            return e.call("NodeRepositoryService.searchNodes", {
                ...n,
                ...t
            })
        }
    }
}, Uae = function (e) {
    return {
        callPortDataService(t) {
            const n = {
                dataServiceRequest: null
            };
            return e.call("PortService.callPortDataService", {
                ...n,
                ...t
            })
        },
        getPortView(t) {
            const n = {};
            return e.call("PortService.getPortView", {
                ...n,
                ...t
            })
        }
    }
}, qae = function (e) {
    return {
        createWorkflow(t) {
            const n = {};
            return e.call("SpaceService.createWorkflow", {
                ...n,
                ...t
            })
        },
        createWorkflowGroup(t) {
            const n = {};
            return e.call("SpaceService.createWorkflowGroup", {
                ...n,
                ...t
            })
        },
        deleteItems(t) {
            const n = {};
            return e.call("SpaceService.deleteItems", {
                ...n,
                ...t
            })
        },
        deleteJobsForWorkflow(t) {
            const n = {};
            return e.call("SpaceService.deleteJobsForWorkflow", {
                ...n,
                ...t
            })
        },
        deleteSchedulesForWorkflow(t) {
            const n = {};
            return e.call("SpaceService.deleteSchedulesForWorkflow", {
                ...n,
                ...t
            })
        },
        getSpaceProvider(t) {
            const n = {};
            return e.call("SpaceService.getSpaceProvider", {
                ...n,
                ...t
            })
        },
        listJobsForWorkflow(t) {
            const n = {};
            return e.call("SpaceService.listJobsForWorkflow", {
                ...n,
                ...t
            })
        },
        listSchedulesForWorkflow(t) {
            const n = {};
            return e.call("SpaceService.listSchedulesForWorkflow", {
                ...n,
                ...t
            })
        },
        listWorkflowGroup(t) {
            const n = {};
            return e.call("SpaceService.listWorkflowGroup", {
                ...n,
                ...t
            })
        },
        moveOrCopyItems(t) {
            const n = {};
            return e.call("SpaceService.moveOrCopyItems", {
                ...n,
                ...t
            })
        },
        renameItem(t) {
            const n = {};
            return e.call("SpaceService.renameItem", {
                ...n,
                ...t
            })
        }
    }
}, Bn = function (e) {
    return {
        executeWorkflowCommand(t) {
            const n = {};
            return e.call("WorkflowService.executeWorkflowCommand", {
                ...n,
                ...t
            })
        },
        getLinkUpdates(t) {
            const n = {};
            return e.call("WorkflowService.getLinkUpdates", {
                ...n,
                ...t
            })
        },
        getWorkflow(t) {
            const n = {
                includeInteractionInfo: null
            };
            return e.call("WorkflowService.getWorkflow", {
                ...n,
                ...t
            })
        },
        redoWorkflowCommand(t) {
            const n = {};
            return e.call("WorkflowService.redoWorkflowCommand", {
                ...n,
                ...t
            })
        },
        undoWorkflowCommand(t) {
            const n = {};
            return e.call("WorkflowService.undoWorkflowCommand", {
                ...n,
                ...t
            })
        }
    }
}, Yae = function (e, t) {
    const n = o => o, {
        postProcessCommandResponse: r = n
    } = t;
    return {
        Translate(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "translate"
                }
            });
            return r(l)
        },
        Delete(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "delete"
                }
            });
            return r(l)
        },
        Connect(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "connect"
                }
            });
            return r(l)
        },
        AddNode(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "add_node"
                }
            });
            return r(l)
        },
        AddBendpoint(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "add_bendpoint"
                }
            });
            return r(l)
        },
        ReplaceNode(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "replace_node"
                }
            });
            return r(l)
        },
        InsertNode(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "insert_node"
                }
            });
            return r(l)
        },
        UpdateComponentOrMetanodeName(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_component_or_metanode_name"
                }
            });
            return r(l)
        },
        UpdateNodeLabel(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_node_label"
                }
            });
            return r(l)
        },
        Expand(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "expand"
                }
            });
            return r(l)
        },
        Collapse(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "collapse"
                }
            });
            return r(l)
        },
        AddPort(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "add_port"
                }
            });
            return r(l)
        },
        RemovePort(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "remove_port"
                }
            });
            return r(l)
        },
        Copy(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "copy"
                }
            });
            return r(l)
        },
        Cut(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "cut"
                }
            });
            return r(l)
        },
        Paste(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "paste"
                }
            });
            return r(l)
        },
        TransformWorkflowAnnotation(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "transform_workflow_annotation"
                }
            });
            return r(l)
        },
        UpdateWorkflowAnnotation(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_workflow_annotation"
                }
            });
            return r(l)
        },
        ReorderWorkflowAnnotations(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "reorder_workflow_annotations"
                }
            });
            return r(l)
        },
        AddWorkflowAnnotation(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "add_workflow_annotation"
                }
            });
            return r(l)
        },
        UpdateProjectMetadata(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_project_metadata"
                }
            });
            return r(l)
        },
        UpdateComponentMetadata(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_component_metadata"
                }
            });
            return r(l)
        },
        UpdateComponentLinkInformation(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_component_link_information"
                }
            });
            return r(l)
        },
        TransformMetanodePortsBar(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "transform_metanode_ports_bar"
                }
            });
            return r(l)
        },
        UpdateLinkedComponents(o) {
            const {
                projectId: i,
                workflowId: s,
                ...a
            } = o,
            l = Bn(e).executeWorkflowCommand({
                projectId: o.projectId,
                workflowId: o.workflowId,
                workflowCommand: {
                    ...a,
                    kind: "update_linked_components"
                }
            });
            return r(l)
        }
    }
}, Kae = function (e) {
    return {
        subscribeEvent(t) {
            return Uk(e).addEventListener({
                eventType: t
            })
        },
        registerEventHandlers(t) {
            e.registerEventHandlers(t)
        },
        unsubscribeEventListener(t) {
            return Uk(e).removeEventListener({
                eventType: t
            })
        }
    }
}, Gae = e => {
    const t = jae(),
    n = {
        application: Wae(t),
        event: Uk(t),
        node: zae(t),
        noderepository: Hae(t),
        port: Uae(t),
        space: qae(t),
        workflow: Bn(t)
    }, {
        workflow: {
            executeWorkflowCommand: r,
            ...o
        }
    } = n;
    return {
        ...n,
        workflow: o,
        event: Kae(t),
        workflowCommand: Yae(t, e)
    }
}, EC = e => Es ? !0 : e === vf.KindEnum.Node, B6 = () => Es, yf = () => Es, V6 = () => Es, F6 = () => Es, j6 = () => Es, qk = () => Es, Xae = Object.freeze(Object.defineProperty({
            __proto__: null,
            canConfigureFlowVariables: B6,
            canConfigureNodes: EC,
            canDetachPortViews: V6,
            canDoComponentOperations: yf,
            isKaiSupported: j6,
            isLocalSaveSupported: qk,
            isSpaceExplorerSupported: F6
        }, Symbol.toStringTag, {
            value: "Module"
        })), hc = window.switchToJavaUI === void 0 ? "BROWSER" : "DESKTOP", Es = hc === "DESKTOP", W6 = hc === "BROWSER", Jae = e => {
    e.config.globalProperties.$environment = hc
}, ap = e => {
    const t = () => Promise.resolve();
    return (e[hc] ?? t)()
}, Zae = Fe({
    components: {
        BaseButton: Z1
    },
    props: {
        withBorder: {
            type: Boolean,
        default:
            !1
        },
        onDark: {
            type: Boolean,
        default:
            !1
        },
        primary: {
            type: Boolean,
        default:
            !1
        },
        compact: {
            type: Boolean,
        default:
            !1
        },
        withWarning: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        classes() {
            return ["button", {
                    primary: this.primary
                }, {
                    "with-border": this.withBorder
                }, {
                    "with-warning": this.withWarning
                }, {
                    "on-dark": this.onDark
                }, {
                    compact: this.compact
                }
            ]
        }
    }
});
function Qae(e, t, n, r, o, i) {
    const s = B("BaseButton");
    return _(),
    H(s, {
        class: he(e.classes),
        disabled: e.disabled
    }, {
    default:
        oe(() => [Ye(e.$slots, "default")]),
        _: 3
    }, 8, ["class", "disabled"])
}
const Pr = te(Zae, [["render", Qae], ["__scopeId", "data-v-30aa7500"]]);
let nf = {}, z6 = -1 / 0;
const ele = e => {
    if (e <= z6)
        return Promise.resolve();
    if (!nf[e]) {
        let n,
        r = new Promise(o => {
            n = o
        });
        nf[e] = [r, n]
    }
    let [t] = nf[e];
    return t
}, tle = e => {
    if (z6 = e, !nf[e])
        return;
    let [, t] = nf[e];
    delete nf[e],
    t()
}, nle = async e => !e || !e.snapshotId ? Promise.resolve(e) : (await ele(e.snapshotId), e), rle = Gae({
    url: "",
    postProcessCommandResponse: nle
});
function ole(e) {
    return {
        all: e = e || new Map,
        on: function (t, n) {
            var r = e.get(t);
            r ? r.push(n) : e.set(t, [n])
        },
        off: function (t, n) {
            var r = e.get(t);
            r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []))
        },
        emit: function (t, n) {
            var r = e.get(t);
            r && r.slice().map(function (o) {
                o(n)
            }),
            (r = e.get("*")) && r.slice().map(function (o) {
                o(t, n)
            })
        }
    }
}
const i0 = ole(), ile = () => {
    i0.all.clear()
}, Ir = {
    on: i0.on,
    off: i0.off,
    emit: i0.emit,
    clearAll: ile
}, sle = ({
    app: e
}) => {
    e.config.globalProperties.$bus = Ir
}, It = (e, t, n, r, o) => {
    if (W6)
        return null;
    try {
        const i = new Promise((s, a) => {
            Ir.on(`desktop-api-function-result-${e.name}`, l => {
                Ir.off(`desktop-api-function-result-${e.name}`),
                o.block && Ir.emit("desktop-api-function-block-ui", {
                    block: !1
                }),
                !r && l && a(l),
                s(l)
            })
        });
        return o.block && Ir.emit("desktop-api-function-block-ui", {
            block: !0,
            darkenBackground: o.darkenBackground
        }),
        e(...t),
        i
    } catch (i) {
        if (consola.error(n, i), r)
            return Promise.resolve(null);
        throw i
    }
}, ale = () => It(window.switchToJavaUI, [], "Could not switch to classic UI", !1, {
    block: !1
}), lle = () => It(window.switchWorkspace, [], "Could not switch workspace", !1, {
    block: !0,
    darkenBackground: !0
}), cle = () => It(window.openAboutDialog, [], "Could not open about dialog", !1, {
    block: !0,
    darkenBackground: !0
}), ule = () => It(window.openUpdateDialog, [], "Could not open update dialog", !1, {
    block: !0
}), dle = () => It(window.openKNIMEHomeDir, [], "Could not the KNIME home directory", !1, {
    block: !1
}), fle = () => It(window.checkForUpdates, [], "Could not check for updates", !1, {
    block: !1
}), hle = ({
    url: e
}) => It(window.openUrlInExternalBrowser, [e], "Could not open URL in External Browser", !1, {
    block: !1
}), ple = () => It(window.openWebUIPreferencePage, [], "Could not open preferences", !1, {
    block: !0,
    darkenBackground: !0
}), mle = () => It(window.openInstallExtensionsDialog, [], "Could not open install extensions dialog", !1, {
    block: !1
}), gle = ({
    projectId: e,
    nodeId: t
}) => It(window.openNodeDialog, [e, t], `Could not open dialog of node ${t}`, !1, {
    block: !0,
    darkenBackground: !1
}), vle = ({
    projectId: e,
    workflowId: t,
    nodeId: n
}) => It(window.openLinkComponentDialog, [e, t, n], `Could not open linking dialog of component ${n}`, !0, {
    block: !0,
    darkenBackground: !0
}), yle = ({
    projectId: e,
    workflowId: t,
    nodeId: n
}) => It(window.openChangeComponentHubItemVersionDialog, [e, t, n], `Could not change Hub item version of component ${n}`, !1, {
    block: !0
}), wle = ({
    projectId: e,
    workflowId: t,
    nodeId: n
}) => It(window.openChangeComponentLinkTypeDialog, [e, t, n], `Could not change link type of component ${n}`, !1, {
    block: !0
}), ble = ({
    projectId: e,
    nodeId: t
}) => It(window.openLegacyFlowVariableDialog, [e, t], `Could not open legacy flow variable dialog of node ${t}`, !1, {
    block: !0,
    darkenBackground: !0
}), _le = ({
    projectId: e,
    nodeId: t,
    portIdx: n,
    executeNode: r
}) => It(window.openLegacyPortView, [e, t, n, r], `Could not execute and open view of node ${t}`, !1, {
    block: !1
}), kle = ({
    projectId: e,
    nodeId: t
}) => It(window.executeNodeAndOpenView, [e, t], `Could not execute and open view of node ${t}`, !1, {
    block: !1
}), xle = ({
    projectId: e,
    nodeId: t,
    portIndex: n,
    viewIndex: r
}) => It(window.openPortView, [e, t, n, r], `Could not open detached view for node ${t} and port #${n}`, !1, {
    block: !1
}), Sle = ({
    projectId: e,
    workflowPreviewSvg: t
}) => It(window.saveWorkflow, [e, t], "Could not save workflow", !1, {
    block: !0
}), Cle = ({
    spaceId: e = "local",
    itemId: t,
    spaceProviderId: n = "local"
}) => It(window.openWorkflow, [e, t, n], "Could not open workflow", !1, {
    block: !0
}), Ile = ({
    closingProjectId: e,
    nextProjectId: t
}) => It(window.closeWorkflow, [e, t], "Could not close workflow", !0, {
    block: !0
}), Tle = ({
    projectIds: e
}) => It(window.forceCloseWorkflows, e, "Could not close workflow", !0, {
    block: !1
}), Mle = ({
    projectId: e
}) => It(window.setProjectActiveAndEnsureItsLoaded, [e], "Failed to set project as active in the backend", !1, {
    block: !1
}), Ple = ({
    projectId: e,
    workflowId: t
}) => It(window.openLayoutEditor, [e, t], "Could not open layout editor", !1, {
    block: !0,
    darkenBackground: !0
}), Ele = () => It(window.openWorkflowCoachPreferencePage, [], "Could not open workflow coach preference page", !1, {
    block: !0
}), Ole = () => It(window.getSpaceProviders, [], "Could not fetch space providers", !1, {
    block: !1
}), $le = async({
    spaceProviderId: e
}) => {
    const t = await It(window.connectSpaceProvider, [e], `Could not connect to provider ${e}`, !0, {
        block: !0
    });
    return JSON.parse(t)
}, Ale = ({
    spaceProviderId: e
}) => It(window.disconnectSpaceProvider, [e], `Could not disconnect from provider ${e}`, !1, {
    block: !1
}), Dle = ({
    spaceProviderId: e = "local",
    spaceId: t = "local",
    itemId: n
}) => It(window.importFiles, [e, t, n], "Could not disconnect import files", !0, {
    block: !0,
    darkenBackground: !0
}), Nle = ({
    spaceProviderId: e = "local",
    spaceId: t = "local",
    itemId: n
}) => It(window.importWorkflows, [e, t, n], "Could not import workflows", !0, {
    block: !0,
    darkenBackground: !0
}), Rle = ({
    spaceProviderId: e = "local",
    spaceId: t = "local",
    itemId: n
}) => It(window.exportSpaceItem, [e, t, n], "Could not export item", !0, {
    block: !0,
    darkenBackground: !0
}), Lle = ({
    spaceProviderId: e = "local",
    spaceId: t = "local",
    itemIds: n,
    destinationItemId: r
}) => It(window.getNameCollisionStrategy, [e, t, n, r], "Could not check for name collisions", !0, {
    block: !1
}), Ble = ({
    spaceProviderId: e = "local",
    spaceId: t = "local",
    itemIds: n
}) => It(window.copyBetweenSpaces, [e, t, n], "Error uploading to Hub space", !0, {
    block: !0,
    darkenBackground: !0
}), Vle = ({
    spaceProviderId: e,
    spaceId: t,
    isCopy: n,
    itemIds: r
}) => {
    const o = n ? "copying" : "moving";
    return It(window.moveOrCopyToSpace, [e, t, n, r], `Error ${o} to Hub space`, !0, {
        block: !0,
        darkenBackground: !0
    })
}, Fle = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n
}) => It(window.openInBrowser, [e, t, n], "Error opening in browser", !1, {
    block: !1
}), jle = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n
}) => It(window.openAPIDefinition, [e, t, n], "Error opening in Hub", !1, {
    block: !1
}), Wle = ({
    projectId: e,
    workflowPreviewSvg: t
}) => It(window.saveWorkflowAs, [e, t], "Could not save workflow locally", !1, {
    block: !0,
    darkenBackground: !0
}), zle = ({
    totalProjects: e,
    projectIds: t,
    svgSnapshots: n,
    params: r
}) => It(window.saveAndCloseWorkflows, [e, ...t, ...n, ...r], "Could not save and close all workflows", !1, {
    block: !0
}), Hle = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n,
    projectId: r,
    workflowId: o,
    x: i,
    y: s
}) => It(window.importComponent, [e, t, n, r, o, i, s], "Could not import component", !0, {
    block: !0
}), Ule = ({
    uri: e,
    projectId: t,
    workflowId: n,
    x: r,
    y: o
}) => It(window.importURIAtWorkflowCanvas, [e, t, n, r, o], `Could not import URI at canvas position (${r}, ${o})`, !1, {
    block: !0
}), qle = ({
    conversationId: e,
    chainType: t
}) => It(window.abortAiRequest, [e, t], "Could not abort AI request", !1, {
    block: !1
}), Yle = ({
    conversationId: e,
    chainType: t,
    projectId: n,
    workflowId: r,
    selectedNodes: o,
    messages: i
}) => It(window.makeAiRequest, [e, t, n, r, o, JSON.stringify(i)], "Could not make AI request", !1, {
    block: !1
}), Kle = async() => {
    const e = await It(window.getUiStrings, [], "Could not get UI strings", !0, {
        block: !1
    });
    return JSON.parse(e)
}, Gle = () => {
    It(window.installKAI, [], "Could not install KAI", !1, {
        block: !1
    })
}, Xle = () => It(window.getHubID, [], "Could not get hub id", !0, {
    block: !1
}), Jle = () => It(window.openAiAssistantPreferencePage, [], "Could not open AI assistant preferences", !1, {
    block: !0,
    darkenBackground: !0
}), Zle = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n
}) => It(window.openPermissionsDialog, [e, t, n], "Could not open server permission dialog", !1, {
    block: !0
}), Qle = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n
}) => It(window.executeOnClassic, [e, t, n], "Could not remote execute workflow", !1, {
    block: !1
}), ece = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n,
    jobId: r,
    jobName: o
}) => It(window.saveJobAsWorkflow, [e, t, n, r, o], "Could not save job as workflow", !0, {
    block: !0
}), tce = ({
    spaceProviderId: e,
    spaceId: t,
    itemId: n,
    scheduleId: r
}) => It(window.editSchedule, [e, t, n, r], "Could not edit schedule", !0, {
    block: !0
}), nce = e => It(window.openWorkflowConfiguration, [e], "Could not open workflow configuration", !0, {
    block: !0
}), rce = Object.freeze(Object.defineProperty({
            __proto__: null,
            abortAiRequest: qle,
            checkForUpdates: fle,
            closeWorkflow: Ile,
            connectSpaceProvider: $le,
            copyBetweenSpaces: Ble,
            disconnectSpaceProvider: Ale,
            editSchedule: tce,
            executeNodeAndOpenView: kle,
            executeWorkflow: Qle,
            exportSpaceItem: Rle,
            forceCloseWorkflows: Tle,
            getHubID: Xle,
            getNameCollisionStrategy: Lle,
            getSpaceProviders: Ole,
            getUiStrings: Kle,
            importComponent: Hle,
            importFiles: Dle,
            importURIAtWorkflowCanvas: Ule,
            importWorkflows: Nle,
            installKAI: Gle,
            makeAiRequest: Yle,
            moveOrCopyToSpace: Vle,
            openAPIDefinition: jle,
            openAboutDialog: cle,
            openAiAssistantPreferencePage: Jle,
            openChangeComponentHubItemVersionDialog: yle,
            openChangeComponentLinkTypeDialog: wle,
            openInBrowser: Fle,
            openInstallExtensionsDialog: mle,
            openKNIMEHomeDir: dle,
            openLayoutEditor: Ple,
            openLegacyFlowVariableDialog: ble,
            openLegacyPortView: _le,
            openLinkComponentDialog: vle,
            openNodeDialog: gle,
            openPermissionsDialog: Zle,
            openPortView: xle,
            openUpdateDialog: ule,
            openUrlInExternalBrowser: hle,
            openWebUIPreferencePage: ple,
            openWorkflow: Cle,
            openWorkflowCoachPreferencePage: Ele,
            openWorkflowConfiguration: nce,
            saveAndCloseWorkflows: zle,
            saveJobAsWorkflow: ece,
            saveWorkflow: Sle,
            saveWorkflowAs: Wle,
            setProjectActiveAndEnsureItsLoaded: Mle,
            switchToJavaUI: ale,
            switchWorkspace: lle
        }, Symbol.toStringTag, {
            value: "Module"
        })), oce = {
    registerEventHandlers: e => {
        Object.entries(e).forEach(([t, n]) => {
            R6(t, n)
        })
    },
    ...rce
}, Oe = {
    ...rle,
    desktop: oce
}, ice = "https://www.knime.com/downloads?src=knimeappmodernui", sce = Fe({
    components: {
        Button: Pr
    },
    props: {
        availableUpdates: {
            type: Object,
        default:
            () => ({})
        }
    },
    computed: {
        hasBugFixes() {
            return this.availableUpdates.bugfixes && this.availableUpdates.bugfixes.length > 0
        },
        hasNewReleases() {
            return this.availableUpdates.newReleases && this.availableUpdates.newReleases.length > 0
        },
        hasReleaseAndIsUpdatePossible() {
            if (!this.hasNewReleases)
                return !1;
            const {
                newReleases: e
            } = this.availableUpdates;
            return e.every(({
                    isUpdatePossible: t
                }) => t)
        },
        buttonText() {
            return this.hasBugFixes || this.hasReleaseAndIsUpdatePossible ? "Update" : "Download"
        },
        updateMessage() {
            if (this.hasBugFixes) {
                const e = this.availableUpdates.bugfixes.length;
                return e > 1 ? `There are updates for ${e} extensions available.` : "There is an update for 1 extension available."
            }
            if (this.hasNewReleases) {
                const {
                    newReleases: e
                } = this.availableUpdates, {
                    shortName: t
                } = e.at(0),
                n = "Get the latest features and enhancements!",
                r = `${n} Update to ${t} now.`,
                o = `${n} Download ${t} now.`;
                return this.hasReleaseAndIsUpdatePossible ? r : o
            }
            return null
        }
    },
    methods: {
        onUpdateAction() {
            this.hasBugFixes || this.hasReleaseAndIsUpdatePossible ? Oe.desktop.openUpdateDialog() : window.open(ice)
        }
    }
});
const ace = {
    key: 0,
    class: "footer-wrapper"
}, lce = {
    class: "grid-container"
}, cce = {
    class: "grid-item-12 update-bar"
}, uce = {
    class: "text"
};
function dce(e, t, n, r, o, i) {
    const s = B("Button");
    return e.availableUpdates ? (_(), O("section", ace, [P("div", lce, [P("div", cce, [P("span", uce, Re(e.updateMessage), 1), z(s, {
                                    "with-border": "",
                                    onClick: e.onUpdateAction
                                }, {
                                default:
                                    oe(() => [mt(Re(e.buttonText), 1)]),
                                    _: 1
                                }, 8, ["onClick"])])])])) : J("", !0)
}
const fce = te(sce, [["render", dce], ["__scopeId", "data-v-5ba9c286"]]);
function  * hce() {
    let e = -1;
    for (; ; )
        e++, yield e
}
const pce = hce(), mce = () => pce.next().value.toString();
let Co = [];
const H6 = ({
    onEscape: e,
    group: t = null,
    alwaysActive: n = !1
}) => ({
    beforeMount() {
        Co.push([this, {
                    onEscape: e,
                    group: t,
                    alwaysActive: n
                }
            ])
    },
    beforeUnmount() {
        Co = Co.filter(([r]) => r !== this)
    }
}), OC = e => Co[Co.length - 1], U6 = (e, t) => {
    Co.filter(t).map(([n, {
                    onEscape: r
                }
            ]) => [n, r]).reverse().forEach(([n, r]) => {
        typeof n == "string" ? r() : r.call(n)
    })
}, gce = e => {
    const [t, n] = OC();
    return U6(e, ([r, o]) => o.group === n.group && !o.alwaysActive),
    e.filter(([r, o]) => o.group !== n.group || o.alwaysActive)
}, vce = e => {
    const [t, {
            onEscape: n
        }
    ] = OC();
    return typeof t == "string" ? n() : n.call(t),
    e.slice(0, -1)
}, yce = () => {
    if (Co.length) {
        Co.some(([, {
                        alwaysActive: r
                    }
                ]) => r) && U6(Co, ([r, o]) => o.alwaysActive);
        const [t, n] = OC();
        if (n.alwaysActive)
            return;
        Co = n.group ? gce(Co) : vce(Co)
    }
}, lg = ({
    onEscape: e,
    group: t = null,
    alwaysActive: n = !1
}) => {
    const r = mce();
    Ur(() => {
        Co.push([r, {
                    onEscape: e,
                    group: t,
                    alwaysActive: n
                }
            ])
    }),
    Rs(() => {
        Co = Co.filter(([o]) => o !== r)
    })
}, wce = /^(input|textarea|select)$/i, Yk = e => e ? !!(wce.test(e.tagName) || e.getAttribute?.("contenteditable") === "true") : !1, bce = {
    mounted() {
        document.addEventListener("keydown", this.onKeydown)
    },
    beforeUnmount() {
        document.removeEventListener("keydown", this.onKeydown)
    },
    methods: {
        onKeydown(e) {
            if (e.key === "Control" || e.key === "Shift" || e.key === "Meta" || (e.key === "Escape" && yce(), Yk(e.target)) || e.repeat === !0)
                return;
            let t = this.$shortcuts.findByHotkey(e);
            if (!t)
                return;
            const n = this.$shortcuts.isEnabled(t);
            n && this.$shortcuts.dispatch(t),
            (n || this.$shortcuts.preventDefault(t)) && e.preventDefault(),
            e.stopPropagation()
        }
    },
    render() {
        return null
    }
}, _ce = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, kce = P("path", {
    d: "m11.9 22.3 2.7 4.4-4.5 2.8m4.5-2.8C9 26 4.7 21.7 4.7 16c0-5.1 3.4-9.4 8.1-10.8M20 9.7l-2.6-4.4 4.5-2.8m-4.5 2.8c5.6.7 9.9 5 9.9 10.7 0 5.1-3.4 9.4-8.1 10.8"
}, null, -1), xce = [kce];
function Sce(e, t) {
    return _(),
    O("svg", _ce, xce)
}
const cg = {
    render: Sce
}, Cce = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Ice = P("path", {
    d: "M11.672 7.407h17.312V29.5H11.672zm8.656 0V2.5H3.016v22.093h8.656V7.407z"
}, null, -1), Tce = [Ice];
function Mce(e, t) {
    return _(),
    O("svg", Cce, Tce)
}
const lw = {
    render: Mce
}, Pce = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Ece = P("path", {
    d: "m4.923 16 8.923 8.308L27.538 8"
}, null, -1), Oce = [Ece];
function $ce(e, t) {
    return _(),
    O("svg", Pce, Oce)
}
const Ace = {
    render: $ce
}, $C = e => {
    let t = document.createElement("textarea");
    t.style = "position:fixed;pointer-events:none;opacity:0;",
    t.setAttribute("readonly", ""),
    t.value = e,
    document.body.appendChild(t),
    t.select(),
    document.execCommand("copy"),
    document.body.removeChild(t)
}, Dce = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Nce = P("path", {
    d: "M24.512 9.5H10.025a2.513 2.513 0 0 0-2.513 2.512v6.858"
}, null, -1), Rce = P("path", {
    d: "m10.625 15.762-3.113 3.113L4.4 15.762M7.512 22.5H22a2.513 2.513 0 0 0 2.512-2.512V13.13"
}, null, -1), Lce = P("path", {
    d: "m21.4 16.242 3.113-3.112 3.112 3.112"
}, null, -1), Bce = [Nce, Rce, Lce];
function Vce(e, t) {
    return _(),
    O("svg", Dce, Bce)
}
const Fce = {
    render: Vce
};
const jce = {
    components: {
        Button: Pr,
        ReloadIcon: cg,
        CopyIcon: lw,
        CheckIcon: Ace,
        WarningIcon: Q1,
        SwitchIcon: Fce,
        FunctionButton: ti
    },
    props: {
        message: {
            type: String,
        default:
            null
        },
        stack: {
            type: String,
        default:
            null
        },
        vueInfo: {
            type: String,
        default:
            null
        }
    },
    emits: ["close"],
    data: () => ({
        copied: !1
    }),
    computed: {
        errorDetails() {
            return [this.message, this.vueInfo, this.stack].filter(Boolean).join(`

`)
        }
    },
    methods: {
        reloadApp() {
            window.location.href = "/index.html"
        },
        copyToClipboard() {
            $C(JSON.stringify({
                    app: "KnimeUI",
                    message: this.message,
                    vueInfo: this.vueInfo,
                    stack: this.stack
                }, null, 2)),
            this.copied = !0
        },
        switchToJavaUI() {
            window.switchToJavaUI()
        }
    }
}, q6 = e => (ir("data-v-a08c75a6"), e = e(), sr(), e), Wce = q6(() => P("div", {
            class: "background"
        }, null, -1)), zce = {
    class: "content"
}, Hce = q6(() => P("div", {
            class: "message"
        }, " Hitting the reload button should bring you back to KNIME Modern UI, while you could also switch back to KNIME Analytics Platform via the button on the top right. ", -1)), Uce = {
    class: "actions"
}, qce = {
    class: "success"
}, Yce = {
    class: "default"
}, Kce = {
    class: "stack",
    readonly: ""
};
function Gce(e, t, n, r, o, i) {
    const s = B("SwitchIcon"),
    a = B("FunctionButton"),
    l = B("WarningIcon"),
    c = B("ReloadIcon"),
    u = B("Button"),
    f = B("CheckIcon"),
    p = B("CopyIcon");
    return _(),
    O("div", {
        class: "error-overlay",
        onKeydown: t[1] || (t[1] = ve(() => {}, ["stop"]))
    }, [Wce, P("div", zce, [z(a, {
                        class: "switch-classic",
                        onClick: i.switchToJavaUI
                    }, {
                    default:
                        oe(() => [z(s)]),
                        _: 1
                    }, 8, ["onClick"]), P("div", {
                        class: "header",
                        onClick: t[0] || (t[0] = m => e.$emit("close"))
                    }, [P("h2", null, [z(l), mt(" Sorry, KNIME UI has stopped due to an error.")]), Hce]), P("div", Uce, [z(u, {
                                primary: "",
                                "on-dark": "",
                                onClick: i.reloadApp
                            }, {
                            default:
                                oe(() => [z(c), mt(" Reload ")]),
                                _: 1
                            }, 8, ["onClick"]), z(u, {
                                "with-border": "",
                                "on-dark": "",
                                class: he(["copy-to-clipboard", {
                                            copied: e.copied
                                        }
                                    ]),
                                onClick: i.copyToClipboard
                            }, {
                            default:
                                oe(() => [P("span", qce, [z(f), mt(" Copied ")]), P("span", Yce, [z(p), mt(" Copy error ")])]),
                                _: 1
                            }, 8, ["class", "onClick"])]), P("textarea", Kce, Re(i.errorDetails), 1)])], 32)
}
const Xce = te(jce, [["render", Gce], ["__scopeId", "data-v-a08c75a6"]]), Jce = ({
    initialCallback: e = () => {},
    firstStageCallback: t = () => {},
    secondStageCallback: n = () => {},
    resetCallback: r = () => {},
    options: o = {}
}) => {
    const a = o.stage1Delay || 1e3,
    l = o.stage2Delay || 2500;
    let c = null;
    return f => {
        if (!f) {
            clearTimeout(c),
            r();
            return
        }
        e(),
        c = setTimeout(() => {
            t(),
            c = setTimeout(() => {
                n()
            }, l)
        }, a)
    }
}, Ml = Object.freeze({
    fullscreen: "fullscreen",
    transparent: "transparent",
    localized: "localized",
    toast: "toast"
}), Zce = Object.freeze({
    normal: "normal",
    stagger: "stagger"
}), Bh = Object.freeze({
    displayMode: Ml.localized,
    loadingMode: Zce.stagger,
    staggerStageCount: 2
}), Qce = Fe({
    components: {
        ReloadIcon: cg
    },
    props: {
        loading: {
            type: Boolean,
        default:
            !1
        },
        text: {
            type: String,
        default:
            "Loading…"
        },
        config: {
            type: Object,
        default:
            () => ({})
        }
    },
    data() {
        return {
            DEFAULTS: Bh,
            showLoader: !1,
            isTextShown: !1,
            isIconShown: !1,
            setLoading: () => {}
        }
    },
    computed: {
        overlayStyles() {
            const {
                displayMode: e = Bh.displayMode
            } = this.config,
            t = {
                [Ml.fullscreen]: "fixed",
                [Ml.localized]: "relative",
                [Ml.transparent]: "fixed"
            },
            n = {
                [Ml.fullscreen]: "99",
                [Ml.localized]: "initial",
                [Ml.transparent]: "initial",
                [Ml.toast]: "initial"
            },
            r = () => {
                const [s] = this.$slots.default?.() || [];
                return s ? {
                    width: "100%",
                    height: "100%"
                }
                 : {
                    height: this.config.initialDimensions?.height || "100%",
                    width: this.config.initialDimensions?.width || "100%"
                }
            }, {
                width: o,
                height: i
            } = r();
            return {
                position: t[e],
                zIndex: n[e],
                "--initial-width": o,
                "--initial-height": i,
                "--smartloader-z-index": 99
            }
        }
    },
    watch: {
        loading: {
            handler(e) {
                e ? this.setupLoader() : this.teardownLoader()
            }
        }
    },
    mounted() {
        this.loading && this.setupLoader()
    },
    methods: {
        setupLoader() {
            const {
                displayMode: e = Bh.displayMode,
                loadingMode: t = Bh.loadingMode
            } = this.config;
            if (e === "transparent") {
                this.setLoading = r => {
                    this.showLoader = r
                },
                this.setLoading(!0);
                return
            }
            ({
                normal: this.useNormalLoadingMode,
                stagger: this.useStaggerLoadingMode
            })[t](),
            this.setLoading(!0)
        },
        teardownLoader() {
            this.setLoading(!1),
            this.setLoading = () => {}
        },
        focus() {
            this.$nextTick(() => {
                this.$refs.loader.focus()
            })
        },
        useNormalLoadingMode() {
            this.setLoading = e => {
                this.showLoader = e,
                this.focus(),
                this.isIconShown = !0,
                this.isTextShown = !0
            }
        },
        useStaggerLoadingMode() {
            const {
                staggerStageCount: e = Bh.staggerStageCount
            } = this.config,
            t = () => {};
            this.setLoading = Jce({
                firstStageCallback: () => {
                    this.showLoader = !0,
                    this.focus(),
                    this.isIconShown = !0
                },
                secondStageCallback: e === 2 ? () => {
                    this.isTextShown = !0
                }
                 : t,
                resetCallback: () => {
                    this.showLoader = !1,
                    this.isTextShown = !1,
                    this.isIconShown = !1
                }
            })
        }
    }
});
const eue = {
    key: 1,
    class: "text"
};
function tue(e, t, n, r, o, i) {
    const s = B("ReloadIcon");
    return _(),
    O("div", {
        style: Yt(e.overlayStyles)
    }, [Cn(P("div", {
                    ref: "loader",
                    class: he(["loader", e.config.displayMode || e.DEFAULTS.displayMode]),
                    tabindex: "-1"
                }, [e.isIconShown ? (_(), H(s, {
                                key: 0
                            })) : J("", !0), e.isTextShown ? (_(), O("span", eue, Re(e.text), 1)) : J("", !0)], 2), [[Kn, e.showLoader]]), e.showLoader ? J("", !0) : Ye(e.$slots, "default", {
                key: 0
            }, void 0, !0)], 4)
}
const nue = te(Qce, [["render", tue], ["__scopeId", "data-v-c602e5cc"]]);
/*!
 * tabbable 6.1.2
 * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
 */
var Y6 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], H0 = Y6.join(","), K6 = typeof Element > "u", Eu = K6 ? function () {}
 : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, U0 = !K6 && Element.prototype.getRootNode ? function (e) {
    var t;
    return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e)
}
 : function (e) {
    return e?.ownerDocument
}, q0 = function e(t, n) {
    var r;
    n === void 0 && (n = !0);
    var o = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"),
    i = o === "" || o === "true",
    s = i || n && t && e(t.parentNode);
    return s
}, rue = function (t) {
    var n,
    r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
    return r === "" || r === "true"
}, G6 = function (t, n, r) {
    if (q0(t))
        return [];
    var o = Array.prototype.slice.apply(t.querySelectorAll(H0));
    return n && Eu.call(t, H0) && o.unshift(t),
    o = o.filter(r),
    o
}, X6 = function e(t, n, r) {
    for (var o = [], i = Array.from(t); i.length; ) {
        var s = i.shift();
        if (!q0(s, !1))
            if (s.tagName === "SLOT") {
                var a = s.assignedElements(),
                l = a.length ? a : s.children,
                c = e(l, !0, r);
                r.flatten ? o.push.apply(o, c) : o.push({
                    scopeParent: s,
                    candidates: c
                })
            } else {
                var u = Eu.call(s, H0);
                u && r.filter(s) && (n || !t.includes(s)) && o.push(s);
                var f = s.shadowRoot || typeof r.getShadowRoot == "function" && r.getShadowRoot(s),
                p = !q0(f, !1) && (!r.shadowRootFilter || r.shadowRootFilter(s));
                if (f && p) {
                    var m = e(f === !0 ? s.children : f.children, !0, r);
                    r.flatten ? o.push.apply(o, m) : o.push({
                        scopeParent: s,
                        candidates: m
                    })
                } else
                    i.unshift.apply(i, s.children)
            }
    }
    return o
}, J6 = function (t, n) {
    return t.tabIndex < 0 && (n || /^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || rue(t)) && isNaN(parseInt(t.getAttribute("tabindex"), 10)) ? 0 : t.tabIndex
}, oue = function (t, n) {
    return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex
}, Z6 = function (t) {
    return t.tagName === "INPUT"
}, iue = function (t) {
    return Z6(t) && t.type === "hidden"
}, sue = function (t) {
    var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function (r) {
        return r.tagName === "SUMMARY"
    });
    return n
}, aue = function (t, n) {
    for (var r = 0; r < t.length; r++)
        if (t[r].checked && t[r].form === n)
            return t[r]
}, lue = function (t) {
    if (!t.name)
        return !0;
    var n = t.form || U0(t),
    r = function (a) {
        return n.querySelectorAll('input[type="radio"][name="' + a + '"]')
    },
    o;
    if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
        o = r(window.CSS.escape(t.name));
    else
        try {
            o = r(t.name)
        } catch (s) {
            return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message),
            !1
        }
    var i = aue(o, t.form);
    return !i || i === t
}, cue = function (t) {
    return Z6(t) && t.type === "radio"
}, uue = function (t) {
    return cue(t) && !lue(t)
}, due = function (t) {
    var n,
    r = t && U0(t),
    o = (n = r) === null || n === void 0 ? void 0 : n.host,
    i = !1;
    if (r && r !== t) {
        var s,
        a,
        l;
        for (i = !!((s = o) !== null && s !== void 0 && (a = s.ownerDocument) !== null && a !== void 0 && a.contains(o) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !i && o; ) {
            var c,
            u,
            f;
            r = U0(o),
            o = (c = r) === null || c === void 0 ? void 0 : c.host,
            i = !!((u = o) !== null && u !== void 0 && (f = u.ownerDocument) !== null && f !== void 0 && f.contains(o))
        }
    }
    return i
}, TO = function (t) {
    var n = t.getBoundingClientRect(),
    r = n.width,
    o = n.height;
    return r === 0 && o === 0
}, fue = function (t, n) {
    var r = n.displayCheck,
    o = n.getShadowRoot;
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    var i = Eu.call(t, "details>summary:first-of-type"),
    s = i ? t.parentElement : t;
    if (Eu.call(s, "details:not([open]) *"))
        return !0;
    if (!r || r === "full" || r === "legacy-full") {
        if (typeof o == "function") {
            for (var a = t; t; ) {
                var l = t.parentElement,
                c = U0(t);
                if (l && !l.shadowRoot && o(l) === !0)
                    return TO(t);
                t.assignedSlot ? t = t.assignedSlot : !l && c !== t.ownerDocument ? t = c.host : t = l
            }
            t = a
        }
        if (due(t))
            return !t.getClientRects().length;
        if (r !== "legacy-full")
            return !0
    } else if (r === "non-zero-area")
        return TO(t);
    return !1
}, hue = function (t) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
        for (var n = t.parentElement; n; ) {
            if (n.tagName === "FIELDSET" && n.disabled) {
                for (var r = 0; r < n.children.length; r++) {
                    var o = n.children.item(r);
                    if (o.tagName === "LEGEND")
                        return Eu.call(n, "fieldset[disabled] *") ? !0 : !o.contains(t)
                }
                return !0
            }
            n = n.parentElement
        }
    return !1
}, Y0 = function (t, n) {
    return !(n.disabled || q0(n) || iue(n) || fue(n, t) || sue(n) || hue(n))
}, Kk = function (t, n) {
    return !(uue(n) || J6(n) < 0 || !Y0(t, n))
}, pue = function (t) {
    var n = parseInt(t.getAttribute("tabindex"), 10);
    return !!(isNaN(n) || n >= 0)
}, mue = function e(t) {
    var n = [],
    r = [];
    return t.forEach(function (o, i) {
        var s = !!o.scopeParent,
        a = s ? o.scopeParent : o,
        l = J6(a, s),
        c = s ? e(o.candidates) : a;
        l === 0 ? s ? n.push.apply(n, c) : n.push(a) : r.push({
            documentOrder: i,
            tabIndex: l,
            item: o,
            isScope: s,
            content: c
        })
    }),
    r.sort(oue).reduce(function (o, i) {
        return i.isScope ? o.push.apply(o, i.content) : o.push(i.content),
        o
    }, []).concat(n)
}, gue = function (t, n) {
    n = n || {};
    var r;
    return n.getShadowRoot ? r = X6([t], n.includeContainer, {
        filter: Kk.bind(null, n),
        flatten: !1,
        getShadowRoot: n.getShadowRoot,
        shadowRootFilter: pue
    }) : r = G6(t, n.includeContainer, Kk.bind(null, n)),
    mue(r)
}, vue = function (t, n) {
    n = n || {};
    var r;
    return n.getShadowRoot ? r = X6([t], n.includeContainer, {
        filter: Y0.bind(null, n),
        flatten: !0,
        getShadowRoot: n.getShadowRoot
    }) : r = G6(t, n.includeContainer, Y0.bind(null, n)),
    r
}, Cv = function (t, n) {
    if (n = n || {}, !t)
        throw new Error("No node provided");
    return Eu.call(t, H0) === !1 ? !1 : Kk(n, t)
}, yue = Y6.concat("iframe").join(","), MO = function (t, n) {
    if (n = n || {}, !t)
        throw new Error("No node provided");
    return Eu.call(t, yue) === !1 ? !1 : Y0(n, t)
};
/*!
 * focus-trap 7.4.1
 * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
 */
function PO(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function (o) {
                return Object.getOwnPropertyDescriptor(e, o).enumerable
            })),
        n.push.apply(n, r)
    }
    return n
}
function EO(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? PO(Object(n), !0).forEach(function (r) {
            wue(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}
function wue(e, t, n) {
    return t = _ue(t),
    t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function bue(e, t) {
    if (typeof e != "object" || e === null)
        return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t || "default");
        if (typeof r != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
function _ue(e) {
    var t = bue(e, "string");
    return typeof t == "symbol" ? t : String(t)
}
var OO = {
    activateTrap: function (t, n) {
        if (t.length > 0) {
            var r = t[t.length - 1];
            r !== n && r.pause()
        }
        var o = t.indexOf(n);
        o === -1 || t.splice(o, 1),
        t.push(n)
    },
    deactivateTrap: function (t, n) {
        var r = t.indexOf(n);
        r !== -1 && t.splice(r, 1),
        t.length > 0 && t[t.length - 1].unpause()
    }
}, kue = function (t) {
    return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function"
}, xue = function (t) {
    return t.key === "Escape" || t.key === "Esc" || t.keyCode === 27
}, Mp = function (t) {
    return t.key === "Tab" || t.keyCode === 9
}, Sue = function (t) {
    return Mp(t) && !t.shiftKey
}, Cue = function (t) {
    return Mp(t) && t.shiftKey
}, $O = function (t) {
    return setTimeout(t, 0)
}, AO = function (t, n) {
    var r = -1;
    return t.every(function (o, i) {
        return n(o) ? (r = i, !1) : !0
    }),
    r
}, Vh = function (t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
        r[o - 1] = arguments[o];
    return typeof t == "function" ? t.apply(void 0, r) : t
}, Iv = function (t) {
    return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target
}, Iue = [], Tue = function (t, n) {
    var r = n?.document || document,
    o = n?.trapStack || Iue,
    i = EO({
        returnFocusOnDeactivate: !0,
        escapeDeactivates: !0,
        delayInitialFocus: !0,
        isKeyForward: Sue,
        isKeyBackward: Cue
    }, n),
    s = {
        containers: [],
        containerGroups: [],
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: !1,
        paused: !1,
        delayInitialFocusTimer: void 0
    },
    a,
    l = function (E, M, N) {
        return E && E[M] !== void 0 ? E[M] : i[N || M]
    },
    c = function (E) {
        return s.containerGroups.findIndex(function (M) {
            var N = M.container,
            F = M.tabbableNodes;
            return N.contains(E) || F.find(function (K) {
                return K === E
            })
        })
    },
    u = function (E) {
        var M = i[E];
        if (typeof M == "function") {
            for (var N = arguments.length, F = new Array(N > 1 ? N - 1 : 0), K = 1; K < N; K++)
                F[K - 1] = arguments[K];
            M = M.apply(void 0, F)
        }
        if (M === !0 && (M = void 0), !M) {
            if (M === void 0 || M === !1)
                return M;
            throw new Error("`".concat(E, "` was specified but was not a node, or did not return a node"))
        }
        var j = M;
        if (typeof M == "string" && (j = r.querySelector(M), !j))
            throw new Error("`".concat(E, "` as selector refers to no known node"));
        return j
    },
    f = function () {
        var E = u("initialFocus");
        if (E === !1)
            return !1;
        if (E === void 0)
            if (c(r.activeElement) >= 0)
                E = r.activeElement;
            else {
                var M = s.tabbableGroups[0],
                N = M && M.firstTabbableNode;
                E = N || u("fallbackFocus")
            }
        if (!E)
            throw new Error("Your focus-trap needs to have at least one focusable element");
        return E
    },
    p = function () {
        if (s.containerGroups = s.containers.map(function (E) {
                var M = gue(E, i.tabbableOptions),
                N = vue(E, i.tabbableOptions);
                return {
                    container: E,
                    tabbableNodes: M,
                    focusableNodes: N,
                    firstTabbableNode: M.length > 0 ? M[0] : null,
                    lastTabbableNode: M.length > 0 ? M[M.length - 1] : null,
                    nextTabbableNode: function (K) {
                        var j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
                        G = N.findIndex(function (Y) {
                            return Y === K
                        });
                        if (!(G < 0))
                            return j ? N.slice(G + 1)
                                .find(function (Y) {
                                    return Cv(Y, i.tabbableOptions)
                                }) : N.slice(0, G).reverse().find(function (Y) {
                                    return Cv(Y, i.tabbableOptions)
                                })
                        }
                    }
                }), s.tabbableGroups = s.containerGroups.filter(function (E) {
                    return E.tabbableNodes.length > 0
                }), s.tabbableGroups.length <= 0 && !u("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times")
},
m = function T(E) {
    if (E !== !1 && E !== r.activeElement) {
        if (!E || !E.focus) {
            T(f());
            return
        }
        E.focus({
            preventScroll: !!i.preventScroll
        }),
        s.mostRecentlyFocusedNode = E,
        kue(E) && E.select()
    }
},
v = function (E) {
    var M = u("setReturnFocus", E);
    return M || (M === !1 ? !1 : E)
},
y = function (E) {
    var M = Iv(E);
    if (!(c(M) >= 0)) {
        if (Vh(i.clickOutsideDeactivates, E)) {
            a.deactivate({
                returnFocus: i.returnFocusOnDeactivate
            });
            return
        }
        Vh(i.allowOutsideClick, E) || E.preventDefault()
    }
},
b = function (E) {
    var M = Iv(E),
    N = c(M) >= 0;
    N || M instanceof Document ? N && (s.mostRecentlyFocusedNode = M) : (E.stopImmediatePropagation(), m(s.mostRecentlyFocusedNode || f()))
},
w = function (E) {
    var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    N = Iv(E);
    p();
    var F = null;
    if (s.tabbableGroups.length > 0) {
        var K = c(N),
        j = K >= 0 ? s.containerGroups[K] : void 0;
        if (K < 0)
            M ? F = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : F = s.tabbableGroups[0].firstTabbableNode;
        else if (M) {
            var G = AO(s.tabbableGroups, function (Pe) {
                var je = Pe.firstTabbableNode;
                return N === je
            });
            if (G < 0 && (j.container === N || MO(N, i.tabbableOptions) && !Cv(N, i.tabbableOptions) && !j.nextTabbableNode(N, !1)) && (G = K), G >= 0) {
                var Y = G === 0 ? s.tabbableGroups.length - 1 : G - 1,
                ue = s.tabbableGroups[Y];
                F = ue.lastTabbableNode
            } else
                Mp(E) || (F = j.nextTabbableNode(N, !1))
        } else {
            var re = AO(s.tabbableGroups, function (Pe) {
                var je = Pe.lastTabbableNode;
                return N === je
            });
            if (re < 0 && (j.container === N || MO(N, i.tabbableOptions) && !Cv(N, i.tabbableOptions) && !j.nextTabbableNode(N)) && (re = K), re >= 0) {
                var de = re === s.tabbableGroups.length - 1 ? 0 : re + 1,
                Se = s.tabbableGroups[de];
                F = Se.firstTabbableNode
            } else
                Mp(E) || (F = j.nextTabbableNode(N))
        }
    } else
        F = u("fallbackFocus");
    F && (Mp(E) && E.preventDefault(), m(F))
},
k = function (E) {
    if (xue(E) && Vh(i.escapeDeactivates, E) !== !1) {
        E.preventDefault(),
        a.deactivate();
        return
    }
    (i.isKeyForward(E) || i.isKeyBackward(E)) && w(E, i.isKeyBackward(E))
},
C = function (E) {
    var M = Iv(E);
    c(M) >= 0 || Vh(i.clickOutsideDeactivates, E) || Vh(i.allowOutsideClick, E) || (E.preventDefault(), E.stopImmediatePropagation())
},
x = function () {
    if (s.active)
        return OO.activateTrap(o, a), s.delayInitialFocusTimer = i.delayInitialFocus ? $O(function () {
            m(f())
        }) : m(f()), r.addEventListener("focusin", b, !0), r.addEventListener("mousedown", y, {
            capture: !0,
            passive: !1
        }), r.addEventListener("touchstart", y, {
            capture: !0,
            passive: !1
        }), r.addEventListener("click", C, {
            capture: !0,
            passive: !1
        }), r.addEventListener("keydown", k, {
            capture: !0,
            passive: !1
        }), a
},
S = function () {
    if (s.active)
        return r.removeEventListener("focusin", b, !0), r.removeEventListener("mousedown", y, !0), r.removeEventListener("touchstart", y, !0), r.removeEventListener("click", C, !0), r.removeEventListener("keydown", k, !0), a
};
return a = {
    get active() {
        return s.active
    },
    get paused() {
        return s.paused
    },
    activate: function (E) {
        if (s.active)
            return this;
        var M = l(E, "onActivate"),
        N = l(E, "onPostActivate"),
        F = l(E, "checkCanFocusTrap");
        F || p(),
        s.active = !0,
        s.paused = !1,
        s.nodeFocusedBeforeActivation = r.activeElement,
        M?.();
        var K = function () {
            F && p(),
            x(),
            N?.()
        };
        return F ? (F(s.containers.concat()).then(K, K), this) : (K(), this)
    },
    deactivate: function (E) {
        if (!s.active)
            return this;
        var M = EO({
            onDeactivate: i.onDeactivate,
            onPostDeactivate: i.onPostDeactivate,
            checkCanReturnFocus: i.checkCanReturnFocus
        }, E);
        clearTimeout(s.delayInitialFocusTimer),
        s.delayInitialFocusTimer = void 0,
        S(),
        s.active = !1,
        s.paused = !1,
        OO.deactivateTrap(o, a);
        var N = l(M, "onDeactivate"),
        F = l(M, "onPostDeactivate"),
        K = l(M, "checkCanReturnFocus"),
        j = l(M, "returnFocus", "returnFocusOnDeactivate");
        N?.();
        var G = function () {
            $O(function () {
                j && m(v(s.nodeFocusedBeforeActivation)),
                F?.()
            })
        };
        return j && K ? (K(v(s.nodeFocusedBeforeActivation)).then(G, G), this) : (G(), this)
    },
    pause: function (E) {
        if (s.paused || !s.active)
            return this;
        var M = l(E, "onPause"),
        N = l(E, "onPostPause");
        return s.paused = !0,
        M?.(),
        S(),
        N?.(),
        this
    },
    unpause: function (E) {
        if (!s.paused || !s.active)
            return this;
        var M = l(E, "onUnpause"),
        N = l(E, "onPostUnpause");
        return s.paused = !1,
        M?.(),
        p(),
        x(),
        N?.(),
        this
    },
    updateContainerElements: function (E) {
        var M = [].concat(E).filter(Boolean);
        return s.containers = M.map(function (N) {
            return typeof N == "string" ? r.querySelector(N) : N
        }),
        s.active && p(),
        this
    }
},
a.updateContainerElements(t),
a
};
/*!
 * focus-trap-vue v4.0.1
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
const Mue = {
    escapeDeactivates: {
        type: Boolean,
    default:
        !0
    },
    returnFocusOnDeactivate: {
        type: Boolean,
    default:
        !0
    },
    allowOutsideClick: {
        type: [Boolean, Function],
    default:
        !0
    },
    clickOutsideDeactivates: [Boolean, Function],
    initialFocus: [String, Function, Boolean],
    fallbackFocus: [String, Function],
    checkCanFocusTrap: Function,
    checkCanReturnFocus: Function,
    delayInitialFocus: {
        type: Boolean,
    default:
        !0
    },
    document: Object,
    preventScroll: Boolean,
    setReturnFocus: [Object, String, Boolean, Function],
    tabbableOptions: Object
}, Pue = Fe({
    props: Object.assign({
        active: {
            type: Boolean,
        default:
            !0
        }
    }, Mue),
    emits: ["update:active", "activate", "postActivate", "deactivate", "postDeactivate"],
    render() {
        return this.renderImpl()
    },
    setup(e, {
        slots: t,
        emit: n
    }) {
        let r;
        const o = De(null),
        i = ne(() => {
            const a = o.value;
            return a && (a instanceof HTMLElement ? a : a.$el)
        });
        function s() {
            return r || (r = Tue(i.value, {
                    escapeDeactivates: e.escapeDeactivates,
                    allowOutsideClick: e.allowOutsideClick,
                    returnFocusOnDeactivate: e.returnFocusOnDeactivate,
                    clickOutsideDeactivates: e.clickOutsideDeactivates,
                    onActivate: () => {
                        n("update:active", !0),
                        n("activate")
                    },
                    onDeactivate: () => {
                        n("update:active", !1),
                        n("deactivate")
                    },
                    onPostActivate: () => n("postActivate"),
                    onPostDeactivate: () => n("postDeactivate"),
                    initialFocus: e.initialFocus,
                    fallbackFocus: e.fallbackFocus,
                    tabbableOptions: e.tabbableOptions,
                    delayInitialFocus: e.delayInitialFocus
                }))
        }
        return Ur(() => {
            Ht(() => e.active, a => {
                a && i.value ? s().activate() : r && (r.deactivate(), (!i.value || i.value.nodeType === Node.COMMENT_NODE) && (r = null))
            }, {
                immediate: !0,
                flush: "post"
            })
        }),
        cc(() => {
            r && r.deactivate(),
            r = null
        }), {
            activate() {
                s().activate()
            },
            deactivate() {
                r && r.deactivate()
            },
            renderImpl() {
                if (!t.default)
                    return null;
                const a = t.default().filter(c => c.type !== Qr);
                return !a || !a.length || a.length > 1 ? (console.error("[focus-trap-vue]: FocusTrap requires exactly one child."), a) : Ps(a[0], {
                    ref: o
                })
            }
        }
    }
});
const Eue = {
    components: {
        FocusTrap: Pue
    },
    props: {
        active: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["cancel"],
    data() {
        return {
            showContent: !1
        }
    },
    watch: {
        active(e) {
            e === !0 ? window.addEventListener("keyup", this.onGlobalKeyUp) : window.removeEventListener("keyup", this.onGlobalKeyUp)
        }
    },
    beforeUnmount() {
        window.removeEventListener("keyup", this.onGlobalKeyUp)
    },
    methods: {
        onGlobalKeyUp(e) {
            e.key === "Escape" && (consola.trace("ESC key press, closing modal"), this.cancel())
        },
        onOverlayClick() {
            this.cancel()
        },
        cancel() {
            this.$emit("cancel")
        }
    }
}, Oue = {
    key: 0,
    class: "wrapper"
}, $ue = {
    class: "inner"
};
function Aue(e, t, n, r, o, i) {
    const s = B("FocusTrap");
    return _(),
    H(ho, {
        name: "fade",
        onAfterEnter: t[2] || (t[2] = a => o.showContent = !0),
        onLeave: t[3] || (t[3] = a => o.showContent = !1)
    }, {
    default:
        oe(() => [n.active ? (_(), H(s, {
                        key: 0,
                        active: n.active && o.showContent,
                        "initial-focus": () => e.$refs.dialog,
                        "allow-outside-click": "",
                        class: "container"
                    }, {
                    default:
                        oe(() => [P("div", {
                                    ref: "dialog",
                                    tabindex: "-1",
                                    onClick: t[1] || (t[1] = ve(() => {}, ["stop"]))
                                }, [P("div", {
                                            class: "overlay",
                                            onClick: t[0] || (t[0] = ve((...a) => i.onOverlayClick && i.onOverlayClick(...a), ["stop"]))
                                        }), z(ho, {
                                            name: "slide"
                                        }, {
                                        default:
                                            oe(() => [o.showContent ? (_(), O("div", Oue, [P("div", $ue, [Ye(e.$slots, "default", {}, void 0, !0)])])) : J("", !0)]),
                                            _: 3
                                        })], 512)]),
                        _: 3
                    }, 8, ["active", "initial-focus"])) : J("", !0)]),
        _: 3
    })
}
const Due = te(Eue, [["render", Aue], ["__scopeId", "data-v-e09f77cd"]]);
const Nue = {
    components: {
        BaseModal: Due,
        CloseIcon: qu,
        FunctionButton: ti
    },
    props: {
        title: {
        default:
            null,
            type: String
        },
        styleType: {
            type: String,
        default:
            "info",
            validator(e = "info") {
                return ["info", "warn"].includes(e)
            }
        }
    },
    emits: ["cancel"],
    methods: {
        onCloserClick() {
            this.$emit("cancel")
        }
    }
}, Rue = {
    class: "header"
}, Lue = {
    class: "header-icon"
}, Bue = {
    key: 0,
    class: "notice"
}, Vue = {
    key: 1,
    class: "confirmation"
}, Fue = {
    class: "controls"
};
function jue(e, t, n, r, o, i) {
    const s = B("CloseIcon"),
    a = B("FunctionButton"),
    l = B("BaseModal");
    return _(),
    H(l, {
        class: he(["modal", n.styleType]),
        onCancel: t[0] || (t[0] = c => e.$emit("cancel", c))
    }, {
    default:
        oe(() => [P("div", Rue, [P("span", Lue, [Ye(e.$slots, "icon", {}, void 0, !0)]), P("h2", null, Re(n.title), 1), z(a, {
                            class: "closer",
                            onClick: i.onCloserClick
                        }, {
                        default:
                            oe(() => [z(s)]),
                            _: 1
                        }, 8, ["onClick"])]), e.$slots.notice ? (_(), O("div", Bue, [Ye(e.$slots, "notice", {}, void 0, !0)])) : J("", !0), e.$slots.confirmation ? (_(), O("div", Vue, [Ye(e.$slots, "confirmation", {}, void 0, !0)])) : J("", !0), P("div", Fue, [Ye(e.$slots, "controls", {}, void 0, !0)])]),
        _: 3
    }, 8, ["class"])
}
const Q6 = te(Nue, [["render", jue], ["__scopeId", "data-v-4621f223"]]);
const Wue = {
    props: {
        modelValue: {
        default:
            "",
            type: [Number, String]
        },
        id: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        type: {
        default:
            "text",
            type: String
        },
        pattern: {
        default:
            null,
            type: String
        },
        placeholder: {
        default:
            null,
            type: String
        },
        autocomplete: {
        default:
            null,
            type: String
        },
        autofocus: {
        default:
            !1,
            type: Boolean
        },
        inputClasses: {
        default:
            "",
            type: String
        },
        disabled: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["update:modelValue", "focus", "keyup", "keypress", "keydown"],
    computed: {
        hasLeftIcon() {
            return this.$slots.icon && this.$slots.icon().length
        },
        hasRightIcon() {
            return this.$slots.iconRight && this.$slots.iconRight().length
        },
        inputClassList() {
            let e = this.inputClasses;
            return this.hasLeftIcon && (e += " with-icon"),
            this.hasRightIcon && (e += " with-icon-right"),
            this.isValid || (e += " invalid"),
            e
        }
    },
    methods: {
        getValue() {
            return this.$refs.input.value
        },
        onInput() {
            this.$emit("update:modelValue", this.getValue())
        },
        focus() {
            this.$refs.input.focus()
        },
        validate() {
            let e = !0,
            t = null;
            return typeof this.getValue() > "u" ? (e = !1, t = "Invalid input") : this.pattern && this.$refs.input.validity.patternMismatch && (e = !1, t = "Input does not match the expected pattern"), {
                isValid: e,
                errorMessage: t
            }
        }
    }
}, zue = e => (ir("data-v-8899cc0d"), e = e(), sr(), e), Hue = {
    class: "input-wrapper"
}, Uue = {
    key: 0,
    class: "icon"
}, que = ["id", "name", "value", "type", "pattern", "placeholder", "autofocus", "autocomplete", "disabled"], Yue = {
    key: 1,
    class: "icon icon-right"
}, Kue = zue(() => P("span", {
            class: "invalid-marker"
        }, null, -1));
function Gue(e, t, n, r, o, i) {
    return _(),
    O("div", Hue, [i.hasLeftIcon ? (_(), O("div", Uue, [Ye(e.$slots, "icon")])) : J("", !0), P("input", {
                id: n.id,
                ref: "input",
                name: n.name,
                value: n.modelValue,
                class: he(i.inputClassList),
                type: n.type,
                pattern: n.pattern,
                placeholder: n.placeholder,
                autofocus: n.autofocus,
                autocomplete: n.autocomplete,
                disabled: n.disabled,
                onInput: t[0] || (t[0] = (...s) => i.onInput && i.onInput(...s)),
                onFocus: t[1] || (t[1] = s => e.$emit("focus", s)),
                onKeyup: t[2] || (t[2] = s => e.$emit("keyup", s)),
                onKeypress: t[3] || (t[3] = s => e.$emit("keypress", s)),
                onKeydown: t[4] || (t[4] = s => e.$emit("keydown", s))
            }, null, 42, que), i.hasRightIcon ? (_(), O("div", Yue, [Ye(e.$slots, "iconRight")])) : J("", !0), Kue])
}
const wf = te(Wue, [["render", Gue], ["__scopeId", "data-v-8899cc0d"]]);
let DO = 0;
const Xue = {
    inject: {
        largeLabels: {
        default:
            !1
        }
    },
    props: {
        generateId: {
            type: Boolean,
        default:
            !0
        },
        idPrefix: {
            type: String,
        default:
            "comp"
        },
        text: {
        default:
            "",
            type: String
        },
        large: {
            type: Boolean,
        default:
            !1
        },
        active: {
            type: Boolean,
        default:
            !0
        }
    },
    emits: ["labelForId"],
    computed: {
        labelFor() {
            return this.generateId ? `${this.idPrefix}-${this.labelForId}` : null
        },
        labelId() {
            return this.generateId ? `label-${this.labelFor}` : null
        },
        isLarge() {
            return this.large || this.largeLabels
        }
    },
    beforeCreate() {
        DO += 1,
        this.labelForId = DO
    },
    mounted() {
        this.$emit("labelForId", this.labelFor)
    }
}, Jue = {
    class: "label-wrapper"
}, Zue = ["id", "for", "textContent"];
function Que(e, t, n, r, o, i) {
    return _(),
    O("div", Jue, [n.active ? (_(), O("label", {
                    key: 0,
                    id: i.labelId,
                    for : i.labelFor, class: he(["label-text", {
                                large: i.isLarge
                            }
                        ]) , textContent: Re(n.text)
                }, null, 10, Zue)) : J("", !0), Ye(e.$slots, "default", {
                labelForId: i.labelFor
            }, void 0, !0)])
}
const Xn = te(Xue, [["render", Que], ["__scopeId", "data-v-b04f7855"]]), ede = /[*?#:";<>%~|/\\]/, tde = 255, nde = "Name is already in use", rde = e => {
    const t = c => c.trim(),
    n = ne(() => t(e.name.value)),
    r = ne(() => n.value.startsWith(".")),
    o = ne(() => n.value.endsWith(".")),
    i = ne(() => !r.value && !o.value && !ede.test(n.value) && n.value.length <= tde),
    s = ne(() => !e.blacklistedNames.value.includes(n.value)),
    a = ne(() => i.value && s.value),
    l = ne(() => r.value ? "Name cannot start with a dot (.)" : o.value ? "Name cannot end with a dot (.)" : i.value ? s.value ? "" : e.unavailableNameMessage || nde : 'Name contains invalid characters *?#:";<>%~|/\\ or exceeds 255 characters');
    return {
        isValid: a,
        errorMessage: l,
        cleanedName: n
    }
}, ode = (e, t) => ({
    render() {
        const n = e.render.apply(this, dt),
        r = dt("title", t);
        return r.ns = "svg",
        n.children.unshift(r),
        n
    }
});
const ide = {
    components: {
        ReloadIcon: ode(cg, "Loading…")
    }
};
function sde(e, t, n, r, o, i) {
    const s = B("ReloadIcon");
    return _(),
    H(s)
}
const ade = te(ide, [["render", sde], ["__scopeId", "data-v-65186a88"]]), e8 = e => (ir("data-v-e43131f8"), e = e(), sr(), e), lde = {
    key: 0,
    class: "item-error"
}, cde = e8(() => P("strong", null, "Cancel", -1)), ude = e8(() => P("strong", null, "Create", -1)), Fh = "KNIME_project", dde = Fe({
    __name: "CreateWorkflowModal",
    setup(e) {
        const t = wa(),
        n = De(!1),
        r = De(null),
        o = De(Fh),
        i = ne(() => t.state.spaces.createWorkflowModalConfig.isOpen),
        s = ne(() => t.getters["spaces/getWorkflowGroupContent"](t.state.spaces.createWorkflowModalConfig.projectId)),
        a = ne(() => (s.value?.items ?? []).map(({
                        name: b
                    }) => b)), {
            isValid: l,
            errorMessage: c,
            cleanedName: u
        } = rde({
            blacklistedNames: a,
            name: o
        }),
        f = () => {
            n.value || t.commit("spaces/setCreateWorkflowModalConfig", {
                isOpen: !1,
                projectId: null
            })
        },
        p = async() => {
            if (!n.value) {
                n.value = !0;
                try {
                    const {
                        projectId: y
                    } = t.state.spaces.createWorkflowModalConfig,
                    b = await t.dispatch("spaces/createWorkflow", {
                        projectId: y,
                        workflowName: u.value
                    });
                    n.value = !1,
                    f(),
                    await t.dispatch("spaces/openWorkflow", {
                        projectId: y,
                        workflowItemId: b.id
                    })
                } catch (y) {
                    n.value = !1,
                    consola.log("There was an error creating the workflow", y)
                }
            }
        },
        m = async y => {
            y.key === "Enter" && l.value && await p()
        },
        v = () => {
            const y = w => a.value.some(k => k === w);
            if (!y(Fh)) {
                o.value = Fh;
                return
            }
            let b = 1;
            for (; y(`${Fh}${b}`); )
                b++;
            o.value = `${Fh}${b}`
        };
        return Ht(i, () => {
            i.value && (v(), setTimeout(() => {
                    const y = r.value?.$refs?.input;
                    y?.setSelectionRange(0, o.value.length),
                    y?.focus()
                }, 200))
        }, {
            immediate: !0
        }),
        (y, b) => Cn((_(), H(Q6, {
                    ref: "modalRef",
                    active: i.value,
                    title: "创建新工作流",
                    "style-type": "info",
                    class: "modal",
                    onCancel: f
                }, {
                    confirmation: oe(() => [z(Xn, {
                                text: "Workflow name"
                            }, {
                            default:
                                oe(() => [P("div", null, [z(wf, {
                                                    ref_key: "inputRef",
                                                    ref: r,
                                                    modelValue: o.value,
                                                    "onUpdate:modelValue": b[0] || (b[0] = w => o.value = w),
                                                    type: "text",
                                                    title: "工作流名称",
                                                    disabled: n.value,
                                                    "is-valid": ke(l) || n.value,
                                                    onKeyup: m
                                                }, null, 8, ["modelValue", "disabled", "is-valid"]), !ke(l) && !n.value ? (_(), O("div", lde, [P("span", null, Re(ke(c)), 1)])) : J("", !0)])]),
                                _: 1
                            })]),
                    controls: oe(() => [z(Pr, {
                                "with-border": "",
                                disabled: n.value,
                                onClick: f
                            }, {
                            default:
                                oe(() => [cde]),
                                _: 1
                            }, 8, ["disabled"]), z(Pr, {
                                primary: "",
                                class: "submit-button",
                                disabled: !ke(l) || n.value,
                                onClick: p
                            }, {
                            default:
                                oe(() => [n.value ? (_(), H(ade, {
                                                key: 0
                                            })) : J("", !0), ude]),
                                _: 1
                            }, 8, ["disabled"])]),
                    _: 1
                }, 8, ["active"])), [[Kn, i.value]])
    }
});
const fde = te(dde, [["__scopeId", "data-v-e43131f8"]]), hde = Fe({
    __name: "BlockUi",
    setup(e) {
        const t = De(!1),
        n = De(!1),
        r = De(null),
        o = async() => {
            await Ci(),
            r.value.focus()
        };
        return Ur(() => {
            Ir.on("desktop-api-function-block-ui", i => {
                t.value = i.block,
                n.value = i.darkenBackground
            })
        }),
        Rs(() => {
            Ir.off("desktop-api-function-block-ui")
        }),
        Ht(t, () => {
            t.value ? o() : n.value = !1
        }),
        (i, s) => Cn((_(), O("div", {
                    ref_key: "blocker",
                    ref: r,
                    class: he(["blocker", {
                                "darken-background": n.value
                            }
                        ]),
                    tabindex: "-1",
                    onClick: s[0] || (s[0] = ve(() => {}, ["prevent", "stop"])),
                    onPointerdown: s[1] || (s[1] = ve(() => {}, ["prevent", "stop"])),
                    onKeydown: s[2] || (s[2] = ve(() => {}, ["stop", "prevent"]))
                }, null, 34)), [[Kn, t.value]])
    }
});
const pde = te(hde, [["__scopeId", "data-v-ef3a74f2"]]), mde = Fe({
    components: {
        AppHeader: Ha(() => Ks(() => import("./AppHeader-8c7cb0a4.js"), ["./AppHeader-8c7cb0a4.js", "./house-1d05c0b5.js", "./house-ff15d853.css", "./CloseButton-3f01b06f.js", "./CloseButton-c3052ed0.css", "./rocket-ea4b98d9.js", "./AppHeader-fde6cfb1.css"], import.meta.url)),
        UpdateBanner: fce,
        HotkeyHandler: bce,
        Error: Xce,
        BlockUi: pde,
        SmartLoader: nue,
        CreateWorkflowModal: fde,
        ToastStack: Cse,
        DynamicEnvRenderer: Ise
    },
    data() {
        return {
            loaded: !1,
            error: null
        }
    },
    computed: {
        ...ut("workflow", {
            workflow: "activeWorkflow"
        }),
        ...ut("application", ["availableUpdates", "globalLoader", "devMode"]),
        environment() {
            return hc
        }
    },
    async beforeMount() {
        await this.setup()
    },
    mounted() {
        this.checkClipboardSupport()
    },
    async beforeUnmount() {
        await this.destroyApplication()
    },
    methods: {
        ...Er("application", ["initializeApplication", "destroyApplication"]),
        async setup() {
            try {
                await Promise.all([this.initializeApplication({
                            $router: this.$router
                        }), document.fonts.load("400 1em Roboto"), document.fonts.load("400 1em Roboto Mono"), document.fonts.load("400 1em Roboto Condensed"), document.fonts.load("700 1em Roboto Condensed")]),
                this.loaded = !0
            } catch ({
                message: e,
                stack: t
            }) {
                this.error = {
                    message: e,
                    stack: t
                }
            }
        },
        async checkClipboardSupport() {
            if (Es) {
                this.$store.commit("application/setHasClipboardSupport", !0);
                return
            }
            let e = !1;
            try {
                const t = await navigator.permissions.query({
                    name: "clipboard-read"
                });
                (t.state === "granted" || t.state === "prompt") && (e = !0)
            } catch {
                navigator.clipboard && "readText" in navigator.clipboard && (e = !0)
            }
            this.$store.commit("application/setHasClipboardSupport", e)
        },
        onCloseError() {
            this.devMode && (this.error = null)
        }
    }
});
const gde = {
    id: "knime-ui"
};
function vde(e, t, n, r, o, i) {
    const s = B("Error"),
    a = B("AppHeader"),
    l = B("DynamicEnvRenderer"),
    c = B("HotkeyHandler"),
    u = B("RouterView"),
    f = B("SmartLoader"),
    p = B("UpdateBanner"),
    m = B("CreateWorkflowModal"),
    v = B("ToastStack"),
    y = B("BlockUi");
    return _(),
    O("div", gde, [e.error ? (_(), H(s, Bt({
                        key: 0
                    }, e.error, {
                        onClose: e.onCloseError
                    }), null, 16, ["onClose"])) : J("", !0), z(l, {
                value: "DESKTOP"
            }, {
            default:
                oe(() => [z(a, {
                            id: "app-header"
                        })]),
                _: 1
            }), z(c), e.loaded ? (_(), O("div", {
                    key: 1,
                    class: he([e.$route.meta.showUpdateBanner && e.availableUpdates ? "main-content-with-banner" : "main-content", e.environment.toLowerCase()])
                }, [z(u)], 2)) : J("", !0), z(f, {
                loading: e.globalLoader.loading,
                text: e.globalLoader.text,
                config: e.globalLoader.config
            }, null, 8, ["loading", "text", "config"]), e.$route.meta.showUpdateBanner ? (_(), H(p, {
                    key: 2,
                    "available-updates": e.availableUpdates
                }, null, 8, ["available-updates"])) : J("", !0), z(m), z(v, {
                class: "toast-stack"
            }), z(y)])
}
const yde = te(mde, [["render", vde], ["__scopeId", "data-v-4a9ed3b3"]]);
var Gk = {}, wde = {
    get exports() {
        return Gk
    },
    set exports(e) {
        Gk = e
    }
};
(function (e, t) {
    (function (n, r) {
        e.exports = r()
    })(Mt, function () {
        function n(x, S) {
            if (!(x instanceof S))
                throw new TypeError("Cannot call a class as a function")
        }
        function r(x, S) {
            for (var T = 0; T < S.length; T++) {
                var E = S[T];
                E.enumerable = E.enumerable || !1,
                E.configurable = !0,
                "value" in E && (E.writable = !0),
                Object.defineProperty(x, E.key, E)
            }
        }
        function o(x, S, T) {
            return S && r(x.prototype, S),
            T && r(x, T),
            x
        }
        function i(x, S, T) {
            return S in x ? Object.defineProperty(x, S, {
                value: T,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : x[S] = T,
            x
        }
        function s(x, S) {
            var T = Object.keys(x);
            if (Object.getOwnPropertySymbols) {
                var E = Object.getOwnPropertySymbols(x);
                S && (E = E.filter(function (M) {
                        return Object.getOwnPropertyDescriptor(x, M).enumerable
                    })),
                T.push.apply(T, E)
            }
            return T
        }
        function a(x) {
            for (var S = 1; S < arguments.length; S++) {
                var T = arguments[S] != null ? arguments[S] : {};
                S % 2 ? s(Object(T), !0).forEach(function (E) {
                    i(x, E, T[E])
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(x, Object.getOwnPropertyDescriptors(T)) : s(Object(T)).forEach(function (E) {
                    Object.defineProperty(x, E, Object.getOwnPropertyDescriptor(T, E))
                })
            }
            return x
        }
        function l(x) {
            return function (S) {
                if (Array.isArray(S))
                    return u(S)
            }
            (x) || function (S) {
                if (typeof Symbol < "u" && Symbol.iterator in Object(S))
                    return Array.from(S)
            }
            (x) || c(x) || function () {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            }
            ()
        }
        function c(x, S) {
            if (x) {
                if (typeof x == "string")
                    return u(x, S);
                var T = Object.prototype.toString.call(x).slice(8, -1);
                return T === "Object" && x.constructor && (T = x.constructor.name),
                T === "Map" || T === "Set" ? Array.from(x) : T === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(T) ? u(x, S) : void 0
            }
        }
        function u(x, S) {
            (S == null || S > x.length) && (S = x.length);
            for (var T = 0, E = new Array(S); T < S; T++)
                E[T] = x[T];
            return E
        }
        function f(x) {
            if (typeof Symbol > "u" || x[Symbol.iterator] == null) {
                if (Array.isArray(x) || (x = c(x))) {
                    var S = 0,
                    T = function () {};
                    return {
                        s: T,
                        n: function () {
                            return S >= x.length ? {
                                done: !0
                            }
                             : {
                                done: !1,
                                value: x[S++]
                            }
                        },
                        e: function (K) {
                            throw K
                        },
                        f: T
                    }
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            }
            var E,
            M,
            N = !0,
            F = !1;
            return {
                s: function () {
                    E = x[Symbol.iterator]()
                },
                n: function () {
                    var K = E.next();
                    return N = K.done,
                    K
                },
                e: function (K) {
                    F = !0,
                    M = K
                },
                f: function () {
                    try {
                        N || E.return == null || E.return()
                    } finally {
                        if (F)
                            throw M
                    }
                }
            }
        }
        var p = {};
        p[p.Fatal = 0] = "Fatal",
        p[p.Error = 0] = "Error",
        p[p.Warn = 1] = "Warn",
        p[p.Log = 2] = "Log",
        p[p.Info = 3] = "Info",
        p[p.Success = 3] = "Success",
        p[p.Debug = 4] = "Debug",
        p[p.Trace = 5] = "Trace",
        p[p.Silent = -1 / 0] = "Silent",
        p[p.Verbose = 1 / 0] = "Verbose";
        var m = {
            silent: {
                level: -1
            },
            fatal: {
                level: p.Fatal
            },
            error: {
                level: p.Error
            },
            warn: {
                level: p.Warn
            },
            log: {
                level: p.Log
            },
            info: {
                level: p.Info
            },
            success: {
                level: p.Success
            },
            debug: {
                level: p.Debug
            },
            trace: {
                level: p.Trace
            },
            verbose: {
                level: p.Trace
            },
            ready: {
                level: p.Info
            },
            start: {
                level: p.Info
            }
        };
        function v(x) {
            return S = x,
            Object.prototype.toString.call(S) === "[object Object]" && !(!x.message && !x.args) && !x.stack;
            var S
        }
        var y = !1,
        b = [],
        w = function () {
            function x() {
                var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                for (var T in n(this, x), this._reporters = S.reporters || [], this._types = S.types || m, this.level = S.level !== void 0 ? S.level : 3, this._defaults = S.defaults || {}, this._async = S.async !== void 0 ? S.async : void 0, this._stdout = S.stdout, this._stderr = S.stderr, this._mockFn = S.mockFn, this._throttle = S.throttle || 1e3, this._throttleMin = S.throttleMin || 5, this._types) {
                    var E = a(a({
                                type: T
                            }, this._types[T]), this._defaults);
                    this[T] = this._wrapLogFn(E),
                    this[T].raw = this._wrapLogFn(E, !0)
                }
                this._mockFn && this.mockTypes(),
                this._lastLogSerialized = void 0,
                this._lastLog = void 0,
                this._lastLogTime = void 0,
                this._lastLogCount = 0,
                this._throttleTimeout = void 0
            }
            return o(x, [{
                        key: "create",
                        value: function (S) {
                            return new x(Object.assign({
                                    reporters: this._reporters,
                                    level: this.level,
                                    types: this._types,
                                    defaults: this._defaults,
                                    stdout: this._stdout,
                                    stderr: this._stderr,
                                    mockFn: this._mockFn
                                }, S))
                        }
                    }, {
                        key: "withDefaults",
                        value: function (S) {
                            return this.create({
                                defaults: Object.assign({}, this._defaults, S)
                            })
                        }
                    }, {
                        key: "withTag",
                        value: function (S) {
                            return this.withDefaults({
                                tag: this._defaults.tag ? this._defaults.tag + ":" + S : S
                            })
                        }
                    }, {
                        key: "addReporter",
                        value: function (S) {
                            return this._reporters.push(S),
                            this
                        }
                    }, {
                        key: "removeReporter",
                        value: function (S) {
                            if (S) {
                                var T = this._reporters.indexOf(S);
                                if (T >= 0)
                                    return this._reporters.splice(T, 1)
                            } else
                                this._reporters.splice(0);
                            return this
                        }
                    }, {
                        key: "setReporters",
                        value: function (S) {
                            return this._reporters = Array.isArray(S) ? S : [S],
                            this
                        }
                    }, {
                        key: "wrapAll",
                        value: function () {
                            this.wrapConsole(),
                            this.wrapStd()
                        }
                    }, {
                        key: "restoreAll",
                        value: function () {
                            this.restoreConsole(),
                            this.restoreStd()
                        }
                    }, {
                        key: "wrapConsole",
                        value: function () {
                            for (var S in this._types)
                                console["__" + S] || (console["__" + S] = console[S]), console[S] = this[S].raw
                        }
                    }, {
                        key: "restoreConsole",
                        value: function () {
                            for (var S in this._types)
                                console["__" + S] && (console[S] = console["__" + S], delete console["__" + S])
                        }
                    }, {
                        key: "wrapStd",
                        value: function () {
                            this._wrapStream(this.stdout, "log"),
                            this._wrapStream(this.stderr, "log")
                        }
                    }, {
                        key: "_wrapStream",
                        value: function (S, T) {
                            var E = this;
                            S && (S.__write || (S.__write = S.write), S.write = function (M) {
                                E[T].raw(String(M).trim())
                            })
                        }
                    }, {
                        key: "restoreStd",
                        value: function () {
                            this._restoreStream(this.stdout),
                            this._restoreStream(this.stderr)
                        }
                    }, {
                        key: "_restoreStream",
                        value: function (S) {
                            S && S.__write && (S.write = S.__write, delete S.__write)
                        }
                    }, {
                        key: "pauseLogs",
                        value: function () {
                            y = !0
                        }
                    }, {
                        key: "resumeLogs",
                        value: function () {
                            y = !1;
                            var S,
                            T = f(b.splice(0));
                            try {
                                for (T.s(); !(S = T.n()).done; ) {
                                    var E = S.value;
                                    E[0]._logFn(E[1], E[2])
                                }
                            } catch (M) {
                                T.e(M)
                            } finally {
                                T.f()
                            }
                        }
                    }, {
                        key: "mockTypes",
                        value: function (S) {
                            if (this._mockFn = S || this._mockFn, typeof this._mockFn == "function")
                                for (var T in this._types)
                                    this[T] = this._mockFn(T, this._types[T]) || this[T], this[T].raw = this[T]
                        }
                    }, {
                        key: "_wrapLogFn",
                        value: function (S, T) {
                            var E = this;
                            return function () {
                                for (var M = arguments.length, N = new Array(M), F = 0; F < M; F++)
                                    N[F] = arguments[F];
                                if (!y)
                                    return E._logFn(S, N, T);
                                b.push([E, S, N, T])
                            }
                        }
                    }, {
                        key: "_logFn",
                        value: function (S, T, E) {
                            var M = this;
                            if (S.level > this.level)
                                return !!this._async && Promise.resolve(!1);
                            var N = Object.assign({
                                date: new Date,
                                args: []
                            }, S);
                            !E && T.length === 1 && v(T[0]) ? Object.assign(N, T[0]) : N.args = Array.from(T),
                            N.message && (N.args.unshift(N.message), delete N.message),
                            N.additional && (Array.isArray(N.additional) || (N.additional = N.additional.split(`
                                            `)), N.args.push(`
                                    ` + N.additional.join(`
`)), delete N.additional),
                            N.type = typeof N.type == "string" ? N.type.toLowerCase() : "",
                            N.tag = typeof N.tag == "string" ? N.tag.toLowerCase() : "";
                            var F = function () {
                                var Y = arguments.length > 0 && arguments[0] !== void 0 && arguments[0],
                                ue = M._lastLogCount - M._throttleMin;
                                if (M._lastLog && ue > 0) {
                                    var re = l(M._lastLog.args);
                                    ue > 1 && re.push("(repeated ".concat(ue, " times)")),
                                    M._log(a(a({}, M._lastLog), {}, {
                                            args: re
                                        })),
                                    M._lastLogCount = 1
                                }
                                if (Y) {
                                    if (M._lastLog = N, M._async)
                                        return M._logAsync(N);
                                    M._log(N)
                                }
                            };
                            clearTimeout(this._throttleTimeout);
                            var K = this._lastLogTime ? N.date - this._lastLogTime : 0;
                            if (this._lastLogTime = N.date, K < this._throttle)
                                try {
                                    var j = JSON.stringify([N.type, N.tag, N.args]),
                                    G = this._lastLogSerialized === j;
                                    if (this._lastLogSerialized = j, G && (this._lastLogCount++, this._lastLogCount > this._throttleMin))
                                        return void(this._throttleTimeout = setTimeout(F, this._throttle))
                                } catch {}
                            F(!0)
                        }
                    }, {
                        key: "_log",
                        value: function (S) {
                            var T,
                            E = f(this._reporters);
                            try {
                                for (E.s(); !(T = E.n()).done; )
                                    T.value.log(S, {
                                        async: !1,
                                        stdout: this.stdout,
                                        stderr: this.stderr
                                    })
                            } catch (M) {
                                E.e(M)
                            } finally {
                                E.f()
                            }
                        }
                    }, {
                        key: "_logAsync",
                        value: function (S) {
                            var T = this;
                            return Promise.all(this._reporters.map(function (E) {
                                    return E.log(S, {
                                        async: !0,
                                        stdout: T.stdout,
                                        stderr: T.stderr
                                    })
                                }))
                        }
                    }, {
                        key: "stdout",
                        get: function () {
                            return this._stdout || console._stdout
                        }
                    }, {
                        key: "stderr",
                        get: function () {
                            return this._stderr || console._stderr
                        }
                    }
                ]),
            x
        }
        ();
        w.prototype.add = w.prototype.addReporter,
        w.prototype.remove = w.prototype.removeReporter,
        w.prototype.clear = w.prototype.removeReporter,
        w.prototype.withScope = w.prototype.withTag,
        w.prototype.mock = w.prototype.mockTypes,
        w.prototype.pause = w.prototype.pauseLogs,
        w.prototype.resume = w.prototype.resumeLogs;
        var k,
        C = function () {
            function x(S) {
                n(this, x),
                this.options = Object.assign({}, S),
                this.defaultColor = "#7f8c8d",
                this.levelColorMap = {
                    0: "#c0392b",
                    1: "#f39c12",
                    3: "#00BCD4"
                },
                this.typeColorMap = {
                    success: "#2ecc71"
                }
            }
            return o(x, [{
                        key: "log",
                        value: function (S) {
                            var T = S.level < 1 ? console.__error || console.error : S.level === 1 && console.warn ? console.__warn || console.warn : console.__log || console.log,
                            E = S.type !== "log" ? S.type : "",
                            M = S.tag ? S.tag : "",
                            N = this.typeColorMap[S.type] || this.levelColorMap[S.level] || this.defaultColor,
                            F = `
      background: `.concat(N, `;
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `),
                            K = "%c".concat([M, E].filter(Boolean).join(":"));
                            typeof S.args[0] == "string" ? T.apply(void 0, ["".concat(K, "%c ").concat(S.args[0]), F, ""].concat(l(S.args.slice(1)))) : T.apply(void 0, [K, F].concat(l(S.args)))
                        }
                    }
                ]),
            x
        }
        ();
        return typeof window < "u" && window.consola || ((k = new w({
                    reporters: [new C]
                })).Consola = w, k.LogLevel = p, k.BrowserReporter = C, k)
    })
})(wde);
const NO = Gk, bde = () => {
    const e = function () {},
    t = ["debug", "error", "fatal", "info", "log", "ready", "silent", "start", "success", "trace", "verbose", "warn"];
    window.consola = t.reduce((n, r) => (n[r] = e, n), {})
}, _de = () => {
    bde()
}, an = e => {
    const {
        activeWorkflow: {
            projectId: t,
            info: {
                containerId: n
            }
        }
    } = e;
    return {
        projectId: t,
        workflowId: n
    }
}, t8 = ({
    openProjects: e,
    activeProjectId: t,
    closingProjectIds: n
}) => {
    if (!n.includes(t))
        return t;
    if (e.length === 1)
        return null;
    const r = e.filter(o => !n.includes(o.projectId));
    return r.length === 0 ? null : r.at(-1).projectId
}, fr = 32, _i = 9, kde = 20, AC = 12, DC = 8, xde = 50, NC = 8, Sde = 7, n8 = 14, Cde = 12, r8 = 2, Ide = 4, Tde = 2, o8 = 37 - (n8 + r8 * 2), cw = 34, uw = 34, i8 = 6, Mde = [o8, cw, i8, uw], Pde = (cw + fr + uw) * 1.7, RC = cw + uw + fr, Ede = fr + NC, Ode = fr + NC + (AC + DC), $de = RC / 2 - (AC + DC + 2), Ade = RC / 2 - 2, Dde = 10, Nde = [29, 19, 8, 19], Rde = 15, Lde = 16, Bde = 25, Vde = .75, Fde = 12, jde = 1, Wde = 2, zde = 3, Hde = 3, Ude = 2, qde = 12, Yde = 540, Kde = 200, s8 = 1e3, s0 = 50, LC = 10, Gde = 13, a8 = 500, BC = {
    x: 5,
    y: 5
}, Xde = 4, Jde = 1, Zde = 2, Qde = 1.3333, efe = 300, l8 = 60, dw = Object.freeze(Object.defineProperty({
            __proto__: null,
            addNodeGhostSize: kde,
            annotationToolbarContainerHeight: l8,
            annotationToolbarContainerWidth: efe,
            annotationsFontSizePointToPixelFactor: Qde,
            autoPositionMetanodeMargin: s0,
            componentBackgroundPortion: Vde,
            connectorWidth: jde,
            defaultMetaNodeBarHeight: a8,
            defaultMetanodeBarPosition: s8,
            gridSize: BC,
            highlightedConnectorWidth: Wde,
            horizontalNodePadding: xde,
            maxNodeNameWidth: Pde,
            metaNodeBarHorizontalPadding: Gde,
            metaNodeBarWidth: LC,
            metanodeLabelActionBarOffset: $de,
            metanodeLabelOffsetY: Ede,
            nodeActionBarButtonSpread: Bde,
            nodeAnnotationMarginTop: NC,
            nodeAnnotationPadding: Ude,
            nodeHoverMargin: Nde,
            nodeHoverPortBottomMargin: Rde,
            nodeIdMargin: Lde,
            nodeLabelActionBarOffset: Ade,
            nodeLabelOffsetY: Ode,
            nodeNameEditorMinWidth: Dde,
            nodeNameFontSize: Cde,
            nodeNameHorizontalMargin: Ide,
            nodeNameLineHeight: n8,
            nodeNameMargin: Sde,
            nodeNameMaxLines: Tde,
            nodeNamePadding: r8,
            nodeSelectionBarHeight: Fde,
            nodeSelectionPadding: Mde,
            nodeSelectionPaddingBottom: i8,
            nodeSelectionPaddingLeft: cw,
            nodeSelectionPaddingRight: uw,
            nodeSelectionPaddingTop: o8,
            nodeSize: fr,
            nodeStatusHeight: AC,
            nodeStatusMarginTop: DC,
            nodeWidthWithPadding: RC,
            portSize: _i,
            selectedAnnotationStrokeWidth: Zde,
            selectedConnectorWidth: zde,
            selectedItemBorderRadius: Xde,
            selectedNodeStrokeWidth: Jde,
            tooltipArrowSize: qde,
            tooltipMaxHeight: Kde,
            tooltipMaxWidth: Yde,
            workflowAnnotationPadding: Hde
        }, Symbol.toStringTag, {
            value: "Module"
        }));
function Va(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function c8(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    e.__proto__ = t
}
/*!
 * GSAP 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Si = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, bf = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, VC, uo, ur, Yi = 1e8, An = 1 / Yi, Xk = Math.PI * 2, tfe = Xk / 4, nfe = 0, u8 = Math.sqrt, rfe = Math.cos, ofe = Math.sin, Wr = function (t) {
    return typeof t == "string"
}, hr = function (t) {
    return typeof t == "function"
}, Xa = function (t) {
    return typeof t == "number"
}, FC = function (t) {
    return typeof t > "u"
}, da = function (t) {
    return typeof t == "object"
}, qo = function (t) {
    return t !== !1
}, jC = function () {
    return typeof window < "u"
}, Tv = function (t) {
    return hr(t) || Wr(t)
}, d8 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () {}, fo = Array.isArray, Jk = /(?:-?\.?\d|\.)+/gi, f8 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Fd = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, L_ = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, h8 = /[+-]=-?[.\d]+/, p8 = /[^,'"\[\]\s]+/gi, ife = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, nr, Wi, Zk, WC, Ii = {}, K0 = {}, m8, g8 = function (t) {
    return (K0 = Ou(t, Ii)) && ni
}, zC = function (t, n) {
    return console.warn("Invalid property", t, "set to", n, "Missing plugin? gsap.registerPlugin()")
}, G0 = function (t, n) {
    return !n && console.warn(t)
}, v8 = function (t, n) {
    return t && (Ii[t] = n) && K0 && (K0[t] = n) || Ii
}, fm = function () {
    return 0
}, sfe = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, a0 = {
    suppressEvents: !0,
    kill: !1
}, afe = {
    suppressEvents: !0
}, HC = {}, Ul = [], Qk = {}, y8, gi = {}, B_ = {}, RO = 30, l0 = [], UC = "", qC = function (t) {
    var n = t[0],
    r,
    o;
    if (da(n) || hr(n) || (t = [t]), !(r = (n._gsap || {}).harness)) {
        for (o = l0.length; o-- && !l0[o].targetTest(n); );
        r = l0[o]
    }
    for (o = t.length; o--; )
        t[o] && (t[o]._gsap || (t[o]._gsap = new W8(t[o], r))) || t.splice(o, 1);
    return t
}, au = function (t) {
    return t._gsap || qC(Ki(t))[0]._gsap
}, w8 = function (t, n, r) {
    return (r = t[n]) && hr(r) ? t[n]() : FC(r) && t.getAttribute && t.getAttribute(n) || r
}, Yo = function (t, n) {
    return (t = t.split(",")).forEach(n) || t
}, wr = function (t) {
    return Math.round(t * 1e5) / 1e5 || 0
}, Xr = function (t) {
    return Math.round(t * 1e7) / 1e7 || 0
}, rf = function (t, n) {
    var r = n.charAt(0),
    o = parseFloat(n.substr(2));
    return t = parseFloat(t),
    r === "+" ? t + o : r === "-" ? t - o : r === "*" ? t * o : t / o
}, lfe = function (t, n) {
    for (var r = n.length, o = 0; t.indexOf(n[o]) < 0 && ++o < r; );
    return o < r
}, X0 = function () {
    var t = Ul.length,
    n = Ul.slice(0),
    r,
    o;
    for (Qk = {}, Ul.length = 0, r = 0; r < t; r++)
        o = n[r], o && o._lazy && (o.render(o._lazy[0], o._lazy[1], !0)._lazy = 0)
}, b8 = function (t, n, r, o) {
    Ul.length && !uo && X0(),
    t.render(n, r, o || uo && n < 0 && (t._initted || t._startAt)),
    Ul.length && !uo && X0()
}, _8 = function (t) {
    var n = parseFloat(t);
    return (n || n === 0) && (t + "").match(p8).length < 2 ? n : Wr(t) ? t.trim() : t
}, k8 = function (t) {
    return t
}, ts = function (t, n) {
    for (var r in n)
        r in t || (t[r] = n[r]);
    return t
}, cfe = function (t) {
    return function (n, r) {
        for (var o in r)
            o in n || o === "duration" && t || o === "ease" || (n[o] = r[o])
    }
}, Ou = function (t, n) {
    for (var r in n)
        t[r] = n[r];
    return t
}, LO = function e(t, n) {
    for (var r in n)
        r !== "__proto__" && r !== "constructor" && r !== "prototype" && (t[r] = da(n[r]) ? e(t[r] || (t[r] = {}), n[r]) : n[r]);
    return t
}, J0 = function (t, n) {
    var r = {},
    o;
    for (o in t)
        o in n || (r[o] = t[o]);
    return r
}, Pp = function (t) {
    var n = t.parent || nr,
    r = t.keyframes ? cfe(fo(t.keyframes)) : ts;
    if (qo(t.inherit))
        for (; n; )
            r(t, n.vars.defaults), n = n.parent || n._dp;
    return t
}, ufe = function (t, n) {
    for (var r = t.length, o = r === n.length; o && r-- && t[r] === n[r]; );
    return r < 0
}, x8 = function (t, n, r, o, i) {
    r === void 0 && (r = "_first"),
    o === void 0 && (o = "_last");
    var s = t[o],
    a;
    if (i)
        for (a = n[i]; s && s[i] > a; )
            s = s._prev;
    return s ? (n._next = s._next, s._next = n) : (n._next = t[r], t[r] = n),
    n._next ? n._next._prev = n : t[o] = n,
    n._prev = s,
    n.parent = n._dp = t,
    n
}, fw = function (t, n, r, o) {
    r === void 0 && (r = "_first"),
    o === void 0 && (o = "_last");
    var i = n._prev,
    s = n._next;
    i ? i._next = s : t[r] === n && (t[r] = s),
    s ? s._prev = i : t[o] === n && (t[o] = i),
    n._next = n._prev = n.parent = null
}, ic = function (t, n) {
    t.parent && (!n || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t),
    t._act = 0
}, lu = function (t, n) {
    if (t && (!n || n._end > t._dur || n._start < 0))
        for (var r = t; r; )
            r._dirty = 1, r = r.parent;
    return t
}, dfe = function (t) {
    for (var n = t.parent; n && n.parent; )
        n._dirty = 1, n.totalDuration(), n = n.parent;
    return t
}, ex = function (t, n, r, o) {
    return t._startAt && (uo ? t._startAt.revert(a0) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(n, !0, o))
}, ffe = function e(t) {
    return !t || t._ts && e(t.parent)
}, BO = function (t) {
    return t._repeat ? _f(t._tTime, t = t.duration() + t._rDelay) * t : 0
}, _f = function (t, n) {
    var r = Math.floor(t /= n);
    return t && r === t ? r - 1 : r
}, Z0 = function (t, n) {
    return (t - n._start) * n._ts + (n._ts >= 0 ? 0 : n._dirty ? n.totalDuration() : n._tDur)
}, hw = function (t) {
    return t._end = Xr(t._start + (t._tDur / Math.abs(t._ts || t._rts || An) || 0))
}, pw = function (t, n) {
    var r = t._dp;
    return r && r.smoothChildTiming && t._ts && (t._start = Xr(r._time - (t._ts > 0 ? n / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - n) / -t._ts)), hw(t), r._dirty || lu(r, t)),
    t
}, S8 = function (t, n) {
    var r;
    if ((n._time || !n._dur && n._initted || n._start < t._time && (n._dur || !n.add)) && (r = Z0(t.rawTime(), n), (!n._dur || ug(0, n.totalDuration(), r) - n._tTime > An) && n.render(r, !0)), lu(t, n)._dp && t._initted && t._time >= t._dur && t._ts) {
        if (t._dur < t.duration())
            for (r = t; r._dp; )
                r.rawTime() >= 0 && r.totalTime(r._tTime), r = r._dp;
        t._zTime = -An
    }
}, Gs = function (t, n, r, o) {
    return n.parent && ic(n),
    n._start = Xr((Xa(r) ? r : r || t !== nr ? ji(t, r, n) : t._time) + n._delay),
    n._end = Xr(n._start + (n.totalDuration() / Math.abs(n.timeScale()) || 0)),
    x8(t, n, "_first", "_last", t._sort ? "_start" : 0),
    tx(n) || (t._recent = n),
    o || S8(t, n),
    t._ts < 0 && pw(t, t._tTime),
    t
}, C8 = function (t, n) {
    return (Ii.ScrollTrigger || zC("scrollTrigger", n)) && Ii.ScrollTrigger.create(n, t)
}, I8 = function (t, n, r, o, i) {
    if (KC(t, n, i), !t._initted)
        return 1;
    if (!r && t._pt && !uo && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && y8 !== ki.frame)
        return Ul.push(t), t._lazy = [i, o], 1
}, hfe = function e(t) {
    var n = t.parent;
    return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
}, tx = function (t) {
    var n = t.data;
    return n === "isFromStart" || n === "isStart"
}, pfe = function (t, n, r, o) {
    var i = t.ratio,
    s = n < 0 || !n && (!t._start && hfe(t) && !(!t._initted && tx(t)) || (t._ts < 0 || t._dp._ts < 0) && !tx(t)) ? 0 : 1,
    a = t._rDelay,
    l = 0,
    c,
    u,
    f;
    if (a && t._repeat && (l = ug(0, t._tDur, n), u = _f(l, a), t._yoyo && u & 1 && (s = 1 - s), u !== _f(t._tTime, a) && (i = 1 - s, t.vars.repeatRefresh && t._initted && t.invalidate())), s !== i || uo || o || t._zTime === An || !n && t._zTime) {
        if (!t._initted && I8(t, n, o, r, l))
            return;
        for (f = t._zTime, t._zTime = n || (r ? An : 0), r || (r = n && !f), t.ratio = s, t._from && (s = 1 - s), t._time = 0, t._tTime = l, c = t._pt; c; )
            c.r(s, c.d), c = c._next;
        n < 0 && ex(t, n, r, !0),
        t._onUpdate && !r && Gi(t, "onUpdate"),
        l && t._repeat && !r && t.parent && Gi(t, "onRepeat"),
        (n >= t._tDur || n < 0) && t.ratio === s && (s && ic(t, 1), !r && !uo && (Gi(t, s ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
    } else
        t._zTime || (t._zTime = n)
}, mfe = function (t, n, r) {
    var o;
    if (r > n)
        for (o = t._first; o && o._start <= r; ) {
            if (o.data === "isPause" && o._start > n)
                return o;
            o = o._next
        }
    else
        for (o = t._last; o && o._start >= r; ) {
            if (o.data === "isPause" && o._start < n)
                return o;
            o = o._prev
        }
}, kf = function (t, n, r, o) {
    var i = t._repeat,
    s = Xr(n) || 0,
    a = t._tTime / t._tDur;
    return a && !o && (t._time *= s / t._dur),
    t._dur = s,
    t._tDur = i ? i < 0 ? 1e10 : Xr(s * (i + 1) + t._rDelay * i) : s,
    a > 0 && !o && pw(t, t._tTime = t._tDur * a),
    t.parent && hw(t),
    r || lu(t.parent, t),
    t
}, VO = function (t) {
    return t instanceof Wo ? lu(t) : kf(t, t._dur)
}, gfe = {
    _start: 0,
    endTime: fm,
    totalDuration: fm
}, ji = function e(t, n, r) {
    var o = t.labels,
    i = t._recent || gfe,
    s = t.duration() >= Yi ? i.endTime(!1) : t._dur,
    a,
    l,
    c;
    return Wr(n) && (isNaN(n) || n in o) ? (l = n.charAt(0), c = n.substr(-1) === "%", a = n.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (n = n.replace(/=/, "")), (l === "<" ? i._start : i.endTime(i._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (c ? (a < 0 ? i : r).totalDuration() / 100 : 1)) : a < 0 ? (n in o || (o[n] = s), o[n]) : (l = parseFloat(n.charAt(a - 1) + n.substr(a + 1)), c && r && (l = l / 100 * (fo(r) ? r[0] : r).totalDuration()), a > 1 ? e(t, n.substr(0, a - 1), r) + l : s + l)) : n == null ? s : +n
}, Ep = function (t, n, r) {
    var o = Xa(n[1]),
    i = (o ? 2 : 1) + (t < 2 ? 0 : 1),
    s = n[i],
    a,
    l;
    if (o && (s.duration = n[1]), s.parent = r, t) {
        for (a = s, l = r; l && !("immediateRender" in a); )
            a = l.vars.defaults || {},
        l = qo(l.vars.inherit) && l.parent;
        s.immediateRender = qo(a.immediateRender),
        t < 2 ? s.runBackwards = 1 : s.startAt = n[i - 1]
    }
    return new Tr(n[0], s, n[i + 1])
}, pc = function (t, n) {
    return t || t === 0 ? n(t) : n
}, ug = function (t, n, r) {
    return r < t ? t : r > n ? n : r
}, co = function (t, n) {
    return !Wr(t) || !(n = ife.exec(t)) ? "" : n[1]
}, vfe = function (t, n, r) {
    return pc(r, function (o) {
        return ug(t, n, o)
    })
}, nx = [].slice, T8 = function (t, n) {
    return t && da(t) && "length" in t && (!n && !t.length || t.length - 1 in t && da(t[0])) && !t.nodeType && t !== Wi
}, yfe = function (t, n, r) {
    return r === void 0 && (r = []),
    t.forEach(function (o) {
        var i;
        return Wr(o) && !n || T8(o, 1) ? (i = r).push.apply(i, Ki(o)) : r.push(o)
    }) || r
}, Ki = function (t, n, r) {
    return ur && !n && ur.selector ? ur.selector(t) : Wr(t) && !r && (Zk || !xf()) ? nx.call((n || WC).querySelectorAll(t), 0) : fo(t) ? yfe(t, r) : T8(t) ? nx.call(t, 0) : t ? [t] : []
}, rx = function (t) {
    return t = Ki(t)[0] || G0("Invalid scope") || {},
    function (n) {
        var r = t.current || t.nativeElement || t;
        return Ki(n, r.querySelectorAll ? r : r === t ? G0("Invalid scope") || WC.createElement("div") : t)
    }
}, M8 = function (t) {
    return t.sort(function () {
        return .5 - Math.random()
    })
}, P8 = function (t) {
    if (hr(t))
        return t;
    var n = da(t) ? t : {
        each: t
    },
    r = cu(n.ease),
    o = n.from || 0,
    i = parseFloat(n.base) || 0,
    s = {},
    a = o > 0 && o < 1,
    l = isNaN(o) || a,
    c = n.axis,
    u = o,
    f = o;
    return Wr(o) ? u = f = {
        center: .5,
        edges: .5,
        end: 1
    }
    [o] || 0 : !a && l && (u = o[0], f = o[1]),
    function (p, m, v) {
        var y = (v || n).length,
        b = s[y],
        w,
        k,
        C,
        x,
        S,
        T,
        E,
        M,
        N;
        if (!b) {
            if (N = n.grid === "auto" ? 0 : (n.grid || [1, Yi])[1], !N) {
                for (E = -Yi; E < (E = v[N++].getBoundingClientRect().left) && N < y; );
                N--
            }
            for (b = s[y] = [], w = l ? Math.min(N, y) * u - .5 : o % N, k = N === Yi ? 0 : l ? y * f / N - .5 : o / N | 0, E = 0, M = Yi, T = 0; T < y; T++)
                C = T % N - w, x = k - (T / N | 0), b[T] = S = c ? Math.abs(c === "y" ? x : C) : u8(C * C + x * x), S > E && (E = S), S < M && (M = S);
            o === "random" && M8(b),
            b.max = E - M,
            b.min = M,
            b.v = y = (parseFloat(n.amount) || parseFloat(n.each) * (N > y ? y - 1 : c ? c === "y" ? y / N : N : Math.max(N, y / N)) || 0) * (o === "edges" ? -1 : 1),
            b.b = y < 0 ? i - y : i,
            b.u = co(n.amount || n.each) || 0,
            r = r && y < 0 ? V8(r) : r
        }
        return y = (b[p] - b.min) / b.max || 0,
        Xr(b.b + (r ? r(y) : y) * b.v) + b.u
    }
}, ox = function (t) {
    var n = Math.pow(10, ((t + "").split(".")[1] || "").length);
    return function (r) {
        var o = Xr(Math.round(parseFloat(r) / t) * t * n);
        return (o - o % 1) / n + (Xa(r) ? 0 : co(r))
    }
}, E8 = function (t, n) {
    var r = fo(t),
    o,
    i;
    return !r && da(t) && (o = r = t.radius || Yi, t.values ? (t = Ki(t.values), (i = !Xa(t[0])) && (o *= o)) : t = ox(t.increment)),
    pc(n, r ? hr(t) ? function (s) {
        return i = t(s),
        Math.abs(i - s) <= o ? i : s
    }
         : function (s) {
        for (var a = parseFloat(i ? s.x : s), l = parseFloat(i ? s.y : 0), c = Yi, u = 0, f = t.length, p, m; f--; )
            i ? (p = t[f].x - a, m = t[f].y - l, p = p * p + m * m) : p = Math.abs(t[f] - a), p < c && (c = p, u = f);
        return u = !o || c <= o ? t[u] : s,
        i || u === s || Xa(s) ? u : u + co(s)
    }
         : ox(t))
}, O8 = function (t, n, r, o) {
    return pc(fo(t) ? !n : r === !0 ? !!(r = 0) : !o, function () {
        return fo(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (o = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((t - r / 2 + Math.random() * (n - t + r * .99)) / r) * r * o) / o
    })
}, wfe = function () {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
        n[r] = arguments[r];
    return function (o) {
        return n.reduce(function (i, s) {
            return s(i)
        }, o)
    }
}, bfe = function (t, n) {
    return function (r) {
        return t(parseFloat(r)) + (n || co(r))
    }
}, _fe = function (t, n, r) {
    return A8(t, n, 0, 1, r)
}, $8 = function (t, n, r) {
    return pc(r, function (o) {
        return t[~~n(o)]
    })
}, kfe = function e(t, n, r) {
    var o = n - t;
    return fo(t) ? $8(t, e(0, t.length), n) : pc(r, function (i) {
        return (o + (i - t) % o) % o + t
    })
}, xfe = function e(t, n, r) {
    var o = n - t,
    i = o * 2;
    return fo(t) ? $8(t, e(0, t.length - 1), n) : pc(r, function (s) {
        return s = (i + (s - t) % i) % i || 0,
        t + (s > o ? i - s : s)
    })
}, hm = function (t) {
    for (var n = 0, r = "", o, i, s, a; ~(o = t.indexOf("random(", n)); )
        s = t.indexOf(")", o), a = t.charAt(o + 7) === "[", i = t.substr(o + 7, s - o - 7).match(a ? p8 : Jk), r += t.substr(n, o - n) + O8(a ? i : +i[0], a ? 0 : +i[1], +i[2] || 1e-5), n = s + 1;
    return r + t.substr(n, t.length - n)
}, A8 = function (t, n, r, o, i) {
    var s = n - t,
    a = o - r;
    return pc(i, function (l) {
        return r + ((l - t) / s * a || 0)
    })
}, Sfe = function e(t, n, r, o) {
    var i = isNaN(t + n) ? 0 : function (m) {
        return (1 - m) * t + m * n
    };
    if (!i) {
        var s = Wr(t),
        a = {},
        l,
        c,
        u,
        f,
        p;
        if (r === !0 && (o = 1) && (r = null), s)
            t = {
                p: t
            },
        n = {
            p: n
        };
        else if (fo(t) && !fo(n)) {
            for (u = [], f = t.length, p = f - 2, c = 1; c < f; c++)
                u.push(e(t[c - 1], t[c]));
            f--,
            i = function (v) {
                v *= f;
                var y = Math.min(p, ~~v);
                return u[y](v - y)
            },
            r = n
        } else
            o || (t = Ou(fo(t) ? [] : {}, t));
        if (!u) {
            for (l in n)
                YC.call(a, t, l, "get", n[l]);
            i = function (v) {
                return JC(v, a) || (s ? t.p : t)
            }
        }
    }
    return pc(r, i)
}, FO = function (t, n, r) {
    var o = t.labels,
    i = Yi,
    s,
    a,
    l;
    for (s in o)
        a = o[s] - n, a < 0 == !!r && a && i > (a = Math.abs(a)) && (l = s, i = a);
    return l
}, Gi = function (t, n, r) {
    var o = t.vars,
    i = o[n],
    s = ur,
    a = t._ctx,
    l,
    c,
    u;
    if (i)
        return l = o[n + "Params"], c = o.callbackScope || t, r && Ul.length && X0(), a && (ur = a), u = l ? i.apply(c, l) : i.call(c), ur = s, u
}, lp = function (t) {
    return ic(t),
    t.scrollTrigger && t.scrollTrigger.kill(!!uo),
    t.progress() < 1 && Gi(t, "onInterrupt"),
    t
}, jd, D8 = [], N8 = function (t) {
    if (jC() && t) {
        t = !t.name && t.default || t;
        var n = t.name,
        r = hr(t),
        o = n && !r && t.init ? function () {
            this._props = []
        }
         : t,
        i = {
            init: fm,
            render: JC,
            add: YC,
            kill: Ffe,
            modifier: Vfe,
            rawVars: 0
        },
        s = {
            targetTest: 0,
            get: 0,
            getSetter: XC,
            aliases: {},
            register: 0
        };
        if (xf(), t !== o) {
            if (gi[n])
                return;
            ts(o, ts(J0(t, i), s)),
            Ou(o.prototype, Ou(i, J0(t, s))),
            gi[o.prop = n] = o,
            t.targetTest && (l0.push(o), HC[n] = 1),
            n = (n === "css" ? "CSS" : n.charAt(0).toUpperCase() + n.substr(1)) + "Plugin"
        }
        v8(n, o),
        t.register && t.register(ni, o, Ko)
    } else
        t && D8.push(t)
}, $n = 255, cp = {
    aqua: [0, $n, $n],
    lime: [0, $n, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, $n],
    navy: [0, 0, 128],
    white: [$n, $n, $n],
    olive: [128, 128, 0],
    yellow: [$n, $n, 0],
    orange: [$n, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [$n, 0, 0],
    pink: [$n, 192, 203],
    cyan: [0, $n, $n],
    transparent: [$n, $n, $n, 0]
}, V_ = function (t, n, r) {
    return t += t < 0 ? 1 : t > 1 ? -1 : 0,
    (t * 6 < 1 ? n + (r - n) * t * 6 : t < .5 ? r : t * 3 < 2 ? n + (r - n) * (2 / 3 - t) * 6 : n) * $n + .5 | 0
}, R8 = function (t, n, r) {
    var o = t ? Xa(t) ? [t >> 16, t >> 8 & $n, t & $n] : 0 : cp.black,
    i,
    s,
    a,
    l,
    c,
    u,
    f,
    p,
    m,
    v;
    if (!o) {
        if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)), cp[t])
            o = cp[t];
        else if (t.charAt(0) === "#") {
            if (t.length < 6 && (i = t.charAt(1), s = t.charAt(2), a = t.charAt(3), t = "#" + i + i + s + s + a + a + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")), t.length === 9)
                return o = parseInt(t.substr(1, 6), 16), [o >> 16, o >> 8 & $n, o & $n, parseInt(t.substr(7), 16) / 255];
            t = parseInt(t.substr(1), 16),
            o = [t >> 16, t >> 8 & $n, t & $n]
        } else if (t.substr(0, 3) === "hsl") {
            if (o = v = t.match(Jk), !n)
                l = +o[0] % 360 / 360, c = +o[1] / 100, u = +o[2] / 100, s = u <= .5 ? u * (c + 1) : u + c - u * c, i = u * 2 - s, o.length > 3 && (o[3] *= 1), o[0] = V_(l + 1 / 3, i, s), o[1] = V_(l, i, s), o[2] = V_(l - 1 / 3, i, s);
            else if (~t.indexOf("="))
                return o = t.match(f8), r && o.length < 4 && (o[3] = 1), o
        } else
            o = t.match(Jk) || cp.transparent;
        o = o.map(Number)
    }
    return n && !v && (i = o[0] / $n, s = o[1] / $n, a = o[2] / $n, f = Math.max(i, s, a), p = Math.min(i, s, a), u = (f + p) / 2, f === p ? l = c = 0 : (m = f - p, c = u > .5 ? m / (2 - f - p) : m / (f + p), l = f === i ? (s - a) / m + (s < a ? 6 : 0) : f === s ? (a - i) / m + 2 : (i - s) / m + 4, l *= 60), o[0] = ~~(l + .5), o[1] = ~~(c * 100 + .5), o[2] = ~~(u * 100 + .5)),
    r && o.length < 4 && (o[3] = 1),
    o
}, L8 = function (t) {
    var n = [],
    r = [],
    o = -1;
    return t.split(ql).forEach(function (i) {
        var s = i.match(Fd) || [];
        n.push.apply(n, s),
        r.push(o += s.length + 1)
    }),
    n.c = r,
    n
}, jO = function (t, n, r) {
    var o = "",
    i = (t + o).match(ql),
    s = n ? "hsla(" : "rgba(",
    a = 0,
    l,
    c,
    u,
    f;
    if (!i)
        return t;
    if (i = i.map(function (p) {
            return (p = R8(p, n, 1)) && s + (n ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")"
        }), r && (u = L8(t), l = r.c, l.join(o) !== u.c.join(o)))
        for (c = t.replace(ql, "1").split(Fd), f = c.length - 1; a < f; a++)
            o += c[a] + (~l.indexOf(a) ? i.shift() || s + "0,0,0,0)" : (u.length ? u : i.length ? i : r).shift());
    if (!c)
        for (c = t.split(ql), f = c.length - 1; a < f; a++)
            o += c[a] + i[a];
    return o + c[f]
}, ql = function () {
    var e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
    t;
    for (t in cp)
        e += "|" + t + "\\b";
    return new RegExp(e + ")", "gi")
}
(), Cfe = /hsl[a]?\(/, B8 = function (t) {
    var n = t.join(" "),
    r;
    if (ql.lastIndex = 0, ql.test(n))
        return r = Cfe.test(n), t[1] = jO(t[1], r), t[0] = jO(t[0], r, L8(t[1])), !0
}, pm, ki = function () {
    var e = Date.now,
    t = 500,
    n = 33,
    r = e(),
    o = r,
    i = 1e3 / 240,
    s = i,
    a = [],
    l,
    c,
    u,
    f,
    p,
    m,
    v = function y(b) {
        var w = e() - o,
        k = b === !0,
        C,
        x,
        S,
        T;
        if (w > t && (r += w - n), o += w, S = o - r, C = S - s, (C > 0 || k) && (T = ++f.frame, p = S - f.time * 1e3, f.time = S = S / 1e3, s += C + (C >= i ? 4 : i - C), x = 1), k || (l = c(y)), x)
            for (m = 0; m < a.length; m++)
                a[m](S, p, T, b)
    };
    return f = {
        time: 0,
        frame: 0,
        tick: function () {
            v(!0)
        },
        deltaRatio: function (b) {
            return p / (1e3 / (b || 60))
        },
        wake: function () {
            m8 && (!Zk && jC() && (Wi = Zk = window, WC = Wi.document || {}, Ii.gsap = ni, (Wi.gsapVersions || (Wi.gsapVersions = [])).push(ni.version), g8(K0 || Wi.GreenSockGlobals || !Wi.gsap && Wi || {}), u = Wi.requestAnimationFrame, D8.forEach(N8)), l && f.sleep(), c = u || function (b) {
                return setTimeout(b, s - f.time * 1e3 + 1 | 0)
            }, pm = 1, v(2))
        },
        sleep: function () {
            (u ? Wi.cancelAnimationFrame : clearTimeout)(l),
            pm = 0,
            c = fm
        },
        lagSmoothing: function (b, w) {
            t = b || 1 / 0,
            n = Math.min(w || 33, t)
        },
        fps: function (b) {
            i = 1e3 / (b || 240),
            s = f.time * 1e3 + i
        },
        add: function (b, w, k) {
            var C = w ? function (x, S, T, E) {
                b(x, S, T, E),
                f.remove(C)
            }
             : b;
            return f.remove(b),
            a[k ? "unshift" : "push"](C),
            xf(),
            C
        },
        remove: function (b, w) {
            ~(w = a.indexOf(b)) && a.splice(w, 1) && m >= w && m--
        },
        _listeners: a
    },
    f
}
(), xf = function () {
    return !pm && ki.wake()
}, tn = {}, Ife = /^[\d.\-M][\d.\-,\s]/, Tfe = /["']/g, Mfe = function (t) {
    for (var n = {}, r = t.substr(1, t.length - 3).split(":"), o = r[0], i = 1, s = r.length, a, l, c; i < s; i++)
        l = r[i], a = i !== s - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), n[o] = isNaN(c) ? c.replace(Tfe, "").trim() : +c, o = l.substr(a + 1).trim();
    return n
}, Pfe = function (t) {
    var n = t.indexOf("(") + 1,
    r = t.indexOf(")"),
    o = t.indexOf("(", n);
    return t.substring(n, ~o && o < r ? t.indexOf(")", r + 1) : r)
}, Efe = function (t) {
    var n = (t + "").split("("),
    r = tn[n[0]];
    return r && n.length > 1 && r.config ? r.config.apply(null, ~t.indexOf("{") ? [Mfe(n[1])] : Pfe(t).split(",").map(_8)) : tn._CE && Ife.test(t) ? tn._CE("", t) : r
}, V8 = function (t) {
    return function (n) {
        return 1 - t(1 - n)
    }
}, F8 = function e(t, n) {
    for (var r = t._first, o; r; )
        r instanceof Wo ? e(r, n) : r.vars.yoyoEase && (!r._yoyo || !r._repeat) && r._yoyo !== n && (r.timeline ? e(r.timeline, n) : (o = r._ease, r._ease = r._yEase, r._yEase = o, r._yoyo = n)), r = r._next
}, cu = function (t, n) {
    return t && (hr(t) ? t : tn[t] || Efe(t)) || n
}, Qu = function (t, n, r, o) {
    r === void 0 && (r = function (l) {
        return 1 - n(1 - l)
    }),
    o === void 0 && (o = function (l) {
        return l < .5 ? n(l * 2) / 2 : 1 - n((1 - l) * 2) / 2
    });
    var i = {
        easeIn: n,
        easeOut: r,
        easeInOut: o
    },
    s;
    return Yo(t, function (a) {
        tn[a] = Ii[a] = i,
        tn[s = a.toLowerCase()] = r;
        for (var l in i)
            tn[s + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = tn[a + "." + l] = i[l]
    }),
    i
}, j8 = function (t) {
    return function (n) {
        return n < .5 ? (1 - t(1 - n * 2)) / 2 : .5 + t((n - .5) * 2) / 2
    }
}, F_ = function e(t, n, r) {
    var o = n >= 1 ? n : 1,
    i = (r || (t ? .3 : .45)) / (n < 1 ? n : 1),
    s = i / Xk * (Math.asin(1 / o) || 0),
    a = function (u) {
        return u === 1 ? 1 : o * Math.pow(2, -10 * u) * ofe((u - s) * i) + 1
    },
    l = t === "out" ? a : t === "in" ? function (c) {
        return 1 - a(1 - c)
    }
     : j8(a);
    return i = Xk / i,
    l.config = function (c, u) {
        return e(t, c, u)
    },
    l
}, j_ = function e(t, n) {
    n === void 0 && (n = 1.70158);
    var r = function (s) {
        return s ? --s * s * ((n + 1) * s + n) + 1 : 0
    },
    o = t === "out" ? r : t === "in" ? function (i) {
        return 1 - r(1 - i)
    }
     : j8(r);
    return o.config = function (i) {
        return e(t, i)
    },
    o
};
Yo("Linear,Quad,Cubic,Quart,Quint,Strong", function (e, t) {
    var n = t < 5 ? t + 1 : t;
    Qu(e + ",Power" + (n - 1), t ? function (r) {
        return Math.pow(r, n)
    }
         : function (r) {
        return r
    }, function (r) {
        return 1 - Math.pow(1 - r, n)
    }, function (r) {
        return r < .5 ? Math.pow(r * 2, n) / 2 : 1 - Math.pow((1 - r) * 2, n) / 2
    })
});
tn.Linear.easeNone = tn.none = tn.Linear.easeIn;
Qu("Elastic", F_("in"), F_("out"), F_());
(function (e, t) {
    var n = 1 / t,
    r = 2 * n,
    o = 2.5 * n,
    i = function (a) {
        return a < n ? e * a * a : a < r ? e * Math.pow(a - 1.5 / t, 2) + .75 : a < o ? e * (a -= 2.25 / t) * a + .9375 : e * Math.pow(a - 2.625 / t, 2) + .984375
    };
    Qu("Bounce", function (s) {
        return 1 - i(1 - s)
    }, i)
})(7.5625, 2.75);
Qu("Expo", function (e) {
    return e ? Math.pow(2, 10 * (e - 1)) : 0
});
Qu("Circ", function (e) {
    return  - (u8(1 - e * e) - 1)
});
Qu("Sine", function (e) {
    return e === 1 ? 1 : -rfe(e * tfe) + 1
});
Qu("Back", j_("in"), j_("out"), j_());
tn.SteppedEase = tn.steps = Ii.SteppedEase = {
    config: function (t, n) {
        t === void 0 && (t = 1);
        var r = 1 / t,
        o = t + (n ? 0 : 1),
        i = n ? 1 : 0,
        s = 1 - An;
        return function (a) {
            return ((o * ug(0, s, a) | 0) + i) * r
        }
    }
};
bf.ease = tn["quad.out"];
Yo("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (e) {
    return UC += e + "," + e + "Params,"
});
var W8 = function (t, n) {
    this.id = nfe++,
    t._gsap = this,
    this.target = t,
    this.harness = n,
    this.get = n ? n.get : w8,
    this.set = n ? n.getSetter : XC
}, mm = function () {
    function e(n) {
        this.vars = n,
        this._delay = +n.delay || 0,
        (this._repeat = n.repeat === 1 / 0 ? -2 : n.repeat || 0) && (this._rDelay = n.repeatDelay || 0, this._yoyo = !!n.yoyo || !!n.yoyoEase),
        this._ts = 1,
        kf(this, +n.duration, 1, 1),
        this.data = n.data,
        ur && (this._ctx = ur, ur.data.push(this)),
        pm || ki.wake()
    }
    var t = e.prototype;
    return t.delay = function (r) {
        return r || r === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + r - this._delay), this._delay = r, this) : this._delay
    },
    t.duration = function (r) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r) : this.totalDuration() && this._dur
    },
    t.totalDuration = function (r) {
        return arguments.length ? (this._dirty = 0, kf(this, this._repeat < 0 ? r : (r - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    },
    t.totalTime = function (r, o) {
        if (xf(), !arguments.length)
            return this._tTime;
        var i = this._dp;
        if (i && i.smoothChildTiming && this._ts) {
            for (pw(this, r), !i._dp || i.parent || S8(i, this); i && i.parent; )
                i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && r < this._tDur || this._ts < 0 && r > 0 || !this._tDur && !r) && Gs(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== r || !this._dur && !o || this._initted && Math.abs(this._zTime) === An || !r && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = r), b8(this, r, o)),
        this
    },
    t.time = function (r, o) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), r + BO(this)) % (this._dur + this._rDelay) || (r ? this._dur : 0), o) : this._time
    },
    t.totalProgress = function (r, o) {
        return arguments.length ? this.totalTime(this.totalDuration() * r, o) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    },
    t.progress = function (r, o) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) + BO(this), o) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    },
    t.iteration = function (r, o) {
        var i = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (r - 1) * i, o) : this._repeat ? _f(this._tTime, i) + 1 : 1
    },
    t.timeScale = function (r) {
        if (!arguments.length)
            return this._rts === -An ? 0 : this._rts;
        if (this._rts === r)
            return this;
        var o = this.parent && this._ts ? Z0(this.parent._time, this) : this._tTime;
        return this._rts = +r || 0,
        this._ts = this._ps || r === -An ? 0 : this._rts,
        this.totalTime(ug(-Math.abs(this._delay), this._tDur, o), !0),
        hw(this),
        dfe(this)
    },
    t.paused = function (r) {
        return arguments.length ? (this._ps !== r && (this._ps = r, r ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (xf(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== An && (this._tTime -= An)))), this) : this._ps
    },
    t.startTime = function (r) {
        if (arguments.length) {
            this._start = r;
            var o = this.parent || this._dp;
            return o && (o._sort || !this.parent) && Gs(o, this, r - this._delay),
            this
        }
        return this._start
    },
    t.endTime = function (r) {
        return this._start + (qo(r) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    },
    t.rawTime = function (r) {
        var o = this.parent || this._dp;
        return o ? r && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Z0(o.rawTime(r), this) : this._tTime : this._tTime
    },
    t.revert = function (r) {
        r === void 0 && (r = afe);
        var o = uo;
        return uo = r,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(r), this.totalTime( - .01, r.suppressEvents)),
        this.data !== "nested" && r.kill !== !1 && this.kill(),
        uo = o,
        this
    },
    t.globalTime = function (r) {
        for (var o = this, i = arguments.length ? r : o.rawTime(); o; )
            i = o._start + i / (o._ts || 1), o = o._dp;
        return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 / 0 : this._sat.globalTime(r) : i
    },
    t.repeat = function (r) {
        return arguments.length ? (this._repeat = r === 1 / 0 ? -2 : r, VO(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    },
    t.repeatDelay = function (r) {
        if (arguments.length) {
            var o = this._time;
            return this._rDelay = r,
            VO(this),
            o ? this.time(o) : this
        }
        return this._rDelay
    },
    t.yoyo = function (r) {
        return arguments.length ? (this._yoyo = r, this) : this._yoyo
    },
    t.seek = function (r, o) {
        return this.totalTime(ji(this, r), qo(o))
    },
    t.restart = function (r, o) {
        return this.play().totalTime(r ? -this._delay : 0, qo(o))
    },
    t.play = function (r, o) {
        return r != null && this.seek(r, o),
        this.reversed(!1).paused(!1)
    },
    t.reverse = function (r, o) {
        return r != null && this.seek(r || this.totalDuration(), o),
        this.reversed(!0).paused(!1)
    },
    t.pause = function (r, o) {
        return r != null && this.seek(r, o),
        this.paused(!0)
    },
    t.resume = function () {
        return this.paused(!1)
    },
    t.reversed = function (r) {
        return arguments.length ? (!!r !== this.reversed() && this.timeScale(-this._rts || (r ? -An : 0)), this) : this._rts < 0
    },
    t.invalidate = function () {
        return this._initted = this._act = 0,
        this._zTime = -An,
        this
    },
    t.isActive = function () {
        var r = this.parent || this._dp,
        o = this._start,
        i;
        return !!(!r || this._ts && this._initted && r.isActive() && (i = r.rawTime(!0)) >= o && i < this.endTime(!0) - An)
    },
    t.eventCallback = function (r, o, i) {
        var s = this.vars;
        return arguments.length > 1 ? (o ? (s[r] = o, i && (s[r + "Params"] = i), r === "onUpdate" && (this._onUpdate = o)) : delete s[r], this) : s[r]
    },
    t.then = function (r) {
        var o = this;
        return new Promise(function (i) {
            var s = hr(r) ? r : k8,
            a = function () {
                var c = o.then;
                o.then = null,
                hr(s) && (s = s(o)) && (s.then || s === o) && (o.then = c),
                i(s),
                o.then = c
            };
            o._initted && o.totalProgress() === 1 && o._ts >= 0 || !o._tTime && o._ts < 0 ? a() : o._prom = a
        })
    },
    t.kill = function () {
        lp(this)
    },
    e
}
();
ts(mm.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -An,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Wo = function (e) {
    c8(t, e);
    function t(r, o) {
        var i;
        return r === void 0 && (r = {}),
        i = e.call(this, r) || this,
        i.labels = {},
        i.smoothChildTiming = !!r.smoothChildTiming,
        i.autoRemoveChildren = !!r.autoRemoveChildren,
        i._sort = qo(r.sortChildren),
        nr && Gs(r.parent || nr, Va(i), o),
        r.reversed && i.reverse(),
        r.paused && i.paused(!0),
        r.scrollTrigger && C8(Va(i), r.scrollTrigger),
        i
    }
    var n = t.prototype;
    return n.to = function (o, i, s) {
        return Ep(0, arguments, this),
        this
    },
    n.from = function (o, i, s) {
        return Ep(1, arguments, this),
        this
    },
    n.fromTo = function (o, i, s, a) {
        return Ep(2, arguments, this),
        this
    },
    n.set = function (o, i, s) {
        return i.duration = 0,
        i.parent = this,
        Pp(i).repeatDelay || (i.repeat = 0),
        i.immediateRender = !!i.immediateRender,
        new Tr(o, i, ji(this, s), 1),
        this
    },
    n.call = function (o, i, s) {
        return Gs(this, Tr.delayedCall(0, o, i), s)
    },
    n.staggerTo = function (o, i, s, a, l, c, u) {
        return s.duration = i,
        s.stagger = s.stagger || a,
        s.onComplete = c,
        s.onCompleteParams = u,
        s.parent = this,
        new Tr(o, s, ji(this, l)),
        this
    },
    n.staggerFrom = function (o, i, s, a, l, c, u) {
        return s.runBackwards = 1,
        Pp(s).immediateRender = qo(s.immediateRender),
        this.staggerTo(o, i, s, a, l, c, u)
    },
    n.staggerFromTo = function (o, i, s, a, l, c, u, f) {
        return a.startAt = s,
        Pp(a).immediateRender = qo(a.immediateRender),
        this.staggerTo(o, i, a, l, c, u, f)
    },
    n.render = function (o, i, s) {
        var a = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        c = this._dur,
        u = o <= 0 ? 0 : Xr(o),
        f = this._zTime < 0 != o < 0 && (this._initted || !c),
        p,
        m,
        v,
        y,
        b,
        w,
        k,
        C,
        x,
        S,
        T,
        E;
        if (this !== nr && u > l && o >= 0 && (u = l), u !== this._tTime || s || f) {
            if (a !== this._time && c && (u += this._time - a, o += this._time - a), p = u, x = this._start, C = this._ts, w = !C, f && (c || (a = this._zTime), (o || !i) && (this._zTime = o)), this._repeat) {
                if (T = this._yoyo, b = c + this._rDelay, this._repeat < -1 && o < 0)
                    return this.totalTime(b * 100 + o, i, s);
                if (p = Xr(u % b), u === l ? (y = this._repeat, p = c) : (y = ~~(u / b), y && y === u / b && (p = c, y--), p > c && (p = c)), S = _f(this._tTime, b), !a && this._tTime && S !== y && this._tTime - S * b - this._dur <= 0 && (S = y), T && y & 1 && (p = c - p, E = 1), y !== S && !this._lock) {
                    var M = T && S & 1,
                    N = M === (T && y & 1);
                    if (y < S && (M = !M), a = M ? 0 : u % c ? c : u, this._lock = 1, this.render(a || (E ? 0 : Xr(y * b)), i, !c)._lock = 0, this._tTime = u, !i && this.parent && Gi(this, "onRepeat"), this.vars.repeatRefresh && !E && (this.invalidate()._lock = 1), a && a !== this._time || w !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (c = this._dur, l = this._tDur, N && (this._lock = 2, a = M ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !E && this.invalidate()), this._lock = 0, !this._ts && !w)
                        return this;
                    F8(this, E)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (k = mfe(this, Xr(a), Xr(p)), k && (u -= p - (p = k._start))), this._tTime = u, this._time = p, this._act = !C, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = o, a = 0), !a && p && !i && !y && (Gi(this, "onStart"), this._tTime !== u))
                return this;
            if (p >= a && o >= 0)
                for (m = this._first; m; ) {
                    if (v = m._next, (m._act || p >= m._start) && m._ts && k !== m) {
                        if (m.parent !== this)
                            return this.render(o, i, s);
                        if (m.render(m._ts > 0 ? (p - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (p - m._start) * m._ts, i, s), p !== this._time || !this._ts && !w) {
                            k = 0,
                            v && (u += this._zTime = -An);
                            break
                        }
                    }
                    m = v
                }
            else {
                m = this._last;
                for (var F = o < 0 ? o : p; m; ) {
                    if (v = m._prev, (m._act || F <= m._end) && m._ts && k !== m) {
                        if (m.parent !== this)
                            return this.render(o, i, s);
                        if (m.render(m._ts > 0 ? (F - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (F - m._start) * m._ts, i, s || uo && (m._initted || m._startAt)), p !== this._time || !this._ts && !w) {
                            k = 0,
                            v && (u += this._zTime = F ? -An : An);
                            break
                        }
                    }
                    m = v
                }
            }
            if (k && !i && (this.pause(), k.render(p >= a ? 0 : -An)._zTime = p >= a ? 1 : -1, this._ts))
                return this._start = x, hw(this), this.render(o, i, s);
            this._onUpdate && !i && Gi(this, "onUpdate", !0),
            (u === l && this._tTime >= this.totalDuration() || !u && a) && (x === this._start || Math.abs(C) !== Math.abs(this._ts)) && (this._lock || ((o || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && ic(this, 1), !i && !(o < 0 && !a) && (u || a || !l) && (Gi(this, u === l && o >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    },
    n.add = function (o, i) {
        var s = this;
        if (Xa(i) || (i = ji(this, i, o)), !(o instanceof mm)) {
            if (fo(o))
                return o.forEach(function (a) {
                    return s.add(a, i)
                }), this;
            if (Wr(o))
                return this.addLabel(o, i);
            if (hr(o))
                o = Tr.delayedCall(0, o);
            else
                return this
        }
        return this !== o ? Gs(this, o, i) : this
    },
    n.getChildren = function (o, i, s, a) {
        o === void 0 && (o = !0),
        i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        a === void 0 && (a = -Yi);
        for (var l = [], c = this._first; c; )
            c._start >= a && (c instanceof Tr ? i && l.push(c) : (s && l.push(c), o && l.push.apply(l, c.getChildren(!0, i, s)))), c = c._next;
        return l
    },
    n.getById = function (o) {
        for (var i = this.getChildren(1, 1, 1), s = i.length; s--; )
            if (i[s].vars.id === o)
                return i[s]
    },
    n.remove = function (o) {
        return Wr(o) ? this.removeLabel(o) : hr(o) ? this.killTweensOf(o) : (fw(this, o), o === this._recent && (this._recent = this._last), lu(this))
    },
    n.totalTime = function (o, i) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Xr(ki.time - (this._ts > 0 ? o / this._ts : (this.totalDuration() - o) / -this._ts))), e.prototype.totalTime.call(this, o, i), this._forcing = 0, this) : this._tTime
    },
    n.addLabel = function (o, i) {
        return this.labels[o] = ji(this, i),
        this
    },
    n.removeLabel = function (o) {
        return delete this.labels[o],
        this
    },
    n.addPause = function (o, i, s) {
        var a = Tr.delayedCall(0, i || fm, s);
        return a.data = "isPause",
        this._hasPause = 1,
        Gs(this, a, ji(this, o))
    },
    n.removePause = function (o) {
        var i = this._first;
        for (o = ji(this, o); i; )
            i._start === o && i.data === "isPause" && ic(i), i = i._next
    },
    n.killTweensOf = function (o, i, s) {
        for (var a = this.getTweensOf(o, s), l = a.length; l--; )
            Rl !== a[l] && a[l].kill(o, i);
        return this
    },
    n.getTweensOf = function (o, i) {
        for (var s = [], a = Ki(o), l = this._first, c = Xa(i), u; l; )
            l instanceof Tr ? lfe(l._targets, a) && (c ? (!Rl || l._initted && l._ts) && l.globalTime(0) <= i && l.globalTime(l.totalDuration()) > i : !i || l.isActive()) && s.push(l) : (u = l.getTweensOf(a, i)).length && s.push.apply(s, u), l = l._next;
        return s
    },
    n.tweenTo = function (o, i) {
        i = i || {};
        var s = this,
        a = ji(s, o),
        l = i,
        c = l.startAt,
        u = l.onStart,
        f = l.onStartParams,
        p = l.immediateRender,
        m,
        v = Tr.to(s, ts({
                    ease: i.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: a,
                    overwrite: "auto",
                    duration: i.duration || Math.abs((a - (c && "time" in c ? c.time : s._time)) / s.timeScale()) || An,
                    onStart: function () {
                        if (s.pause(), !m) {
                            var b = i.duration || Math.abs((a - (c && "time" in c ? c.time : s._time)) / s.timeScale());
                            v._dur !== b && kf(v, b, 0, 1).render(v._time, !0, !0),
                            m = 1
                        }
                        u && u.apply(v, f || [])
                    }
                }, i));
        return p ? v.render(0) : v
    },
    n.tweenFromTo = function (o, i, s) {
        return this.tweenTo(i, ts({
                startAt: {
                    time: ji(this, o)
                }
            }, s))
    },
    n.recent = function () {
        return this._recent
    },
    n.nextLabel = function (o) {
        return o === void 0 && (o = this._time),
        FO(this, ji(this, o))
    },
    n.previousLabel = function (o) {
        return o === void 0 && (o = this._time),
        FO(this, ji(this, o), 1)
    },
    n.currentLabel = function (o) {
        return arguments.length ? this.seek(o, !0) : this.previousLabel(this._time + An)
    },
    n.shiftChildren = function (o, i, s) {
        s === void 0 && (s = 0);
        for (var a = this._first, l = this.labels, c; a; )
            a._start >= s && (a._start += o, a._end += o), a = a._next;
        if (i)
            for (c in l)
                l[c] >= s && (l[c] += o);
        return lu(this)
    },
    n.invalidate = function (o) {
        var i = this._first;
        for (this._lock = 0; i; )
            i.invalidate(o), i = i._next;
        return e.prototype.invalidate.call(this, o)
    },
    n.clear = function (o) {
        o === void 0 && (o = !0);
        for (var i = this._first, s; i; )
            s = i._next, this.remove(i), i = s;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        o && (this.labels = {}),
        lu(this)
    },
    n.totalDuration = function (o) {
        var i = 0,
        s = this,
        a = s._last,
        l = Yi,
        c,
        u,
        f;
        if (arguments.length)
            return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -o : o));
        if (s._dirty) {
            for (f = s.parent; a; )
                c = a._prev, a._dirty && a.totalDuration(), u = a._start, u > l && s._sort && a._ts && !s._lock ? (s._lock = 1, Gs(s, a, u - a._delay, 1)._lock = 0) : l = u, u < 0 && a._ts && (i -= u, (!f && !s._dp || f && f.smoothChildTiming) && (s._start += u / s._ts, s._time -= u, s._tTime -= u), s.shiftChildren(-u, !1, -1 / 0), l = 0), a._end > i && a._ts && (i = a._end), a = c;
            kf(s, s === nr && s._time > i ? s._time : i, 1, 1),
            s._dirty = 0
        }
        return s._tDur
    },
    t.updateRoot = function (o) {
        if (nr._ts && (b8(nr, Z0(o, nr)), y8 = ki.frame), ki.frame >= RO) {
            RO += Si.autoSleep || 120;
            var i = nr._first;
            if ((!i || !i._ts) && Si.autoSleep && ki._listeners.length < 2) {
                for (; i && !i._ts; )
                    i = i._next;
                i || ki.sleep()
            }
        }
    },
    t
}
(mm);
ts(Wo.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var Ofe = function (t, n, r, o, i, s, a) {
    var l = new Ko(this._pt, t, n, 0, 1, K8, null, i),
    c = 0,
    u = 0,
    f,
    p,
    m,
    v,
    y,
    b,
    w,
    k;
    for (l.b = r, l.e = o, r += "", o += "", (w = ~o.indexOf("random(")) && (o = hm(o)), s && (k = [r, o], s(k, t, n), r = k[0], o = k[1]), p = r.match(L_) || []; f = L_.exec(o); )
        v = f[0], y = o.substring(c, f.index), m ? m = (m + 1) % 5 : y.substr(-5) === "rgba(" && (m = 1), v !== p[u++] && (b = parseFloat(p[u - 1]) || 0, l._pt = {
                _next: l._pt,
                p: y || u === 1 ? y : ",",
                s: b,
                c: v.charAt(1) === "=" ? rf(b, v) - b : parseFloat(v) - b,
                m: m && m < 4 ? Math.round : 0
            }, c = L_.lastIndex);
    return l.c = c < o.length ? o.substring(c, o.length) : "",
    l.fp = a,
    (h8.test(o) || w) && (l.e = 0),
    this._pt = l,
    l
}, YC = function (t, n, r, o, i, s, a, l, c, u) {
    hr(o) && (o = o(i || 0, t, s));
    var f = t[n],
    p = r !== "get" ? r : hr(f) ? c ? t[n.indexOf("set") || !hr(t["get" + n.substr(3)]) ? n : "get" + n.substr(3)](c) : t[n]() : f,
    m = hr(f) ? c ? Rfe : q8 : GC,
    v;
    if (Wr(o) && (~o.indexOf("random(") && (o = hm(o)), o.charAt(1) === "=" && (v = rf(p, o) + (co(p) || 0), (v || v === 0) && (o = v))), !u || p !== o || ix)
        return !isNaN(p * o) && o !== "" ? (v = new Ko(this._pt, t, n, +p || 0, o - (p || 0), typeof f == "boolean" ? Bfe : Y8, 0, m), c && (v.fp = c), a && v.modifier(a, this, t), this._pt = v) : (!f && !(n in t) && zC(n, o), Ofe.call(this, t, n, p, o, m, l || Si.stringFilter, c))
}, $fe = function (t, n, r, o, i) {
    if (hr(t) && (t = Op(t, i, n, r, o)), !da(t) || t.style && t.nodeType || fo(t) || d8(t))
        return Wr(t) ? Op(t, i, n, r, o) : t;
    var s = {},
    a;
    for (a in t)
        s[a] = Op(t[a], i, n, r, o);
    return s
}, z8 = function (t, n, r, o, i, s) {
    var a,
    l,
    c,
    u;
    if (gi[t] && (a = new gi[t]).init(i, a.rawVars ? n[t] : $fe(n[t], o, i, s, r), r, o, s) !== !1 && (r._pt = l = new Ko(r._pt, i, t, 0, 1, a.render, a, 0, a.priority), r !== jd))
        for (c = r._ptLookup[r._targets.indexOf(i)], u = a._props.length; u--; )
            c[a._props[u]] = l;
    return a
}, Rl, ix, KC = function e(t, n, r) {
    var o = t.vars,
    i = o.ease,
    s = o.startAt,
    a = o.immediateRender,
    l = o.lazy,
    c = o.onUpdate,
    u = o.onUpdateParams,
    f = o.callbackScope,
    p = o.runBackwards,
    m = o.yoyoEase,
    v = o.keyframes,
    y = o.autoRevert,
    b = t._dur,
    w = t._startAt,
    k = t._targets,
    C = t.parent,
    x = C && C.data === "nested" ? C.vars.targets : k,
    S = t._overwrite === "auto" && !VC,
    T = t.timeline,
    E,
    M,
    N,
    F,
    K,
    j,
    G,
    Y,
    ue,
    re,
    de,
    Se,
    Pe;
    if (T && (!v || !i) && (i = "none"), t._ease = cu(i, bf.ease), t._yEase = m ? V8(cu(m === !0 ? i : m, bf.ease)) : 0, m && t._yoyo && !t._repeat && (m = t._yEase, t._yEase = t._ease, t._ease = m), t._from = !T && !!o.runBackwards, !T || v && !o.stagger) {
        if (Y = k[0] ? au(k[0]).harness : 0, Se = Y && o[Y.prop], E = J0(o, HC), w && (w._zTime < 0 && w.progress(1), n < 0 && p && a && !y ? w.render(-1, !0) : w.revert(p && b ? a0 : sfe), w._lazy = 0), s) {
            if (ic(t._startAt = Tr.set(k, ts({
                                data: "isStart",
                                overwrite: !1,
                                parent: C,
                                immediateRender: !0,
                                lazy: !w && qo(l),
                                startAt: null,
                                delay: 0,
                                onUpdate: c,
                                onUpdateParams: u,
                                callbackScope: f,
                                stagger: 0
                            }, s))), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (uo || !a && !y) && t._startAt.revert(a0), a && b && n <= 0 && r <= 0) {
                n && (t._zTime = n);
                return
            }
        } else if (p && b && !w) {
            if (n && (a = !1), N = ts({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: a && !w && qo(l),
                    immediateRender: a,
                    stagger: 0,
                    parent: C
                }, E), Se && (N[Y.prop] = Se), ic(t._startAt = Tr.set(k, N)), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (uo ? t._startAt.revert(a0) : t._startAt.render(-1, !0)), t._zTime = n, !a)
                e(t._startAt, An, An);
            else if (!n)
                return
        }
        for (t._pt = t._ptCache = 0, l = b && qo(l) || l && !b, M = 0; M < k.length; M++) {
            if (K = k[M], G = K._gsap || qC(k)[M]._gsap, t._ptLookup[M] = re = {}, Qk[G.id] && Ul.length && X0(), de = x === k ? M : x.indexOf(K), Y && (ue = new Y).init(K, Se || E, t, de, x) !== !1 && (t._pt = F = new Ko(t._pt, K, ue.name, 0, 1, ue.render, ue, 0, ue.priority), ue._props.forEach(function (je) {
                        re[je] = F
                    }), ue.priority && (j = 1)), !Y || Se)
                for (N in E)
                    gi[N] && (ue = z8(N, E, t, de, K, x)) ? ue.priority && (j = 1) : re[N] = F = YC.call(t, K, N, "get", E[N], de, x, 0, o.stringFilter);
            t._op && t._op[M] && t.kill(K, t._op[M]),
            S && t._pt && (Rl = t, nr.killTweensOf(K, re, t.globalTime(n)), Pe = !t.parent, Rl = 0),
            t._pt && l && (Qk[G.id] = 1)
        }
        j && G8(t),
        t._onInit && t._onInit(t)
    }
    t._onUpdate = c,
    t._initted = (!t._op || t._pt) && !Pe,
    v && n <= 0 && T.render(Yi, !0, !0)
}, Afe = function (t, n, r, o, i, s, a) {
    var l = (t._pt && t._ptCache || (t._ptCache = {}))[n],
    c,
    u,
    f,
    p;
    if (!l)
        for (l = t._ptCache[n] = [], f = t._ptLookup, p = t._targets.length; p--; ) {
            if (c = f[p][n], c && c.d && c.d._pt)
                for (c = c.d._pt; c && c.p !== n && c.fp !== n; )
                    c = c._next;
            if (!c)
                return ix = 1, t.vars[n] = "+=0", KC(t, a), ix = 0, 1;
            l.push(c)
        }
    for (p = l.length; p--; )
        u = l[p], c = u._pt || u, c.s = (o || o === 0) && !i ? o : c.s + (o || 0) + s * c.c, c.c = r - c.s, u.e && (u.e = wr(r) + co(u.e)), u.b && (u.b = c.s + co(u.b))
}, Dfe = function (t, n) {
    var r = t[0] ? au(t[0]).harness : 0,
    o = r && r.aliases,
    i,
    s,
    a,
    l;
    if (!o)
        return n;
    i = Ou({}, n);
    for (s in o)
        if (s in i)
            for (l = o[s].split(","), a = l.length; a--; )
                i[l[a]] = i[s];
    return i
}, Nfe = function (t, n, r, o) {
    var i = n.ease || o || "power1.inOut",
    s,
    a;
    if (fo(n))
        a = r[t] || (r[t] = []), n.forEach(function (l, c) {
            return a.push({
                t: c / (n.length - 1) * 100,
                v: l,
                e: i
            })
        });
    else
        for (s in n)
            a = r[s] || (r[s] = []), s === "ease" || a.push({
                t: parseFloat(t),
                v: n[s],
                e: i
            })
}, Op = function (t, n, r, o, i) {
    return hr(t) ? t.call(n, r, o, i) : Wr(t) && ~t.indexOf("random(") ? hm(t) : t
}, H8 = UC + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", U8 = {};
Yo(H8 + ",id,stagger,delay,duration,paused,scrollTrigger", function (e) {
    return U8[e] = 1
});
var Tr = function (e) {
    c8(t, e);
    function t(r, o, i, s) {
        var a;
        typeof o == "number" && (i.duration = o, o = i, i = null),
        a = e.call(this, s ? o : Pp(o)) || this;
        var l = a.vars,
        c = l.duration,
        u = l.delay,
        f = l.immediateRender,
        p = l.stagger,
        m = l.overwrite,
        v = l.keyframes,
        y = l.defaults,
        b = l.scrollTrigger,
        w = l.yoyoEase,
        k = o.parent || nr,
        C = (fo(r) || d8(r) ? Xa(r[0]) : "length" in o) ? [r] : Ki(r),
        x,
        S,
        T,
        E,
        M,
        N,
        F,
        K;
        if (a._targets = C.length ? qC(C) : G0("GSAP target " + r + " not found. https://greensock.com", !Si.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = m, v || p || Tv(c) || Tv(u)) {
            if (o = a.vars, x = a.timeline = new Wo({
                    data: "nested",
                    defaults: y || {},
                    targets: k && k.data === "nested" ? k.vars.targets : C
                }), x.kill(), x.parent = x._dp = Va(a), x._start = 0, p || Tv(c) || Tv(u)) {
                if (E = C.length, F = p && P8(p), da(p))
                    for (M in p)
                        ~H8.indexOf(M) && (K || (K = {}), K[M] = p[M]);
                for (S = 0; S < E; S++)
                    T = J0(o, U8), T.stagger = 0, w && (T.yoyoEase = w), K && Ou(T, K), N = C[S], T.duration = +Op(c, Va(a), S, N, C), T.delay = (+Op(u, Va(a), S, N, C) || 0) - a._delay, !p && E === 1 && T.delay && (a._delay = u = T.delay, a._start += u, T.delay = 0), x.to(N, T, F ? F(S, N, C) : 0), x._ease = tn.none;
                x.duration() ? c = u = 0 : a.timeline = 0
            } else if (v) {
                Pp(ts(x.vars.defaults, {
                        ease: "none"
                    })),
                x._ease = cu(v.ease || o.ease || "none");
                var j = 0,
                G,
                Y,
                ue;
                if (fo(v))
                    v.forEach(function (re) {
                        return x.to(C, re, ">")
                    }), x.duration();
                else {
                    T = {};
                    for (M in v)
                        M === "ease" || M === "easeEach" || Nfe(M, v[M], T, v.easeEach);
                    for (M in T)
                        for (G = T[M].sort(function (re, de) {
                                return re.t - de.t
                            }), j = 0, S = 0; S < G.length; S++)
                            Y = G[S], ue = {
                                ease: Y.e,
                                duration: (Y.t - (S ? G[S - 1].t : 0)) / 100 * c
                            },
                    ue[M] = Y.v,
                    x.to(C, ue, j),
                    j += ue.duration;
                    x.duration() < c && x.to({}, {
                        duration: c - x.duration()
                    })
                }
            }
            c || a.duration(c = x.duration())
        } else
            a.timeline = 0;
        return m === !0 && !VC && (Rl = Va(a), nr.killTweensOf(C), Rl = 0),
        Gs(k, Va(a), i),
        o.reversed && a.reverse(),
        o.paused && a.paused(!0),
        (f || !c && !v && a._start === Xr(k._time) && qo(f) && ffe(Va(a)) && k.data !== "nested") && (a._tTime = -An, a.render(Math.max(0, -u) || 0)),
        b && C8(Va(a), b),
        a
    }
    var n = t.prototype;
    return n.render = function (o, i, s) {
        var a = this._time,
        l = this._tDur,
        c = this._dur,
        u = o < 0,
        f = o > l - An && !u ? l : o < An ? 0 : o,
        p,
        m,
        v,
        y,
        b,
        w,
        k,
        C,
        x;
        if (!c)
            pfe(this, o, i, s);
        else if (f !== this._tTime || !o || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
            if (p = f, C = this.timeline, this._repeat) {
                if (y = c + this._rDelay, this._repeat < -1 && u)
                    return this.totalTime(y * 100 + o, i, s);
                if (p = Xr(f % y), f === l ? (v = this._repeat, p = c) : (v = ~~(f / y), v && v === f / y && (p = c, v--), p > c && (p = c)), w = this._yoyo && v & 1, w && (x = this._yEase, p = c - p), b = _f(this._tTime, y), p === a && !s && this._initted)
                    return this._tTime = f, this;
                v !== b && (C && this._yEase && F8(C, w), this.vars.repeatRefresh && !w && !this._lock && (this._lock = s = 1, this.render(Xr(y * v), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (I8(this, u ? o : p, s, i, f))
                    return this._tTime = 0, this;
                if (a !== this._time)
                    return this;
                if (c !== this._dur)
                    return this.render(o, i, s)
            }
            if (this._tTime = f, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = k = (x || this._ease)(p / c), this._from && (this.ratio = k = 1 - k), p && !a && !i && !v && (Gi(this, "onStart"), this._tTime !== f))
                return this;
            for (m = this._pt; m; )
                m.r(k, m.d), m = m._next;
            C && C.render(o < 0 ? o : !p && w ? -An : C._dur * C._ease(p / this._dur), i, s) || this._startAt && (this._zTime = o),
            this._onUpdate && !i && (u && ex(this, o, i, s), Gi(this, "onUpdate")),
            this._repeat && v !== b && this.vars.onRepeat && !i && this.parent && Gi(this, "onRepeat"),
            (f === this._tDur || !f) && this._tTime === f && (u && !this._onUpdate && ex(this, o, !0, !0), (o || !c) && (f === this._tDur && this._ts > 0 || !f && this._ts < 0) && ic(this, 1), !i && !(u && !a) && (f || a || w) && (Gi(this, f === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    },
    n.targets = function () {
        return this._targets
    },
    n.invalidate = function (o) {
        return (!o || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(o),
        e.prototype.invalidate.call(this, o)
    },
    n.resetTo = function (o, i, s, a) {
        pm || ki.wake(),
        this._ts || this.play();
        var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        c;
        return this._initted || KC(this, l),
        c = this._ease(l / this._dur),
        Afe(this, o, i, s, a, c, l) ? this.resetTo(o, i, s, a) : (pw(this, 0), this.parent || x8(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
    },
    n.kill = function (o, i) {
        if (i === void 0 && (i = "all"), !o && (!i || i === "all"))
            return this._lazy = this._pt = 0, this.parent ? lp(this) : this;
        if (this.timeline) {
            var s = this.timeline.totalDuration();
            return this.timeline.killTweensOf(o, i, Rl && Rl.vars.overwrite !== !0)._first || lp(this),
            this.parent && s !== this.timeline.totalDuration() && kf(this, this._dur * this.timeline._tDur / s, 0, 1),
            this
        }
        var a = this._targets,
        l = o ? Ki(o) : a,
        c = this._ptLookup,
        u = this._pt,
        f,
        p,
        m,
        v,
        y,
        b,
        w;
        if ((!i || i === "all") && ufe(a, l))
            return i === "all" && (this._pt = 0), lp(this);
        for (f = this._op = this._op || [], i !== "all" && (Wr(i) && (y = {}, Yo(i, function (k) {
                        return y[k] = 1
                    }), i = y), i = Dfe(a, i)), w = a.length; w--; )
            if (~l.indexOf(a[w])) {
                p = c[w],
                i === "all" ? (f[w] = i, v = p, m = {}) : (m = f[w] = f[w] || {}, v = i);
                for (y in v)
                    b = p && p[y], b && ((!("kill" in b.d) || b.d.kill(y) === !0) && fw(this, b, "_pt"), delete p[y]), m !== "all" && (m[y] = 1)
            }
        return this._initted && !this._pt && u && lp(this),
        this
    },
    t.to = function (o, i) {
        return new t(o, i, arguments[2])
    },
    t.from = function (o, i) {
        return Ep(1, arguments)
    },
    t.delayedCall = function (o, i, s, a) {
        return new t(i, 0, {
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: o,
            onComplete: i,
            onReverseComplete: i,
            onCompleteParams: s,
            onReverseCompleteParams: s,
            callbackScope: a
        })
    },
    t.fromTo = function (o, i, s) {
        return Ep(2, arguments)
    },
    t.set = function (o, i) {
        return i.duration = 0,
        i.repeatDelay || (i.repeat = 0),
        new t(o, i)
    },
    t.killTweensOf = function (o, i, s) {
        return nr.killTweensOf(o, i, s)
    },
    t
}
(mm);
ts(Tr.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
Yo("staggerTo,staggerFrom,staggerFromTo", function (e) {
    Tr[e] = function () {
        var t = new Wo,
        n = nx.call(arguments, 0);
        return n.splice(e === "staggerFromTo" ? 5 : 4, 0, 0),
        t[e].apply(t, n)
    }
});
var GC = function (t, n, r) {
    return t[n] = r
}, q8 = function (t, n, r) {
    return t[n](r)
}, Rfe = function (t, n, r, o) {
    return t[n](o.fp, r)
}, Lfe = function (t, n, r) {
    return t.setAttribute(n, r)
}, XC = function (t, n) {
    return hr(t[n]) ? q8 : FC(t[n]) && t.setAttribute ? Lfe : GC
}, Y8 = function (t, n) {
    return n.set(n.t, n.p, Math.round((n.s + n.c * t) * 1e6) / 1e6, n)
}, Bfe = function (t, n) {
    return n.set(n.t, n.p, !!(n.s + n.c * t), n)
}, K8 = function (t, n) {
    var r = n._pt,
    o = "";
    if (!t && n.b)
        o = n.b;
    else if (t === 1 && n.e)
        o = n.e;
    else {
        for (; r; )
            o = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round((r.s + r.c * t) * 1e4) / 1e4) + o, r = r._next;
        o += n.c
    }
    n.set(n.t, n.p, o, n)
}, JC = function (t, n) {
    for (var r = n._pt; r; )
        r.r(t, r.d), r = r._next
}, Vfe = function (t, n, r, o) {
    for (var i = this._pt, s; i; )
        s = i._next, i.p === o && i.modifier(t, n, r), i = s
}, Ffe = function (t) {
    for (var n = this._pt, r, o; n; )
        o = n._next, n.p === t && !n.op || n.op === t ? fw(this, n, "_pt") : n.dep || (r = 1), n = o;
    return !r
}, jfe = function (t, n, r, o) {
    o.mSet(t, n, o.m.call(o.tween, r, o.mt), o)
}, G8 = function (t) {
    for (var n = t._pt, r, o, i, s; n; ) {
        for (r = n._next, o = i; o && o.pr > n.pr; )
            o = o._next;
        (n._prev = o ? o._prev : s) ? n._prev._next = n : i = n,
        (n._next = o) ? o._prev = n : s = n,
        n = r
    }
    t._pt = i
}, Ko = function () {
    function e(n, r, o, i, s, a, l, c, u) {
        this.t = r,
        this.s = i,
        this.c = s,
        this.p = o,
        this.r = a || Y8,
        this.d = l || this,
        this.set = c || GC,
        this.pr = u || 0,
        this._next = n,
        n && (n._prev = this)
    }
    var t = e.prototype;
    return t.modifier = function (r, o, i) {
        this.mSet = this.mSet || this.set,
        this.set = jfe,
        this.m = r,
        this.mt = i,
        this.tween = o
    },
    e
}
();
Yo(UC + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (e) {
    return HC[e] = 1
});
Ii.TweenMax = Ii.TweenLite = Tr;
Ii.TimelineLite = Ii.TimelineMax = Wo;
nr = new Wo({
    sortChildren: !1,
    defaults: bf,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Si.stringFilter = B8;
var uu = [], c0 = {}, Wfe = [], WO = 0, zfe = 0, W_ = function (t) {
    return (c0[t] || Wfe).map(function (n) {
        return n()
    })
}, sx = function () {
    var t = Date.now(),
    n = [];
    t - WO > 2 && (W_("matchMediaInit"), uu.forEach(function (r) {
            var o = r.queries,
            i = r.conditions,
            s,
            a,
            l,
            c;
            for (a in o)
                s = Wi.matchMedia(o[a]).matches, s && (l = 1), s !== i[a] && (i[a] = s, c = 1);
            c && (r.revert(), l && n.push(r))
        }), W_("matchMediaRevert"), n.forEach(function (r) {
            return r.onMatch(r)
        }), WO = t, W_("matchMedia"))
}, X8 = function () {
    function e(n, r) {
        this.selector = r && rx(r),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = zfe++,
        n && this.add(n)
    }
    var t = e.prototype;
    return t.add = function (r, o, i) {
        hr(r) && (i = o, o = r, r = hr);
        var s = this,
        a = function () {
            var c = ur,
            u = s.selector,
            f;
            return c && c !== s && c.data.push(s),
            i && (s.selector = rx(i)),
            ur = s,
            f = o.apply(s, arguments),
            hr(f) && s._r.push(f),
            ur = c,
            s.selector = u,
            s.isReverted = !1,
            f
        };
        return s.last = a,
        r === hr ? a(s) : r ? s[r] = a : a
    },
    t.ignore = function (r) {
        var o = ur;
        ur = null,
        r(this),
        ur = o
    },
    t.getTweens = function () {
        var r = [];
        return this.data.forEach(function (o) {
            return o instanceof e ? r.push.apply(r, o.getTweens()) : o instanceof Tr && !(o.parent && o.parent.data === "nested") && r.push(o)
        }),
        r
    },
    t.clear = function () {
        this._r.length = this.data.length = 0
    },
    t.kill = function (r, o) {
        var i = this;
        if (r) {
            var s = this.getTweens();
            this.data.forEach(function (l) {
                l.data === "isFlip" && (l.revert(), l.getChildren(!0, !0, !1).forEach(function (c) {
                        return s.splice(s.indexOf(c), 1)
                    }))
            }),
            s.map(function (l) {
                return {
                    g: l.globalTime(0),
                    t: l
                }
            }).sort(function (l, c) {
                return c.g - l.g || -1 / 0
            }).forEach(function (l) {
                return l.t.revert(r)
            }),
            this.data.forEach(function (l) {
                return !(l instanceof Tr) && l.revert && l.revert(r)
            }),
            this._r.forEach(function (l) {
                return l(r, i)
            }),
            this.isReverted = !0
        } else
            this.data.forEach(function (l) {
                return l.kill && l.kill()
            });
        if (this.clear(), o)
            for (var a = uu.length; a--; )
                uu[a].id === this.id && uu.splice(a, 1)
    },
    t.revert = function (r) {
        this.kill(r || {})
    },
    e
}
(), Hfe = function () {
    function e(n) {
        this.contexts = [],
        this.scope = n
    }
    var t = e.prototype;
    return t.add = function (r, o, i) {
        da(r) || (r = {
                matches: r
            });
        var s = new X8(0, i || this.scope),
        a = s.conditions = {},
        l,
        c,
        u;
        ur && !s.selector && (s.selector = ur.selector),
        this.contexts.push(s),
        o = s.add("onMatch", o),
        s.queries = r;
        for (c in r)
            c === "all" ? u = 1 : (l = Wi.matchMedia(r[c]), l && (uu.indexOf(s) < 0 && uu.push(s), (a[c] = l.matches) && (u = 1), l.addListener ? l.addListener(sx) : l.addEventListener("change", sx)));
        return u && o(s),
        this
    },
    t.revert = function (r) {
        this.kill(r || {})
    },
    t.kill = function (r) {
        this.contexts.forEach(function (o) {
            return o.kill(r, !0)
        })
    },
    e
}
(), Q0 = {
    registerPlugin: function () {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
            n[r] = arguments[r];
        n.forEach(function (o) {
            return N8(o)
        })
    },
    timeline: function (t) {
        return new Wo(t)
    },
    getTweensOf: function (t, n) {
        return nr.getTweensOf(t, n)
    },
    getProperty: function (t, n, r, o) {
        Wr(t) && (t = Ki(t)[0]);
        var i = au(t || {}).get,
        s = r ? k8 : _8;
        return r === "native" && (r = ""),
        t && (n ? s((gi[n] && gi[n].get || i)(t, n, r, o)) : function (a, l, c) {
            return s((gi[a] && gi[a].get || i)(t, a, l, c))
        })
    },
    quickSetter: function (t, n, r) {
        if (t = Ki(t), t.length > 1) {
            var o = t.map(function (u) {
                return ni.quickSetter(u, n, r)
            }),
            i = o.length;
            return function (u) {
                for (var f = i; f--; )
                    o[f](u)
            }
        }
        t = t[0] || {};
        var s = gi[n],
        a = au(t),
        l = a.harness && (a.harness.aliases || {})[n] || n,
        c = s ? function (u) {
            var f = new s;
            jd._pt = 0,
            f.init(t, r ? u + r : u, jd, 0, [t]),
            f.render(1, f),
            jd._pt && JC(1, jd)
        }
         : a.set(t, l);
        return s ? c : function (u) {
            return c(t, l, r ? u + r : u, a, 1)
        }
    },
    quickTo: function (t, n, r) {
        var o,
        i = ni.to(t, Ou((o = {}, o[n] = "+=0.1", o.paused = !0, o), r || {})),
        s = function (l, c, u) {
            return i.resetTo(n, l, c, u)
        };
        return s.tween = i,
        s
    },
    isTweening: function (t) {
        return nr.getTweensOf(t, !0).length > 0
    },
    defaults: function (t) {
        return t && t.ease && (t.ease = cu(t.ease, bf.ease)),
        LO(bf, t || {})
    },
    config: function (t) {
        return LO(Si, t || {})
    },
    registerEffect: function (t) {
        var n = t.name,
        r = t.effect,
        o = t.plugins,
        i = t.defaults,
        s = t.extendTimeline;
        (o || "").split(",").forEach(function (a) {
            return a && !gi[a] && !Ii[a] && G0(n + " effect requires " + a + " plugin.")
        }),
        B_[n] = function (a, l, c) {
            return r(Ki(a), ts(l || {}, i), c)
        },
        s && (Wo.prototype[n] = function (a, l, c) {
            return this.add(B_[n](a, da(l) ? l : (c = l) && {}, this), c)
        })
    },
    registerEase: function (t, n) {
        tn[t] = cu(n)
    },
    parseEase: function (t, n) {
        return arguments.length ? cu(t, n) : tn
    },
    getById: function (t) {
        return nr.getById(t)
    },
    exportRoot: function (t, n) {
        t === void 0 && (t = {});
        var r = new Wo(t),
        o,
        i;
        for (r.smoothChildTiming = qo(t.smoothChildTiming), nr.remove(r), r._dp = 0, r._time = r._tTime = nr._time, o = nr._first; o; )
            i = o._next, (n || !(!o._dur && o instanceof Tr && o.vars.onComplete === o._targets[0])) && Gs(r, o, o._start - o._delay), o = i;
        return Gs(nr, r, 0),
        r
    },
    context: function (t, n) {
        return t ? new X8(t, n) : ur
    },
    matchMedia: function (t) {
        return new Hfe(t)
    },
    matchMediaRefresh: function () {
        return uu.forEach(function (t) {
            var n = t.conditions,
            r,
            o;
            for (o in n)
                n[o] && (n[o] = !1, r = 1);
            r && t.revert()
        }) || sx()
    },
    addEventListener: function (t, n) {
        var r = c0[t] || (c0[t] = []);
        ~r.indexOf(n) || r.push(n)
    },
    removeEventListener: function (t, n) {
        var r = c0[t],
        o = r && r.indexOf(n);
        o >= 0 && r.splice(o, 1)
    },
    utils: {
        wrap: kfe,
        wrapYoyo: xfe,
        distribute: P8,
        random: O8,
        snap: E8,
        normalize: _fe,
        getUnit: co,
        clamp: vfe,
        splitColor: R8,
        toArray: Ki,
        selector: rx,
        mapRange: A8,
        pipe: wfe,
        unitize: bfe,
        interpolate: Sfe,
        shuffle: M8
    },
    install: g8,
    effects: B_,
    ticker: ki,
    updateRoot: Wo.updateRoot,
    plugins: gi,
    globalTimeline: nr,
    core: {
        PropTween: Ko,
        globals: v8,
        Tween: Tr,
        Timeline: Wo,
        Animation: mm,
        getCache: au,
        _removeLinkedListItem: fw,
        reverting: function () {
            return uo
        },
        context: function (t) {
            return t && ur && (ur.data.push(t), t._ctx = ur),
            ur
        },
        suppressOverwrites: function (t) {
            return VC = t
        }
    }
};
Yo("to,from,fromTo,delayedCall,set,killTweensOf", function (e) {
    return Q0[e] = Tr[e]
});
ki.add(Wo.updateRoot);
jd = Q0.to({}, {
    duration: 0
});
var Ufe = function (t, n) {
    for (var r = t._pt; r && r.p !== n && r.op !== n && r.fp !== n; )
        r = r._next;
    return r
}, qfe = function (t, n) {
    var r = t._targets,
    o,
    i,
    s;
    for (o in n)
        for (i = r.length; i--; )
            s = t._ptLookup[i][o], s && (s = s.d) && (s._pt && (s = Ufe(s, o)), s && s.modifier && s.modifier(n[o], t, r[i], o))
}, z_ = function (t, n) {
    return {
        name: t,
        rawVars: 1,
        init: function (o, i, s) {
            s._onInit = function (a) {
                var l,
                c;
                if (Wr(i) && (l = {}, Yo(i, function (u) {
                            return l[u] = 1
                        }), i = l), n) {
                    l = {};
                    for (c in i)
                        l[c] = n(i[c]);
                    i = l
                }
                qfe(a, i)
            }
        }
    }
}, ni = Q0.registerPlugin({
    name: "attr",
    init: function (t, n, r, o, i) {
        var s,
        a,
        l;
        this.tween = r;
        for (s in n)
            l = t.getAttribute(s) || "", a = this.add(t, "setAttribute", (l || 0) + "", n[s], o, i, 0, 0, s), a.op = s, a.b = l, this._props.push(s)
    },
    render: function (t, n) {
        for (var r = n._pt; r; )
            uo ? r.set(r.t, r.p, r.b, r) : r.r(t, r.d), r = r._next
    }
}, {
    name: "endArray",
    init: function (t, n) {
        for (var r = n.length; r--; )
            this.add(t, r, t[r] || 0, n[r], 0, 0, 0, 0, 0, 1)
    }
}, z_("roundProps", ox), z_("modifiers"), z_("snap", E8)) || Q0;
Tr.version = Wo.version = ni.version = "3.12.2";
m8 = 1;
jC() && xf();
tn.Power0;
tn.Power1;
tn.Power2;
tn.Power3;
tn.Power4;
tn.Linear;
tn.Quad;
tn.Cubic;
tn.Quart;
tn.Quint;
tn.Strong;
tn.Elastic;
tn.Back;
tn.SteppedEase;
tn.Bounce;
tn.Sine;
tn.Expo;
tn.Circ;
/*!
 * CSSPlugin 3.12.2
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var zO, Ll, of, ZC, Zc, HO, QC, Yfe = function () {
    return typeof window < "u"
}, Ja = {}, Bc = 180 / Math.PI, sf = Math.PI / 180, _d = Math.atan2, UO = 1e8, eI = /([A-Z])/g, Kfe = /(left|right|width|margin|padding|x)/i, Gfe = /[\s,\(]\S/, ea = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, ax = function (t, n) {
    return n.set(n.t, n.p, Math.round((n.s + n.c * t) * 1e4) / 1e4 + n.u, n)
}, Xfe = function (t, n) {
    return n.set(n.t, n.p, t === 1 ? n.e : Math.round((n.s + n.c * t) * 1e4) / 1e4 + n.u, n)
}, Jfe = function (t, n) {
    return n.set(n.t, n.p, t ? Math.round((n.s + n.c * t) * 1e4) / 1e4 + n.u : n.b, n)
}, Zfe = function (t, n) {
    var r = n.s + n.c * t;
    n.set(n.t, n.p, ~~(r + (r < 0 ?  - .5 : .5)) + n.u, n)
}, J8 = function (t, n) {
    return n.set(n.t, n.p, t ? n.e : n.b, n)
}, Z8 = function (t, n) {
    return n.set(n.t, n.p, t !== 1 ? n.b : n.e, n)
}, Qfe = function (t, n, r) {
    return t.style[n] = r
}, ehe = function (t, n, r) {
    return t.style.setProperty(n, r)
}, the = function (t, n, r) {
    return t._gsap[n] = r
}, nhe = function (t, n, r) {
    return t._gsap.scaleX = t._gsap.scaleY = r
}, rhe = function (t, n, r, o, i) {
    var s = t._gsap;
    s.scaleX = s.scaleY = r,
    s.renderTransform(i, s)
}, ohe = function (t, n, r, o, i) {
    var s = t._gsap;
    s[n] = r,
    s.renderTransform(i, s)
}, rr = "transform", Is = rr + "Origin", ihe = function e(t, n) {
    var r = this,
    o = this.target,
    i = o.style;
    if (t in Ja && i) {
        if (this.tfm = this.tfm || {}, t !== "transform")
            t = ea[t] || t, ~t.indexOf(",") ? t.split(",").forEach(function (s) {
                return r.tfm[s] = Wa(o, s)
            }) : this.tfm[t] = o._gsap.x ? o._gsap[t] : Wa(o, t);
        else
            return ea.transform.split(",").forEach(function (s) {
                return e.call(r, s, n)
            });
        if (this.props.indexOf(rr) >= 0)
            return;
        o._gsap.svg && (this.svgo = o.getAttribute("data-svg-origin"), this.props.push(Is, n, "")),
        t = rr
    }
    (i || n) && this.props.push(t, n, i[t])
}, Q8 = function (t) {
    t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
}, she = function () {
    var t = this.props,
    n = this.target,
    r = n.style,
    o = n._gsap,
    i,
    s;
    for (i = 0; i < t.length; i += 3)
        t[i + 1] ? n[t[i]] = t[i + 2] : t[i + 2] ? r[t[i]] = t[i + 2] : r.removeProperty(t[i].substr(0, 2) === "--" ? t[i] : t[i].replace(eI, "-$1").toLowerCase());
    if (this.tfm) {
        for (s in this.tfm)
            o[s] = this.tfm[s];
        o.svg && (o.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")),
        i = QC(),
        (!i || !i.isStart) && !r[rr] && (Q8(r), o.uncache = 1)
    }
}, eB = function (t, n) {
    var r = {
        target: t,
        props: [],
        revert: she,
        save: ihe
    };
    return t._gsap || ni.core.getCache(t),
    n && n.split(",").forEach(function (o) {
        return r.save(o)
    }),
    r
}, tB, lx = function (t, n) {
    var r = Ll.createElementNS ? Ll.createElementNS((n || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Ll.createElement(t);
    return r.style ? r : Ll.createElement(t)
}, ia = function e(t, n, r) {
    var o = getComputedStyle(t);
    return o[n] || o.getPropertyValue(n.replace(eI, "-$1").toLowerCase()) || o.getPropertyValue(n) || !r && e(t, Sf(n) || n, 1) || ""
}, qO = "O,Moz,ms,Ms,Webkit".split(","), Sf = function (t, n, r) {
    var o = n || Zc,
    i = o.style,
    s = 5;
    if (t in i && !r)
        return t;
    for (t = t.charAt(0).toUpperCase() + t.substr(1); s-- && !(qO[s] + t in i); );
    return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? qO[s] : "") + t
}, cx = function () {
    Yfe() && window.document && (zO = window, Ll = zO.document, of = Ll.documentElement, Zc = lx("div") || {
            style: {}
        }, lx("div"), rr = Sf(rr), Is = rr + "Origin", Zc.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", tB = !!Sf("perspective"), QC = ni.core.reverting, ZC = 1)
}, H_ = function e(t) {
    var n = lx("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
    r = this.parentNode,
    o = this.nextSibling,
    i = this.style.cssText,
    s;
    if (of.appendChild(n), n.appendChild(this), this.style.display = "block", t)
        try {
            s = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = e
        } catch {}
    else
        this._gsapBBox && (s = this._gsapBBox());
    return r && (o ? r.insertBefore(this, o) : r.appendChild(this)),
    of.removeChild(n),
    this.style.cssText = i,
    s
}, YO = function (t, n) {
    for (var r = n.length; r--; )
        if (t.hasAttribute(n[r]))
            return t.getAttribute(n[r])
}, nB = function (t) {
    var n;
    try {
        n = t.getBBox()
    } catch {
        n = H_.call(t, !0)
    }
    return n && (n.width || n.height) || t.getBBox === H_ || (n = H_.call(t, !0)),
    n && !n.width && !n.x && !n.y ? {
        x: +YO(t, ["x", "cx", "x1"]) || 0,
        y: +YO(t, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    }
     : n
}, rB = function (t) {
    return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && nB(t))
}, gm = function (t, n) {
    if (n) {
        var r = t.style;
        n in Ja && n !== Is && (n = rr),
        r.removeProperty ? ((n.substr(0, 2) === "ms" || n.substr(0, 6) === "webkit") && (n = "-" + n), r.removeProperty(n.replace(eI, "-$1").toLowerCase())) : r.removeAttribute(n)
    }
}, Bl = function (t, n, r, o, i, s) {
    var a = new Ko(t._pt, n, r, 0, 1, s ? Z8 : J8);
    return t._pt = a,
    a.b = o,
    a.e = i,
    t._props.push(r),
    a
}, KO = {
    deg: 1,
    rad: 1,
    turn: 1
}, ahe = {
    grid: 1,
    flex: 1
}, sc = function e(t, n, r, o) {
    var i = parseFloat(r) || 0,
    s = (r + "").trim().substr((i + "").length) || "px",
    a = Zc.style,
    l = Kfe.test(n),
    c = t.tagName.toLowerCase() === "svg",
    u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
    f = 100,
    p = o === "px",
    m = o === "%",
    v,
    y,
    b,
    w;
    return o === s || !i || KO[o] || KO[s] ? i : (s !== "px" && !p && (i = e(t, n, r, "px")), w = t.getCTM && rB(t), (m || s === "%") && (Ja[n] || ~n.indexOf("adius")) ? (v = w ? t.getBBox()[l ? "width" : "height"] : t[u], wr(m ? i / v * f : i / 100 * v)) : (a[l ? "width" : "height"] = f + (p ? s : o), y = ~n.indexOf("adius") || o === "em" && t.appendChild && !c ? t : t.parentNode, w && (y = (t.ownerSVGElement || {}).parentNode), (!y || y === Ll || !y.appendChild) && (y = Ll.body), b = y._gsap, b && m && b.width && l && b.time === ki.time && !b.uncache ? wr(i / b.width * f) : ((m || s === "%") && !ahe[ia(y, "display")] && (a.position = ia(t, "position")), y === t && (a.position = "static"), y.appendChild(Zc), v = Zc[u], y.removeChild(Zc), a.position = "absolute", l && m && (b = au(y), b.time = ki.time, b.width = y[u]), wr(p ? v * i / f : v && i ? f / v * i : 0))))
}, Wa = function (t, n, r, o) {
    var i;
    return ZC || cx(),
    n in ea && n !== "transform" && (n = ea[n], ~n.indexOf(",") && (n = n.split(",")[0])),
    Ja[n] && n !== "transform" ? (i = ym(t, o), i = n !== "transformOrigin" ? i[n] : i.svg ? i.origin : ty(ia(t, Is)) + " " + i.zOrigin + "px") : (i = t.style[n], (!i || i === "auto" || o || ~(i + "").indexOf("calc(")) && (i = ey[n] && ey[n](t, n, r) || ia(t, n) || w8(t, n) || (n === "opacity" ? 1 : 0))),
    r && !~(i + "").trim().indexOf(" ") ? sc(t, n, i, r) + r : i
}, lhe = function (t, n, r, o) {
    if (!r || r === "none") {
        var i = Sf(n, t, 1),
        s = i && ia(t, i, 1);
        s && s !== r ? (n = i, r = s) : n === "borderColor" && (r = ia(t, "borderTopColor"))
    }
    var a = new Ko(this._pt, t.style, n, 0, 1, K8),
    l = 0,
    c = 0,
    u,
    f,
    p,
    m,
    v,
    y,
    b,
    w,
    k,
    C,
    x,
    S;
    if (a.b = r, a.e = o, r += "", o += "", o === "auto" && (t.style[n] = o, o = ia(t, n) || o, t.style[n] = r), u = [r, o], B8(u), r = u[0], o = u[1], p = r.match(Fd) || [], S = o.match(Fd) || [], S.length) {
        for (; f = Fd.exec(o); )
            b = f[0], k = o.substring(l, f.index), v ? v = (v + 1) % 5 : (k.substr(-5) === "rgba(" || k.substr(-5) === "hsla(") && (v = 1), b !== (y = p[c++] || "") && (m = parseFloat(y) || 0, x = y.substr((m + "").length), b.charAt(1) === "=" && (b = rf(m, b) + x), w = parseFloat(b), C = b.substr((w + "").length), l = Fd.lastIndex - C.length, C || (C = C || Si.units[n] || x, l === o.length && (o += C, a.e += C)), x !== C && (m = sc(t, n, y, C) || 0), a._pt = {
                    _next: a._pt,
                    p: k || c === 1 ? k : ",",
                    s: m,
                    c: w - m,
                    m: v && v < 4 || n === "zIndex" ? Math.round : 0
                });
        a.c = l < o.length ? o.substring(l, o.length) : ""
    } else
        a.r = n === "display" && o === "none" ? Z8 : J8;
    return h8.test(o) && (a.e = 0),
    this._pt = a,
    a
}, GO = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, che = function (t) {
    var n = t.split(" "),
    r = n[0],
    o = n[1] || "50%";
    return (r === "top" || r === "bottom" || o === "left" || o === "right") && (t = r, r = o, o = t),
    n[0] = GO[r] || r,
    n[1] = GO[o] || o,
    n.join(" ")
}, uhe = function (t, n) {
    if (n.tween && n.tween._time === n.tween._dur) {
        var r = n.t,
        o = r.style,
        i = n.u,
        s = r._gsap,
        a,
        l,
        c;
        if (i === "all" || i === !0)
            o.cssText = "", l = 1;
        else
            for (i = i.split(","), c = i.length; --c > -1; )
                a = i[c], Ja[a] && (l = 1, a = a === "transformOrigin" ? Is : rr), gm(r, a);
        l && (gm(r, rr), s && (s.svg && r.removeAttribute("transform"), ym(r, 1), s.uncache = 1, Q8(o)))
    }
}, ey = {
    clearProps: function (t, n, r, o, i) {
        if (i.data !== "isFromStart") {
            var s = t._pt = new Ko(t._pt, n, r, 0, 0, uhe);
            return s.u = o,
            s.pr = -10,
            s.tween = i,
            t._props.push(r),
            1
        }
    }
}, vm = [1, 0, 0, 1, 0, 0], oB = {}, iB = function (t) {
    return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t
}, XO = function (t) {
    var n = ia(t, rr);
    return iB(n) ? vm : n.substr(7).match(f8).map(wr)
}, tI = function (t, n) {
    var r = t._gsap || au(t),
    o = t.style,
    i = XO(t),
    s,
    a,
    l,
    c;
    return r.svg && t.getAttribute("transform") ? (l = t.transform.baseVal.consolidate().matrix, i = [l.a, l.b, l.c, l.d, l.e, l.f], i.join(",") === "1,0,0,1,0,0" ? vm : i) : (i === vm && !t.offsetParent && t !== of && !r.svg && (l = o.display, o.display = "block", s = t.parentNode, (!s || !t.offsetParent) && (c = 1, a = t.nextElementSibling, of.appendChild(t)), i = XO(t), l ? o.display = l : gm(t, "display"), c && (a ? s.insertBefore(t, a) : s ? s.appendChild(t) : of.removeChild(t))), n && i.length > 6 ? [i[0], i[1], i[4], i[5], i[12], i[13]] : i)
}, ux = function (t, n, r, o, i, s) {
    var a = t._gsap,
    l = i || tI(t, !0),
    c = a.xOrigin || 0,
    u = a.yOrigin || 0,
    f = a.xOffset || 0,
    p = a.yOffset || 0,
    m = l[0],
    v = l[1],
    y = l[2],
    b = l[3],
    w = l[4],
    k = l[5],
    C = n.split(" "),
    x = parseFloat(C[0]) || 0,
    S = parseFloat(C[1]) || 0,
    T,
    E,
    M,
    N;
    r ? l !== vm && (E = m * b - v * y) && (M = x * (b / E) + S * (-y / E) + (y * k - b * w) / E, N = x * (-v / E) + S * (m / E) - (m * k - v * w) / E, x = M, S = N) : (T = nB(t), x = T.x + (~C[0].indexOf("%") ? x / 100 * T.width : x), S = T.y + (~(C[1] || C[0]).indexOf("%") ? S / 100 * T.height : S)),
    o || o !== !1 && a.smooth ? (w = x - c, k = S - u, a.xOffset = f + (w * m + k * y) - w, a.yOffset = p + (w * v + k * b) - k) : a.xOffset = a.yOffset = 0,
    a.xOrigin = x,
    a.yOrigin = S,
    a.smooth = !!o,
    a.origin = n,
    a.originIsAbsolute = !!r,
    t.style[Is] = "0px 0px",
    s && (Bl(s, a, "xOrigin", c, x), Bl(s, a, "yOrigin", u, S), Bl(s, a, "xOffset", f, a.xOffset), Bl(s, a, "yOffset", p, a.yOffset)),
    t.setAttribute("data-svg-origin", x + " " + S)
}, ym = function (t, n) {
    var r = t._gsap || new W8(t);
    if ("x" in r && !n && !r.uncache)
        return r;
    var o = t.style,
    i = r.scaleX < 0,
    s = "px",
    a = "deg",
    l = getComputedStyle(t),
    c = ia(t, Is) || "0",
    u,
    f,
    p,
    m,
    v,
    y,
    b,
    w,
    k,
    C,
    x,
    S,
    T,
    E,
    M,
    N,
    F,
    K,
    j,
    G,
    Y,
    ue,
    re,
    de,
    Se,
    Pe,
    je,
    Ke,
    Ue,
    yt,
    at,
    le;
    return u = f = p = y = b = w = k = C = x = 0,
    m = v = 1,
    r.svg = !!(t.getCTM && rB(t)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (o[rr] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[rr] !== "none" ? l[rr] : "")), o.scale = o.rotate = o.translate = "none"),
    E = tI(t, r.svg),
    r.svg && (r.uncache ? (Se = t.getBBox(), c = r.xOrigin - Se.x + "px " + (r.yOrigin - Se.y) + "px", de = "") : de = !n && t.getAttribute("data-svg-origin"), ux(t, de || c, !!de || r.originIsAbsolute, r.smooth !== !1, E)),
    S = r.xOrigin || 0,
    T = r.yOrigin || 0,
    E !== vm && (K = E[0], j = E[1], G = E[2], Y = E[3], u = ue = E[4], f = re = E[5], E.length === 6 ? (m = Math.sqrt(K * K + j * j), v = Math.sqrt(Y * Y + G * G), y = K || j ? _d(j, K) * Bc : 0, k = G || Y ? _d(G, Y) * Bc + y : 0, k && (v *= Math.abs(Math.cos(k * sf))), r.svg && (u -= S - (S * K + T * G), f -= T - (S * j + T * Y))) : (le = E[6], yt = E[7], je = E[8], Ke = E[9], Ue = E[10], at = E[11], u = E[12], f = E[13], p = E[14], M = _d(le, Ue), b = M * Bc, M && (N = Math.cos(-M), F = Math.sin(-M), de = ue * N + je * F, Se = re * N + Ke * F, Pe = le * N + Ue * F, je = ue * -F + je * N, Ke = re * -F + Ke * N, Ue = le * -F + Ue * N, at = yt * -F + at * N, ue = de, re = Se, le = Pe), M = _d(-G, Ue), w = M * Bc, M && (N = Math.cos(-M), F = Math.sin(-M), de = K * N - je * F, Se = j * N - Ke * F, Pe = G * N - Ue * F, at = Y * F + at * N, K = de, j = Se, G = Pe), M = _d(j, K), y = M * Bc, M && (N = Math.cos(M), F = Math.sin(M), de = K * N + j * F, Se = ue * N + re * F, j = j * N - K * F, re = re * N - ue * F, K = de, ue = Se), b && Math.abs(b) + Math.abs(y) > 359.9 && (b = y = 0, w = 180 - w), m = wr(Math.sqrt(K * K + j * j + G * G)), v = wr(Math.sqrt(re * re + le * le)), M = _d(ue, re), k = Math.abs(M) > 2e-4 ? M * Bc : 0, x = at ? 1 / (at < 0 ? -at : at) : 0), r.svg && (de = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !iB(ia(t, rr)), de && t.setAttribute("transform", de))),
    Math.abs(k) > 90 && Math.abs(k) < 270 && (i ? (m *= -1, k += y <= 0 ? 180 : -180, y += y <= 0 ? 180 : -180) : (v *= -1, k += k <= 0 ? 180 : -180)),
    n = n || r.uncache,
    r.x = u - ((r.xPercent = u && (!n && r.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? t.offsetWidth * r.xPercent / 100 : 0) + s,
    r.y = f - ((r.yPercent = f && (!n && r.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-f) ? -50 : 0))) ? t.offsetHeight * r.yPercent / 100 : 0) + s,
    r.z = p + s,
    r.scaleX = wr(m),
    r.scaleY = wr(v),
    r.rotation = wr(y) + a,
    r.rotationX = wr(b) + a,
    r.rotationY = wr(w) + a,
    r.skewX = k + a,
    r.skewY = C + a,
    r.transformPerspective = x + s,
    (r.zOrigin = parseFloat(c.split(" ")[2]) || 0) && (o[Is] = ty(c)),
    r.xOffset = r.yOffset = 0,
    r.force3D = Si.force3D,
    r.renderTransform = r.svg ? fhe : tB ? sB : dhe,
    r.uncache = 0,
    r
}, ty = function (t) {
    return (t = t.split(" "))[0] + " " + t[1]
}, U_ = function (t, n, r) {
    var o = co(n);
    return wr(parseFloat(n) + parseFloat(sc(t, "x", r + "px", o))) + o
}, dhe = function (t, n) {
    n.z = "0px",
    n.rotationY = n.rotationX = "0deg",
    n.force3D = 0,
    sB(t, n)
}, Dc = "0deg", jh = "0px", Nc = ") ", sB = function (t, n) {
    var r = n || this,
    o = r.xPercent,
    i = r.yPercent,
    s = r.x,
    a = r.y,
    l = r.z,
    c = r.rotation,
    u = r.rotationY,
    f = r.rotationX,
    p = r.skewX,
    m = r.skewY,
    v = r.scaleX,
    y = r.scaleY,
    b = r.transformPerspective,
    w = r.force3D,
    k = r.target,
    C = r.zOrigin,
    x = "",
    S = w === "auto" && t && t !== 1 || w === !0;
    if (C && (f !== Dc || u !== Dc)) {
        var T = parseFloat(u) * sf,
        E = Math.sin(T),
        M = Math.cos(T),
        N;
        T = parseFloat(f) * sf,
        N = Math.cos(T),
        s = U_(k, s, E * N * -C),
        a = U_(k, a, -Math.sin(T) * -C),
        l = U_(k, l, M * N * -C + C)
    }
    b !== jh && (x += "perspective(" + b + Nc),
    (o || i) && (x += "translate(" + o + "%, " + i + "%) "),
    (S || s !== jh || a !== jh || l !== jh) && (x += l !== jh || S ? "translate3d(" + s + ", " + a + ", " + l + ") " : "translate(" + s + ", " + a + Nc),
    c !== Dc && (x += "rotate(" + c + Nc),
    u !== Dc && (x += "rotateY(" + u + Nc),
    f !== Dc && (x += "rotateX(" + f + Nc),
    (p !== Dc || m !== Dc) && (x += "skew(" + p + ", " + m + Nc),
    (v !== 1 || y !== 1) && (x += "scale(" + v + ", " + y + Nc),
    k.style[rr] = x || "translate(0, 0)"
}, fhe = function (t, n) {
    var r = n || this,
    o = r.xPercent,
    i = r.yPercent,
    s = r.x,
    a = r.y,
    l = r.rotation,
    c = r.skewX,
    u = r.skewY,
    f = r.scaleX,
    p = r.scaleY,
    m = r.target,
    v = r.xOrigin,
    y = r.yOrigin,
    b = r.xOffset,
    w = r.yOffset,
    k = r.forceCSS,
    C = parseFloat(s),
    x = parseFloat(a),
    S,
    T,
    E,
    M,
    N;
    l = parseFloat(l),
    c = parseFloat(c),
    u = parseFloat(u),
    u && (u = parseFloat(u), c += u, l += u),
    l || c ? (l *= sf, c *= sf, S = Math.cos(l) * f, T = Math.sin(l) * f, E = Math.sin(l - c) * -p, M = Math.cos(l - c) * p, c && (u *= sf, N = Math.tan(c - u), N = Math.sqrt(1 + N * N), E *= N, M *= N, u && (N = Math.tan(u), N = Math.sqrt(1 + N * N), S *= N, T *= N)), S = wr(S), T = wr(T), E = wr(E), M = wr(M)) : (S = f, M = p, T = E = 0),
    (C && !~(s + "").indexOf("px") || x && !~(a + "").indexOf("px")) && (C = sc(m, "x", s, "px"), x = sc(m, "y", a, "px")),
    (v || y || b || w) && (C = wr(C + v - (v * S + y * E) + b), x = wr(x + y - (v * T + y * M) + w)),
    (o || i) && (N = m.getBBox(), C = wr(C + o / 100 * N.width), x = wr(x + i / 100 * N.height)),
    N = "matrix(" + S + "," + T + "," + E + "," + M + "," + C + "," + x + ")",
    m.setAttribute("transform", N),
    k && (m.style[rr] = N)
}, hhe = function (t, n, r, o, i) {
    var s = 360,
    a = Wr(i),
    l = parseFloat(i) * (a && ~i.indexOf("rad") ? Bc : 1),
    c = l - o,
    u = o + c + "deg",
    f,
    p;
    return a && (f = i.split("_")[1], f === "short" && (c %= s, c !== c % (s / 2) && (c += c < 0 ? s : -s)), f === "cw" && c < 0 ? c = (c + s * UO) % s - ~~(c / s) * s : f === "ccw" && c > 0 && (c = (c - s * UO) % s - ~~(c / s) * s)),
    t._pt = p = new Ko(t._pt, n, r, o, c, Xfe),
    p.e = u,
    p.u = "deg",
    t._props.push(r),
    p
}, JO = function (t, n) {
    for (var r in n)
        t[r] = n[r];
    return t
}, phe = function (t, n, r) {
    var o = JO({}, r._gsap),
    i = "perspective,force3D,transformOrigin,svgOrigin",
    s = r.style,
    a,
    l,
    c,
    u,
    f,
    p,
    m,
    v;
    o.svg ? (c = r.getAttribute("transform"), r.setAttribute("transform", ""), s[rr] = n, a = ym(r, 1), gm(r, rr), r.setAttribute("transform", c)) : (c = getComputedStyle(r)[rr], s[rr] = n, a = ym(r, 1), s[rr] = c);
    for (l in Ja)
        c = o[l], u = a[l], c !== u && i.indexOf(l) < 0 && (m = co(c), v = co(u), f = m !== v ? sc(r, l, c, v) : parseFloat(c), p = parseFloat(u), t._pt = new Ko(t._pt, a, l, f, p - f, ax), t._pt.u = v || 0, t._props.push(l));
    JO(a, o)
};
Yo("padding,margin,Width,Radius", function (e, t) {
    var n = "Top",
    r = "Right",
    o = "Bottom",
    i = "Left",
    s = (t < 3 ? [n, r, o, i] : [n + i, n + r, o + r, o + i]).map(function (a) {
        return t < 2 ? e + a : "border" + a + e
    });
    ey[t > 1 ? "border" + e : e] = function (a, l, c, u, f) {
        var p,
        m;
        if (arguments.length < 4)
            return p = s.map(function (v) {
                return Wa(a, v, c)
            }), m = p.join(" "), m.split(p[0]).length === 5 ? p[0] : m;
        p = (u + "").split(" "),
        m = {},
        s.forEach(function (v, y) {
            return m[v] = p[y] = p[y] || p[(y - 1) / 2 | 0]
        }),
        a.init(l, m, f)
    }
});
var aB = {
    name: "css",
    register: cx,
    targetTest: function (t) {
        return t.style && t.nodeType
    },
    init: function (t, n, r, o, i) {
        var s = this._props,
        a = t.style,
        l = r.vars.startAt,
        c,
        u,
        f,
        p,
        m,
        v,
        y,
        b,
        w,
        k,
        C,
        x,
        S,
        T,
        E,
        M;
        ZC || cx(),
        this.styles = this.styles || eB(t),
        M = this.styles.props,
        this.tween = r;
        for (y in n)
            if (y !== "autoRound" && (u = n[y], !(gi[y] && z8(y, n, r, o, t, i)))) {
                if (m = typeof u, v = ey[y], m === "function" && (u = u.call(r, o, t, i), m = typeof u), m === "string" && ~u.indexOf("random(") && (u = hm(u)), v)
                    v(this, t, y, u, r) && (E = 1);
                else if (y.substr(0, 2) === "--")
                    c = (getComputedStyle(t).getPropertyValue(y) + "").trim(), u += "", ql.lastIndex = 0, ql.test(c) || (b = co(c), w = co(u)), w ? b !== w && (c = sc(t, y, c, w) + w) : b && (u += b), this.add(a, "setProperty", c, u, o, i, 0, 0, y), s.push(y), M.push(y, 0, a[y]);
                else if (m !== "undefined") {
                    if (l && y in l ? (c = typeof l[y] == "function" ? l[y].call(r, o, t, i) : l[y], Wr(c) && ~c.indexOf("random(") && (c = hm(c)), co(c + "") || (c += Si.units[y] || co(Wa(t, y)) || ""), (c + "").charAt(1) === "=" && (c = Wa(t, y))) : c = Wa(t, y), p = parseFloat(c), k = m === "string" && u.charAt(1) === "=" && u.substr(0, 2), k && (u = u.substr(2)), f = parseFloat(u), y in ea && (y === "autoAlpha" && (p === 1 && Wa(t, "visibility") === "hidden" && f && (p = 0), M.push("visibility", 0, a.visibility), Bl(this, a, "visibility", p ? "inherit" : "hidden", f ? "inherit" : "hidden", !f)), y !== "scale" && y !== "transform" && (y = ea[y], ~y.indexOf(",") && (y = y.split(",")[0]))), C = y in Ja, C) {
                        if (this.styles.save(y), x || (S = t._gsap, S.renderTransform && !n.parseTransform || ym(t, n.parseTransform), T = n.smoothOrigin !== !1 && S.smooth, x = this._pt = new Ko(this._pt, a, rr, 0, 1, S.renderTransform, S, 0, -1), x.dep = 1), y === "scale")
                            this._pt = new Ko(this._pt, S, "scaleY", S.scaleY, (k ? rf(S.scaleY, k + f) : f) - S.scaleY || 0, ax), this._pt.u = 0, s.push("scaleY", y), y += "X";
                        else if (y === "transformOrigin") {
                            M.push(Is, 0, a[Is]),
                            u = che(u),
                            S.svg ? ux(t, u, 0, T, 0, this) : (w = parseFloat(u.split(" ")[2]) || 0, w !== S.zOrigin && Bl(this, S, "zOrigin", S.zOrigin, w), Bl(this, a, y, ty(c), ty(u)));
                            continue
                        } else if (y === "svgOrigin") {
                            ux(t, u, 1, T, 0, this);
                            continue
                        } else if (y in oB) {
                            hhe(this, S, y, p, k ? rf(p, k + u) : u);
                            continue
                        } else if (y === "smoothOrigin") {
                            Bl(this, S, "smooth", S.smooth, u);
                            continue
                        } else if (y === "force3D") {
                            S[y] = u;
                            continue
                        } else if (y === "transform") {
                            phe(this, u, t);
                            continue
                        }
                    } else
                        y in a || (y = Sf(y) || y);
                    if (C || (f || f === 0) && (p || p === 0) && !Gfe.test(u) && y in a)
                        b = (c + "").substr((p + "").length), f || (f = 0), w = co(u) || (y in Si.units ? Si.units[y] : b), b !== w && (p = sc(t, y, c, w)), this._pt = new Ko(this._pt, C ? S : a, y, p, (k ? rf(p, k + f) : f) - p, !C && (w === "px" || y === "zIndex") && n.autoRound !== !1 ? Zfe : ax), this._pt.u = w || 0, b !== w && w !== "%" && (this._pt.b = c, this._pt.r = Jfe);
                    else if (y in a)
                        lhe.call(this, t, y, c, k ? k + u : u);
                    else if (y in t)
                        this.add(t, y, c || t[y], k ? k + u : u, o, i);
                    else if (y !== "parseTransform") {
                        zC(y, u);
                        continue
                    }
                    C || (y in a ? M.push(y, 0, a[y]) : M.push(y, 1, c || t[y])),
                    s.push(y)
                }
            }
        E && G8(this)
    },
    render: function (t, n) {
        if (n.tween._time || !QC())
            for (var r = n._pt; r; )
                r.r(t, r.d), r = r._next;
        else
            n.styles.revert()
    },
    get: Wa,
    aliases: ea,
    getSetter: function (t, n, r) {
        var o = ea[n];
        return o && o.indexOf(",") < 0 && (n = o),
        n in Ja && n !== Is && (t._gsap.x || Wa(t, "x")) ? r && HO === r ? n === "scale" ? nhe : the : (HO = r || {}) && (n === "scale" ? rhe : ohe) : t.style && !FC(t.style[n]) ? Qfe : ~n.indexOf("-") ? ehe : XC(t, n)
    },
    core: {
        _removeProperty: gm,
        _getMatrix: tI
    }
};
ni.utils.checkPrefix = Sf;
ni.core.getStyleSaver = eB;
(function (e, t, n, r) {
    var o = Yo(e + "," + t + "," + n, function (i) {
        Ja[i] = 1
    });
    Yo(t, function (i) {
        Si.units[i] = "deg",
        oB[i] = 1
    }),
    ea[o[13]] = e + "," + t,
    Yo(r, function (i) {
        var s = i.split(":");
        ea[s[1]] = o[s[0]]
    })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Yo("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (e) {
    Si.units[e] = "px"
});
ni.registerPlugin(aB);
var nI = ni.registerPlugin(aB) || ni;
nI.core.Tween;
const lB = (e, t) => {
    const n = Math.max(e.left, t.left),
    r = Math.min(e.left + e.width, t.left + t.width);
    if (r <= n)
        return null;
    const o = Math.max(e.top, t.top),
    i = Math.min(e.top + e.height, t.top + t.height);
    return i <= o ? null : {
        left: n,
        top: o,
        width: r - n,
        height: i - o
    }
}, rI = (e, t) => {
    const n = lB(e, t);
    if (!n)
        return 0;
    const r = e.width * e.height;
    return n.width * n.height / r
}, mhe = (e, t = BC.x) => nI.utils.snap(t, e), cB = ({
    left: e,
    top: t,
    width: n,
    height: r
}, o) => ({
    x: e + n / 2 - o.width / 2,
    y: t + r / 2 * .75 - o.height / 2
}), ghe = (e, t, n, r) => Math.sqrt(Math.pow(n - e, 2) + Math.pow(r - t, 2)), vhe = (e, t) => {
    const n = (t.x + e.x) / 2,
    r = (t.y + e.y) / 2;
    return {
        x: n,
        y: r
    }
}, yhe = Object.freeze(Object.defineProperty({
            __proto__: null,
            areaCoverage: rI,
            distanceBetweenPoints: ghe,
            getCenterPoint: vhe,
            getCenteredPositionInVisibleFrame: cB,
            rectangleIntersection: lB,
            snapToGrid: mhe
        }, Symbol.toStringTag, {
            value: "Module"
        })), Vc = 50, uB = .7, dB = ({
    area: e,
    workflow: {
        nodes: t
    },
    startPosition: n = {
        x: 0,
        y: 0
    },
    step: r
}) => {
    const o = l => ({
        top: l.position.y - Vc,
        left: l.position.x - Vc,
        width: fr + Vc + Vc,
        height: fr + Vc + Vc
    }),
    i = Object.values(t).map(o),
    s = {
        top: n.y,
        left: n.x,
        width: e.width,
        height: e.height
    };
    let a;
    do {
        if (a = 0, i.forEach(l => {
                a += rI(s, l)
            }), a === 0)
            return {
                x: s.left,
                y: s.top
            };
        s.left += r.x,
        s.top += r.y
    } while (!0)
}, fB = ({
    objectBounds: e,
    nodes: t,
    visibleFrame: n
}) => ({
    left: r,
    top: o
}) => {
    const i = dB({
        area: e,
        workflow: {
            nodes: t
        },
        startPosition: {
            x: r,
            y: o
        },
        step: {
            x: 120,
            y: 120
        }
    }),
    s = rI({
        left: i.x,
        top: i.y,
        width: e.width,
        height: e.height
    }, n);
    return {
        ...i,
        visibility: s
    }
}, hB = ({
    startPoint: {
        x: e,
        y: t
    },
    visibleFrame: n,
    objectBounds: r = {
        width: fr,
        height: fr
    },
    nodes: o
}) => {
    let i = 0;
    do {
        const s = fB({
            visibleFrame: n,
            objectBounds: r,
            nodes: o
        })({
            left: e + i,
            top: t
        });
        if (s.visibility >= uB) {
            consola.info("found free space around center");
            const {
                x: a,
                y: l
            } = s;
            return {
                x: a,
                y: l
            }
        }
        i += 120
    } while (i < n.right);
    return consola.info("no free space found around center"), {
        x: e + Math.random() * r.width,
        y: t + Math.random() * r.height
    }
}, whe = ({
    visibleFrame: e,
    objectBounds: t = {
        width: fr,
        height: fr
    },
    nodes: n
}) => {
    const r = cB(e, t);
    return hB({
        startPoint: r,
        visibleFrame: e,
        objectBounds: t,
        nodes: n
    })
}, dx = (e, t) => ({
    ...e ?? t,
    width: LC
}), {
    nodeSize: ZO,
    nodeNameMargin: bhe,
    nodeStatusMarginTop: _he,
    nodeStatusHeight: khe,
    nodeNameLineHeight: xhe,
    portSize: QO,
    horizontalNodePadding: e$
} = dw, up = {
    top: bhe + xhe,
    bottom: _he + khe,
    left: e$,
    right: e$
}, She = ({
    nodes: e,
    workflowAnnotations: t,
    padding: n
}) => {
    let r = 1 / 0,
    o = 1 / 0,
    i = -1 / 0,
    s = -1 / 0;
    return Object.values(e).forEach(({
            position: {
                x: a,
                y: l
            }
        }) => {
        const c = l - (n ? up.top : 0),
        u = l + ZO + (n ? up.bottom : 0),
        f = a - (n ? up.left : 0),
        p = a + ZO + (n ? up.right : 0);
        r = Math.min(r, f),
        o = Math.min(o, c),
        i = Math.max(i, p),
        s = Math.max(s, u)
    }),
    t.forEach(({
            bounds: {
                x: a,
                y: l,
                height: c,
                width: u
            }
        }) => {
        r = Math.min(r, a),
        o = Math.min(o, l),
        i = Math.max(i, a + u),
        s = Math.max(s, l + c)
    }),
    r === 1 / 0 && (r = 0, o = 0, i = 0, s = 0), {
        left: r,
        top: o,
        right: i,
        bottom: s
    }
}, t$ = (e, t, n) => {
    const r = dx(e.bounds, n),
    o = () => r.y,
    i = () => {
        const l = t === "in" ? QO : r.width;
        return r.x - l
    },
    s = () => {
        const l = t === "in" ? QO : r.width;
        return r.x + l
    },
    a = () => o() + r.height;
    return {
        leftMargin: i(),
        rightMargin: s(),
        topMargin: o(),
        bottomMargin: a()
    }
}, pB = ({
    nodes: e = {},
    workflowAnnotations: t = [],
    metaInPorts: n = null,
    metaOutPorts: r = null
}, {
    padding: o = !1,
    calculatedPortBarBounds: i = null
} = {}) => {
    let {
        left: s,
        top: a,
        right: l,
        bottom: c
    } = She({
        nodes: e,
        workflowAnnotations: t,
        padding: o
    });
    const u = Object.keys(e).length !== 0,
    f = Boolean(n || r),
    p = n?.ports?.length > 0,
    m = Boolean(i?.in),
    v = Boolean(i?.out),
    y = r?.ports?.length > 0;
    if (!u && f && (p || y))
        return {
            left: s,
            top: a,
            right: l,
            bottom: c,
            width: l - s,
            height: c - a
        };
    if (p && m) {
        const {
            leftMargin: b,
            rightMargin: w,
            topMargin: k,
            bottomMargin: C
        } = t$(n, "in", i?.in);
        s = Math.min(s, b),
        l = Math.max(l, w),
        a = Math.min(a, k),
        c = Math.max(c, C)
    }
    if (y && v) {
        const {
            leftMargin: b,
            rightMargin: w,
            topMargin: k,
            bottomMargin: C
        } = t$(r, "out", i?.out);
        s = Math.min(s, b),
        l = Math.max(l, w),
        a = Math.min(a, k),
        c = Math.max(c, C)
    }
    return {
        left: s,
        top: a,
        right: l,
        bottom: c,
        width: l - s,
        height: c - a
    }
}, Che = e => {
    const t = pB(e, {
        padding: !0
    }),
    n = -s0,
    r = s0,
    o = -s0,
    i = a8,
    s = LC,
    a = t.left + n,
    l = t.top + o,
    c = {
        x: a,
        y: l,
        height: i,
        width: s
    },
    u = {
        x: Math.max(t.right + r, a + s8),
        y: l,
        height: i,
        width: s
    };
    return {
        in: c,
        out: u
    }
}, br = {
    findFreeSpace: dB,
    findFreeSpaceFrom: fB,
    findFreeSpaceAroundPointWithFallback: hB,
    findFreeSpaceAroundCenterWithFallback: whe,
    getWorkflowObjectBounds: pB,
    calculateMetaNodePortBarBounds: Che,
    nodePadding: up,
    utils: yhe,
    constants: {
        NODE_PADDING: Vc,
        VISIBILITY_THRESHOLD: uB
    }
}, zo = {
    WorkflowPage: "WorkflowPage",
    EntryPage: {
        GetStartedPage: "GetStartedPage"
    },
    SpaceBrowsingPage: "SpaceBrowsingPage"
}, $p = e => (n => {
    const r = new Uint16Array(n.length);
    for (let o = 0; o < r.length; o++)
        r[o] = n.charCodeAt(o);
    return btoa(String.fromCharCode(...new Uint8Array(r.buffer)))
})(e), Ihe = e => $p(e), The = () => ({
    isLoadingWorkflow: !1
}), Mhe = {
    setIsLoadingWorkflow(e, t) {
        e.isLoadingWorkflow = t
    }
}, Phe = {
    async initializeApplication({
        dispatch: e
    }, {
        $router: t
    }) {
        await Oe.event.subscribeEvent({
            typeId: "AppStateChangedEventType"
        }),
        await ap({
            DESKTOP: async() => {
                try {
                    await Oe.event.subscribeEvent({
                        typeId: "UpdateAvailableEventType"
                    }),
                    Oe.desktop.checkForUpdates()
                } catch (r) {
                    consola.log(r)
                }
            }
        }),
        t.beforeEach(async(r, o, i) => {
            const s = o.name === zo.WorkflowPage,
            a = r.name === zo.WorkflowPage;
            if (s && !a) {
                await e("switchWorkflow", {
                    newWorkflow: null
                }),
                i();
                return
            }
            if (a) {
                i(),
                await e("switchWorkflow", {
                    newWorkflow: r.params
                });
                return
            }
            i()
        }),
        await e("settings/fetchSettings", {}, {
            root: !0
        });
        const n = await Oe.application.getState({});
        await e("replaceApplicationState", n),
        await e("setActiveProject", {
            $router: t
        }),
        await ap({
            DESKTOP: () => Promise.all([e("spaces/loadLocalSpace", {}, {
                        root: !0
                    }), e("spaces/fetchAllSpaceProviders", {}, {
                        root: !0
                    })])
        })
    },
    destroyApplication({
        dispatch: e
    }) {
        Oe.event.unsubscribeEventListener({
            typeId: "AppStateChangedEventType"
        }),
        e("unloadActiveWorkflow", {
            clearWorkflow: !0
        })
    },
    async setActiveProject({
        state: e
    }, {
        $router: t
    }) {
        const {
            openProjects: n
        } = e;
        if (n.length === 0) {
            consola.info("No workflows opened"),
            await ap({
                DESKTOP: () => t.push({
                    name: zo.EntryPage.GetStartedPage
                })
            });
            return
        }
        const r = n.find(i => i.activeWorkflowId);
        if (!r) {
            await ap({
                DESKTOP: () => t.push({
                    name: zo.EntryPage.GetStartedPage
                })
            });
            return
        }
        e?.activeProjectId !== r.projectId && await t.push({
            name: zo.WorkflowPage,
            params: {
                projectId: r.projectId,
                workflowId: r.activeWorkflowId
            },
            force: !0
        })
    },
    async switchWorkflow({
        commit: e,
        dispatch: t,
        rootState: n,
        state: r
    }, {
        newWorkflow: o = null
    }) {
        const i = n.workflow?.activeWorkflow?.projectId !== o?.projectId;
        if (await t("updatePreviewSnapshot", {
                isChangingProject: i,
                newWorkflow: o
            }), e("setIsLoadingWorkflow", !0), n.workflow?.activeWorkflow && (t("saveCanvasState"), await t("unloadActiveWorkflow", {
                    clearWorkflow: !o
                }), o || e("setActiveProjectId", null)), o) {
            const {
                projectId: s,
                workflowId: a = "root"
            } = o;
            if (i) {
                const l = Ihe(`${s}--${a}`),
                c = r.savedCanvasStates[l]?.lastActive;
                await t("loadWorkflow", {
                    projectId: s,
                    workflowId: c
                })
            } else
                await t("loadWorkflow", {
                    projectId: s,
                    workflowId: a
                })
        }
        e("setIsLoadingWorkflow", !1)
    },
    async loadWorkflow({
        dispatch: e
    }, {
        projectId: t,
        workflowId: n = "root"
    }) {
        await Oe.desktop.setProjectActiveAndEnsureItsLoaded({
            projectId: t
        });
        const r = await Oe.workflow.getWorkflow({
            projectId: t,
            workflowId: n,
            includeInteractionInfo: !0
        });
        if (!r)
            throw new Error(`Workflow not found: "${t}" > "${n}"`);
        await e("beforeSetActivateWorkflow", {
            workflow: r.workflow
        }),
        await e("setWorkflow", {
            projectId: t,
            workflow: r.workflow,
            snapshotId: r.snapshotId
        }),
        await e("afterSetActivateWorkflow")
    },
    beforeSetActivateWorkflow({
        commit: e
    }, {
        workflow: t
    }) {
        e("workflow/setCalculatedMetanodePortBarBounds", br.calculateMetaNodePortBarBounds(t), {
            root: !0
        })
    },
    async setWorkflow({
        commit: e,
        dispatch: t
    }, {
        workflow: n,
        projectId: r,
        snapshotId: o
    }) {
        e("setActiveProjectId", r),
        e("workflow/setActiveWorkflow", {
            ...n,
            projectId: r
        }, {
            root: !0
        }),
        e("workflow/setActiveSnapshotId", o, {
            root: !0
        });
        const i = n.info.containerId;
        Oe.event.subscribeEvent({
            typeId: "WorkflowChangedEventType",
            projectId: r,
            workflowId: i,
            snapshotId: o
        }),
        await t("restoreCanvasState")
    },
    afterSetActivateWorkflow({
        dispatch: e
    }) {
        e("workflow/checkForLinkedComponentUpdates", {
            auto: !0
        }, {
            root: !0
        })
    },
    async unloadActiveWorkflow({
        commit: e,
        rootState: t,
        dispatch: n
    }, {
        clearWorkflow: r
    }) {
        const {
            activeWorkflow: o
        } = t.workflow;
        if (!o)
            return;
        const {
            projectId: i,
            info: {
                containerId: s
            }
        } = o;
        await n("resetCanvasMode"),
        await n("toggleContextMenu"),
        n("workflow/setEditableAnnotationId", null, {
            root: !0
        }),
        n("panel/closeExtensionPanel", null, {
            root: !0
        }),
        n("workflow/clearComponentUpdateToasts", null, {
            root: !0
        });
        const {
            activeSnapshotId: a
        } = t.workflow;
        Oe.event.unsubscribeEventListener({
            typeId: "WorkflowChangedEventType",
            projectId: i,
            workflowId: s,
            snapshotId: a
        }),
        e("selection/clearSelection", null, {
            root: !0
        }),
        e("workflow/setTooltip", null, {
            root: !0
        }),
        r && e("workflow/setActiveWorkflow", null, {
            root: !0
        })
    },
    async subscribeToNodeRepositoryLoadingEvent({
        state: e
    }) {
        e.nodeRepositoryLoaded || await Oe.event.subscribeEvent({
            typeId: "NodeRepositoryLoadingProgressEventType"
        })
    }
}, Ehe = {};
var Za = {}, Ohe = {
    get exports() {
        return Za
    },
    set exports(e) {
        Za = e
    }
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function (e, t) {
    (function () {
        var n,
        r = "4.17.21",
        o = 200,
        i = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
        s = "Expected a function",
        a = "Invalid `variable` option passed into `_.template`",
        l = "__lodash_hash_undefined__",
        c = 500,
        u = "__lodash_placeholder__",
        f = 1,
        p = 2,
        m = 4,
        v = 1,
        y = 2,
        b = 1,
        w = 2,
        k = 4,
        C = 8,
        x = 16,
        S = 32,
        T = 64,
        E = 128,
        M = 256,
        N = 512,
        F = 30,
        K = "...",
        j = 800,
        G = 16,
        Y = 1,
        ue = 2,
        re = 3,
        de = 1 / 0,
        Se = 9007199254740991,
        Pe = 17976931348623157e292,
        je = 0 / 0,
        Ke = 4294967295,
        Ue = Ke - 1,
        yt = Ke >>> 1,
        at = [["ary", E], ["bind", b], ["bindKey", w], ["curry", C], ["curryRight", x], ["flip", N], ["partial", S], ["partialRight", T], ["rearg", M]],
        le = "[object Arguments]",
        ye = "[object Array]",
        ge = "[object AsyncFunction]",
        pe = "[object Boolean]",
        xe = "[object Date]",
        et = "[object DOMException]",
        Xe = "[object Error]",
        W = "[object Function]",
        R = "[object GeneratorFunction]",
        X = "[object Map]",
        Q = "[object Number]",
        Z = "[object Null]",
        fe = "[object Object]",
        be = "[object Promise]",
        Ee = "[object Proxy]",
        Me = "[object RegExp]",
        we = "[object Set]",
        He = "[object String]",
        We = "[object Symbol]",
        Je = "[object Undefined]",
        qe = "[object WeakMap]",
        wt = "[object WeakSet]",
        Et = "[object ArrayBuffer]",
        bt = "[object DataView]",
        ze = "[object Float32Array]",
        Ze = "[object Float64Array]",
        Lt = "[object Int8Array]",
        pn = "[object Int16Array]",
        mr = "[object Int32Array]",
        vo = "[object Uint8Array]",
        Pn = "[object Uint8ClampedArray]",
        Jn = "[object Uint16Array]",
        $o = "[object Uint32Array]",
        ln = /\b__p \+= '';/g,
        on = /\b(__p \+=) '' \+/g,
        _t = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
        tt = /&(?:amp|lt|gt|quot|#39);/g,
        Tt = /[&<>"']/g,
        mn = RegExp(tt.source),
        hn = RegExp(Tt.source),
        $ = /<%-([\s\S]+?)%>/g,
        D = /<%([\s\S]+?)%>/g,
        q = /<%=([\s\S]+?)%>/g,
        ie = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        Ae = /^\w*$/,
        it = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        vt = /[\\^$.*+?()[\]{}|]/g,
        gr = RegExp(vt.source),
        gt = /^\s+/,
        Zn = /\s/,
        Sr = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        ce = /\{\n\/\* \[wrapped with (.+)\] \*/,
        Ie = /,? & /,
        Ve = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
        kt = /[()=,{}\[\]\/\s]/,
        Qt = /\\(\\)?/g,
        qn = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
        Qn = /\w*$/,
        ar = /^[-+]0x[0-9a-f]+$/i,
        Nn = /^0b[01]+$/i,
        Rn = /^\[object .+?Constructor\]$/,
        En = /^0o[0-7]+$/i,
        Jt = /^(?:0|[1-9]\d*)$/,
        Ao = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
        no = /($^)/,
        ll = /['\n\r\u2028\u2029\\]/g,
        nd = "\\ud800-\\udfff",
        LW = "\\u0300-\\u036f",
        BW = "\\ufe20-\\ufe2f",
        VW = "\\u20d0-\\u20ff",
        iM = LW + BW + VW,
        sM = "\\u2700-\\u27bf",
        aM = "a-z\\xdf-\\xf6\\xf8-\\xff",
        FW = "\\xac\\xb1\\xd7\\xf7",
        jW = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
        WW = "\\u2000-\\u206f",
        zW = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
        lM = "A-Z\\xc0-\\xd6\\xd8-\\xde",
        cM = "\\ufe0e\\ufe0f",
        uM = FW + jW + WW + zW,
        fb = "['’]",
        HW = "[" + nd + "]",
        dM = "[" + uM + "]",
        Tg = "[" + iM + "]",
        fM = "\\d+",
        UW = "[" + sM + "]",
        hM = "[" + aM + "]",
        pM = "[^" + nd + uM + fM + sM + aM + lM + "]",
        hb = "\\ud83c[\\udffb-\\udfff]",
        qW = "(?:" + Tg + "|" + hb + ")",
        mM = "[^" + nd + "]",
        pb = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        mb = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        rd = "[" + lM + "]",
        gM = "\\u200d",
        vM = "(?:" + hM + "|" + pM + ")",
        YW = "(?:" + rd + "|" + pM + ")",
        yM = "(?:" + fb + "(?:d|ll|m|re|s|t|ve))?",
        wM = "(?:" + fb + "(?:D|LL|M|RE|S|T|VE))?",
        bM = qW + "?",
        _M = "[" + cM + "]?",
        KW = "(?:" + gM + "(?:" + [mM, pb, mb].join("|") + ")" + _M + bM + ")*",
        GW = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
        XW = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
        kM = _M + bM + KW,
        JW = "(?:" + [UW, pb, mb].join("|") + ")" + kM,
        ZW = "(?:" + [mM + Tg + "?", Tg, pb, mb, HW].join("|") + ")",
        QW = RegExp(fb, "g"),
        ez = RegExp(Tg, "g"),
        gb = RegExp(hb + "(?=" + hb + ")|" + ZW + kM, "g"),
        tz = RegExp([rd + "?" + hM + "+" + yM + "(?=" + [dM, rd, "$"].join("|") + ")", YW + "+" + wM + "(?=" + [dM, rd + vM, "$"].join("|") + ")", rd + "?" + vM + "+" + yM, rd + "+" + wM, XW, GW, fM, JW].join("|"), "g"),
        nz = RegExp("[" + gM + nd + iM + cM + "]"),
        rz = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
        oz = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
        iz = -1,
        Wn = {};
        Wn[ze] = Wn[Ze] = Wn[Lt] = Wn[pn] = Wn[mr] = Wn[vo] = Wn[Pn] = Wn[Jn] = Wn[$o] = !0,
        Wn[le] = Wn[ye] = Wn[Et] = Wn[pe] = Wn[bt] = Wn[xe] = Wn[Xe] = Wn[W] = Wn[X] = Wn[Q] = Wn[fe] = Wn[Me] = Wn[we] = Wn[He] = Wn[qe] = !1;
        var Ln = {};
        Ln[le] = Ln[ye] = Ln[Et] = Ln[bt] = Ln[pe] = Ln[xe] = Ln[ze] = Ln[Ze] = Ln[Lt] = Ln[pn] = Ln[mr] = Ln[X] = Ln[Q] = Ln[fe] = Ln[Me] = Ln[we] = Ln[He] = Ln[We] = Ln[vo] = Ln[Pn] = Ln[Jn] = Ln[$o] = !0,
        Ln[Xe] = Ln[W] = Ln[qe] = !1;
        var sz = {
            À: "A",
            Á: "A",
            Â: "A",
            Ã: "A",
            Ä: "A",
            Å: "A",
            à: "a",
            á: "a",
            â: "a",
            ã: "a",
            ä: "a",
            å: "a",
            Ç: "C",
            ç: "c",
            Ð: "D",
            ð: "d",
            È: "E",
            É: "E",
            Ê: "E",
            Ë: "E",
            è: "e",
            é: "e",
            ê: "e",
            ë: "e",
            Ì: "I",
            Í: "I",
            Î: "I",
            Ï: "I",
            ì: "i",
            í: "i",
            î: "i",
            ï: "i",
            Ñ: "N",
            ñ: "n",
            Ò: "O",
            Ó: "O",
            Ô: "O",
            Õ: "O",
            Ö: "O",
            Ø: "O",
            ò: "o",
            ó: "o",
            ô: "o",
            õ: "o",
            ö: "o",
            ø: "o",
            Ù: "U",
            Ú: "U",
            Û: "U",
            Ü: "U",
            ù: "u",
            ú: "u",
            û: "u",
            ü: "u",
            Ý: "Y",
            ý: "y",
            ÿ: "y",
            Æ: "Ae",
            æ: "ae",
            Þ: "Th",
            þ: "th",
            ß: "ss",
            Ā: "A",
            Ă: "A",
            Ą: "A",
            ā: "a",
            ă: "a",
            ą: "a",
            Ć: "C",
            Ĉ: "C",
            Ċ: "C",
            Č: "C",
            ć: "c",
            ĉ: "c",
            ċ: "c",
            č: "c",
            Ď: "D",
            Đ: "D",
            ď: "d",
            đ: "d",
            Ē: "E",
            Ĕ: "E",
            Ė: "E",
            Ę: "E",
            Ě: "E",
            ē: "e",
            ĕ: "e",
            ė: "e",
            ę: "e",
            ě: "e",
            Ĝ: "G",
            Ğ: "G",
            Ġ: "G",
            Ģ: "G",
            ĝ: "g",
            ğ: "g",
            ġ: "g",
            ģ: "g",
            Ĥ: "H",
            Ħ: "H",
            ĥ: "h",
            ħ: "h",
            Ĩ: "I",
            Ī: "I",
            Ĭ: "I",
            Į: "I",
            İ: "I",
            ĩ: "i",
            ī: "i",
            ĭ: "i",
            į: "i",
            ı: "i",
            Ĵ: "J",
            ĵ: "j",
            Ķ: "K",
            ķ: "k",
            ĸ: "k",
            Ĺ: "L",
            Ļ: "L",
            Ľ: "L",
            Ŀ: "L",
            Ł: "L",
            ĺ: "l",
            ļ: "l",
            ľ: "l",
            ŀ: "l",
            ł: "l",
            Ń: "N",
            Ņ: "N",
            Ň: "N",
            Ŋ: "N",
            ń: "n",
            ņ: "n",
            ň: "n",
            ŋ: "n",
            Ō: "O",
            Ŏ: "O",
            Ő: "O",
            ō: "o",
            ŏ: "o",
            ő: "o",
            Ŕ: "R",
            Ŗ: "R",
            Ř: "R",
            ŕ: "r",
            ŗ: "r",
            ř: "r",
            Ś: "S",
            Ŝ: "S",
            Ş: "S",
            Š: "S",
            ś: "s",
            ŝ: "s",
            ş: "s",
            š: "s",
            Ţ: "T",
            Ť: "T",
            Ŧ: "T",
            ţ: "t",
            ť: "t",
            ŧ: "t",
            Ũ: "U",
            Ū: "U",
            Ŭ: "U",
            Ů: "U",
            Ű: "U",
            Ų: "U",
            ũ: "u",
            ū: "u",
            ŭ: "u",
            ů: "u",
            ű: "u",
            ų: "u",
            Ŵ: "W",
            ŵ: "w",
            Ŷ: "Y",
            ŷ: "y",
            Ÿ: "Y",
            Ź: "Z",
            Ż: "Z",
            Ž: "Z",
            ź: "z",
            ż: "z",
            ž: "z",
            Ĳ: "IJ",
            ĳ: "ij",
            Œ: "Oe",
            œ: "oe",
            ŉ: "'n",
            ſ: "s"
        },
        az = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        },
        lz = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        },
        cz = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        },
        uz = parseFloat,
        dz = parseInt,
        xM = typeof Mt == "object" && Mt && Mt.Object === Object && Mt,
        fz = typeof self == "object" && self && self.Object === Object && self,
        qr = xM || fz || Function("return this")(),
        vb = t && !t.nodeType && t,
        xc = vb && !0 && e && !e.nodeType && e,
        SM = xc && xc.exports === vb,
        yb = SM && xM.process,
        Oi = function () {
            try {
                var se = xc && xc.require && xc.require("util").types;
                return se || yb && yb.binding && yb.binding("util")
            } catch {}
        }
        (),
        CM = Oi && Oi.isArrayBuffer,
        IM = Oi && Oi.isDate,
        TM = Oi && Oi.isMap,
        MM = Oi && Oi.isRegExp,
        PM = Oi && Oi.isSet,
        EM = Oi && Oi.isTypedArray;
        function li(se, _e, me) {
            switch (me.length) {
            case 0:
                return se.call(_e);
            case 1:
                return se.call(_e, me[0]);
            case 2:
                return se.call(_e, me[0], me[1]);
            case 3:
                return se.call(_e, me[0], me[1], me[2])
            }
            return se.apply(_e, me)
        }
        function hz(se, _e, me, rt) {
            for (var Dt = -1, gn = se == null ? 0 : se.length; ++Dt < gn; ) {
                var Or = se[Dt];
                _e(rt, Or, me(Or), se)
            }
            return rt
        }
        function $i(se, _e) {
            for (var me = -1, rt = se == null ? 0 : se.length; ++me < rt && _e(se[me], me, se) !== !1; );
            return se
        }
        function pz(se, _e) {
            for (var me = se == null ? 0 : se.length; me-- && _e(se[me], me, se) !== !1; );
            return se
        }
        function OM(se, _e) {
            for (var me = -1, rt = se == null ? 0 : se.length; ++me < rt; )
                if (!_e(se[me], me, se))
                    return !1;
            return !0
        }
        function cl(se, _e) {
            for (var me = -1, rt = se == null ? 0 : se.length, Dt = 0, gn = []; ++me < rt; ) {
                var Or = se[me];
                _e(Or, me, se) && (gn[Dt++] = Or)
            }
            return gn
        }
        function Mg(se, _e) {
            var me = se == null ? 0 : se.length;
            return !!me && od(se, _e, 0) > -1
        }
        function wb(se, _e, me) {
            for (var rt = -1, Dt = se == null ? 0 : se.length; ++rt < Dt; )
                if (me(_e, se[rt]))
                    return !0;
            return !1
        }
        function Yn(se, _e) {
            for (var me = -1, rt = se == null ? 0 : se.length, Dt = Array(rt); ++me < rt; )
                Dt[me] = _e(se[me], me, se);
            return Dt
        }
        function ul(se, _e) {
            for (var me = -1, rt = _e.length, Dt = se.length; ++me < rt; )
                se[Dt + me] = _e[me];
            return se
        }
        function bb(se, _e, me, rt) {
            var Dt = -1,
            gn = se == null ? 0 : se.length;
            for (rt && gn && (me = se[++Dt]); ++Dt < gn; )
                me = _e(me, se[Dt], Dt, se);
            return me
        }
        function mz(se, _e, me, rt) {
            var Dt = se == null ? 0 : se.length;
            for (rt && Dt && (me = se[--Dt]); Dt--; )
                me = _e(me, se[Dt], Dt, se);
            return me
        }
        function _b(se, _e) {
            for (var me = -1, rt = se == null ? 0 : se.length; ++me < rt; )
                if (_e(se[me], me, se))
                    return !0;
            return !1
        }
        var gz = kb("length");
        function vz(se) {
            return se.split("")
        }
        function yz(se) {
            return se.match(Ve) || []
        }
        function $M(se, _e, me) {
            var rt;
            return me(se, function (Dt, gn, Or) {
                if (_e(Dt, gn, Or))
                    return rt = gn, !1
            }),
            rt
        }
        function Pg(se, _e, me, rt) {
            for (var Dt = se.length, gn = me + (rt ? 1 : -1); rt ? gn-- : ++gn < Dt; )
                if (_e(se[gn], gn, se))
                    return gn;
            return -1
        }
        function od(se, _e, me) {
            return _e === _e ? Ez(se, _e, me) : Pg(se, AM, me)
        }
        function wz(se, _e, me, rt) {
            for (var Dt = me - 1, gn = se.length; ++Dt < gn; )
                if (rt(se[Dt], _e))
                    return Dt;
            return -1
        }
        function AM(se) {
            return se !== se
        }
        function DM(se, _e) {
            var me = se == null ? 0 : se.length;
            return me ? Sb(se, _e) / me : je
        }
        function kb(se) {
            return function (_e) {
                return _e == null ? n : _e[se]
            }
        }
        function xb(se) {
            return function (_e) {
                return se == null ? n : se[_e]
            }
        }
        function NM(se, _e, me, rt, Dt) {
            return Dt(se, function (gn, Or, On) {
                me = rt ? (rt = !1, gn) : _e(me, gn, Or, On)
            }),
            me
        }
        function bz(se, _e) {
            var me = se.length;
            for (se.sort(_e); me--; )
                se[me] = se[me].value;
            return se
        }
        function Sb(se, _e) {
            for (var me, rt = -1, Dt = se.length; ++rt < Dt; ) {
                var gn = _e(se[rt]);
                gn !== n && (me = me === n ? gn : me + gn)
            }
            return me
        }
        function Cb(se, _e) {
            for (var me = -1, rt = Array(se); ++me < se; )
                rt[me] = _e(me);
            return rt
        }
        function _z(se, _e) {
            return Yn(_e, function (me) {
                return [me, se[me]]
            })
        }
        function RM(se) {
            return se && se.slice(0, FM(se) + 1).replace(gt, "")
        }
        function ci(se) {
            return function (_e) {
                return se(_e)
            }
        }
        function Ib(se, _e) {
            return Yn(_e, function (me) {
                return se[me]
            })
        }
        function wh(se, _e) {
            return se.has(_e)
        }
        function LM(se, _e) {
            for (var me = -1, rt = se.length; ++me < rt && od(_e, se[me], 0) > -1; );
            return me
        }
        function BM(se, _e) {
            for (var me = se.length; me-- && od(_e, se[me], 0) > -1; );
            return me
        }
        function kz(se, _e) {
            for (var me = se.length, rt = 0; me--; )
                se[me] === _e && ++rt;
            return rt
        }
        var xz = xb(sz),
        Sz = xb(az);
        function Cz(se) {
            return "\\" + cz[se]
        }
        function Iz(se, _e) {
            return se == null ? n : se[_e]
        }
        function id(se) {
            return nz.test(se)
        }
        function Tz(se) {
            return rz.test(se)
        }
        function Mz(se) {
            for (var _e, me = []; !(_e = se.next()).done; )
                me.push(_e.value);
            return me
        }
        function Tb(se) {
            var _e = -1,
            me = Array(se.size);
            return se.forEach(function (rt, Dt) {
                me[++_e] = [Dt, rt]
            }),
            me
        }
        function VM(se, _e) {
            return function (me) {
                return se(_e(me))
            }
        }
        function dl(se, _e) {
            for (var me = -1, rt = se.length, Dt = 0, gn = []; ++me < rt; ) {
                var Or = se[me];
                (Or === _e || Or === u) && (se[me] = u, gn[Dt++] = me)
            }
            return gn
        }
        function Eg(se) {
            var _e = -1,
            me = Array(se.size);
            return se.forEach(function (rt) {
                me[++_e] = rt
            }),
            me
        }
        function Pz(se) {
            var _e = -1,
            me = Array(se.size);
            return se.forEach(function (rt) {
                me[++_e] = [rt, rt]
            }),
            me
        }
        function Ez(se, _e, me) {
            for (var rt = me - 1, Dt = se.length; ++rt < Dt; )
                if (se[rt] === _e)
                    return rt;
            return -1
        }
        function Oz(se, _e, me) {
            for (var rt = me + 1; rt--; )
                if (se[rt] === _e)
                    return rt;
            return rt
        }
        function sd(se) {
            return id(se) ? Az(se) : gz(se)
        }
        function gs(se) {
            return id(se) ? Dz(se) : vz(se)
        }
        function FM(se) {
            for (var _e = se.length; _e-- && Zn.test(se.charAt(_e)); );
            return _e
        }
        var $z = xb(lz);
        function Az(se) {
            for (var _e = gb.lastIndex = 0; gb.test(se); )
                ++_e;
            return _e
        }
        function Dz(se) {
            return se.match(gb) || []
        }
        function Nz(se) {
            return se.match(tz) || []
        }
        var Rz = function se(_e) {
            _e = _e == null ? qr : ad.defaults(qr.Object(), _e, ad.pick(qr, oz));
            var me = _e.Array,
            rt = _e.Date,
            Dt = _e.Error,
            gn = _e.Function,
            Or = _e.Math,
            On = _e.Object,
            Mb = _e.RegExp,
            Lz = _e.String,
            Ai = _e.TypeError,
            Og = me.prototype,
            Bz = gn.prototype,
            ld = On.prototype,
            $g = _e["__core-js_shared__"],
            Ag = Bz.toString,
            _n = ld.hasOwnProperty,
            Vz = 0,
            jM = function () {
                var d = /[^.]+$/.exec($g && $g.keys && $g.keys.IE_PROTO || "");
                return d ? "Symbol(src)_1." + d : ""
            }
            (),
            Dg = ld.toString,
            Fz = Ag.call(On),
            jz = qr._,
            Wz = Mb("^" + Ag.call(_n).replace(vt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
            Ng = SM ? _e.Buffer : n,
            fl = _e.Symbol,
            Rg = _e.Uint8Array,
            WM = Ng ? Ng.allocUnsafe : n,
            Lg = VM(On.getPrototypeOf, On),
            zM = On.create,
            HM = ld.propertyIsEnumerable,
            Bg = Og.splice,
            UM = fl ? fl.isConcatSpreadable : n,
            bh = fl ? fl.iterator : n,
            Sc = fl ? fl.toStringTag : n,
            Vg = function () {
                try {
                    var d = Pc(On, "defineProperty");
                    return d({}, "", {}),
                    d
                } catch {}
            }
            (),
            zz = _e.clearTimeout !== qr.clearTimeout && _e.clearTimeout,
            Hz = rt && rt.now !== qr.Date.now && rt.now,
            Uz = _e.setTimeout !== qr.setTimeout && _e.setTimeout,
            Fg = Or.ceil,
            jg = Or.floor,
            Pb = On.getOwnPropertySymbols,
            qz = Ng ? Ng.isBuffer : n,
            qM = _e.isFinite,
            Yz = Og.join,
            Kz = VM(On.keys, On),
            $r = Or.max,
            ro = Or.min,
            Gz = rt.now,
            Xz = _e.parseInt,
            YM = Or.random,
            Jz = Og.reverse,
            Eb = Pc(_e, "DataView"),
            _h = Pc(_e, "Map"),
            Ob = Pc(_e, "Promise"),
            cd = Pc(_e, "Set"),
            kh = Pc(_e, "WeakMap"),
            xh = Pc(On, "create"),
            Wg = kh && new kh,
            ud = {},
            Zz = Ec(Eb),
            Qz = Ec(_h),
            eH = Ec(Ob),
            tH = Ec(cd),
            nH = Ec(kh),
            zg = fl ? fl.prototype : n,
            Sh = zg ? zg.valueOf : n,
            KM = zg ? zg.toString : n;
            function L(d) {
                if (lr(d) && !Nt(d) && !(d instanceof Zt)) {
                    if (d instanceof Di)
                        return d;
                    if (_n.call(d, "__wrapped__"))
                        return GP(d)
                }
                return new Di(d)
            }
            var dd = function () {
                function d() {}
                return function (h) {
                    if (!er(h))
                        return {};
                    if (zM)
                        return zM(h);
                    d.prototype = h;
                    var g = new d;
                    return d.prototype = n,
                    g
                }
            }
            ();
            function Hg() {}
            function Di(d, h) {
                this.__wrapped__ = d,
                this.__actions__ = [],
                this.__chain__ = !!h,
                this.__index__ = 0,
                this.__values__ = n
            }
            L.templateSettings = {
                escape: $,
                evaluate: D,
                interpolate: q,
                variable: "",
                imports: {
                    _: L
                }
            },
            L.prototype = Hg.prototype,
            L.prototype.constructor = L,
            Di.prototype = dd(Hg.prototype),
            Di.prototype.constructor = Di;
            function Zt(d) {
                this.__wrapped__ = d,
                this.__actions__ = [],
                this.__dir__ = 1,
                this.__filtered__ = !1,
                this.__iteratees__ = [],
                this.__takeCount__ = Ke,
                this.__views__ = []
            }
            function rH() {
                var d = new Zt(this.__wrapped__);
                return d.__actions__ = Do(this.__actions__),
                d.__dir__ = this.__dir__,
                d.__filtered__ = this.__filtered__,
                d.__iteratees__ = Do(this.__iteratees__),
                d.__takeCount__ = this.__takeCount__,
                d.__views__ = Do(this.__views__),
                d
            }
            function oH() {
                if (this.__filtered__) {
                    var d = new Zt(this);
                    d.__dir__ = -1,
                    d.__filtered__ = !0
                } else
                    d = this.clone(), d.__dir__ *= -1;
                return d
            }
            function iH() {
                var d = this.__wrapped__.value(),
                h = this.__dir__,
                g = Nt(d),
                I = h < 0,
                A = g ? d.length : 0,
                V = vU(0, A, this.__views__),
                U = V.start,
                ee = V.end,
                ae = ee - U,
                Ce = I ? ee : U - 1,
                Te = this.__iteratees__,
                $e = Te.length,
                Ge = 0,
                ht = ro(ae, this.__takeCount__);
                if (!g || !I && A == ae && ht == ae)
                    return yP(d, this.__actions__);
                var St = [];
                e: for (; ae-- && Ge < ht; ) {
                    Ce += h;
                    for (var Ft = -1, Ct = d[Ce]; ++Ft < $e; ) {
                        var Gt = Te[Ft],
                        en = Gt.iteratee,
                        fi = Gt.type,
                        bo = en(Ct);
                        if (fi == ue)
                            Ct = bo;
                        else if (!bo) {
                            if (fi == Y)
                                continue e;
                            break e
                        }
                    }
                    St[Ge++] = Ct
                }
                return St
            }
            Zt.prototype = dd(Hg.prototype),
            Zt.prototype.constructor = Zt;
            function Cc(d) {
                var h = -1,
                g = d == null ? 0 : d.length;
                for (this.clear(); ++h < g; ) {
                    var I = d[h];
                    this.set(I[0], I[1])
                }
            }
            function sH() {
                this.__data__ = xh ? xh(null) : {},
                this.size = 0
            }
            function aH(d) {
                var h = this.has(d) && delete this.__data__[d];
                return this.size -= h ? 1 : 0,
                h
            }
            function lH(d) {
                var h = this.__data__;
                if (xh) {
                    var g = h[d];
                    return g === l ? n : g
                }
                return _n.call(h, d) ? h[d] : n
            }
            function cH(d) {
                var h = this.__data__;
                return xh ? h[d] !== n : _n.call(h, d)
            }
            function uH(d, h) {
                var g = this.__data__;
                return this.size += this.has(d) ? 0 : 1,
                g[d] = xh && h === n ? l : h,
                this
            }
            Cc.prototype.clear = sH,
            Cc.prototype.delete = aH,
            Cc.prototype.get = lH,
            Cc.prototype.has = cH,
            Cc.prototype.set = uH;
            function Sa(d) {
                var h = -1,
                g = d == null ? 0 : d.length;
                for (this.clear(); ++h < g; ) {
                    var I = d[h];
                    this.set(I[0], I[1])
                }
            }
            function dH() {
                this.__data__ = [],
                this.size = 0
            }
            function fH(d) {
                var h = this.__data__,
                g = Ug(h, d);
                if (g < 0)
                    return !1;
                var I = h.length - 1;
                return g == I ? h.pop() : Bg.call(h, g, 1),
                --this.size,
                !0
            }
            function hH(d) {
                var h = this.__data__,
                g = Ug(h, d);
                return g < 0 ? n : h[g][1]
            }
            function pH(d) {
                return Ug(this.__data__, d) > -1
            }
            function mH(d, h) {
                var g = this.__data__,
                I = Ug(g, d);
                return I < 0 ? (++this.size, g.push([d, h])) : g[I][1] = h,
                this
            }
            Sa.prototype.clear = dH,
            Sa.prototype.delete = fH,
            Sa.prototype.get = hH,
            Sa.prototype.has = pH,
            Sa.prototype.set = mH;
            function Ca(d) {
                var h = -1,
                g = d == null ? 0 : d.length;
                for (this.clear(); ++h < g; ) {
                    var I = d[h];
                    this.set(I[0], I[1])
                }
            }
            function gH() {
                this.size = 0,
                this.__data__ = {
                    hash: new Cc,
                    map: new(_h || Sa),
                    string: new Cc
                }
            }
            function vH(d) {
                var h = rv(this, d).delete(d);
                return this.size -= h ? 1 : 0,
                h
            }
            function yH(d) {
                return rv(this, d).get(d)
            }
            function wH(d) {
                return rv(this, d).has(d)
            }
            function bH(d, h) {
                var g = rv(this, d),
                I = g.size;
                return g.set(d, h),
                this.size += g.size == I ? 0 : 1,
                this
            }
            Ca.prototype.clear = gH,
            Ca.prototype.delete = vH,
            Ca.prototype.get = yH,
            Ca.prototype.has = wH,
            Ca.prototype.set = bH;
            function Ic(d) {
                var h = -1,
                g = d == null ? 0 : d.length;
                for (this.__data__ = new Ca; ++h < g; )
                    this.add(d[h])
            }
            function _H(d) {
                return this.__data__.set(d, l),
                this
            }
            function kH(d) {
                return this.__data__.has(d)
            }
            Ic.prototype.add = Ic.prototype.push = _H,
            Ic.prototype.has = kH;
            function vs(d) {
                var h = this.__data__ = new Sa(d);
                this.size = h.size
            }
            function xH() {
                this.__data__ = new Sa,
                this.size = 0
            }
            function SH(d) {
                var h = this.__data__,
                g = h.delete(d);
                return this.size = h.size,
                g
            }
            function CH(d) {
                return this.__data__.get(d)
            }
            function IH(d) {
                return this.__data__.has(d)
            }
            function TH(d, h) {
                var g = this.__data__;
                if (g instanceof Sa) {
                    var I = g.__data__;
                    if (!_h || I.length < o - 1)
                        return I.push([d, h]), this.size = ++g.size, this;
                    g = this.__data__ = new Ca(I)
                }
                return g.set(d, h),
                this.size = g.size,
                this
            }
            vs.prototype.clear = xH,
            vs.prototype.delete = SH,
            vs.prototype.get = CH,
            vs.prototype.has = IH,
            vs.prototype.set = TH;
            function GM(d, h) {
                var g = Nt(d),
                I = !g && Oc(d),
                A = !g && !I && vl(d),
                V = !g && !I && !A && md(d),
                U = g || I || A || V,
                ee = U ? Cb(d.length, Lz) : [],
                ae = ee.length;
                for (var Ce in d)
                    (h || _n.call(d, Ce)) && !(U && (Ce == "length" || A && (Ce == "offset" || Ce == "parent") || V && (Ce == "buffer" || Ce == "byteLength" || Ce == "byteOffset") || Pa(Ce, ae))) && ee.push(Ce);
                return ee
            }
            function XM(d) {
                var h = d.length;
                return h ? d[Wb(0, h - 1)] : n
            }
            function MH(d, h) {
                return ov(Do(d), Tc(h, 0, d.length))
            }
            function PH(d) {
                return ov(Do(d))
            }
            function $b(d, h, g) {
                (g !== n && !ys(d[h], g) || g === n && !(h in d)) && Ia(d, h, g)
            }
            function Ch(d, h, g) {
                var I = d[h];
                (!(_n.call(d, h) && ys(I, g)) || g === n && !(h in d)) && Ia(d, h, g)
            }
            function Ug(d, h) {
                for (var g = d.length; g--; )
                    if (ys(d[g][0], h))
                        return g;
                return -1
            }
            function EH(d, h, g, I) {
                return hl(d, function (A, V, U) {
                    h(I, A, g(A), U)
                }),
                I
            }
            function JM(d, h) {
                return d && Vs(h, Br(h), d)
            }
            function OH(d, h) {
                return d && Vs(h, Ro(h), d)
            }
            function Ia(d, h, g) {
                h == "__proto__" && Vg ? Vg(d, h, {
                    configurable: !0,
                    enumerable: !0,
                    value: g,
                    writable: !0
                }) : d[h] = g
            }
            function Ab(d, h) {
                for (var g = -1, I = h.length, A = me(I), V = d == null; ++g < I; )
                    A[g] = V ? n : h_(d, h[g]);
                return A
            }
            function Tc(d, h, g) {
                return d === d && (g !== n && (d = d <= g ? d : g), h !== n && (d = d >= h ? d : h)),
                d
            }
            function Ni(d, h, g, I, A, V) {
                var U,
                ee = h & f,
                ae = h & p,
                Ce = h & m;
                if (g && (U = A ? g(d, I, A, V) : g(d)), U !== n)
                    return U;
                if (!er(d))
                    return d;
                var Te = Nt(d);
                if (Te) {
                    if (U = wU(d), !ee)
                        return Do(d, U)
                } else {
                    var $e = oo(d),
                    Ge = $e == W || $e == R;
                    if (vl(d))
                        return _P(d, ee);
                    if ($e == fe || $e == le || Ge && !A) {
                        if (U = ae || Ge ? {}
                             : FP(d), !ee)
                            return ae ? lU(d, OH(U, d)) : aU(d, JM(U, d))
                    } else {
                        if (!Ln[$e])
                            return A ? d : {};
                        U = bU(d, $e, ee)
                    }
                }
                V || (V = new vs);
                var ht = V.get(d);
                if (ht)
                    return ht;
                V.set(d, U),
                mE(d) ? d.forEach(function (Ct) {
                    U.add(Ni(Ct, h, g, Ct, d, V))
                }) : hE(d) && d.forEach(function (Ct, Gt) {
                    U.set(Gt, Ni(Ct, h, g, Gt, d, V))
                });
                var St = Ce ? ae ? Qb : Zb : ae ? Ro : Br,
                Ft = Te ? n : St(d);
                return $i(Ft || d, function (Ct, Gt) {
                    Ft && (Gt = Ct, Ct = d[Gt]),
                    Ch(U, Gt, Ni(Ct, h, g, Gt, d, V))
                }),
                U
            }
            function $H(d) {
                var h = Br(d);
                return function (g) {
                    return ZM(g, d, h)
                }
            }
            function ZM(d, h, g) {
                var I = g.length;
                if (d == null)
                    return !I;
                for (d = On(d); I--; ) {
                    var A = g[I],
                    V = h[A],
                    U = d[A];
                    if (U === n && !(A in d) || !V(U))
                        return !1
                }
                return !0
            }
            function QM(d, h, g) {
                if (typeof d != "function")
                    throw new Ai(s);
                return $h(function () {
                    d.apply(n, g)
                }, h)
            }
            function Ih(d, h, g, I) {
                var A = -1,
                V = Mg,
                U = !0,
                ee = d.length,
                ae = [],
                Ce = h.length;
                if (!ee)
                    return ae;
                g && (h = Yn(h, ci(g))),
                I ? (V = wb, U = !1) : h.length >= o && (V = wh, U = !1, h = new Ic(h));
                e: for (; ++A < ee; ) {
                    var Te = d[A],
                    $e = g == null ? Te : g(Te);
                    if (Te = I || Te !== 0 ? Te : 0, U && $e === $e) {
                        for (var Ge = Ce; Ge--; )
                            if (h[Ge] === $e)
                                continue e;
                        ae.push(Te)
                    } else
                        V(h, $e, I) || ae.push(Te)
                }
                return ae
            }
            var hl = IP(Bs),
            eP = IP(Nb, !0);
            function AH(d, h) {
                var g = !0;
                return hl(d, function (I, A, V) {
                    return g = !!h(I, A, V),
                    g
                }),
                g
            }
            function qg(d, h, g) {
                for (var I = -1, A = d.length; ++I < A; ) {
                    var V = d[I],
                    U = h(V);
                    if (U != null && (ee === n ? U === U && !di(U) : g(U, ee)))
                        var ee = U, ae = V
                }
                return ae
            }
            function DH(d, h, g, I) {
                var A = d.length;
                for (g = Vt(g), g < 0 && (g = -g > A ? 0 : A + g), I = I === n || I > A ? A : Vt(I), I < 0 && (I += A), I = g > I ? 0 : vE(I); g < I; )
                    d[g++] = h;
                return d
            }
            function tP(d, h) {
                var g = [];
                return hl(d, function (I, A, V) {
                    h(I, A, V) && g.push(I)
                }),
                g
            }
            function Yr(d, h, g, I, A) {
                var V = -1,
                U = d.length;
                for (g || (g = kU), A || (A = []); ++V < U; ) {
                    var ee = d[V];
                    h > 0 && g(ee) ? h > 1 ? Yr(ee, h - 1, g, I, A) : ul(A, ee) : I || (A[A.length] = ee)
                }
                return A
            }
            var Db = TP(),
            nP = TP(!0);
            function Bs(d, h) {
                return d && Db(d, h, Br)
            }
            function Nb(d, h) {
                return d && nP(d, h, Br)
            }
            function Yg(d, h) {
                return cl(h, function (g) {
                    return Ea(d[g])
                })
            }
            function Mc(d, h) {
                h = ml(h, d);
                for (var g = 0, I = h.length; d != null && g < I; )
                    d = d[Fs(h[g++])];
                return g && g == I ? d : n
            }
            function rP(d, h, g) {
                var I = h(d);
                return Nt(d) ? I : ul(I, g(d))
            }
            function yo(d) {
                return d == null ? d === n ? Je : Z : Sc && Sc in On(d) ? gU(d) : PU(d)
            }
            function Rb(d, h) {
                return d > h
            }
            function NH(d, h) {
                return d != null && _n.call(d, h)
            }
            function RH(d, h) {
                return d != null && h in On(d)
            }
            function LH(d, h, g) {
                return d >= ro(h, g) && d < $r(h, g)
            }
            function Lb(d, h, g) {
                for (var I = g ? wb : Mg, A = d[0].length, V = d.length, U = V, ee = me(V), ae = 1 / 0, Ce = []; U--; ) {
                    var Te = d[U];
                    U && h && (Te = Yn(Te, ci(h))),
                    ae = ro(Te.length, ae),
                    ee[U] = !g && (h || A >= 120 && Te.length >= 120) ? new Ic(U && Te) : n
                }
                Te = d[0];
                var $e = -1,
                Ge = ee[0];
                e: for (; ++$e < A && Ce.length < ae; ) {
                    var ht = Te[$e],
                    St = h ? h(ht) : ht;
                    if (ht = g || ht !== 0 ? ht : 0, !(Ge ? wh(Ge, St) : I(Ce, St, g))) {
                        for (U = V; --U; ) {
                            var Ft = ee[U];
                            if (!(Ft ? wh(Ft, St) : I(d[U], St, g)))
                                continue e
                        }
                        Ge && Ge.push(St),
                        Ce.push(ht)
                    }
                }
                return Ce
            }
            function BH(d, h, g, I) {
                return Bs(d, function (A, V, U) {
                    h(I, g(A), V, U)
                }),
                I
            }
            function Th(d, h, g) {
                h = ml(h, d),
                d = HP(d, h);
                var I = d == null ? d : d[Fs(Li(h))];
                return I == null ? n : li(I, d, g)
            }
            function oP(d) {
                return lr(d) && yo(d) == le
            }
            function VH(d) {
                return lr(d) && yo(d) == Et
            }
            function FH(d) {
                return lr(d) && yo(d) == xe
            }
            function Mh(d, h, g, I, A) {
                return d === h ? !0 : d == null || h == null || !lr(d) && !lr(h) ? d !== d && h !== h : jH(d, h, g, I, Mh, A)
            }
            function jH(d, h, g, I, A, V) {
                var U = Nt(d),
                ee = Nt(h),
                ae = U ? ye : oo(d),
                Ce = ee ? ye : oo(h);
                ae = ae == le ? fe : ae,
                Ce = Ce == le ? fe : Ce;
                var Te = ae == fe,
                $e = Ce == fe,
                Ge = ae == Ce;
                if (Ge && vl(d)) {
                    if (!vl(h))
                        return !1;
                    U = !0,
                    Te = !1
                }
                if (Ge && !Te)
                    return V || (V = new vs), U || md(d) ? LP(d, h, g, I, A, V) : pU(d, h, ae, g, I, A, V);
                if (!(g & v)) {
                    var ht = Te && _n.call(d, "__wrapped__"),
                    St = $e && _n.call(h, "__wrapped__");
                    if (ht || St) {
                        var Ft = ht ? d.value() : d,
                        Ct = St ? h.value() : h;
                        return V || (V = new vs),
                        A(Ft, Ct, g, I, V)
                    }
                }
                return Ge ? (V || (V = new vs), mU(d, h, g, I, A, V)) : !1
            }
            function WH(d) {
                return lr(d) && oo(d) == X
            }
            function Bb(d, h, g, I) {
                var A = g.length,
                V = A,
                U = !I;
                if (d == null)
                    return !V;
                for (d = On(d); A--; ) {
                    var ee = g[A];
                    if (U && ee[2] ? ee[1] !== d[ee[0]] : !(ee[0]in d))
                        return !1
                }
                for (; ++A < V; ) {
                    ee = g[A];
                    var ae = ee[0],
                    Ce = d[ae],
                    Te = ee[1];
                    if (U && ee[2]) {
                        if (Ce === n && !(ae in d))
                            return !1
                    } else {
                        var $e = new vs;
                        if (I)
                            var Ge = I(Ce, Te, ae, d, h, $e);
                        if (!(Ge === n ? Mh(Te, Ce, v | y, I, $e) : Ge))
                            return !1
                    }
                }
                return !0
            }
            function iP(d) {
                if (!er(d) || SU(d))
                    return !1;
                var h = Ea(d) ? Wz : Rn;
                return h.test(Ec(d))
            }
            function zH(d) {
                return lr(d) && yo(d) == Me
            }
            function HH(d) {
                return lr(d) && oo(d) == we
            }
            function UH(d) {
                return lr(d) && uv(d.length) && !!Wn[yo(d)]
            }
            function sP(d) {
                return typeof d == "function" ? d : d == null ? Lo : typeof d == "object" ? Nt(d) ? cP(d[0], d[1]) : lP(d) : ME(d)
            }
            function Vb(d) {
                if (!Oh(d))
                    return Kz(d);
                var h = [];
                for (var g in On(d))
                    _n.call(d, g) && g != "constructor" && h.push(g);
                return h
            }
            function qH(d) {
                if (!er(d))
                    return MU(d);
                var h = Oh(d),
                g = [];
                for (var I in d)
                    I == "constructor" && (h || !_n.call(d, I)) || g.push(I);
                return g
            }
            function Fb(d, h) {
                return d < h
            }
            function aP(d, h) {
                var g = -1,
                I = No(d) ? me(d.length) : [];
                return hl(d, function (A, V, U) {
                    I[++g] = h(A, V, U)
                }),
                I
            }
            function lP(d) {
                var h = t_(d);
                return h.length == 1 && h[0][2] ? WP(h[0][0], h[0][1]) : function (g) {
                    return g === d || Bb(g, d, h)
                }
            }
            function cP(d, h) {
                return r_(d) && jP(h) ? WP(Fs(d), h) : function (g) {
                    var I = h_(g, d);
                    return I === n && I === h ? p_(g, d) : Mh(h, I, v | y)
                }
            }
            function Kg(d, h, g, I, A) {
                d !== h && Db(h, function (V, U) {
                    if (A || (A = new vs), er(V))
                        YH(d, h, U, g, Kg, I, A);
                    else {
                        var ee = I ? I(i_(d, U), V, U + "", d, h, A) : n;
                        ee === n && (ee = V),
                        $b(d, U, ee)
                    }
                }, Ro)
            }
            function YH(d, h, g, I, A, V, U) {
                var ee = i_(d, g),
                ae = i_(h, g),
                Ce = U.get(ae);
                if (Ce) {
                    $b(d, g, Ce);
                    return
                }
                var Te = V ? V(ee, ae, g + "", d, h, U) : n,
                $e = Te === n;
                if ($e) {
                    var Ge = Nt(ae),
                    ht = !Ge && vl(ae),
                    St = !Ge && !ht && md(ae);
                    Te = ae,
                    Ge || ht || St ? Nt(ee) ? Te = ee : vr(ee) ? Te = Do(ee) : ht ? ($e = !1, Te = _P(ae, !0)) : St ? ($e = !1, Te = kP(ae, !0)) : Te = [] : Ah(ae) || Oc(ae) ? (Te = ee, Oc(ee) ? Te = yE(ee) : (!er(ee) || Ea(ee)) && (Te = FP(ae))) : $e = !1
                }
                $e && (U.set(ae, Te), A(Te, ae, I, V, U), U.delete(ae)),
                $b(d, g, Te)
            }
            function uP(d, h) {
                var g = d.length;
                if (g)
                    return h += h < 0 ? g : 0, Pa(h, g) ? d[h] : n
            }
            function dP(d, h, g) {
                h.length ? h = Yn(h, function (V) {
                    return Nt(V) ? function (U) {
                        return Mc(U, V.length === 1 ? V[0] : V)
                    }
                     : V
                }) : h = [Lo];
                var I = -1;
                h = Yn(h, ci(xt()));
                var A = aP(d, function (V, U, ee) {
                    var ae = Yn(h, function (Ce) {
                        return Ce(V)
                    });
                    return {
                        criteria: ae,
                        index: ++I,
                        value: V
                    }
                });
                return bz(A, function (V, U) {
                    return sU(V, U, g)
                })
            }
            function KH(d, h) {
                return fP(d, h, function (g, I) {
                    return p_(d, I)
                })
            }
            function fP(d, h, g) {
                for (var I = -1, A = h.length, V = {}; ++I < A; ) {
                    var U = h[I],
                    ee = Mc(d, U);
                    g(ee, U) && Ph(V, ml(U, d), ee)
                }
                return V
            }
            function GH(d) {
                return function (h) {
                    return Mc(h, d)
                }
            }
            function jb(d, h, g, I) {
                var A = I ? wz : od,
                V = -1,
                U = h.length,
                ee = d;
                for (d === h && (h = Do(h)), g && (ee = Yn(d, ci(g))); ++V < U; )
                    for (var ae = 0, Ce = h[V], Te = g ? g(Ce) : Ce; (ae = A(ee, Te, ae, I)) > -1; )
                        ee !== d && Bg.call(ee, ae, 1), Bg.call(d, ae, 1);
                return d
            }
            function hP(d, h) {
                for (var g = d ? h.length : 0, I = g - 1; g--; ) {
                    var A = h[g];
                    if (g == I || A !== V) {
                        var V = A;
                        Pa(A) ? Bg.call(d, A, 1) : Ub(d, A)
                    }
                }
                return d
            }
            function Wb(d, h) {
                return d + jg(YM() * (h - d + 1))
            }
            function XH(d, h, g, I) {
                for (var A = -1, V = $r(Fg((h - d) / (g || 1)), 0), U = me(V); V--; )
                    U[I ? V : ++A] = d, d += g;
                return U
            }
            function zb(d, h) {
                var g = "";
                if (!d || h < 1 || h > Se)
                    return g;
                do
                    h % 2 && (g += d), h = jg(h / 2), h && (d += d);
                while (h);
                return g
            }
            function Ut(d, h) {
                return s_(zP(d, h, Lo), d + "")
            }
            function JH(d) {
                return XM(gd(d))
            }
            function ZH(d, h) {
                var g = gd(d);
                return ov(g, Tc(h, 0, g.length))
            }
            function Ph(d, h, g, I) {
                if (!er(d))
                    return d;
                h = ml(h, d);
                for (var A = -1, V = h.length, U = V - 1, ee = d; ee != null && ++A < V; ) {
                    var ae = Fs(h[A]),
                    Ce = g;
                    if (ae === "__proto__" || ae === "constructor" || ae === "prototype")
                        return d;
                    if (A != U) {
                        var Te = ee[ae];
                        Ce = I ? I(Te, ae, ee) : n,
                        Ce === n && (Ce = er(Te) ? Te : Pa(h[A + 1]) ? [] : {})
                    }
                    Ch(ee, ae, Ce),
                    ee = ee[ae]
                }
                return d
            }
            var pP = Wg ? function (d, h) {
                return Wg.set(d, h),
                d
            }
             : Lo,
            QH = Vg ? function (d, h) {
                return Vg(d, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: g_(h),
                    writable: !0
                })
            }
             : Lo;
            function eU(d) {
                return ov(gd(d))
            }
            function Ri(d, h, g) {
                var I = -1,
                A = d.length;
                h < 0 && (h = -h > A ? 0 : A + h),
                g = g > A ? A : g,
                g < 0 && (g += A),
                A = h > g ? 0 : g - h >>> 0,
                h >>>= 0;
                for (var V = me(A); ++I < A; )
                    V[I] = d[I + h];
                return V
            }
            function tU(d, h) {
                var g;
                return hl(d, function (I, A, V) {
                    return g = h(I, A, V),
                    !g
                }),
                !!g
            }
            function Gg(d, h, g) {
                var I = 0,
                A = d == null ? I : d.length;
                if (typeof h == "number" && h === h && A <= yt) {
                    for (; I < A; ) {
                        var V = I + A >>> 1,
                        U = d[V];
                        U !== null && !di(U) && (g ? U <= h : U < h) ? I = V + 1 : A = V
                    }
                    return A
                }
                return Hb(d, h, Lo, g)
            }
            function Hb(d, h, g, I) {
                var A = 0,
                V = d == null ? 0 : d.length;
                if (V === 0)
                    return 0;
                h = g(h);
                for (var U = h !== h, ee = h === null, ae = di(h), Ce = h === n; A < V; ) {
                    var Te = jg((A + V) / 2),
                    $e = g(d[Te]),
                    Ge = $e !== n,
                    ht = $e === null,
                    St = $e === $e,
                    Ft = di($e);
                    if (U)
                        var Ct = I || St;
                    else
                        Ce ? Ct = St && (I || Ge) : ee ? Ct = St && Ge && (I || !ht) : ae ? Ct = St && Ge && !ht && (I || !Ft) : ht || Ft ? Ct = !1 : Ct = I ? $e <= h : $e < h;
                    Ct ? A = Te + 1 : V = Te
                }
                return ro(V, Ue)
            }
            function mP(d, h) {
                for (var g = -1, I = d.length, A = 0, V = []; ++g < I; ) {
                    var U = d[g],
                    ee = h ? h(U) : U;
                    if (!g || !ys(ee, ae)) {
                        var ae = ee;
                        V[A++] = U === 0 ? 0 : U
                    }
                }
                return V
            }
            function gP(d) {
                return typeof d == "number" ? d : di(d) ? je : +d
            }
            function ui(d) {
                if (typeof d == "string")
                    return d;
                if (Nt(d))
                    return Yn(d, ui) + "";
                if (di(d))
                    return KM ? KM.call(d) : "";
                var h = d + "";
                return h == "0" && 1 / d == -de ? "-0" : h
            }
            function pl(d, h, g) {
                var I = -1,
                A = Mg,
                V = d.length,
                U = !0,
                ee = [],
                ae = ee;
                if (g)
                    U = !1, A = wb;
                else if (V >= o) {
                    var Ce = h ? null : fU(d);
                    if (Ce)
                        return Eg(Ce);
                    U = !1,
                    A = wh,
                    ae = new Ic
                } else
                    ae = h ? [] : ee;
                e: for (; ++I < V; ) {
                    var Te = d[I],
                    $e = h ? h(Te) : Te;
                    if (Te = g || Te !== 0 ? Te : 0, U && $e === $e) {
                        for (var Ge = ae.length; Ge--; )
                            if (ae[Ge] === $e)
                                continue e;
                        h && ae.push($e),
                        ee.push(Te)
                    } else
                        A(ae, $e, g) || (ae !== ee && ae.push($e), ee.push(Te))
                }
                return ee
            }
            function Ub(d, h) {
                return h = ml(h, d),
                d = HP(d, h),
                d == null || delete d[Fs(Li(h))]
            }
            function vP(d, h, g, I) {
                return Ph(d, h, g(Mc(d, h)), I)
            }
            function Xg(d, h, g, I) {
                for (var A = d.length, V = I ? A : -1; (I ? V-- : ++V < A) && h(d[V], V, d); );
                return g ? Ri(d, I ? 0 : V, I ? V + 1 : A) : Ri(d, I ? V + 1 : 0, I ? A : V)
            }
            function yP(d, h) {
                var g = d;
                return g instanceof Zt && (g = g.value()),
                bb(h, function (I, A) {
                    return A.func.apply(A.thisArg, ul([I], A.args))
                }, g)
            }
            function qb(d, h, g) {
                var I = d.length;
                if (I < 2)
                    return I ? pl(d[0]) : [];
                for (var A = -1, V = me(I); ++A < I; )
                    for (var U = d[A], ee = -1; ++ee < I; )
                        ee != A && (V[A] = Ih(V[A] || U, d[ee], h, g));
                return pl(Yr(V, 1), h, g)
            }
            function wP(d, h, g) {
                for (var I = -1, A = d.length, V = h.length, U = {}; ++I < A; ) {
                    var ee = I < V ? h[I] : n;
                    g(U, d[I], ee)
                }
                return U
            }
            function Yb(d) {
                return vr(d) ? d : []
            }
            function Kb(d) {
                return typeof d == "function" ? d : Lo
            }
            function ml(d, h) {
                return Nt(d) ? d : r_(d, h) ? [d] : KP(yn(d))
            }
            var nU = Ut;
            function gl(d, h, g) {
                var I = d.length;
                return g = g === n ? I : g,
                !h && g >= I ? d : Ri(d, h, g)
            }
            var bP = zz || function (d) {
                return qr.clearTimeout(d)
            };
            function _P(d, h) {
                if (h)
                    return d.slice();
                var g = d.length,
                I = WM ? WM(g) : new d.constructor(g);
                return d.copy(I),
                I
            }
            function Gb(d) {
                var h = new d.constructor(d.byteLength);
                return new Rg(h).set(new Rg(d)),
                h
            }
            function rU(d, h) {
                var g = h ? Gb(d.buffer) : d.buffer;
                return new d.constructor(g, d.byteOffset, d.byteLength)
            }
            function oU(d) {
                var h = new d.constructor(d.source, Qn.exec(d));
                return h.lastIndex = d.lastIndex,
                h
            }
            function iU(d) {
                return Sh ? On(Sh.call(d)) : {}
            }
            function kP(d, h) {
                var g = h ? Gb(d.buffer) : d.buffer;
                return new d.constructor(g, d.byteOffset, d.length)
            }
            function xP(d, h) {
                if (d !== h) {
                    var g = d !== n,
                    I = d === null,
                    A = d === d,
                    V = di(d),
                    U = h !== n,
                    ee = h === null,
                    ae = h === h,
                    Ce = di(h);
                    if (!ee && !Ce && !V && d > h || V && U && ae && !ee && !Ce || I && U && ae || !g && ae || !A)
                        return 1;
                    if (!I && !V && !Ce && d < h || Ce && g && A && !I && !V || ee && g && A || !U && A || !ae)
                        return -1
                }
                return 0
            }
            function sU(d, h, g) {
                for (var I = -1, A = d.criteria, V = h.criteria, U = A.length, ee = g.length; ++I < U; ) {
                    var ae = xP(A[I], V[I]);
                    if (ae) {
                        if (I >= ee)
                            return ae;
                        var Ce = g[I];
                        return ae * (Ce == "desc" ? -1 : 1)
                    }
                }
                return d.index - h.index
            }
            function SP(d, h, g, I) {
                for (var A = -1, V = d.length, U = g.length, ee = -1, ae = h.length, Ce = $r(V - U, 0), Te = me(ae + Ce), $e = !I; ++ee < ae; )
                    Te[ee] = h[ee];
                for (; ++A < U; )
                    ($e || A < V) && (Te[g[A]] = d[A]);
                for (; Ce--; )
                    Te[ee++] = d[A++];
                return Te
            }
            function CP(d, h, g, I) {
                for (var A = -1, V = d.length, U = -1, ee = g.length, ae = -1, Ce = h.length, Te = $r(V - ee, 0), $e = me(Te + Ce), Ge = !I; ++A < Te; )
                    $e[A] = d[A];
                for (var ht = A; ++ae < Ce; )
                    $e[ht + ae] = h[ae];
                for (; ++U < ee; )
                    (Ge || A < V) && ($e[ht + g[U]] = d[A++]);
                return $e
            }
            function Do(d, h) {
                var g = -1,
                I = d.length;
                for (h || (h = me(I)); ++g < I; )
                    h[g] = d[g];
                return h
            }
            function Vs(d, h, g, I) {
                var A = !g;
                g || (g = {});
                for (var V = -1, U = h.length; ++V < U; ) {
                    var ee = h[V],
                    ae = I ? I(g[ee], d[ee], ee, g, d) : n;
                    ae === n && (ae = d[ee]),
                    A ? Ia(g, ee, ae) : Ch(g, ee, ae)
                }
                return g
            }
            function aU(d, h) {
                return Vs(d, n_(d), h)
            }
            function lU(d, h) {
                return Vs(d, BP(d), h)
            }
            function Jg(d, h) {
                return function (g, I) {
                    var A = Nt(g) ? hz : EH,
                    V = h ? h() : {};
                    return A(g, d, xt(I, 2), V)
                }
            }
            function fd(d) {
                return Ut(function (h, g) {
                    var I = -1,
                    A = g.length,
                    V = A > 1 ? g[A - 1] : n,
                    U = A > 2 ? g[2] : n;
                    for (V = d.length > 3 && typeof V == "function" ? (A--, V) : n, U && wo(g[0], g[1], U) && (V = A < 3 ? n : V, A = 1), h = On(h); ++I < A; ) {
                        var ee = g[I];
                        ee && d(h, ee, I, V)
                    }
                    return h
                })
            }
            function IP(d, h) {
                return function (g, I) {
                    if (g == null)
                        return g;
                    if (!No(g))
                        return d(g, I);
                    for (var A = g.length, V = h ? A : -1, U = On(g); (h ? V-- : ++V < A) && I(U[V], V, U) !== !1; );
                    return g
                }
            }
            function TP(d) {
                return function (h, g, I) {
                    for (var A = -1, V = On(h), U = I(h), ee = U.length; ee--; ) {
                        var ae = U[d ? ee : ++A];
                        if (g(V[ae], ae, V) === !1)
                            break
                    }
                    return h
                }
            }
            function cU(d, h, g) {
                var I = h & b,
                A = Eh(d);
                function V() {
                    var U = this && this !== qr && this instanceof V ? A : d;
                    return U.apply(I ? g : this, arguments)
                }
                return V
            }
            function MP(d) {
                return function (h) {
                    h = yn(h);
                    var g = id(h) ? gs(h) : n,
                    I = g ? g[0] : h.charAt(0),
                    A = g ? gl(g, 1).join("") : h.slice(1);
                    return I[d]() + A
                }
            }
            function hd(d) {
                return function (h) {
                    return bb(IE(CE(h).replace(QW, "")), d, "")
                }
            }
            function Eh(d) {
                return function () {
                    var h = arguments;
                    switch (h.length) {
                    case 0:
                        return new d;
                    case 1:
                        return new d(h[0]);
                    case 2:
                        return new d(h[0], h[1]);
                    case 3:
                        return new d(h[0], h[1], h[2]);
                    case 4:
                        return new d(h[0], h[1], h[2], h[3]);
                    case 5:
                        return new d(h[0], h[1], h[2], h[3], h[4]);
                    case 6:
                        return new d(h[0], h[1], h[2], h[3], h[4], h[5]);
                    case 7:
                        return new d(h[0], h[1], h[2], h[3], h[4], h[5], h[6])
                    }
                    var g = dd(d.prototype),
                    I = d.apply(g, h);
                    return er(I) ? I : g
                }
            }
            function uU(d, h, g) {
                var I = Eh(d);
                function A() {
                    for (var V = arguments.length, U = me(V), ee = V, ae = pd(A); ee--; )
                        U[ee] = arguments[ee];
                    var Ce = V < 3 && U[0] !== ae && U[V - 1] !== ae ? [] : dl(U, ae);
                    if (V -= Ce.length, V < g)
                        return AP(d, h, Zg, A.placeholder, n, U, Ce, n, n, g - V);
                    var Te = this && this !== qr && this instanceof A ? I : d;
                    return li(Te, this, U)
                }
                return A
            }
            function PP(d) {
                return function (h, g, I) {
                    var A = On(h);
                    if (!No(h)) {
                        var V = xt(g, 3);
                        h = Br(h),
                        g = function (ee) {
                            return V(A[ee], ee, A)
                        }
                    }
                    var U = d(h, g, I);
                    return U > -1 ? A[V ? h[U] : U] : n
                }
            }
            function EP(d) {
                return Ma(function (h) {
                    var g = h.length,
                    I = g,
                    A = Di.prototype.thru;
                    for (d && h.reverse(); I--; ) {
                        var V = h[I];
                        if (typeof V != "function")
                            throw new Ai(s);
                        if (A && !U && nv(V) == "wrapper")
                            var U = new Di([], !0)
                    }
                    for (I = U ? I : g; ++I < g; ) {
                        V = h[I];
                        var ee = nv(V),
                        ae = ee == "wrapper" ? e_(V) : n;
                        ae && o_(ae[0]) && ae[1] == (E | C | S | M) && !ae[4].length && ae[9] == 1 ? U = U[nv(ae[0])].apply(U, ae[3]) : U = V.length == 1 && o_(V) ? U[ee]() : U.thru(V)
                    }
                    return function () {
                        var Ce = arguments,
                        Te = Ce[0];
                        if (U && Ce.length == 1 && Nt(Te))
                            return U.plant(Te).value();
                        for (var $e = 0, Ge = g ? h[$e].apply(this, Ce) : Te; ++$e < g; )
                            Ge = h[$e].call(this, Ge);
                        return Ge
                    }
                })
            }
            function Zg(d, h, g, I, A, V, U, ee, ae, Ce) {
                var Te = h & E,
                $e = h & b,
                Ge = h & w,
                ht = h & (C | x),
                St = h & N,
                Ft = Ge ? n : Eh(d);
                function Ct() {
                    for (var Gt = arguments.length, en = me(Gt), fi = Gt; fi--; )
                        en[fi] = arguments[fi];
                    if (ht)
                        var bo = pd(Ct), hi = kz(en, bo);
                    if (I && (en = SP(en, I, A, ht)), V && (en = CP(en, V, U, ht)), Gt -= hi, ht && Gt < Ce) {
                        var yr = dl(en, bo);
                        return AP(d, h, Zg, Ct.placeholder, g, en, yr, ee, ae, Ce - Gt)
                    }
                    var ws = $e ? g : this,
                    $a = Ge ? ws[d] : d;
                    return Gt = en.length,
                    ee ? en = EU(en, ee) : St && Gt > 1 && en.reverse(),
                    Te && ae < Gt && (en.length = ae),
                    this && this !== qr && this instanceof Ct && ($a = Ft || Eh($a)),
                    $a.apply(ws, en)
                }
                return Ct
            }
            function OP(d, h) {
                return function (g, I) {
                    return BH(g, d, h(I), {})
                }
            }
            function Qg(d, h) {
                return function (g, I) {
                    var A;
                    if (g === n && I === n)
                        return h;
                    if (g !== n && (A = g), I !== n) {
                        if (A === n)
                            return I;
                        typeof g == "string" || typeof I == "string" ? (g = ui(g), I = ui(I)) : (g = gP(g), I = gP(I)),
                        A = d(g, I)
                    }
                    return A
                }
            }
            function Xb(d) {
                return Ma(function (h) {
                    return h = Yn(h, ci(xt())),
                    Ut(function (g) {
                        var I = this;
                        return d(h, function (A) {
                            return li(A, I, g)
                        })
                    })
                })
            }
            function ev(d, h) {
                h = h === n ? " " : ui(h);
                var g = h.length;
                if (g < 2)
                    return g ? zb(h, d) : h;
                var I = zb(h, Fg(d / sd(h)));
                return id(h) ? gl(gs(I), 0, d).join("") : I.slice(0, d)
            }
            function dU(d, h, g, I) {
                var A = h & b,
                V = Eh(d);
                function U() {
                    for (var ee = -1, ae = arguments.length, Ce = -1, Te = I.length, $e = me(Te + ae), Ge = this && this !== qr && this instanceof U ? V : d; ++Ce < Te; )
                        $e[Ce] = I[Ce];
                    for (; ae--; )
                        $e[Ce++] = arguments[++ee];
                    return li(Ge, A ? g : this, $e)
                }
                return U
            }
            function $P(d) {
                return function (h, g, I) {
                    return I && typeof I != "number" && wo(h, g, I) && (g = I = n),
                    h = Oa(h),
                    g === n ? (g = h, h = 0) : g = Oa(g),
                    I = I === n ? h < g ? 1 : -1 : Oa(I),
                    XH(h, g, I, d)
                }
            }
            function tv(d) {
                return function (h, g) {
                    return typeof h == "string" && typeof g == "string" || (h = Bi(h), g = Bi(g)),
                    d(h, g)
                }
            }
            function AP(d, h, g, I, A, V, U, ee, ae, Ce) {
                var Te = h & C,
                $e = Te ? U : n,
                Ge = Te ? n : U,
                ht = Te ? V : n,
                St = Te ? n : V;
                h |= Te ? S : T,
                h &= ~(Te ? T : S),
                h & k || (h &= ~(b | w));
                var Ft = [d, h, A, ht, $e, St, Ge, ee, ae, Ce],
                Ct = g.apply(n, Ft);
                return o_(d) && UP(Ct, Ft),
                Ct.placeholder = I,
                qP(Ct, d, h)
            }
            function Jb(d) {
                var h = Or[d];
                return function (g, I) {
                    if (g = Bi(g), I = I == null ? 0 : ro(Vt(I), 292), I && qM(g)) {
                        var A = (yn(g) + "e").split("e"),
                        V = h(A[0] + "e" + (+A[1] + I));
                        return A = (yn(V) + "e").split("e"),
                         + (A[0] + "e" + (+A[1] - I))
                    }
                    return h(g)
                }
            }
            var fU = cd && 1 / Eg(new cd([, -0]))[1] == de ? function (d) {
                return new cd(d)
            }
             : w_;
            function DP(d) {
                return function (h) {
                    var g = oo(h);
                    return g == X ? Tb(h) : g == we ? Pz(h) : _z(h, d(h))
                }
            }
            function Ta(d, h, g, I, A, V, U, ee) {
                var ae = h & w;
                if (!ae && typeof d != "function")
                    throw new Ai(s);
                var Ce = I ? I.length : 0;
                if (Ce || (h &= ~(S | T), I = A = n), U = U === n ? U : $r(Vt(U), 0), ee = ee === n ? ee : Vt(ee), Ce -= A ? A.length : 0, h & T) {
                    var Te = I,
                    $e = A;
                    I = A = n
                }
                var Ge = ae ? n : e_(d),
                ht = [d, h, g, I, A, Te, $e, V, U, ee];
                if (Ge && TU(ht, Ge), d = ht[0], h = ht[1], g = ht[2], I = ht[3], A = ht[4], ee = ht[9] = ht[9] === n ? ae ? 0 : d.length : $r(ht[9] - Ce, 0), !ee && h & (C | x) && (h &= ~(C | x)), !h || h == b)
                    var St = cU(d, h, g);
                else
                    h == C || h == x ? St = uU(d, h, ee) : (h == S || h == (b | S)) && !A.length ? St = dU(d, h, g, I) : St = Zg.apply(n, ht);
                var Ft = Ge ? pP : UP;
                return qP(Ft(St, ht), d, h)
            }
            function NP(d, h, g, I) {
                return d === n || ys(d, ld[g]) && !_n.call(I, g) ? h : d
            }
            function RP(d, h, g, I, A, V) {
                return er(d) && er(h) && (V.set(h, d), Kg(d, h, n, RP, V), V.delete(h)),
                d
            }
            function hU(d) {
                return Ah(d) ? n : d
            }
            function LP(d, h, g, I, A, V) {
                var U = g & v,
                ee = d.length,
                ae = h.length;
                if (ee != ae && !(U && ae > ee))
                    return !1;
                var Ce = V.get(d),
                Te = V.get(h);
                if (Ce && Te)
                    return Ce == h && Te == d;
                var $e = -1,
                Ge = !0,
                ht = g & y ? new Ic : n;
                for (V.set(d, h), V.set(h, d); ++$e < ee; ) {
                    var St = d[$e],
                    Ft = h[$e];
                    if (I)
                        var Ct = U ? I(Ft, St, $e, h, d, V) : I(St, Ft, $e, d, h, V);
                    if (Ct !== n) {
                        if (Ct)
                            continue;
                        Ge = !1;
                        break
                    }
                    if (ht) {
                        if (!_b(h, function (Gt, en) {
                                if (!wh(ht, en) && (St === Gt || A(St, Gt, g, I, V)))
                                    return ht.push(en)
                                })) {
                                Ge = !1;
                                break
                            }
                    } else if (!(St === Ft || A(St, Ft, g, I, V))) {
                        Ge = !1;
                        break
                    }
                }
                return V.delete(d),
                V.delete(h),
                Ge
            }
            function pU(d, h, g, I, A, V, U) {
                switch (g) {
                case bt:
                    if (d.byteLength != h.byteLength || d.byteOffset != h.byteOffset)
                        return !1;
                    d = d.buffer,
                    h = h.buffer;
                case Et:
                    return !(d.byteLength != h.byteLength || !V(new Rg(d), new Rg(h)));
                case pe:
                case xe:
                case Q:
                    return ys(+d, +h);
                case Xe:
                    return d.name == h.name && d.message == h.message;
                case Me:
                case He:
                    return d == h + "";
                case X:
                    var ee = Tb;
                case we:
                    var ae = I & v;
                    if (ee || (ee = Eg), d.size != h.size && !ae)
                        return !1;
                    var Ce = U.get(d);
                    if (Ce)
                        return Ce == h;
                    I |= y,
                    U.set(d, h);
                    var Te = LP(ee(d), ee(h), I, A, V, U);
                    return U.delete(d),
                    Te;
                case We:
                    if (Sh)
                        return Sh.call(d) == Sh.call(h)
                }
                return !1
            }
            function mU(d, h, g, I, A, V) {
                var U = g & v,
                ee = Zb(d),
                ae = ee.length,
                Ce = Zb(h),
                Te = Ce.length;
                if (ae != Te && !U)
                    return !1;
                for (var $e = ae; $e--; ) {
                    var Ge = ee[$e];
                    if (!(U ? Ge in h : _n.call(h, Ge)))
                        return !1
                }
                var ht = V.get(d),
                St = V.get(h);
                if (ht && St)
                    return ht == h && St == d;
                var Ft = !0;
                V.set(d, h),
                V.set(h, d);
                for (var Ct = U; ++$e < ae; ) {
                    Ge = ee[$e];
                    var Gt = d[Ge],
                    en = h[Ge];
                    if (I)
                        var fi = U ? I(en, Gt, Ge, h, d, V) : I(Gt, en, Ge, d, h, V);
                    if (!(fi === n ? Gt === en || A(Gt, en, g, I, V) : fi)) {
                        Ft = !1;
                        break
                    }
                    Ct || (Ct = Ge == "constructor")
                }
                if (Ft && !Ct) {
                    var bo = d.constructor,
                    hi = h.constructor;
                    bo != hi && "constructor" in d && "constructor" in h && !(typeof bo == "function" && bo instanceof bo && typeof hi == "function" && hi instanceof hi) && (Ft = !1)
                }
                return V.delete(d),
                V.delete(h),
                Ft
            }
            function Ma(d) {
                return s_(zP(d, n, ZP), d + "")
            }
            function Zb(d) {
                return rP(d, Br, n_)
            }
            function Qb(d) {
                return rP(d, Ro, BP)
            }
            var e_ = Wg ? function (d) {
                return Wg.get(d)
            }
             : w_;
            function nv(d) {
                for (var h = d.name + "", g = ud[h], I = _n.call(ud, h) ? g.length : 0; I--; ) {
                    var A = g[I],
                    V = A.func;
                    if (V == null || V == d)
                        return A.name
                }
                return h
            }
            function pd(d) {
                var h = _n.call(L, "placeholder") ? L : d;
                return h.placeholder
            }
            function xt() {
                var d = L.iteratee || v_;
                return d = d === v_ ? sP : d,
                arguments.length ? d(arguments[0], arguments[1]) : d
            }
            function rv(d, h) {
                var g = d.__data__;
                return xU(h) ? g[typeof h == "string" ? "string" : "hash"] : g.map
            }
            function t_(d) {
                for (var h = Br(d), g = h.length; g--; ) {
                    var I = h[g],
                    A = d[I];
                    h[g] = [I, A, jP(A)]
                }
                return h
            }
            function Pc(d, h) {
                var g = Iz(d, h);
                return iP(g) ? g : n
            }
            function gU(d) {
                var h = _n.call(d, Sc),
                g = d[Sc];
                try {
                    d[Sc] = n;
                    var I = !0
                } catch {}
                var A = Dg.call(d);
                return I && (h ? d[Sc] = g : delete d[Sc]),
                A
            }
            var n_ = Pb ? function (d) {
                return d == null ? [] : (d = On(d), cl(Pb(d), function (h) {
                        return HM.call(d, h)
                    }))
            }
             : b_,
            BP = Pb ? function (d) {
                for (var h = []; d; )
                    ul(h, n_(d)), d = Lg(d);
                return h
            }
             : b_,
            oo = yo;
            (Eb && oo(new Eb(new ArrayBuffer(1))) != bt || _h && oo(new _h) != X || Ob && oo(Ob.resolve()) != be || cd && oo(new cd) != we || kh && oo(new kh) != qe) && (oo = function (d) {
                var h = yo(d),
                g = h == fe ? d.constructor : n,
                I = g ? Ec(g) : "";
                if (I)
                    switch (I) {
                    case Zz:
                        return bt;
                    case Qz:
                        return X;
                    case eH:
                        return be;
                    case tH:
                        return we;
                    case nH:
                        return qe
                    }
                return h
            });
            function vU(d, h, g) {
                for (var I = -1, A = g.length; ++I < A; ) {
                    var V = g[I],
                    U = V.size;
                    switch (V.type) {
                    case "drop":
                        d += U;
                        break;
                    case "dropRight":
                        h -= U;
                        break;
                    case "take":
                        h = ro(h, d + U);
                        break;
                    case "takeRight":
                        d = $r(d, h - U);
                        break
                    }
                }
                return {
                    start: d,
                    end: h
                }
            }
            function yU(d) {
                var h = d.match(ce);
                return h ? h[1].split(Ie) : []
            }
            function VP(d, h, g) {
                h = ml(h, d);
                for (var I = -1, A = h.length, V = !1; ++I < A; ) {
                    var U = Fs(h[I]);
                    if (!(V = d != null && g(d, U)))
                        break;
                    d = d[U]
                }
                return V || ++I != A ? V : (A = d == null ? 0 : d.length, !!A && uv(A) && Pa(U, A) && (Nt(d) || Oc(d)))
            }
            function wU(d) {
                var h = d.length,
                g = new d.constructor(h);
                return h && typeof d[0] == "string" && _n.call(d, "index") && (g.index = d.index, g.input = d.input),
                g
            }
            function FP(d) {
                return typeof d.constructor == "function" && !Oh(d) ? dd(Lg(d)) : {}
            }
            function bU(d, h, g) {
                var I = d.constructor;
                switch (h) {
                case Et:
                    return Gb(d);
                case pe:
                case xe:
                    return new I(+d);
                case bt:
                    return rU(d, g);
                case ze:
                case Ze:
                case Lt:
                case pn:
                case mr:
                case vo:
                case Pn:
                case Jn:
                case $o:
                    return kP(d, g);
                case X:
                    return new I;
                case Q:
                case He:
                    return new I(d);
                case Me:
                    return oU(d);
                case we:
                    return new I;
                case We:
                    return iU(d)
                }
            }
            function _U(d, h) {
                var g = h.length;
                if (!g)
                    return d;
                var I = g - 1;
                return h[I] = (g > 1 ? "& " : "") + h[I],
                h = h.join(g > 2 ? ", " : " "),
                d.replace(Sr, `{
/* [wrapped with ` + h + `] */
`)
            }
            function kU(d) {
                return Nt(d) || Oc(d) || !!(UM && d && d[UM])
            }
            function Pa(d, h) {
                var g = typeof d;
                return h = h ?? Se,
                !!h && (g == "number" || g != "symbol" && Jt.test(d)) && d > -1 && d % 1 == 0 && d < h
            }
            function wo(d, h, g) {
                if (!er(g))
                    return !1;
                var I = typeof h;
                return (I == "number" ? No(g) && Pa(h, g.length) : I == "string" && h in g) ? ys(g[h], d) : !1
            }
            function r_(d, h) {
                if (Nt(d))
                    return !1;
                var g = typeof d;
                return g == "number" || g == "symbol" || g == "boolean" || d == null || di(d) ? !0 : Ae.test(d) || !ie.test(d) || h != null && d in On(h)
            }
            function xU(d) {
                var h = typeof d;
                return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? d !== "__proto__" : d === null
            }
            function o_(d) {
                var h = nv(d),
                g = L[h];
                if (typeof g != "function" || !(h in Zt.prototype))
                    return !1;
                if (d === g)
                    return !0;
                var I = e_(g);
                return !!I && d === I[0]
            }
            function SU(d) {
                return !!jM && jM in d
            }
            var CU = $g ? Ea : __;
            function Oh(d) {
                var h = d && d.constructor,
                g = typeof h == "function" && h.prototype || ld;
                return d === g
            }
            function jP(d) {
                return d === d && !er(d)
            }
            function WP(d, h) {
                return function (g) {
                    return g == null ? !1 : g[d] === h && (h !== n || d in On(g))
                }
            }
            function IU(d) {
                var h = lv(d, function (I) {
                    return g.size === c && g.clear(),
                    I
                }),
                g = h.cache;
                return h
            }
            function TU(d, h) {
                var g = d[1],
                I = h[1],
                A = g | I,
                V = A < (b | w | E),
                U = I == E && g == C || I == E && g == M && d[7].length <= h[8] || I == (E | M) && h[7].length <= h[8] && g == C;
                if (!(V || U))
                    return d;
                I & b && (d[2] = h[2], A |= g & b ? 0 : k);
                var ee = h[3];
                if (ee) {
                    var ae = d[3];
                    d[3] = ae ? SP(ae, ee, h[4]) : ee,
                    d[4] = ae ? dl(d[3], u) : h[4]
                }
                return ee = h[5],
                ee && (ae = d[5], d[5] = ae ? CP(ae, ee, h[6]) : ee, d[6] = ae ? dl(d[5], u) : h[6]),
                ee = h[7],
                ee && (d[7] = ee),
                I & E && (d[8] = d[8] == null ? h[8] : ro(d[8], h[8])),
                d[9] == null && (d[9] = h[9]),
                d[0] = h[0],
                d[1] = A,
                d
            }
            function MU(d) {
                var h = [];
                if (d != null)
                    for (var g in On(d))
                        h.push(g);
                return h
            }
            function PU(d) {
                return Dg.call(d)
            }
            function zP(d, h, g) {
                return h = $r(h === n ? d.length - 1 : h, 0),
                function () {
                    for (var I = arguments, A = -1, V = $r(I.length - h, 0), U = me(V); ++A < V; )
                        U[A] = I[h + A];
                    A = -1;
                    for (var ee = me(h + 1); ++A < h; )
                        ee[A] = I[A];
                    return ee[h] = g(U),
                    li(d, this, ee)
                }
            }
            function HP(d, h) {
                return h.length < 2 ? d : Mc(d, Ri(h, 0, -1))
            }
            function EU(d, h) {
                for (var g = d.length, I = ro(h.length, g), A = Do(d); I--; ) {
                    var V = h[I];
                    d[I] = Pa(V, g) ? A[V] : n
                }
                return d
            }
            function i_(d, h) {
                if (!(h === "constructor" && typeof d[h] == "function") && h != "__proto__")
                    return d[h]
            }
            var UP = YP(pP),
            $h = Uz || function (d, h) {
                return qr.setTimeout(d, h)
            },
            s_ = YP(QH);
            function qP(d, h, g) {
                var I = h + "";
                return s_(d, _U(I, OU(yU(I), g)))
            }
            function YP(d) {
                var h = 0,
                g = 0;
                return function () {
                    var I = Gz(),
                    A = G - (I - g);
                    if (g = I, A > 0) {
                        if (++h >= j)
                            return arguments[0]
                    } else
                        h = 0;
                    return d.apply(n, arguments)
                }
            }
            function ov(d, h) {
                var g = -1,
                I = d.length,
                A = I - 1;
                for (h = h === n ? I : h; ++g < h; ) {
                    var V = Wb(g, A),
                    U = d[V];
                    d[V] = d[g],
                    d[g] = U
                }
                return d.length = h,
                d
            }
            var KP = IU(function (d) {
                var h = [];
                return d.charCodeAt(0) === 46 && h.push(""),
                d.replace(it, function (g, I, A, V) {
                    h.push(A ? V.replace(Qt, "$1") : I || g)
                }),
                h
            });
            function Fs(d) {
                if (typeof d == "string" || di(d))
                    return d;
                var h = d + "";
                return h == "0" && 1 / d == -de ? "-0" : h
            }
            function Ec(d) {
                if (d != null) {
                    try {
                        return Ag.call(d)
                    } catch {}
                    try {
                        return d + ""
                    } catch {}
                }
                return ""
            }
            function OU(d, h) {
                return $i(at, function (g) {
                    var I = "_." + g[0];
                    h & g[1] && !Mg(d, I) && d.push(I)
                }),
                d.sort()
            }
            function GP(d) {
                if (d instanceof Zt)
                    return d.clone();
                var h = new Di(d.__wrapped__, d.__chain__);
                return h.__actions__ = Do(d.__actions__),
                h.__index__ = d.__index__,
                h.__values__ = d.__values__,
                h
            }
            function $U(d, h, g) {
                (g ? wo(d, h, g) : h === n) ? h = 1 : h = $r(Vt(h), 0);
                var I = d == null ? 0 : d.length;
                if (!I || h < 1)
                    return [];
                for (var A = 0, V = 0, U = me(Fg(I / h)); A < I; )
                    U[V++] = Ri(d, A, A += h);
                return U
            }
            function AU(d) {
                for (var h = -1, g = d == null ? 0 : d.length, I = 0, A = []; ++h < g; ) {
                    var V = d[h];
                    V && (A[I++] = V)
                }
                return A
            }
            function DU() {
                var d = arguments.length;
                if (!d)
                    return [];
                for (var h = me(d - 1), g = arguments[0], I = d; I--; )
                    h[I - 1] = arguments[I];
                return ul(Nt(g) ? Do(g) : [g], Yr(h, 1))
            }
            var NU = Ut(function (d, h) {
                return vr(d) ? Ih(d, Yr(h, 1, vr, !0)) : []
            }),
            RU = Ut(function (d, h) {
                var g = Li(h);
                return vr(g) && (g = n),
                vr(d) ? Ih(d, Yr(h, 1, vr, !0), xt(g, 2)) : []
            }),
            LU = Ut(function (d, h) {
                var g = Li(h);
                return vr(g) && (g = n),
                vr(d) ? Ih(d, Yr(h, 1, vr, !0), n, g) : []
            });
            function BU(d, h, g) {
                var I = d == null ? 0 : d.length;
                return I ? (h = g || h === n ? 1 : Vt(h), Ri(d, h < 0 ? 0 : h, I)) : []
            }
            function VU(d, h, g) {
                var I = d == null ? 0 : d.length;
                return I ? (h = g || h === n ? 1 : Vt(h), h = I - h, Ri(d, 0, h < 0 ? 0 : h)) : []
            }
            function FU(d, h) {
                return d && d.length ? Xg(d, xt(h, 3), !0, !0) : []
            }
            function jU(d, h) {
                return d && d.length ? Xg(d, xt(h, 3), !0) : []
            }
            function WU(d, h, g, I) {
                var A = d == null ? 0 : d.length;
                return A ? (g && typeof g != "number" && wo(d, h, g) && (g = 0, I = A), DH(d, h, g, I)) : []
            }
            function XP(d, h, g) {
                var I = d == null ? 0 : d.length;
                if (!I)
                    return -1;
                var A = g == null ? 0 : Vt(g);
                return A < 0 && (A = $r(I + A, 0)),
                Pg(d, xt(h, 3), A)
            }
            function JP(d, h, g) {
                var I = d == null ? 0 : d.length;
                if (!I)
                    return -1;
                var A = I - 1;
                return g !== n && (A = Vt(g), A = g < 0 ? $r(I + A, 0) : ro(A, I - 1)),
                Pg(d, xt(h, 3), A, !0)
            }
            function ZP(d) {
                var h = d == null ? 0 : d.length;
                return h ? Yr(d, 1) : []
            }
            function zU(d) {
                var h = d == null ? 0 : d.length;
                return h ? Yr(d, de) : []
            }
            function HU(d, h) {
                var g = d == null ? 0 : d.length;
                return g ? (h = h === n ? 1 : Vt(h), Yr(d, h)) : []
            }
            function UU(d) {
                for (var h = -1, g = d == null ? 0 : d.length, I = {}; ++h < g; ) {
                    var A = d[h];
                    I[A[0]] = A[1]
                }
                return I
            }
            function QP(d) {
                return d && d.length ? d[0] : n
            }
            function qU(d, h, g) {
                var I = d == null ? 0 : d.length;
                if (!I)
                    return -1;
                var A = g == null ? 0 : Vt(g);
                return A < 0 && (A = $r(I + A, 0)),
                od(d, h, A)
            }
            function YU(d) {
                var h = d == null ? 0 : d.length;
                return h ? Ri(d, 0, -1) : []
            }
            var KU = Ut(function (d) {
                var h = Yn(d, Yb);
                return h.length && h[0] === d[0] ? Lb(h) : []
            }),
            GU = Ut(function (d) {
                var h = Li(d),
                g = Yn(d, Yb);
                return h === Li(g) ? h = n : g.pop(),
                g.length && g[0] === d[0] ? Lb(g, xt(h, 2)) : []
            }),
            XU = Ut(function (d) {
                var h = Li(d),
                g = Yn(d, Yb);
                return h = typeof h == "function" ? h : n,
                h && g.pop(),
                g.length && g[0] === d[0] ? Lb(g, n, h) : []
            });
            function JU(d, h) {
                return d == null ? "" : Yz.call(d, h)
            }
            function Li(d) {
                var h = d == null ? 0 : d.length;
                return h ? d[h - 1] : n
            }
            function ZU(d, h, g) {
                var I = d == null ? 0 : d.length;
                if (!I)
                    return -1;
                var A = I;
                return g !== n && (A = Vt(g), A = A < 0 ? $r(I + A, 0) : ro(A, I - 1)),
                h === h ? Oz(d, h, A) : Pg(d, AM, A, !0)
            }
            function QU(d, h) {
                return d && d.length ? uP(d, Vt(h)) : n
            }
            var eq = Ut(eE);
            function eE(d, h) {
                return d && d.length && h && h.length ? jb(d, h) : d
            }
            function tq(d, h, g) {
                return d && d.length && h && h.length ? jb(d, h, xt(g, 2)) : d
            }
            function nq(d, h, g) {
                return d && d.length && h && h.length ? jb(d, h, n, g) : d
            }
            var rq = Ma(function (d, h) {
                var g = d == null ? 0 : d.length,
                I = Ab(d, h);
                return hP(d, Yn(h, function (A) {
                        return Pa(A, g) ? +A : A
                    }).sort(xP)),
                I
            });
            function oq(d, h) {
                var g = [];
                if (!(d && d.length))
                    return g;
                var I = -1,
                A = [],
                V = d.length;
                for (h = xt(h, 3); ++I < V; ) {
                    var U = d[I];
                    h(U, I, d) && (g.push(U), A.push(I))
                }
                return hP(d, A),
                g
            }
            function a_(d) {
                return d == null ? d : Jz.call(d)
            }
            function iq(d, h, g) {
                var I = d == null ? 0 : d.length;
                return I ? (g && typeof g != "number" && wo(d, h, g) ? (h = 0, g = I) : (h = h == null ? 0 : Vt(h), g = g === n ? I : Vt(g)), Ri(d, h, g)) : []
            }
            function sq(d, h) {
                return Gg(d, h)
            }
            function aq(d, h, g) {
                return Hb(d, h, xt(g, 2))
            }
            function lq(d, h) {
                var g = d == null ? 0 : d.length;
                if (g) {
                    var I = Gg(d, h);
                    if (I < g && ys(d[I], h))
                        return I
                }
                return -1
            }
            function cq(d, h) {
                return Gg(d, h, !0)
            }
            function uq(d, h, g) {
                return Hb(d, h, xt(g, 2), !0)
            }
            function dq(d, h) {
                var g = d == null ? 0 : d.length;
                if (g) {
                    var I = Gg(d, h, !0) - 1;
                    if (ys(d[I], h))
                        return I
                }
                return -1
            }
            function fq(d) {
                return d && d.length ? mP(d) : []
            }
            function hq(d, h) {
                return d && d.length ? mP(d, xt(h, 2)) : []
            }
            function pq(d) {
                var h = d == null ? 0 : d.length;
                return h ? Ri(d, 1, h) : []
            }
            function mq(d, h, g) {
                return d && d.length ? (h = g || h === n ? 1 : Vt(h), Ri(d, 0, h < 0 ? 0 : h)) : []
            }
            function gq(d, h, g) {
                var I = d == null ? 0 : d.length;
                return I ? (h = g || h === n ? 1 : Vt(h), h = I - h, Ri(d, h < 0 ? 0 : h, I)) : []
            }
            function vq(d, h) {
                return d && d.length ? Xg(d, xt(h, 3), !1, !0) : []
            }
            function yq(d, h) {
                return d && d.length ? Xg(d, xt(h, 3)) : []
            }
            var wq = Ut(function (d) {
                return pl(Yr(d, 1, vr, !0))
            }),
            bq = Ut(function (d) {
                var h = Li(d);
                return vr(h) && (h = n),
                pl(Yr(d, 1, vr, !0), xt(h, 2))
            }),
            _q = Ut(function (d) {
                var h = Li(d);
                return h = typeof h == "function" ? h : n,
                pl(Yr(d, 1, vr, !0), n, h)
            });
            function kq(d) {
                return d && d.length ? pl(d) : []
            }
            function xq(d, h) {
                return d && d.length ? pl(d, xt(h, 2)) : []
            }
            function Sq(d, h) {
                return h = typeof h == "function" ? h : n,
                d && d.length ? pl(d, n, h) : []
            }
            function l_(d) {
                if (!(d && d.length))
                    return [];
                var h = 0;
                return d = cl(d, function (g) {
                    if (vr(g))
                        return h = $r(g.length, h), !0
                }),
                Cb(h, function (g) {
                    return Yn(d, kb(g))
                })
            }
            function tE(d, h) {
                if (!(d && d.length))
                    return [];
                var g = l_(d);
                return h == null ? g : Yn(g, function (I) {
                    return li(h, n, I)
                })
            }
            var Cq = Ut(function (d, h) {
                return vr(d) ? Ih(d, h) : []
            }),
            Iq = Ut(function (d) {
                return qb(cl(d, vr))
            }),
            Tq = Ut(function (d) {
                var h = Li(d);
                return vr(h) && (h = n),
                qb(cl(d, vr), xt(h, 2))
            }),
            Mq = Ut(function (d) {
                var h = Li(d);
                return h = typeof h == "function" ? h : n,
                qb(cl(d, vr), n, h)
            }),
            Pq = Ut(l_);
            function Eq(d, h) {
                return wP(d || [], h || [], Ch)
            }
            function Oq(d, h) {
                return wP(d || [], h || [], Ph)
            }
            var $q = Ut(function (d) {
                var h = d.length,
                g = h > 1 ? d[h - 1] : n;
                return g = typeof g == "function" ? (d.pop(), g) : n,
                tE(d, g)
            });
            function nE(d) {
                var h = L(d);
                return h.__chain__ = !0,
                h
            }
            function Aq(d, h) {
                return h(d),
                d
            }
            function iv(d, h) {
                return h(d)
            }
            var Dq = Ma(function (d) {
                var h = d.length,
                g = h ? d[0] : 0,
                I = this.__wrapped__,
                A = function (V) {
                    return Ab(V, d)
                };
                return h > 1 || this.__actions__.length || !(I instanceof Zt) || !Pa(g) ? this.thru(A) : (I = I.slice(g, +g + (h ? 1 : 0)), I.__actions__.push({
                        func: iv,
                        args: [A],
                        thisArg: n
                    }), new Di(I, this.__chain__).thru(function (V) {
                        return h && !V.length && V.push(n),
                        V
                    }))
            });
            function Nq() {
                return nE(this)
            }
            function Rq() {
                return new Di(this.value(), this.__chain__)
            }
            function Lq() {
                this.__values__ === n && (this.__values__ = gE(this.value()));
                var d = this.__index__ >= this.__values__.length,
                h = d ? n : this.__values__[this.__index__++];
                return {
                    done: d,
                    value: h
                }
            }
            function Bq() {
                return this
            }
            function Vq(d) {
                for (var h, g = this; g instanceof Hg; ) {
                    var I = GP(g);
                    I.__index__ = 0,
                    I.__values__ = n,
                    h ? A.__wrapped__ = I : h = I;
                    var A = I;
                    g = g.__wrapped__
                }
                return A.__wrapped__ = d,
                h
            }
            function Fq() {
                var d = this.__wrapped__;
                if (d instanceof Zt) {
                    var h = d;
                    return this.__actions__.length && (h = new Zt(this)),
                    h = h.reverse(),
                    h.__actions__.push({
                        func: iv,
                        args: [a_],
                        thisArg: n
                    }),
                    new Di(h, this.__chain__)
                }
                return this.thru(a_)
            }
            function jq() {
                return yP(this.__wrapped__, this.__actions__)
            }
            var Wq = Jg(function (d, h, g) {
                _n.call(d, g) ? ++d[g] : Ia(d, g, 1)
            });
            function zq(d, h, g) {
                var I = Nt(d) ? OM : AH;
                return g && wo(d, h, g) && (h = n),
                I(d, xt(h, 3))
            }
            function Hq(d, h) {
                var g = Nt(d) ? cl : tP;
                return g(d, xt(h, 3))
            }
            var Uq = PP(XP),
            qq = PP(JP);
            function Yq(d, h) {
                return Yr(sv(d, h), 1)
            }
            function Kq(d, h) {
                return Yr(sv(d, h), de)
            }
            function Gq(d, h, g) {
                return g = g === n ? 1 : Vt(g),
                Yr(sv(d, h), g)
            }
            function rE(d, h) {
                var g = Nt(d) ? $i : hl;
                return g(d, xt(h, 3))
            }
            function oE(d, h) {
                var g = Nt(d) ? pz : eP;
                return g(d, xt(h, 3))
            }
            var Xq = Jg(function (d, h, g) {
                _n.call(d, g) ? d[g].push(h) : Ia(d, g, [h])
            });
            function Jq(d, h, g, I) {
                d = No(d) ? d : gd(d),
                g = g && !I ? Vt(g) : 0;
                var A = d.length;
                return g < 0 && (g = $r(A + g, 0)),
                dv(d) ? g <= A && d.indexOf(h, g) > -1 : !!A && od(d, h, g) > -1
            }
            var Zq = Ut(function (d, h, g) {
                var I = -1,
                A = typeof h == "function",
                V = No(d) ? me(d.length) : [];
                return hl(d, function (U) {
                    V[++I] = A ? li(h, U, g) : Th(U, h, g)
                }),
                V
            }),
            Qq = Jg(function (d, h, g) {
                Ia(d, g, h)
            });
            function sv(d, h) {
                var g = Nt(d) ? Yn : aP;
                return g(d, xt(h, 3))
            }
            function eY(d, h, g, I) {
                return d == null ? [] : (Nt(h) || (h = h == null ? [] : [h]), g = I ? n : g, Nt(g) || (g = g == null ? [] : [g]), dP(d, h, g))
            }
            var tY = Jg(function (d, h, g) {
                d[g ? 0 : 1].push(h)
            }, function () {
                return [[], []]
            });
            function nY(d, h, g) {
                var I = Nt(d) ? bb : NM,
                A = arguments.length < 3;
                return I(d, xt(h, 4), g, A, hl)
            }
            function rY(d, h, g) {
                var I = Nt(d) ? mz : NM,
                A = arguments.length < 3;
                return I(d, xt(h, 4), g, A, eP)
            }
            function oY(d, h) {
                var g = Nt(d) ? cl : tP;
                return g(d, cv(xt(h, 3)))
            }
            function iY(d) {
                var h = Nt(d) ? XM : JH;
                return h(d)
            }
            function sY(d, h, g) {
                (g ? wo(d, h, g) : h === n) ? h = 1 : h = Vt(h);
                var I = Nt(d) ? MH : ZH;
                return I(d, h)
            }
            function aY(d) {
                var h = Nt(d) ? PH : eU;
                return h(d)
            }
            function lY(d) {
                if (d == null)
                    return 0;
                if (No(d))
                    return dv(d) ? sd(d) : d.length;
                var h = oo(d);
                return h == X || h == we ? d.size : Vb(d).length
            }
            function cY(d, h, g) {
                var I = Nt(d) ? _b : tU;
                return g && wo(d, h, g) && (h = n),
                I(d, xt(h, 3))
            }
            var uY = Ut(function (d, h) {
                if (d == null)
                    return [];
                var g = h.length;
                return g > 1 && wo(d, h[0], h[1]) ? h = [] : g > 2 && wo(h[0], h[1], h[2]) && (h = [h[0]]),
                dP(d, Yr(h, 1), [])
            }),
            av = Hz || function () {
                return qr.Date.now()
            };
            function dY(d, h) {
                if (typeof h != "function")
                    throw new Ai(s);
                return d = Vt(d),
                function () {
                    if (--d < 1)
                        return h.apply(this, arguments)
                }
            }
            function iE(d, h, g) {
                return h = g ? n : h,
                h = d && h == null ? d.length : h,
                Ta(d, E, n, n, n, n, h)
            }
            function sE(d, h) {
                var g;
                if (typeof h != "function")
                    throw new Ai(s);
                return d = Vt(d),
                function () {
                    return --d > 0 && (g = h.apply(this, arguments)),
                    d <= 1 && (h = n),
                    g
                }
            }
            var c_ = Ut(function (d, h, g) {
                var I = b;
                if (g.length) {
                    var A = dl(g, pd(c_));
                    I |= S
                }
                return Ta(d, I, h, g, A)
            }),
            aE = Ut(function (d, h, g) {
                var I = b | w;
                if (g.length) {
                    var A = dl(g, pd(aE));
                    I |= S
                }
                return Ta(h, I, d, g, A)
            });
            function lE(d, h, g) {
                h = g ? n : h;
                var I = Ta(d, C, n, n, n, n, n, h);
                return I.placeholder = lE.placeholder,
                I
            }
            function cE(d, h, g) {
                h = g ? n : h;
                var I = Ta(d, x, n, n, n, n, n, h);
                return I.placeholder = cE.placeholder,
                I
            }
            function uE(d, h, g) {
                var I,
                A,
                V,
                U,
                ee,
                ae,
                Ce = 0,
                Te = !1,
                $e = !1,
                Ge = !0;
                if (typeof d != "function")
                    throw new Ai(s);
                h = Bi(h) || 0,
                er(g) && (Te = !!g.leading, $e = "maxWait" in g, V = $e ? $r(Bi(g.maxWait) || 0, h) : V, Ge = "trailing" in g ? !!g.trailing : Ge);
                function ht(yr) {
                    var ws = I,
                    $a = A;
                    return I = A = n,
                    Ce = yr,
                    U = d.apply($a, ws),
                    U
                }
                function St(yr) {
                    return Ce = yr,
                    ee = $h(Gt, h),
                    Te ? ht(yr) : U
                }
                function Ft(yr) {
                    var ws = yr - ae,
                    $a = yr - Ce,
                    PE = h - ws;
                    return $e ? ro(PE, V - $a) : PE
                }
                function Ct(yr) {
                    var ws = yr - ae,
                    $a = yr - Ce;
                    return ae === n || ws >= h || ws < 0 || $e && $a >= V
                }
                function Gt() {
                    var yr = av();
                    if (Ct(yr))
                        return en(yr);
                    ee = $h(Gt, Ft(yr))
                }
                function en(yr) {
                    return ee = n,
                    Ge && I ? ht(yr) : (I = A = n, U)
                }
                function fi() {
                    ee !== n && bP(ee),
                    Ce = 0,
                    I = ae = A = ee = n
                }
                function bo() {
                    return ee === n ? U : en(av())
                }
                function hi() {
                    var yr = av(),
                    ws = Ct(yr);
                    if (I = arguments, A = this, ae = yr, ws) {
                        if (ee === n)
                            return St(ae);
                        if ($e)
                            return bP(ee), ee = $h(Gt, h), ht(ae)
                    }
                    return ee === n && (ee = $h(Gt, h)),
                    U
                }
                return hi.cancel = fi,
                hi.flush = bo,
                hi
            }
            var fY = Ut(function (d, h) {
                return QM(d, 1, h)
            }),
            hY = Ut(function (d, h, g) {
                return QM(d, Bi(h) || 0, g)
            });
            function pY(d) {
                return Ta(d, N)
            }
            function lv(d, h) {
                if (typeof d != "function" || h != null && typeof h != "function")
                    throw new Ai(s);
                var g = function () {
                    var I = arguments,
                    A = h ? h.apply(this, I) : I[0],
                    V = g.cache;
                    if (V.has(A))
                        return V.get(A);
                    var U = d.apply(this, I);
                    return g.cache = V.set(A, U) || V,
                    U
                };
                return g.cache = new(lv.Cache || Ca),
                g
            }
            lv.Cache = Ca;
            function cv(d) {
                if (typeof d != "function")
                    throw new Ai(s);
                return function () {
                    var h = arguments;
                    switch (h.length) {
                    case 0:
                        return !d.call(this);
                    case 1:
                        return !d.call(this, h[0]);
                    case 2:
                        return !d.call(this, h[0], h[1]);
                    case 3:
                        return !d.call(this, h[0], h[1], h[2])
                    }
                    return !d.apply(this, h)
                }
            }
            function mY(d) {
                return sE(2, d)
            }
            var gY = nU(function (d, h) {
                h = h.length == 1 && Nt(h[0]) ? Yn(h[0], ci(xt())) : Yn(Yr(h, 1), ci(xt()));
                var g = h.length;
                return Ut(function (I) {
                    for (var A = -1, V = ro(I.length, g); ++A < V; )
                        I[A] = h[A].call(this, I[A]);
                    return li(d, this, I)
                })
            }),
            u_ = Ut(function (d, h) {
                var g = dl(h, pd(u_));
                return Ta(d, S, n, h, g)
            }),
            dE = Ut(function (d, h) {
                var g = dl(h, pd(dE));
                return Ta(d, T, n, h, g)
            }),
            vY = Ma(function (d, h) {
                return Ta(d, M, n, n, n, h)
            });
            function yY(d, h) {
                if (typeof d != "function")
                    throw new Ai(s);
                return h = h === n ? h : Vt(h),
                Ut(d, h)
            }
            function wY(d, h) {
                if (typeof d != "function")
                    throw new Ai(s);
                return h = h == null ? 0 : $r(Vt(h), 0),
                Ut(function (g) {
                    var I = g[h],
                    A = gl(g, 0, h);
                    return I && ul(A, I),
                    li(d, this, A)
                })
            }
            function bY(d, h, g) {
                var I = !0,
                A = !0;
                if (typeof d != "function")
                    throw new Ai(s);
                return er(g) && (I = "leading" in g ? !!g.leading : I, A = "trailing" in g ? !!g.trailing : A),
                uE(d, h, {
                    leading: I,
                    maxWait: h,
                    trailing: A
                })
            }
            function _Y(d) {
                return iE(d, 1)
            }
            function kY(d, h) {
                return u_(Kb(h), d)
            }
            function xY() {
                if (!arguments.length)
                    return [];
                var d = arguments[0];
                return Nt(d) ? d : [d]
            }
            function SY(d) {
                return Ni(d, m)
            }
            function CY(d, h) {
                return h = typeof h == "function" ? h : n,
                Ni(d, m, h)
            }
            function IY(d) {
                return Ni(d, f | m)
            }
            function TY(d, h) {
                return h = typeof h == "function" ? h : n,
                Ni(d, f | m, h)
            }
            function MY(d, h) {
                return h == null || ZM(d, h, Br(h))
            }
            function ys(d, h) {
                return d === h || d !== d && h !== h
            }
            var PY = tv(Rb),
            EY = tv(function (d, h) {
                return d >= h
            }),
            Oc = oP(function () {
                return arguments
            }
                    ()) ? oP : function (d) {
                return lr(d) && _n.call(d, "callee") && !HM.call(d, "callee")
            },
            Nt = me.isArray,
            OY = CM ? ci(CM) : VH;
            function No(d) {
                return d != null && uv(d.length) && !Ea(d)
            }
            function vr(d) {
                return lr(d) && No(d)
            }
            function $Y(d) {
                return d === !0 || d === !1 || lr(d) && yo(d) == pe
            }
            var vl = qz || __,
            AY = IM ? ci(IM) : FH;
            function DY(d) {
                return lr(d) && d.nodeType === 1 && !Ah(d)
            }
            function NY(d) {
                if (d == null)
                    return !0;
                if (No(d) && (Nt(d) || typeof d == "string" || typeof d.splice == "function" || vl(d) || md(d) || Oc(d)))
                    return !d.length;
                var h = oo(d);
                if (h == X || h == we)
                    return !d.size;
                if (Oh(d))
                    return !Vb(d).length;
                for (var g in d)
                    if (_n.call(d, g))
                        return !1;
                return !0
            }
            function RY(d, h) {
                return Mh(d, h)
            }
            function LY(d, h, g) {
                g = typeof g == "function" ? g : n;
                var I = g ? g(d, h) : n;
                return I === n ? Mh(d, h, n, g) : !!I
            }
            function d_(d) {
                if (!lr(d))
                    return !1;
                var h = yo(d);
                return h == Xe || h == et || typeof d.message == "string" && typeof d.name == "string" && !Ah(d)
            }
            function BY(d) {
                return typeof d == "number" && qM(d)
            }
            function Ea(d) {
                if (!er(d))
                    return !1;
                var h = yo(d);
                return h == W || h == R || h == ge || h == Ee
            }
            function fE(d) {
                return typeof d == "number" && d == Vt(d)
            }
            function uv(d) {
                return typeof d == "number" && d > -1 && d % 1 == 0 && d <= Se
            }
            function er(d) {
                var h = typeof d;
                return d != null && (h == "object" || h == "function")
            }
            function lr(d) {
                return d != null && typeof d == "object"
            }
            var hE = TM ? ci(TM) : WH;
            function VY(d, h) {
                return d === h || Bb(d, h, t_(h))
            }
            function FY(d, h, g) {
                return g = typeof g == "function" ? g : n,
                Bb(d, h, t_(h), g)
            }
            function jY(d) {
                return pE(d) && d != +d
            }
            function WY(d) {
                if (CU(d))
                    throw new Dt(i);
                return iP(d)
            }
            function zY(d) {
                return d === null
            }
            function HY(d) {
                return d == null
            }
            function pE(d) {
                return typeof d == "number" || lr(d) && yo(d) == Q
            }
            function Ah(d) {
                if (!lr(d) || yo(d) != fe)
                    return !1;
                var h = Lg(d);
                if (h === null)
                    return !0;
                var g = _n.call(h, "constructor") && h.constructor;
                return typeof g == "function" && g instanceof g && Ag.call(g) == Fz
            }
            var f_ = MM ? ci(MM) : zH;
            function UY(d) {
                return fE(d) && d >= -Se && d <= Se
            }
            var mE = PM ? ci(PM) : HH;
            function dv(d) {
                return typeof d == "string" || !Nt(d) && lr(d) && yo(d) == He
            }
            function di(d) {
                return typeof d == "symbol" || lr(d) && yo(d) == We
            }
            var md = EM ? ci(EM) : UH;
            function qY(d) {
                return d === n
            }
            function YY(d) {
                return lr(d) && oo(d) == qe
            }
            function KY(d) {
                return lr(d) && yo(d) == wt
            }
            var GY = tv(Fb),
            XY = tv(function (d, h) {
                return d <= h
            });
            function gE(d) {
                if (!d)
                    return [];
                if (No(d))
                    return dv(d) ? gs(d) : Do(d);
                if (bh && d[bh])
                    return Mz(d[bh]());
                var h = oo(d),
                g = h == X ? Tb : h == we ? Eg : gd;
                return g(d)
            }
            function Oa(d) {
                if (!d)
                    return d === 0 ? d : 0;
                if (d = Bi(d), d === de || d === -de) {
                    var h = d < 0 ? -1 : 1;
                    return h * Pe
                }
                return d === d ? d : 0
            }
            function Vt(d) {
                var h = Oa(d),
                g = h % 1;
                return h === h ? g ? h - g : h : 0
            }
            function vE(d) {
                return d ? Tc(Vt(d), 0, Ke) : 0
            }
            function Bi(d) {
                if (typeof d == "number")
                    return d;
                if (di(d))
                    return je;
                if (er(d)) {
                    var h = typeof d.valueOf == "function" ? d.valueOf() : d;
                    d = er(h) ? h + "" : h
                }
                if (typeof d != "string")
                    return d === 0 ? d : +d;
                d = RM(d);
                var g = Nn.test(d);
                return g || En.test(d) ? dz(d.slice(2), g ? 2 : 8) : ar.test(d) ? je : +d
            }
            function yE(d) {
                return Vs(d, Ro(d))
            }
            function JY(d) {
                return d ? Tc(Vt(d), -Se, Se) : d === 0 ? d : 0
            }
            function yn(d) {
                return d == null ? "" : ui(d)
            }
            var ZY = fd(function (d, h) {
                if (Oh(h) || No(h)) {
                    Vs(h, Br(h), d);
                    return
                }
                for (var g in h)
                    _n.call(h, g) && Ch(d, g, h[g])
            }),
            wE = fd(function (d, h) {
                Vs(h, Ro(h), d)
            }),
            fv = fd(function (d, h, g, I) {
                Vs(h, Ro(h), d, I)
            }),
            QY = fd(function (d, h, g, I) {
                Vs(h, Br(h), d, I)
            }),
            eK = Ma(Ab);
            function tK(d, h) {
                var g = dd(d);
                return h == null ? g : JM(g, h)
            }
            var nK = Ut(function (d, h) {
                d = On(d);
                var g = -1,
                I = h.length,
                A = I > 2 ? h[2] : n;
                for (A && wo(h[0], h[1], A) && (I = 1); ++g < I; )
                    for (var V = h[g], U = Ro(V), ee = -1, ae = U.length; ++ee < ae; ) {
                        var Ce = U[ee],
                        Te = d[Ce];
                        (Te === n || ys(Te, ld[Ce]) && !_n.call(d, Ce)) && (d[Ce] = V[Ce])
                    }
                return d
            }),
            rK = Ut(function (d) {
                return d.push(n, RP),
                li(bE, n, d)
            });
            function oK(d, h) {
                return $M(d, xt(h, 3), Bs)
            }
            function iK(d, h) {
                return $M(d, xt(h, 3), Nb)
            }
            function sK(d, h) {
                return d == null ? d : Db(d, xt(h, 3), Ro)
            }
            function aK(d, h) {
                return d == null ? d : nP(d, xt(h, 3), Ro)
            }
            function lK(d, h) {
                return d && Bs(d, xt(h, 3))
            }
            function cK(d, h) {
                return d && Nb(d, xt(h, 3))
            }
            function uK(d) {
                return d == null ? [] : Yg(d, Br(d))
            }
            function dK(d) {
                return d == null ? [] : Yg(d, Ro(d))
            }
            function h_(d, h, g) {
                var I = d == null ? n : Mc(d, h);
                return I === n ? g : I
            }
            function fK(d, h) {
                return d != null && VP(d, h, NH)
            }
            function p_(d, h) {
                return d != null && VP(d, h, RH)
            }
            var hK = OP(function (d, h, g) {
                h != null && typeof h.toString != "function" && (h = Dg.call(h)),
                d[h] = g
            }, g_(Lo)),
            pK = OP(function (d, h, g) {
                h != null && typeof h.toString != "function" && (h = Dg.call(h)),
                _n.call(d, h) ? d[h].push(g) : d[h] = [g]
            }, xt),
            mK = Ut(Th);
            function Br(d) {
                return No(d) ? GM(d) : Vb(d)
            }
            function Ro(d) {
                return No(d) ? GM(d, !0) : qH(d)
            }
            function gK(d, h) {
                var g = {};
                return h = xt(h, 3),
                Bs(d, function (I, A, V) {
                    Ia(g, h(I, A, V), I)
                }),
                g
            }
            function vK(d, h) {
                var g = {};
                return h = xt(h, 3),
                Bs(d, function (I, A, V) {
                    Ia(g, A, h(I, A, V))
                }),
                g
            }
            var yK = fd(function (d, h, g) {
                Kg(d, h, g)
            }),
            bE = fd(function (d, h, g, I) {
                Kg(d, h, g, I)
            }),
            wK = Ma(function (d, h) {
                var g = {};
                if (d == null)
                    return g;
                var I = !1;
                h = Yn(h, function (V) {
                    return V = ml(V, d),
                    I || (I = V.length > 1),
                    V
                }),
                Vs(d, Qb(d), g),
                I && (g = Ni(g, f | p | m, hU));
                for (var A = h.length; A--; )
                    Ub(g, h[A]);
                return g
            });
            function bK(d, h) {
                return _E(d, cv(xt(h)))
            }
            var _K = Ma(function (d, h) {
                return d == null ? {}
                 : KH(d, h)
            });
            function _E(d, h) {
                if (d == null)
                    return {};
                var g = Yn(Qb(d), function (I) {
                    return [I]
                });
                return h = xt(h),
                fP(d, g, function (I, A) {
                    return h(I, A[0])
                })
            }
            function kK(d, h, g) {
                h = ml(h, d);
                var I = -1,
                A = h.length;
                for (A || (A = 1, d = n); ++I < A; ) {
                    var V = d == null ? n : d[Fs(h[I])];
                    V === n && (I = A, V = g),
                    d = Ea(V) ? V.call(d) : V
                }
                return d
            }
            function xK(d, h, g) {
                return d == null ? d : Ph(d, h, g)
            }
            function SK(d, h, g, I) {
                return I = typeof I == "function" ? I : n,
                d == null ? d : Ph(d, h, g, I)
            }
            var kE = DP(Br),
            xE = DP(Ro);
            function CK(d, h, g) {
                var I = Nt(d),
                A = I || vl(d) || md(d);
                if (h = xt(h, 4), g == null) {
                    var V = d && d.constructor;
                    A ? g = I ? new V : [] : er(d) ? g = Ea(V) ? dd(Lg(d)) : {}
                     : g = {}
                }
                return (A ? $i : Bs)(d, function (U, ee, ae) {
                    return h(g, U, ee, ae)
                }),
                g
            }
            function IK(d, h) {
                return d == null ? !0 : Ub(d, h)
            }
            function TK(d, h, g) {
                return d == null ? d : vP(d, h, Kb(g))
            }
            function MK(d, h, g, I) {
                return I = typeof I == "function" ? I : n,
                d == null ? d : vP(d, h, Kb(g), I)
            }
            function gd(d) {
                return d == null ? [] : Ib(d, Br(d))
            }
            function PK(d) {
                return d == null ? [] : Ib(d, Ro(d))
            }
            function EK(d, h, g) {
                return g === n && (g = h, h = n),
                g !== n && (g = Bi(g), g = g === g ? g : 0),
                h !== n && (h = Bi(h), h = h === h ? h : 0),
                Tc(Bi(d), h, g)
            }
            function OK(d, h, g) {
                return h = Oa(h),
                g === n ? (g = h, h = 0) : g = Oa(g),
                d = Bi(d),
                LH(d, h, g)
            }
            function $K(d, h, g) {
                if (g && typeof g != "boolean" && wo(d, h, g) && (h = g = n), g === n && (typeof h == "boolean" ? (g = h, h = n) : typeof d == "boolean" && (g = d, d = n)), d === n && h === n ? (d = 0, h = 1) : (d = Oa(d), h === n ? (h = d, d = 0) : h = Oa(h)), d > h) {
                    var I = d;
                    d = h,
                    h = I
                }
                if (g || d % 1 || h % 1) {
                    var A = YM();
                    return ro(d + A * (h - d + uz("1e-" + ((A + "").length - 1))), h)
                }
                return Wb(d, h)
            }
            var AK = hd(function (d, h, g) {
                return h = h.toLowerCase(),
                d + (g ? SE(h) : h)
            });
            function SE(d) {
                return m_(yn(d).toLowerCase())
            }
            function CE(d) {
                return d = yn(d),
                d && d.replace(Ao, xz).replace(ez, "")
            }
            function DK(d, h, g) {
                d = yn(d),
                h = ui(h);
                var I = d.length;
                g = g === n ? I : Tc(Vt(g), 0, I);
                var A = g;
                return g -= h.length,
                g >= 0 && d.slice(g, A) == h
            }
            function NK(d) {
                return d = yn(d),
                d && hn.test(d) ? d.replace(Tt, Sz) : d
            }
            function RK(d) {
                return d = yn(d),
                d && gr.test(d) ? d.replace(vt, "\\$&") : d
            }
            var LK = hd(function (d, h, g) {
                return d + (g ? "-" : "") + h.toLowerCase()
            }),
            BK = hd(function (d, h, g) {
                return d + (g ? " " : "") + h.toLowerCase()
            }),
            VK = MP("toLowerCase");
            function FK(d, h, g) {
                d = yn(d),
                h = Vt(h);
                var I = h ? sd(d) : 0;
                if (!h || I >= h)
                    return d;
                var A = (h - I) / 2;
                return ev(jg(A), g) + d + ev(Fg(A), g)
            }
            function jK(d, h, g) {
                d = yn(d),
                h = Vt(h);
                var I = h ? sd(d) : 0;
                return h && I < h ? d + ev(h - I, g) : d
            }
            function WK(d, h, g) {
                d = yn(d),
                h = Vt(h);
                var I = h ? sd(d) : 0;
                return h && I < h ? ev(h - I, g) + d : d
            }
            function zK(d, h, g) {
                return g || h == null ? h = 0 : h && (h = +h),
                Xz(yn(d).replace(gt, ""), h || 0)
            }
            function HK(d, h, g) {
                return (g ? wo(d, h, g) : h === n) ? h = 1 : h = Vt(h),
                zb(yn(d), h)
            }
            function UK() {
                var d = arguments,
                h = yn(d[0]);
                return d.length < 3 ? h : h.replace(d[1], d[2])
            }
            var qK = hd(function (d, h, g) {
                return d + (g ? "_" : "") + h.toLowerCase()
            });
            function YK(d, h, g) {
                return g && typeof g != "number" && wo(d, h, g) && (h = g = n),
                g = g === n ? Ke : g >>> 0,
                g ? (d = yn(d), d && (typeof h == "string" || h != null && !f_(h)) && (h = ui(h), !h && id(d)) ? gl(gs(d), 0, g) : d.split(h, g)) : []
            }
            var KK = hd(function (d, h, g) {
                return d + (g ? " " : "") + m_(h)
            });
            function GK(d, h, g) {
                return d = yn(d),
                g = g == null ? 0 : Tc(Vt(g), 0, d.length),
                h = ui(h),
                d.slice(g, g + h.length) == h
            }
            function XK(d, h, g) {
                var I = L.templateSettings;
                g && wo(d, h, g) && (h = n),
                d = yn(d),
                h = fv({}, h, I, NP);
                var A = fv({}, h.imports, I.imports, NP),
                V = Br(A),
                U = Ib(A, V),
                ee,
                ae,
                Ce = 0,
                Te = h.interpolate || no,
                $e = "__p += '",
                Ge = Mb((h.escape || no).source + "|" + Te.source + "|" + (Te === q ? qn : no).source + "|" + (h.evaluate || no).source + "|$", "g"),
                ht = "//# sourceURL=" + (_n.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++iz + "]") + `
`;
                d.replace(Ge, function (Ct, Gt, en, fi, bo, hi) {
                    return en || (en = fi),
                    $e += d.slice(Ce, hi).replace(ll, Cz),
                    Gt && (ee = !0, $e += `' +
__e(` + Gt + `) +
'`),
                    bo && (ae = !0, $e += `';
                        ` + bo + `;
__p += '`),
                    en && ($e += `' +
((__t = (` + en + `)) == null ? '' : __t) +
'`),
                    Ce = hi + Ct.length,
                    Ct
                }),
                $e += `';
`;
                var St = _n.call(h, "variable") && h.variable;
                if (!St)
                    $e = `with (obj) {
                        ` + $e + `
}
`;
                else if (kt.test(St))
                    throw new Dt(a);
                $e = (ae ? $e.replace(ln, "") : $e).replace(on, "$1").replace(_t, "$1;"),
                $e = "function(" + (St || "obj") + `) {
                    ` + (St ? "" : `obj || (obj = {});
                        `) + "var __t, __p = ''" + (ee ? ", __e = _.escape" : "") + (ae ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
                        ` : `;
                        `) + $e + `return __p
}`;
                var Ft = TE(function () {
                    return gn(V, ht + "return " + $e).apply(n, U)
                });
                if (Ft.source = $e, d_(Ft))
                    throw Ft;
                return Ft
            }
            function JK(d) {
                return yn(d).toLowerCase()
            }
            function ZK(d) {
                return yn(d).toUpperCase()
            }
            function QK(d, h, g) {
                if (d = yn(d), d && (g || h === n))
                    return RM(d);
                if (!d || !(h = ui(h)))
                    return d;
                var I = gs(d),
                A = gs(h),
                V = LM(I, A),
                U = BM(I, A) + 1;
                return gl(I, V, U).join("")
            }
            function eG(d, h, g) {
                if (d = yn(d), d && (g || h === n))
                    return d.slice(0, FM(d) + 1);
                if (!d || !(h = ui(h)))
                    return d;
                var I = gs(d),
                A = BM(I, gs(h)) + 1;
                return gl(I, 0, A).join("")
            }
            function tG(d, h, g) {
                if (d = yn(d), d && (g || h === n))
                    return d.replace(gt, "");
                if (!d || !(h = ui(h)))
                    return d;
                var I = gs(d),
                A = LM(I, gs(h));
                return gl(I, A).join("")
            }
            function nG(d, h) {
                var g = F,
                I = K;
                if (er(h)) {
                    var A = "separator" in h ? h.separator : A;
                    g = "length" in h ? Vt(h.length) : g,
                    I = "omission" in h ? ui(h.omission) : I
                }
                d = yn(d);
                var V = d.length;
                if (id(d)) {
                    var U = gs(d);
                    V = U.length
                }
                if (g >= V)
                    return d;
                var ee = g - sd(I);
                if (ee < 1)
                    return I;
                var ae = U ? gl(U, 0, ee).join("") : d.slice(0, ee);
                if (A === n)
                    return ae + I;
                if (U && (ee += ae.length - ee), f_(A)) {
                    if (d.slice(ee).search(A)) {
                        var Ce,
                        Te = ae;
                        for (A.global || (A = Mb(A.source, yn(Qn.exec(A)) + "g")), A.lastIndex = 0; Ce = A.exec(Te); )
                            var $e = Ce.index;
                        ae = ae.slice(0, $e === n ? ee : $e)
                    }
                } else if (d.indexOf(ui(A), ee) != ee) {
                    var Ge = ae.lastIndexOf(A);
                    Ge > -1 && (ae = ae.slice(0, Ge))
                }
                return ae + I
            }
            function rG(d) {
                return d = yn(d),
                d && mn.test(d) ? d.replace(tt, $z) : d
            }
            var oG = hd(function (d, h, g) {
                return d + (g ? " " : "") + h.toUpperCase()
            }),
            m_ = MP("toUpperCase");
            function IE(d, h, g) {
                return d = yn(d),
                h = g ? n : h,
                h === n ? Tz(d) ? Nz(d) : yz(d) : d.match(h) || []
            }
            var TE = Ut(function (d, h) {
                try {
                    return li(d, n, h)
                } catch (g) {
                    return d_(g) ? g : new Dt(g)
                }
            }),
            iG = Ma(function (d, h) {
                return $i(h, function (g) {
                    g = Fs(g),
                    Ia(d, g, c_(d[g], d))
                }),
                d
            });
            function sG(d) {
                var h = d == null ? 0 : d.length,
                g = xt();
                return d = h ? Yn(d, function (I) {
                    if (typeof I[1] != "function")
                        throw new Ai(s);
                    return [g(I[0]), I[1]]
                }) : [],
                Ut(function (I) {
                    for (var A = -1; ++A < h; ) {
                        var V = d[A];
                        if (li(V[0], this, I))
                            return li(V[1], this, I)
                    }
                })
            }
            function aG(d) {
                return $H(Ni(d, f))
            }
            function g_(d) {
                return function () {
                    return d
                }
            }
            function lG(d, h) {
                return d == null || d !== d ? h : d
            }
            var cG = EP(),
            uG = EP(!0);
            function Lo(d) {
                return d
            }
            function v_(d) {
                return sP(typeof d == "function" ? d : Ni(d, f))
            }
            function dG(d) {
                return lP(Ni(d, f))
            }
            function fG(d, h) {
                return cP(d, Ni(h, f))
            }
            var hG = Ut(function (d, h) {
                return function (g) {
                    return Th(g, d, h)
                }
            }),
            pG = Ut(function (d, h) {
                return function (g) {
                    return Th(d, g, h)
                }
            });
            function y_(d, h, g) {
                var I = Br(h),
                A = Yg(h, I);
                g == null && !(er(h) && (A.length || !I.length)) && (g = h, h = d, d = this, A = Yg(h, Br(h)));
                var V = !(er(g) && "chain" in g) || !!g.chain,
                U = Ea(d);
                return $i(A, function (ee) {
                    var ae = h[ee];
                    d[ee] = ae,
                    U && (d.prototype[ee] = function () {
                        var Ce = this.__chain__;
                        if (V || Ce) {
                            var Te = d(this.__wrapped__),
                            $e = Te.__actions__ = Do(this.__actions__);
                            return $e.push({
                                func: ae,
                                args: arguments,
                                thisArg: d
                            }),
                            Te.__chain__ = Ce,
                            Te
                        }
                        return ae.apply(d, ul([this.value()], arguments))
                    })
                }),
                d
            }
            function mG() {
                return qr._ === this && (qr._ = jz),
                this
            }
            function w_() {}
            function gG(d) {
                return d = Vt(d),
                Ut(function (h) {
                    return uP(h, d)
                })
            }
            var vG = Xb(Yn),
            yG = Xb(OM),
            wG = Xb(_b);
            function ME(d) {
                return r_(d) ? kb(Fs(d)) : GH(d)
            }
            function bG(d) {
                return function (h) {
                    return d == null ? n : Mc(d, h)
                }
            }
            var _G = $P(),
            kG = $P(!0);
            function b_() {
                return []
            }
            function __() {
                return !1
            }
            function xG() {
                return {}
            }
            function SG() {
                return ""
            }
            function CG() {
                return !0
            }
            function IG(d, h) {
                if (d = Vt(d), d < 1 || d > Se)
                    return [];
                var g = Ke,
                I = ro(d, Ke);
                h = xt(h),
                d -= Ke;
                for (var A = Cb(I, h); ++g < d; )
                    h(g);
                return A
            }
            function TG(d) {
                return Nt(d) ? Yn(d, Fs) : di(d) ? [d] : Do(KP(yn(d)))
            }
            function MG(d) {
                var h = ++Vz;
                return yn(d) + h
            }
            var PG = Qg(function (d, h) {
                return d + h
            }, 0),
            EG = Jb("ceil"),
            OG = Qg(function (d, h) {
                return d / h
            }, 1),
            $G = Jb("floor");
            function AG(d) {
                return d && d.length ? qg(d, Lo, Rb) : n
            }
            function DG(d, h) {
                return d && d.length ? qg(d, xt(h, 2), Rb) : n
            }
            function NG(d) {
                return DM(d, Lo)
            }
            function RG(d, h) {
                return DM(d, xt(h, 2))
            }
            function LG(d) {
                return d && d.length ? qg(d, Lo, Fb) : n
            }
            function BG(d, h) {
                return d && d.length ? qg(d, xt(h, 2), Fb) : n
            }
            var VG = Qg(function (d, h) {
                return d * h
            }, 1),
            FG = Jb("round"),
            jG = Qg(function (d, h) {
                return d - h
            }, 0);
            function WG(d) {
                return d && d.length ? Sb(d, Lo) : 0
            }
            function zG(d, h) {
                return d && d.length ? Sb(d, xt(h, 2)) : 0
            }
            return L.after = dY,
            L.ary = iE,
            L.assign = ZY,
            L.assignIn = wE,
            L.assignInWith = fv,
            L.assignWith = QY,
            L.at = eK,
            L.before = sE,
            L.bind = c_,
            L.bindAll = iG,
            L.bindKey = aE,
            L.castArray = xY,
            L.chain = nE,
            L.chunk = $U,
            L.compact = AU,
            L.concat = DU,
            L.cond = sG,
            L.conforms = aG,
            L.constant = g_,
            L.countBy = Wq,
            L.create = tK,
            L.curry = lE,
            L.curryRight = cE,
            L.debounce = uE,
            L.defaults = nK,
            L.defaultsDeep = rK,
            L.defer = fY,
            L.delay = hY,
            L.difference = NU,
            L.differenceBy = RU,
            L.differenceWith = LU,
            L.drop = BU,
            L.dropRight = VU,
            L.dropRightWhile = FU,
            L.dropWhile = jU,
            L.fill = WU,
            L.filter = Hq,
            L.flatMap = Yq,
            L.flatMapDeep = Kq,
            L.flatMapDepth = Gq,
            L.flatten = ZP,
            L.flattenDeep = zU,
            L.flattenDepth = HU,
            L.flip = pY,
            L.flow = cG,
            L.flowRight = uG,
            L.fromPairs = UU,
            L.functions = uK,
            L.functionsIn = dK,
            L.groupBy = Xq,
            L.initial = YU,
            L.intersection = KU,
            L.intersectionBy = GU,
            L.intersectionWith = XU,
            L.invert = hK,
            L.invertBy = pK,
            L.invokeMap = Zq,
            L.iteratee = v_,
            L.keyBy = Qq,
            L.keys = Br,
            L.keysIn = Ro,
            L.map = sv,
            L.mapKeys = gK,
            L.mapValues = vK,
            L.matches = dG,
            L.matchesProperty = fG,
            L.memoize = lv,
            L.merge = yK,
            L.mergeWith = bE,
            L.method = hG,
            L.methodOf = pG,
            L.mixin = y_,
            L.negate = cv,
            L.nthArg = gG,
            L.omit = wK,
            L.omitBy = bK,
            L.once = mY,
            L.orderBy = eY,
            L.over = vG,
            L.overArgs = gY,
            L.overEvery = yG,
            L.overSome = wG,
            L.partial = u_,
            L.partialRight = dE,
            L.partition = tY,
            L.pick = _K,
            L.pickBy = _E,
            L.property = ME,
            L.propertyOf = bG,
            L.pull = eq,
            L.pullAll = eE,
            L.pullAllBy = tq,
            L.pullAllWith = nq,
            L.pullAt = rq,
            L.range = _G,
            L.rangeRight = kG,
            L.rearg = vY,
            L.reject = oY,
            L.remove = oq,
            L.rest = yY,
            L.reverse = a_,
            L.sampleSize = sY,
            L.set = xK,
            L.setWith = SK,
            L.shuffle = aY,
            L.slice = iq,
            L.sortBy = uY,
            L.sortedUniq = fq,
            L.sortedUniqBy = hq,
            L.split = YK,
            L.spread = wY,
            L.tail = pq,
            L.take = mq,
            L.takeRight = gq,
            L.takeRightWhile = vq,
            L.takeWhile = yq,
            L.tap = Aq,
            L.throttle = bY,
            L.thru = iv,
            L.toArray = gE,
            L.toPairs = kE,
            L.toPairsIn = xE,
            L.toPath = TG,
            L.toPlainObject = yE,
            L.transform = CK,
            L.unary = _Y,
            L.union = wq,
            L.unionBy = bq,
            L.unionWith = _q,
            L.uniq = kq,
            L.uniqBy = xq,
            L.uniqWith = Sq,
            L.unset = IK,
            L.unzip = l_,
            L.unzipWith = tE,
            L.update = TK,
            L.updateWith = MK,
            L.values = gd,
            L.valuesIn = PK,
            L.without = Cq,
            L.words = IE,
            L.wrap = kY,
            L.xor = Iq,
            L.xorBy = Tq,
            L.xorWith = Mq,
            L.zip = Pq,
            L.zipObject = Eq,
            L.zipObjectDeep = Oq,
            L.zipWith = $q,
            L.entries = kE,
            L.entriesIn = xE,
            L.extend = wE,
            L.extendWith = fv,
            y_(L, L),
            L.add = PG,
            L.attempt = TE,
            L.camelCase = AK,
            L.capitalize = SE,
            L.ceil = EG,
            L.clamp = EK,
            L.clone = SY,
            L.cloneDeep = IY,
            L.cloneDeepWith = TY,
            L.cloneWith = CY,
            L.conformsTo = MY,
            L.deburr = CE,
            L.defaultTo = lG,
            L.divide = OG,
            L.endsWith = DK,
            L.eq = ys,
            L.escape = NK,
            L.escapeRegExp = RK,
            L.every = zq,
            L.find = Uq,
            L.findIndex = XP,
            L.findKey = oK,
            L.findLast = qq,
            L.findLastIndex = JP,
            L.findLastKey = iK,
            L.floor = $G,
            L.forEach = rE,
            L.forEachRight = oE,
            L.forIn = sK,
            L.forInRight = aK,
            L.forOwn = lK,
            L.forOwnRight = cK,
            L.get = h_,
            L.gt = PY,
            L.gte = EY,
            L.has = fK,
            L.hasIn = p_,
            L.head = QP,
            L.identity = Lo,
            L.includes = Jq,
            L.indexOf = qU,
            L.inRange = OK,
            L.invoke = mK,
            L.isArguments = Oc,
            L.isArray = Nt,
            L.isArrayBuffer = OY,
            L.isArrayLike = No,
            L.isArrayLikeObject = vr,
            L.isBoolean = $Y,
            L.isBuffer = vl,
            L.isDate = AY,
            L.isElement = DY,
            L.isEmpty = NY,
            L.isEqual = RY,
            L.isEqualWith = LY,
            L.isError = d_,
            L.isFinite = BY,
            L.isFunction = Ea,
            L.isInteger = fE,
            L.isLength = uv,
            L.isMap = hE,
            L.isMatch = VY,
            L.isMatchWith = FY,
            L.isNaN = jY,
            L.isNative = WY,
            L.isNil = HY,
            L.isNull = zY,
            L.isNumber = pE,
            L.isObject = er,
            L.isObjectLike = lr,
            L.isPlainObject = Ah,
            L.isRegExp = f_,
            L.isSafeInteger = UY,
            L.isSet = mE,
            L.isString = dv,
            L.isSymbol = di,
            L.isTypedArray = md,
            L.isUndefined = qY,
            L.isWeakMap = YY,
            L.isWeakSet = KY,
            L.join = JU,
            L.kebabCase = LK,
            L.last = Li,
            L.lastIndexOf = ZU,
            L.lowerCase = BK,
            L.lowerFirst = VK,
            L.lt = GY,
            L.lte = XY,
            L.max = AG,
            L.maxBy = DG,
            L.mean = NG,
            L.meanBy = RG,
            L.min = LG,
            L.minBy = BG,
            L.stubArray = b_,
            L.stubFalse = __,
            L.stubObject = xG,
            L.stubString = SG,
            L.stubTrue = CG,
            L.multiply = VG,
            L.nth = QU,
            L.noConflict = mG,
            L.noop = w_,
            L.now = av,
            L.pad = FK,
            L.padEnd = jK,
            L.padStart = WK,
            L.parseInt = zK,
            L.random = $K,
            L.reduce = nY,
            L.reduceRight = rY,
            L.repeat = HK,
            L.replace = UK,
            L.result = kK,
            L.round = FG,
            L.runInContext = se,
            L.sample = iY,
            L.size = lY,
            L.snakeCase = qK,
            L.some = cY,
            L.sortedIndex = sq,
            L.sortedIndexBy = aq,
            L.sortedIndexOf = lq,
            L.sortedLastIndex = cq,
            L.sortedLastIndexBy = uq,
            L.sortedLastIndexOf = dq,
            L.startCase = KK,
            L.startsWith = GK,
            L.subtract = jG,
            L.sum = WG,
            L.sumBy = zG,
            L.template = XK,
            L.times = IG,
            L.toFinite = Oa,
            L.toInteger = Vt,
            L.toLength = vE,
            L.toLower = JK,
            L.toNumber = Bi,
            L.toSafeInteger = JY,
            L.toString = yn,
            L.toUpper = ZK,
            L.trim = QK,
            L.trimEnd = eG,
            L.trimStart = tG,
            L.truncate = nG,
            L.unescape = rG,
            L.uniqueId = MG,
            L.upperCase = oG,
            L.upperFirst = m_,
            L.each = rE,
            L.eachRight = oE,
            L.first = QP,
            y_(L, function () {
                var d = {};
                return Bs(L, function (h, g) {
                    _n.call(L.prototype, g) || (d[g] = h)
                }),
                d
            }
                (), {
                chain: !1
            }),
            L.VERSION = r,
            $i(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (d) {
                L[d].placeholder = L
            }),
            $i(["drop", "take"], function (d, h) {
                Zt.prototype[d] = function (g) {
                    g = g === n ? 1 : $r(Vt(g), 0);
                    var I = this.__filtered__ && !h ? new Zt(this) : this.clone();
                    return I.__filtered__ ? I.__takeCount__ = ro(g, I.__takeCount__) : I.__views__.push({
                        size: ro(g, Ke),
                        type: d + (I.__dir__ < 0 ? "Right" : "")
                    }),
                    I
                },
                Zt.prototype[d + "Right"] = function (g) {
                    return this.reverse()[d](g).reverse()
                }
            }),
            $i(["filter", "map", "takeWhile"], function (d, h) {
                var g = h + 1,
                I = g == Y || g == re;
                Zt.prototype[d] = function (A) {
                    var V = this.clone();
                    return V.__iteratees__.push({
                        iteratee: xt(A, 3),
                        type: g
                    }),
                    V.__filtered__ = V.__filtered__ || I,
                    V
                }
            }),
            $i(["head", "last"], function (d, h) {
                var g = "take" + (h ? "Right" : "");
                Zt.prototype[d] = function () {
                    return this[g](1).value()[0]
                }
            }),
            $i(["initial", "tail"], function (d, h) {
                var g = "drop" + (h ? "" : "Right");
                Zt.prototype[d] = function () {
                    return this.__filtered__ ? new Zt(this) : this[g](1)
                }
            }),
            Zt.prototype.compact = function () {
                return this.filter(Lo)
            },
            Zt.prototype.find = function (d) {
                return this.filter(d).head()
            },
            Zt.prototype.findLast = function (d) {
                return this.reverse().find(d)
            },
            Zt.prototype.invokeMap = Ut(function (d, h) {
                return typeof d == "function" ? new Zt(this) : this.map(function (g) {
                    return Th(g, d, h)
                })
            }),
            Zt.prototype.reject = function (d) {
                return this.filter(cv(xt(d)))
            },
            Zt.prototype.slice = function (d, h) {
                d = Vt(d);
                var g = this;
                return g.__filtered__ && (d > 0 || h < 0) ? new Zt(g) : (d < 0 ? g = g.takeRight(-d) : d && (g = g.drop(d)), h !== n && (h = Vt(h), g = h < 0 ? g.dropRight(-h) : g.take(h - d)), g)
            },
            Zt.prototype.takeRightWhile = function (d) {
                return this.reverse().takeWhile(d).reverse()
            },
            Zt.prototype.toArray = function () {
                return this.take(Ke)
            },
            Bs(Zt.prototype, function (d, h) {
                var g = /^(?:filter|find|map|reject)|While$/.test(h),
                I = /^(?:head|last)$/.test(h),
                A = L[I ? "take" + (h == "last" ? "Right" : "") : h],
                V = I || /^find/.test(h);
                A && (L.prototype[h] = function () {
                    var U = this.__wrapped__,
                    ee = I ? [1] : arguments,
                    ae = U instanceof Zt,
                    Ce = ee[0],
                    Te = ae || Nt(U),
                    $e = function (Gt) {
                        var en = A.apply(L, ul([Gt], ee));
                        return I && Ge ? en[0] : en
                    };
                    Te && g && typeof Ce == "function" && Ce.length != 1 && (ae = Te = !1);
                    var Ge = this.__chain__,
                    ht = !!this.__actions__.length,
                    St = V && !Ge,
                    Ft = ae && !ht;
                    if (!V && Te) {
                        U = Ft ? U : new Zt(this);
                        var Ct = d.apply(U, ee);
                        return Ct.__actions__.push({
                            func: iv,
                            args: [$e],
                            thisArg: n
                        }),
                        new Di(Ct, Ge)
                    }
                    return St && Ft ? d.apply(this, ee) : (Ct = this.thru($e), St ? I ? Ct.value()[0] : Ct.value() : Ct)
                })
            }),
            $i(["pop", "push", "shift", "sort", "splice", "unshift"], function (d) {
                var h = Og[d],
                g = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru",
                I = /^(?:pop|shift)$/.test(d);
                L.prototype[d] = function () {
                    var A = arguments;
                    if (I && !this.__chain__) {
                        var V = this.value();
                        return h.apply(Nt(V) ? V : [], A)
                    }
                    return this[g](function (U) {
                        return h.apply(Nt(U) ? U : [], A)
                    })
                }
            }),
            Bs(Zt.prototype, function (d, h) {
                var g = L[h];
                if (g) {
                    var I = g.name + "";
                    _n.call(ud, I) || (ud[I] = []),
                    ud[I].push({
                        name: h,
                        func: g
                    })
                }
            }),
            ud[Zg(n, w).name] = [{
                    name: "wrapper",
                    func: n
                }
            ],
            Zt.prototype.clone = rH,
            Zt.prototype.reverse = oH,
            Zt.prototype.value = iH,
            L.prototype.at = Dq,
            L.prototype.chain = Nq,
            L.prototype.commit = Rq,
            L.prototype.next = Lq,
            L.prototype.plant = Vq,
            L.prototype.reverse = Fq,
            L.prototype.toJSON = L.prototype.valueOf = L.prototype.value = jq,
            L.prototype.first = L.prototype.head,
            bh && (L.prototype[bh] = Bq),
            L
        },
        ad = Rz();
        xc ? ((xc.exports = ad)._ = ad, vb._ = ad) : qr._ = ad
    }).call(Mt)
})(Ohe, Za);
const n$ = "" + new URL("roboto-condensed-all-400-normal-dcd32ca7.woff", import.meta.url).href, $he = `<!--
The embedded fonts are based on open source fonts

About Roboto & Roboto Condensed
https://fonts.google.com/specimen/Roboto/about
https://fonts.google.com/specimen/Roboto+Condensed/about?query=roboto+condensed

These fonts are licensed under the Apache License, Version 2.0.

Copyright 2013 Google

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->`, r$ = (e, t = !1) => {
    let r = new XMLSerializer().serializeToString(e);
    return r.match(/^<svg[^>]*?\sxmlns=(['"`])https?:\/\/www\.w3\.org\/2000\/svg\1/) || (r = r.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"')),
    r.match(/^<svg[^>]*?\sxmlns:xlink=(['"`])http:\/\/www\.w3\.org\/1999\/xlink\1/) || (r = r.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"')),
    r = `<?xml version="1.0" standalone="no"?>${t ? "" : `\r
${$he}`}\r
${r}`,
    r
}, Mv = (e, t = () => !0) => {
    e.forEach(n => {
        t(n) && n.parentNode.removeChild(n)
    })
}, Ahe = e => {
    const t = document.createElement("div");
    t.id = "NODE_PREVIEW_CONTAINER";
    const n = e.cloneNode(!0);
    return t.appendChild(n),
    t.style.visibility = "hidden",
    t.style.display = "table",
    t.style.position = "absolute",
    document.body.appendChild(t), {
        svgClone: n,
        teardown: () => {
            document.body.removeChild(t)
        }
    }
}, Dhe = (e, {
    x: t,
    y: n,
    width: r,
    height: o
}) => {
    e.setAttribute("viewBox", `${t} ${n} ${r} ${o}`)
}, Nhe = ["box-sizing", "width", "height", "inline-size", "block-size", "stroke", "stroke-width", "font-family", "font-style", "font-weight", "line-height", "font-size", "text-align", "border", "padding", "margin", "display", "overflow-x", "overflow-y", "word-wrap", "white-space", "text-overflow", "-webkit-line-clamp", "-webkit-box-orient", "-webkit-font-smoothing"], u0 = (e = {}) => t => {
    t.childNodes.forEach(r => {
        r.nodeType === 1 && u0(e)(r)
    });
    const n = getComputedStyle(t);
    n.length > 0 && Nhe.forEach(r => {
        const o = e[Za.camelCase(r)] ? e[Za.camelCase(r)] : n.getPropertyValue(r);
        t.style.setProperty(r, o)
    })
}, Rhe = async e => {
    const t = /data:.+\/.+;base64,/g,
    n = await fetch(e).then(r => r.blob());
    return new Promise(r => {
        const o = new FileReader;
        o.onload = function (i) {
            r(i.target.result.replace(t, ""))
        },
        o.readAsDataURL(n)
    })
}, Lhe = async() => {
    const e = `workflow-preview-font-${n$}`,
    t = localStorage.getItem(e);
    if (t)
        return Promise.resolve(t);
    const n = await Rhe(n$);
    return localStorage.setItem(e, n),
    n
}, Bhe = async e => {
    const t = document.createElement("style"),
    n = await Lhe();
    t.appendChild(document.createTextNode(`@font-face {
      font-family: "Roboto Condensed";
      font-weight: bold;
      src: url("data:application/font-woff;charset=utf-8;base64,${n}") format('woff');
    }`)),
    t.appendChild(document.createTextNode("li { overflow: initial !important; }")),
    t.type = "text/css",
    e.getElementsByTagName("defs")[0].appendChild(t)
}, o$ = async(e, t) => {
    if (!e)
        return null;
    if (t) {
        const a = "http://www.w3.org/2000/svg",
        l = document.createElementNS(a, "svg");
        return r$(l, !0)
    }
    const r = e.querySelector(".workflow").getBBox(), {
        svgClone: o,
        teardown: i
    } = Ahe(e);
    await Bhe(o),
    Dhe(o, r),
    Mv(o.querySelectorAll("[data-portal-target]")),
    Mv(o.querySelectorAll("[data-hide-in-workflow-preview]")),
    Mv(o.querySelectorAll("g"), a => !a.hasChildNodes()),
    Mv(o.querySelectorAll('[style*="display: none"]')),
    o.querySelectorAll("[data-connector-id]").forEach(u0({
            strokeWidth: "1px"
        })),
    o.querySelectorAll("foreignObject").forEach(u0()),
    o.querySelectorAll(".annotation-editor").forEach(u0({
            overflowX: "hidden",
            overflowY: "hidden"
        }));
    const s = r$(o);
    return i(),
    s
}, Vhe = () => ({
    rootWorkflowSnapshots: new Map
}), Fhe = {}, jhe = {
    updatePreviewSnapshot({
        rootState: e,
        state: t,
        dispatch: n,
        rootGetters: r
    }, {
        isChangingProject: o,
        newWorkflow: i
    }) {
        const s = e.workflow?.activeWorkflow?.info.containerId === "root",
        a = e.workflow?.activeWorkflow?.dirty, {
            activeProjectId: l
        } = t;
        if (s && i && !o || o && a) {
            const f = e.canvas.getScrollContainerElement().firstChild;
            n("addToRootWorkflowSnapshots", {
                projectId: l,
                element: f,
                isCanvasEmpty: r["workflow/isWorkflowEmpty"]
            });
            return
        }
        const u = i?.workflowId === "root";
        !s && u && !o && n("removeFromRootWorkflowSnapshots", {
            projectId: l
        })
    },
    async addToRootWorkflowSnapshots({
        state: e
    }, {
        projectId: t,
        element: n,
        isCanvasEmpty: r
    }) {
        const o = $p(`${t}--root`);
        e.rootWorkflowSnapshots.set(o, await o$(n, r))
    },
    removeFromRootWorkflowSnapshots({
        state: e
    }, {
        projectId: t
    }) {
        e.rootWorkflowSnapshots.delete($p(`${t}--root`))
    },
    getRootWorkflowSnapshotByProjectId({
        state: e
    }, {
        projectId: t
    }) {
        const n = $p(`${t}--root`);
        return e.rootWorkflowSnapshots.get(n)
    },
    async getActiveWorkflowSnapshot({
        rootState: e,
        dispatch: t,
        rootGetters: n
    }) {
        const {
            getScrollContainerElement: r
        } = e.canvas, {
            activeWorkflow: {
                projectId: o,
                info: {
                    containerId: i
                }
            }
        } = e.workflow;
        return i === "root" ? await o$(r().firstChild, n["workflow/isWorkflowEmpty"]) : await t("getRootWorkflowSnapshotByProjectId", {
            projectId: o
        })
    }
}, Whe = {}, du = e => $p(e), zhe = () => ({
    savedCanvasStates: {}
}), Hhe = {
    setSavedCanvasStates(e, t) {
        const {
            savedCanvasStates: n
        } = e, {
            workflow: r,
            project: o
        } = t,
        i = "root",
        s = i === r,
        a = {
            children: {}
        };
        if (s) {
            const l = du(`${o}--${r}`),
            c = n[l] || a;
            c.lastActive = r,
            e.savedCanvasStates[l] = {
                ...c,
                ...t
            }
        } else {
            const l = du(`${o}--${i}`),
            c = du(`${r}`),
            u = n[l] || a;
            e.savedCanvasStates[l] = {
                ...u,
                lastActive: r,
                children: {
                    ...u.children,
                    [c]: t
                }
            }
        }
    }
}, Uhe = {
    saveCanvasState({
        rootGetters: e,
        commit: t
    }) {
        const {
            projectId: n,
            workflowId: r
        } = e["workflow/projectAndWorkflowIds"],
        o = e["canvas/getCanvasScrollState"]();
        t("setSavedCanvasStates", {
            ...o,
            project: n,
            workflow: r
        })
    },
    async restoreCanvasState({
        dispatch: e,
        getters: t
    }) {
        const {
            workflowCanvasState: n
        } = t;
        n && await e("canvas/restoreScrollState", n, {
            root: !0
        })
    },
    removeCanvasState({
        state: e
    }, t) {
        const n = du(`${t}--root`);
        delete e.savedCanvasStates[n]
    }
}, qhe = {
    workflowCanvasState({
        savedCanvasStates: e
    }, t, {
        workflow: n
    }, r) {
        if (!n.activeWorkflow)
            return null;
        const {
            projectId: o,
            workflowId: i
        } = r["workflow/projectAndWorkflowIds"],
        s = "root",
        a = s === i,
        l = du(`${o}--${s}`);
        if (a)
            return e[l]; {
            const c = du(i);
            return e[l]?.children[c]
        }
    },
    getCanvasStateById(e) {
        return (t, n = "root") => {
            const r = du(`${t}--${n}`);
            return e.savedCanvasStates[r] || null
        }
    }
}, Yhe = () => ({
    hasClipboardSupport: !1,
    hasNodeRecommendationsEnabled: !1,
    hasNodeCollectionActive: null,
    scrollToZoomEnabled: !1,
    devMode: !1
}), Khe = {
    setHasClipboardSupport(e, t) {
        e.hasClipboardSupport = t
    },
    setHasNodeRecommendationsEnabled(e, t) {
        e.hasNodeRecommendationsEnabled = t
    },
    setScrollToZoomEnabled(e, t) {
        e.scrollToZoomEnabled = t
    },
    setHasNodeCollectionActive(e, t) {
        e.hasNodeCollectionActive = t
    },
    setDevMode(e, t) {
        e.devMode = t
    }
}, Ghe = {}, Xhe = {}, Jhe = () => ({
    globalLoader: {
        loading: !1,
        text: "",
        config: {
            displayMode: "fullscreen"
        }
    }
}), Zhe = {}, Qhe = {
    updateGlobalLoader({
        state: e
    }, {
        loading: t,
        text: n,
        config: r
    }) {
        e.globalLoader = {
            loading: t,
            text: n,
            config: r || {
                displayMode: "fullscreen"
            }
        }
    }
}, epe = {}, tpe = () => ({
    dirtyProjectsMap: {}
}), npe = {
    setDirtyProjectsMap(e, t) {
        e.dirtyProjectsMap = t
    }
}, rpe = {
    setDirtyProjectsMap({
        commit: e
    }, t) {
        e("setDirtyProjectsMap", t)
    },
    updateDirtyProjectsMap({
        state: e,
        commit: t
    }, n) {
        const r = {
            ...e.dirtyProjectsMap,
            ...n
        };
        t("setDirtyProjectsMap", r)
    }
}, ope = {}, ipe = () => ({
    canvasMode: "selection"
}), spe = {
    setCanvasMode(e, t) {
        e.canvasMode = t
    }
}, ape = {
    resetCanvasMode({
        state: e,
        commit: t
    }) {
        e.canvasMode !== "selection" && t("setCanvasMode", "selection")
    },
    switchCanvasMode({
        commit: e
    }, t) {
        e("setCanvasMode", t)
    }
}, lpe = {
    hasAnnotationModeEnabled(e) {
        return e.canvasMode === "annotation"
    },
    hasSelectionModeEnabled(e) {
        return e.canvasMode === "selection"
    },
    hasPanModeEnabled(e) {
        return e.canvasMode === "pan"
    }
}, cpe = () => ({
    permissions: {
        canConfigureNodes: !0,
        canEditWorkflow: !0,
        canAccessNodeRepository: !0,
        canAccessKAIPanel: !0,
        canAccessSpaceExplorer: !0
    }
}), upe = {
    setPermissions(e, t) {
        e.permissions = t
    }
}, dpe = () => ({
    ...The(),
    ...Vhe(),
    ...zhe(),
    ...Yhe(),
    ...Jhe(),
    ...tpe(),
    ...ipe(),
    ...cpe(),
    openProjects: [],
    activeProjectId: null,
    availablePortTypes: {},
    suggestedPortTypes: [],
    availableComponentTypes: [],
    contextMenu: {
        isOpen: !1,
        position: null
    },
    availableUpdates: null,
    featureFlags: {},
    exampleProjects: [],
    fileExtensionToNodeTemplateId: {},
    nodeRepositoryLoaded: !1,
    nodeRepositoryLoadingProgress: null
}), fpe = {
    ...Mhe,
    ...Fhe,
    ...Hhe,
    ...Khe,
    ...Zhe,
    ...npe,
    ...spe,
    ...upe,
    setActiveProjectId(e, t) {
        e.activeProjectId = t
    },
    setOpenProjects(e, t) {
        e.openProjects = t
    },
    setExampleProjects(e, t) {
        e.exampleProjects = t
    },
    setAvailablePortTypes(e, t) {
        e.availablePortTypes = t
    },
    setSuggestedPortTypes(e, t) {
        e.suggestedPortTypes = t
    },
    setAvailableComponentTypes(e, t) {
        e.availableComponentTypes = t
    },
    setFeatureFlags(e, t) {
        e.featureFlags = t
    },
    setContextMenu(e, t) {
        e.contextMenu = t
    },
    setAvailableUpdates(e, t) {
        e.availableUpdates = t
    },
    setFileExtensionToNodeTemplateId(e, t) {
        e.fileExtensionToNodeTemplateId = t
    },
    setNodeRepositoryLoaded(e, t) {
        e.nodeRepositoryLoaded = t
    },
    setNodeRepositoryLoadingProgress(e, t) {
        e.nodeRepositoryLoadingProgress = t
    }
}, hpe = {
    ...Phe,
    ...jhe,
    ...Uhe,
    ...Ghe,
    ...Qhe,
    ...rpe,
    ...ape,
    replaceApplicationState({
        commit: e,
        dispatch: t,
        state: n
    }, r) {
        if (r.availablePortTypes && e("setAvailablePortTypes", r.availablePortTypes), r.suggestedPortTypeIds && e("setSuggestedPortTypes", r.suggestedPortTypeIds), r.availableComponentTypes && e("setAvailableComponentTypes", r.availableComponentTypes), r.hasOwnProperty("hasNodeRecommendationsEnabled") && e("setHasNodeRecommendationsEnabled", r.hasNodeRecommendationsEnabled), r.featureFlags && e("setFeatureFlags", r.featureFlags), r.permissions && e("setPermissions", r.permissions), r.openProjects && (e("setOpenProjects", r.openProjects), t("spaces/syncPathWithOpenProjects", {
                    openProjects: r.openProjects
                }, {
                    root: !0
                })), r.exampleProjects && e("setExampleProjects", r.exampleProjects), r.hasOwnProperty("scrollToZoomEnabled") && e("setScrollToZoomEnabled", r.scrollToZoomEnabled), r.hasOwnProperty("hasNodeCollectionActive")) {
            const o = n.hasNodeCollectionActive;
            e("setHasNodeCollectionActive", r.hasNodeCollectionActive),
            o !== null && o !== r.hasNodeCollectionActive && t("nodeRepository/resetSearchAndCategories", {}, {
                root: !0
            })
        }
        r.hasOwnProperty("devMode") && e("setDevMode", r.devMode),
        r.fileExtensionToNodeTemplateId && e("setFileExtensionToNodeTemplateId", r.fileExtensionToNodeTemplateId),
        r.hasOwnProperty("nodeRepositoryLoaded") && e("setNodeRepositoryLoaded", r.nodeRepositoryLoaded)
    },
    async forceCloseProjects({
        state: e
    }, {
        projectIds: t
    }) {
        const {
            openProjects: n,
            activeProjectId: r
        } = e,
        o = t8({
            openProjects: n,
            activeProjectId: r,
            closingProjectIds: t
        });
        return await Oe.desktop.forceCloseWorkflows({
            projectIds: t
        }),
        o
    },
    async toggleContextMenu({
        state: e,
        commit: t,
        dispatch: n,
        rootGetters: r,
        rootState: o
    }, {
        event: i = null,
        deselectAllObjects: s = !1
    } = {}) {
        if (o.workflow.quickAddNodeMenu.isOpen && o.workflow.quickAddNodeMenu.events.menuClose?.(), o.workflow.portTypeMenu.isOpen && o.workflow.portTypeMenu.events.menuClose?.(), e.contextMenu.isOpen) {
            i?.preventDefault(),
            t("setContextMenu", {
                isOpen: !1,
                position: null
            });
            return
        }
        if (!i)
            return;
        i.stopPropagation(),
        i.preventDefault(),
        s && await n("selection/deselectAllObjects", null, {
            root: !0
        }),
        await n("resetCanvasMode");
        const {
            clientX: a,
            clientY: l
        } = i,
        c = r["canvas/screenToCanvasCoordinates"],
        [u, f] = c([a, l]);
        e.contextMenu = {
            isOpen: !0,
            position: {
                x: u,
                y: f
            }
        }
    }
}, ppe = {
    ...Ehe,
    ...Whe,
    ...qhe,
    ...Xhe,
    ...epe,
    ...ope,
    ...lpe,
    activeProjectOrigin({
        openProjects: e,
        activeProjectId: t
    }) {
        if (!t)
            return null;
        const n = e.find(r => r.projectId === t);
        return n ? n.origin ?? null : null
    },
    isUnknownProject(e, t, n) {
        if (t.activeProjectOrigin === null)
            return !0;
        const r = n.spaces.spaceProviders ?? {};
        return !Object.values(r).find(o => {
            const {
                spaces: i = []
            } = o;
            return i.find(s => s.id === t.activeProjectOrigin.spaceId)
        })
    },
    isDirtyActiveProject({
        dirtyProjectsMap: e,
        activeProjectId: t
    }) {
        return t ? Boolean(e[t]) : !1
    }
}, mpe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: hpe,
            getters: ppe,
            mutations: fpe,
            state: dpe
        }, Symbol.toStringTag, {
            value: "Module"
        })), mB = 1.09, gB = 1, vB = .01, yB = 5, dp = 20, wB = 1e3, gpe = e => Math.min(Math.max(vB, e), yB), bB = () => {
    throw new Error("dom element hasn't been set yet")
}, vpe = () => ({
    zoomFactor: gB,
    containerSize: {
        width: 0,
        height: 0
    },
    getScrollContainerElement: bB,
    interactionsEnabled: !0,
    zoomCache: null,
    isMoveLocked: !1
}), ype = {
    setScrollContainerElement(e, t) {
        e.getScrollContainerElement = () => t
    },
    clearScrollContainerElement(e) {
        e.getScrollContainerElement = bB
    },
    setFactor(e, t) {
        e.zoomFactor = gpe(t)
    },
    setContainerSize(e, {
        width: t,
        height: n
    }) {
        e.containerSize.width = t,
        e.containerSize.height = n
    },
    setInteractionsEnabled(e, t) {
        e.interactionsEnabled = t
    },
    setIsMoveLocked(e, t) {
        e.isMoveLocked = t
    }
}, wpe = {
    initScrollContainerElement({
        commit: e
    }, t) {
        e("setScrollContainerElement", t),
        e("setContainerSize", {
            width: t.clientWidth,
            height: t.clientHeight
        })
    },
    contentBoundsChanged({
        state: e
    }, [t, n]) {
        const [r, o] = [t.left - n.left, t.top - n.top],
        i = e.getScrollContainerElement();
        i.scrollLeft -= r * e.zoomFactor,
        i.scrollTop -= o * e.zoomFactor
    },
    fitToScreen({
        dispatch: e,
        getters: t,
        commit: n
    }) {
        n("setFactor", t.fitToScreenZoomFactor.min * .98),
        e("scroll", {
            canvasX: "center",
            toScreenX: "center",
            canvasY: "center",
            toScreenY: "center"
        })
    },
    fillScreen({
        dispatch: e,
        commit: t,
        getters: n
    }) {
        const r = Math.min(n.fitToScreenZoomFactor.max * .95, 1);
        t("setFactor", r);
        const o = n.fitToScreenZoomFactor.y >= r,
        i = n.fitToScreenZoomFactor.x >= r,
        s = 20,
        a = i ? {
            canvasX: "center",
            toScreenX: "center"
        }
         : {
            canvasX: n.contentBounds.left,
            toScreenX: s
        },
        l = o ? {
            canvasY: "center",
            toScreenY: "center"
        }
         : {
            canvasY: n.contentBounds.top,
            toScreenY: s
        };
        e("scroll", {
            ...a,
            ...l
        })
    },
    zoomCentered({
        state: e,
        dispatch: t
    }, {
        delta: n,
        factor: r
    }) {
        t("zoomAroundPointer", {
            delta: n,
            factor: r,
            cursorX: e.containerSize.width / 2,
            cursorY: e.containerSize.height / 2
        })
    },
    zoomAroundPointer({
        commit: e,
        getters: t,
        state: n
    }, {
        factor: r,
        delta: o,
        cursorX: i,
        cursorY: s
    }) {
        const a = n.getScrollContainerElement(), {
            scrollLeft: l,
            scrollTop: c
        } = a;
        let u;
        if (Date.now() - n.zoomCache?.timestamp < wB && n.zoomCache?.invariant[0] === i && n.zoomCache?.invariant[1] === s && n.zoomCache?.invariant[2] === l && n.zoomCache?.invariant[3] === c)
            u = n.zoomCache.result;
        else {
            const m = [i + l, s + c];
            u = t.toCanvasCoordinates(m)
        }
        if (isNaN(r) === isNaN(o))
            throw new Error("Either delta or factor have to be passed to zoomAroundPointer");
        isNaN(o) ? isNaN(r) || e("setFactor", r) : e("setFactor", n.zoomFactor * Math.pow(mB, o));
        const f = t.fromCanvasCoordinates({
            x: u[0],
            y: u[1]
        }),
        p = [f.x - i - l, f.y - s - c];
        a.scrollLeft += p[0],
        a.scrollTop += p[1],
        n.zoomCache = {
            invariant: [i, s, a.scrollLeft, a.scrollTop],
            timestamp: Date.now(),
            result: u
        }
    },
    scroll({
        getters: e,
        state: t
    }, {
        canvasX: n = 0,
        canvasY: r = 0,
        toScreenX: o = 0,
        toScreenY: i = 0,
        smooth: s = !1
    }) {
        const a = t.getScrollContainerElement();
        n === "center" && (n = e.contentBounds.centerX),
        r === "center" && (r = e.contentBounds.centerY),
        o === "center" && (o = a.clientWidth / 2),
        i === "center" && (i = a.clientHeight / 2);
        const l = e.fromCanvasCoordinates({
            x: n,
            y: r
        });
        l.x -= o,
        l.y -= i,
        a.scrollTo({
            top: l.y,
            left: l.x,
            behavior: s ? "smooth" : "auto"
        })
    },
    async updateContainerSize({
        state: e,
        getters: t,
        commit: n
    }) {
        const r = e.getScrollContainerElement();
        let {
            x: o,
            y: i
        } = t.fromCanvasCoordinates({
            x: 0,
            y: 0
        });
        i -= r.scrollTop,
        o -= r.scrollLeft,
        n("setContainerSize", {
            width: r.clientWidth,
            height: r.clientHeight
        }),
        await Ci();
        let {
            x: s,
            y: a
        } = t.fromCanvasCoordinates({
            x: 0,
            y: 0
        });
        s -= r.scrollLeft,
        a -= r.scrollTop;
        const [l, c] = [s - o, a - i];
        r.scrollLeft += l,
        r.scrollTop += c
    },
    async restoreScrollState({
        state: e,
        commit: t,
        dispatch: n
    }, r = {}) {
        const {
            zoomFactor: o,
            scrollLeft: i,
            scrollTop: s,
            scrollWidth: a,
            scrollHeight: l
        } = r;
        if (!(o && i && s && a && l)) {
            await n("fillScreen");
            return
        }
        t("setFactor", o),
        await Ci();
        const u = e.getScrollContainerElement(),
        f = i / a,
        p = u.scrollWidth * f,
        m = s / l,
        v = u.scrollHeight * m;
        u.scrollTo({
            top: v,
            left: p,
            behavior: "auto"
        })
    }
}, bpe = {
    getCanvasScrollState(e) {
        const t = e.getScrollContainerElement();
        return () => {
            const {
                zoomFactor: n
            } = e, {
                scrollLeft: r,
                scrollTop: o,
                scrollWidth: i,
                scrollHeight: s
            } = t;
            return {
                scrollLeft: r,
                scrollTop: o,
                scrollWidth: i,
                scrollHeight: s,
                zoomFactor: n
            }
        }
    },
    contentBounds(e, t, n, r) {
        let {
            left: o,
            top: i,
            right: s,
            bottom: a
        } = r["workflow/workflowBounds"];
        o -= dp,
        s += dp,
        i -= dp,
        a += dp;
        const l = s - o,
        c = a - i,
        u = o + l / 2,
        f = i + c / 2;
        return {
            left: o,
            top: i,
            right: s,
            bottom: a,
            width: l,
            height: c,
            centerX: u,
            centerY: f
        }
    },
    contentPadding({
        containerSize: e,
        zoomFactor: t
    }) {
        const n = e.width / t,
        r = e.height / t,
        o = e.width / t,
        i = e.height / t;
        return {
            left: n,
            right: o,
            top: r,
            bottom: i
        }
    },
    paddedBounds(e, {
        contentBounds: t,
        contentPadding: n
    }) {
        const r = t.left - n.left,
        o = t.top - n.top,
        i = t.right + n.right,
        s = t.bottom + n.bottom;
        return {
            left: r,
            top: o,
            right: i,
            bottom: s,
            width: i - r,
            height: s - o
        }
    },
    canvasSize({
        zoomFactor: e
    }, {
        paddedBounds: t
    }) {
        return {
            width: t.width * e,
            height: t.height * e
        }
    },
    viewBox(e, {
        paddedBounds: t
    }) {
        const {
            left: n,
            top: r,
            width: o,
            height: i
        } = t;
        return {
            left: n,
            top: r,
            width: o,
            height: i,
            string: `${n} ${r} ${o} ${i}`
        }
    },
    fromCanvasCoordinates({
        zoomFactor: e
    }, {
        viewBox: t
    }) {
        return ({
            x: n,
            y: r
        }) => ({
            x: (n - t.left) * e,
            y: (r - t.top) * e
        })
    },
    screenFromCanvasCoordinates({
        getScrollContainerElement: e
    }, {
        fromCanvasCoordinates: t
    }) {
        const n = e();
        return ({
            x: r,
            y: o
        }) => {
            const {
                x: i,
                y: s
            } = n.getBoundingClientRect(), {
                scrollLeft: a,
                scrollTop: l
            } = n,
            c = t({
                x: r,
                y: o
            });
            return c.x = c.x - a + i,
            c.y = c.y - l + s,
            c
        }
    },
    toCanvasCoordinates({
        zoomFactor: e
    }, {
        viewBox: t
    }) {
        return ([n, r]) => [n / e + t.left, r / e + t.top]
    },
    screenToCanvasCoordinates({
        getScrollContainerElement: e
    }, {
        toCanvasCoordinates: t
    }) {
        const n = e();
        return ([r, o]) => {
            const {
                x: i,
                y: s
            } = n.getBoundingClientRect(), {
                scrollLeft: a,
                scrollTop: l
            } = n,
            c = r - i + a,
            u = o - s + l;
            return t([c, u])
        }
    },
    fitToScreenZoomFactor({
        containerSize: e
    }, {
        contentBounds: t
    }) {
        const {
            width: n,
            height: r
        } = e, {
            width: o,
            height: i
        } = t,
        s = n / o,
        a = r / i;
        return {
            min: Math.min(s, a),
            max: Math.max(s, a),
            y: a,
            x: s
        }
    },
    getVisibleFrame({
        getScrollContainerElement: e
    }, {
        screenToCanvasCoordinates: t
    }) {
        return () => {
            const r = e().getBoundingClientRect(),
            [o, i] = t([r.x, r.y]),
            [s, a] = t([r.right, r.bottom]);
            return {
                left: o,
                top: i,
                right: s,
                bottom: a,
                width: s - o,
                height: a - i
            }
        }
    }
}, _pe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: wpe,
            defaultZoomFactor: gB,
            getters: bpe,
            maxZoomFactor: yB,
            minZoomFactor: vB,
            mutations: ype,
            padding: dp,
            state: vpe,
            zoomCacheLifespan: wB,
            zoomMultiplier: mB
        }, Symbol.toStringTag, {
            value: "Module"
        })), ri = (e, t = !0) => n => {
    const r = typeof n == "string",
    o = r ? e[n] : e[n.typeId],
    i = {
        ...o,
        description: "No description available",
        typeId: r ? n : n?.typeId
    };
    return t ? {
        ...i,
        type: o.kind,
        ...typeof n == "string" ? {}
         : n
    }
     : i
}, oI = e => t => {
    const {
        inPorts: n = [],
        outPorts: r = []
    } = t;
    return {
        ...t,
        inPorts: n.map(ri(e)),
        outPorts: r.map(ri(e))
    }
}, i$ = e => t => {
    const {
        identifier: n,
        description: r = "No description available",
        supportedPortTypes: o = []
    } = t,
    i = o.map(ri(e)).map(s => ({
                ...s,
                typeName: s.name
            }));
    return {
        groupName: n,
        groupDescription: r,
        types: i
    }
}, kpe = e => t => {
    const {
        inPorts: n = [],
        outPorts: r = [],
        dynamicInPortGroupDescriptions: o = [],
        dynamicOutPortGroupDescriptions: i = []
    } = t;
    return {
        ...t,
        inPorts: n.map(ri(e)),
        outPorts: r.map(ri(e)),
        dynInPorts: o.map(i$(e)),
        dynOutPorts: i.map(i$(e))
    }
}, xpe = e => t => {
    const {
        inPorts: n = [],
        outPorts: r = []
    } = t;
    return {
        ...t,
        inPorts: n.map(ri(e)),
        outPorts: r.map(ri(e))
    }
}, _B = () => {
    const e = new AbortController;
    return {
        abortController: e,
        runAbortablePromise: n => new Promise((r, o) => {
            const i = ({
                target: s
            }) => {
                e.signal.removeEventListener("abort", i),
                o(s.reason)
            };
            n().then(r),
            e.signal.addEventListener("abort", i)
        })
    }
}, s$ = 100, Spe = 150, kB = () => ({
    query: "",
    selectedTags: [],
    portTypeId: null,
    searchScrollPosition: 0,
    nodes: null,
    totalNumNodesFound: 0,
    totalNumFilteredNodesFound: 0,
    nodeSearchPage: 0,
    nodesTags: [],
    abortController: new AbortController
}), xB = {
    setQuery(e, t) {
        e.query = t,
        e.searchScrollPosition = 0
    },
    setSelectedTags(e, t) {
        e.selectedTags = t,
        e.searchScrollPosition = 0
    },
    setPortTypeId(e, t) {
        e.portTypeId = t
    },
    setSearchScrollPosition(e, t) {
        e.searchScrollPosition = t
    },
    setNodes(e, t) {
        e.nodes = t
    },
    addNodes(e, t) {
        const n = e.nodes.map(o => o.id),
        r = t.filter(o => !n.includes(o.id));
        e.nodes.push(...r)
    },
    setTotalNumNodesFound(e, t) {
        e.totalNumNodesFound = t
    },
    setTotalNumFilteredNodesFound(e, t) {
        e.totalNumFilteredNodesFound = t
    },
    setNodeSearchPage(e, t) {
        e.nodeSearchPage = t
    },
    setNodesTags(e, t) {
        e.nodesTags = t
    },
    setAbortController(e, t) {
        e.abortController = t
    }
}, SB = {
    async searchNodes({
        commit: e,
        state: t,
        dispatch: n,
        getters: r,
        rootState: o
    }, {
        append: i = !1,
        all: s = !1
    } = {}) {
        if (!r.hasSearchParams) {
            n("clearSearchResults");
            return
        }
        const {
            abortController: a,
            runAbortablePromise: l
        } = _B();
        t.abortController.abort(),
        e("setAbortController", a);
        const c = t.nodeSearchPage + 1,
        u = i ? c : 0;
        try {
            const f = await l(() => Oe.noderepository.searchNodes({
                        q: t.query,
                        tags: t.selectedTags,
                        allTagsMatch: !0,
                        offset: u * s$,
                        limit: s$,
                        fullTemplateInfo: !0,
                        nodesPartition: s ? "ALL" : "IN_COLLECTION",
                        portTypeId: t.portTypeId
                    }));
            e("setNodeSearchPage", u);
            const {
                nodes: p,
                totalNumNodesFound: m,
                tags: v,
                totalNumFilteredNodesFound: y = 0
            } = f, {
                availablePortTypes: b
            } = o.application,
            w = p.map(oI(b));
            e("setTotalNumNodesFound", m),
            e("setTotalNumFilteredNodesFound", y),
            e(i ? "addNodes" : "setNodes", w),
            e("setNodesTags", v)
        } catch (f) {
            if (f?.name === "AbortError")
                return;
            throw f
        }
    },
    searchStarterOrAllNodes: Za.debounce(async({
            dispatch: e,
            rootState: t
        }) => {
        const n = !t.application.hasNodeCollectionActive;
        await e("searchNodes", {
            all: n
        })
    }, Spe),
    clearSearchResults({
        commit: e
    }) {
        e("setNodes", null),
        e("setNodesTags", []),
        e("setTotalNumNodesFound", 0),
        e("setTotalNumFilteredNodesFound", 0)
    },
    async searchNodesNextPage({
        dispatch: e,
        state: t
    }) {
        t.nodes?.length !== t.totalNumNodesFound && await e("searchNodes", {
            append: !0
        })
    },
    async setSelectedTags({
        dispatch: e,
        commit: t
    }, n) {
        t("setSelectedTags", n),
        await e("searchStarterOrAllNodes")
    },
    async updateQuery({
        commit: e,
        dispatch: t
    }, n) {
        e("setQuery", n),
        await t("searchStarterOrAllNodes")
    },
    async clearSearchParams({
        commit: e,
        dispatch: t
    }) {
        e("setSelectedTags", []),
        e("setQuery", ""),
        e("setPortTypeId", null),
        await t("clearSearchResults")
    }
}, CB = {
    hasSearchParams: e => e.query !== "" || e.selectedTags.length > 0,
    searchIsActive: e => Boolean(e.query || e.nodesTags.length),
    searchResultsContainNodeId(e) {
        return t => Boolean(e.nodes?.some(n => n.id === t))
    },
    getFirstSearchResult: e => () => e.nodes.at(0) || null,
    tagsOfVisibleNodes: e => {
        const t = [...e.nodesTags, ...e.selectedTags];
        return [...new Set(t)]
    }
}, a$ = 3, l$ = 6, Cpe = () => ({
    ...kB(),
    nodesPerCategory: [],
    totalNumCategories: null,
    categoryPage: 0,
    categoryScrollPosition: 0,
    selectedNode: null,
    isDraggingNode: !1,
    draggedNodeData: null,
    nodeTemplates: {}
}), Ipe = {
    ...xB,
    setCategoryPage(e, t) {
        e.categoryPage = t
    },
    setNodesPerCategories(e, {
        groupedNodes: t,
        append: n
    }) {
        e.nodesPerCategory = n ? e.nodesPerCategory.concat(t) : t
    },
    setTotalNumCategories(e, t) {
        e.totalNumCategories = t
    },
    setCategoryScrollPosition(e, t) {
        e.categoryScrollPosition = t
    },
    setSelectedNode(e, t) {
        e.selectedNode = t
    },
    setDraggingNode(e, t) {
        e.isDraggingNode = t
    },
    setDraggedNodeData(e, t) {
        e.draggedNodeData = t
    }
}, Tpe = {
    ...SB,
    async getAllNodes({
        commit: e,
        state: t,
        rootState: n
    }, {
        append: r
    }) {
        if (t.nodesPerCategory.length === t.totalNumCategories)
            return;
        const o = r ? l$ + t.categoryPage * a$ : 0,
        i = r ? a$ : l$;
        r ? e("setCategoryPage", t.categoryPage + 1) : (e("setNodeSearchPage", 0), e("setCategoryPage", 0));
        const {
            totalNumGroups: s,
            groups: a
        } = await Oe.noderepository.getNodesGroupedByTags({
            numNodesPerTag: 8,
            tagsOffset: o,
            tagsLimit: i,
            fullTemplateInfo: !0
        }), {
            availablePortTypes: l
        } = n.application,
        c = a.map(({
                    nodes: u,
                    tag: f
                }) => ({
                    nodes: u.map(oI(l)),
                    tag: f
                }));
        e("setTotalNumCategories", s),
        e("setNodesPerCategories", {
            groupedNodes: c,
            append: r
        })
    },
    async getNodeDescription({
        rootState: e
    }, {
        selectedNode: t
    }) {
        const {
            className: n,
            settings: r
        } = t.nodeFactory,
        o = await Oe.node.getNodeDescription({
            nodeFactoryKey: {
                className: n,
                settings: r
            }
        }), {
            availablePortTypes: i
        } = e.application;
        return kpe(i)(o)
    },
    async getComponentDescription({
        rootState: e,
        rootGetters: t
    }, {
        nodeId: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = t["workflow/projectAndWorkflowIds"],
        i = await Oe.node.getComponentDescription({
            nodeId: n,
            projectId: r,
            workflowId: o
        }), {
            availablePortTypes: s
        } = e.application;
        return xpe(s)(i)
    },
    clearCategoryResults({
        commit: e
    }) {
        e("setNodesPerCategories", {
            groupedNodes: [],
            append: !1
        }),
        e("setTotalNumCategories", null),
        e("setCategoryPage", 0),
        e("setCategoryScrollPosition", 0)
    },
    async resetSearchAndCategories({
        dispatch: e,
        getters: t
    }) {
        t.searchIsActive && (await e("clearSearchResults"), await e("searchStarterOrAllNodes")),
        await e("clearCategoryResults"),
        await e("getAllNodes", {
            append: !1
        })
    },
    async getNodeTemplate({
        state: e
    }, t) {
        if (e.nodeTemplates?.nodeTemplateId)
            return e.nodeTemplates?.nodeTemplateId; {
            const n = await Oe.noderepository.getNodeTemplates({
                nodeTemplateIds: [t]
            });
            return e.nodeTemplates[t] = n[t],
            n[t]
        }
    },
    setDraggingNodeTemplate({
        commit: e
    }, t) {
        e("setDraggingNode", Boolean(t)),
        e("setDraggedNodeData", t)
    }
}, Mpe = {
    ...CB,
    nodesPerCategoryContainSelectedNode(e) {
        return e.nodesPerCategory.some(t => t.nodes.some(n => n.id === e.selectedNode?.id))
    },
    isSelectedNodeVisible: (e, t) => t.searchIsActive ? t.searchResultsContainNodeId(e.selectedNode?.id) : t.nodesPerCategoryContainSelectedNode
}, Ppe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: Tpe,
            getters: Mpe,
            mutations: Ipe,
            state: Cpe
        }, Symbol.toStringTag, {
            value: "Module"
        })), wn = {
    CONTEXT_AWARE_DESCRIPTION: "description",
    NODE_REPOSITORY: "nodeRepository",
    NODE_DIALOG: "nodeDialog",
    SPACE_EXPLORER: "spaceExplorer",
    KAI: "kai"
}, Epe = () => ({
    expanded: !0,
    activeTab: {},
    isExtensionPanelOpen: !1
}), Ope = {
    setCurrentProjectActiveTab({
        commit: e,
        rootState: t
    }, n) {
        const r = t.application.activeProjectId;
        r !== null && e("setActiveTab", {
            projectId: r,
            activeTab: n
        })
    },
    openExtensionPanel({
        commit: e
    }) {
        e("setExtensionPanelOpen", !0)
    },
    closeExtensionPanel({
        commit: e
    }) {
        e("setExtensionPanelOpen", !1)
    }
}, $pe = {
    setActiveTab(e, {
        projectId: t,
        activeTab: n
    }) {
        e.activeTab = {
            ...e.activeTab,
            [t]: n
        },
        e.expanded = !0
    },
    toggleExpanded(e) {
        e.expanded = !e.expanded
    },
    closePanel(e) {
        e.expanded = !1
    },
    setExtensionPanelOpen(e, t) {
        e.isExtensionPanelOpen = t
    }
}, Ape = Object.freeze(Object.defineProperty({
            __proto__: null,
            TABS: wn,
            actions: Ope,
            mutations: $pe,
            state: Epe
        }, Symbol.toStringTag, {
            value: "Module"
        })), IB = "__", $d = (e, t) => `${e}${IB}${t}`, Dpe = e => {
    const [t, n] = e.split(IB);
    return {
        connectionId: t,
        index: Number(n)
    }
}, Npe = () => ({
    selectedNodes: {},
    selectedConnections: {},
    selectedAnnotations: {},
    selectedMetanodePortBars: {},
    startedSelectionFromAnnotationId: null,
    didStartRectangleSelection: !1,
    selectedBendpoints: {}
}), Rpe = {
    addNodesToSelection(e, t) {
        const n = {
            ...e.selectedNodes
        };
        t.forEach(r => {
            n[r] = !0
        }),
        e.selectedNodes = n
    },
    removeNodesFromSelection(e, t) {
        const n = {
            ...e.selectedNodes
        };
        t.forEach(r => {
            delete n[r]
        }),
        e.selectedNodes = n
    },
    clearSelection(e) {
        Object.keys(e.selectedNodes).length > 0 && (e.selectedNodes = {}),
        Object.keys(e.selectedConnections).length > 0 && (e.selectedConnections = {}),
        Object.keys(e.selectedAnnotations).length > 0 && (e.selectedAnnotations = {}),
        Object.keys(e.selectedBendpoints).length > 0 && (e.selectedBendpoints = {}),
        Object.keys(e.selectedMetanodePortBars).length > 0 && (e.selectedMetanodePortBars = {})
    },
    addConnectionsToSelection(e, t) {
        t.forEach(n => {
            e.selectedConnections[n] = !0
        })
    },
    removeConnectionsFromSelection(e, t) {
        t.forEach(n => {
            delete e.selectedConnections[n]
        })
    },
    removeMetanodePortBarsFromSelection(e, t) {
        t.forEach(n => {
            delete e.selectedMetanodePortBars[n]
        })
    },
    addMetanodePortBarsToSelection(e, t) {
        t.forEach(n => e.selectedMetanodePortBars[n] = !0)
    },
    addAnnotationToSelection(e, t) {
        t.forEach(n => {
            e.selectedAnnotations[n] = !0
        })
    },
    removeAnnotationFromSelection(e, t) {
        t.forEach(n => {
            delete e.selectedAnnotations[n]
        })
    },
    addBendpointsToSelection(e, t) {
        t.forEach(n => {
            e.selectedBendpoints[n] = !0
        })
    },
    removeBendpointsFromSelection(e, t) {
        t.forEach(n => {
            delete e.selectedBendpoints[n]
        })
    },
    setStartedSelectionFromAnnotationId(e, t) {
        e.startedSelectionFromAnnotationId = t
    },
    setDidStartRectangleSelection(e, t) {
        e.didStartRectangleSelection = t
    }
}, Lpe = {
    deselectAllObjects({
        commit: e
    }) {
        e("clearSelection")
    },
    selectAllObjects({
        commit: e,
        rootState: t
    }) {
        e("addNodesToSelection", Object.keys(t.workflow.activeWorkflow.nodes)),
        e("addAnnotationToSelection", t.workflow.activeWorkflow.workflowAnnotations.map(n => n.id))
    },
    selectNode({
        commit: e
    }, t) {
        e("addNodesToSelection", [t])
    },
    selectNodes({
        commit: e
    }, t) {
        e("addNodesToSelection", t)
    },
    deselectNode({
        commit: e
    }, t) {
        e("removeNodesFromSelection", [t])
    },
    deselectNodes({
        commit: e
    }, t) {
        e("removeNodesFromSelection", t)
    },
    selectConnection({
        commit: e
    }, t) {
        e("addConnectionsToSelection", [t])
    },
    deselectConnection({
        commit: e
    }, t) {
        e("removeConnectionsFromSelection", [t])
    },
    selectMetanodePortBar({
        commit: e
    }, t) {
        e("addMetanodePortBarsToSelection", [t])
    },
    deselectMetanodePortBar({
        commit: e
    }, t) {
        e("removeMetanodePortBarsFromSelection", [t])
    },
    selectAnnotation({
        commit: e
    }, t) {
        e("addAnnotationToSelection", [t])
    },
    selectAnnotations({
        commit: e
    }, t) {
        e("addAnnotationToSelection", t)
    },
    deselectAnnotation({
        commit: e
    }, t) {
        e("removeAnnotationFromSelection", [t])
    },
    deselectAnnotations({
        commit: e
    }, t) {
        e("removeAnnotationFromSelection", t)
    },
    selectBendpoint({
        commit: e
    }, t) {
        e("addBendpointsToSelection", [t])
    },
    deselectBendpoint({
        commit: e
    }, t) {
        e("removeBendpointsFromSelection", [t])
    },
    selectBendpoints({
        commit: e
    }, t) {
        e("addBendpointsToSelection", t)
    },
    deselectBendpoints({
        commit: e
    }, t) {
        e("removeBendpointsFromSelection", t)
    },
    async toggleAnnotationSelection({
        state: e,
        dispatch: t,
        commit: n
    }, {
        annotationId: r,
        isMultiselect: o,
        isSelected: i
    }) {
        if (r === e.startedSelectionFromAnnotationId && e.didStartRectangleSelection) {
            n("setStartedSelectionFromAnnotationId", null);
            return
        }
        if (!o) {
            await t("deselectAllObjects"),
            await t("selectAnnotation", r);
            return
        }
        t(i ? "deselectAnnotation" : "selectAnnotation", r)
    }
}, Bpe = {
    selectedNodes(e, t, n) {
        return n.workflow.activeWorkflow ? Object.keys(e.selectedNodes).map(r => n.workflow.activeWorkflow.nodes[r]).filter(Boolean) : []
    },
    selectedAnnotations(e, t, n) {
        return n.workflow.activeWorkflow ? n.workflow.activeWorkflow.workflowAnnotations.filter(r => Object.keys(e.selectedAnnotations).includes(r.id)) : []
    },
    selectedMetanodePortBars(e, t, n) {
        return n.workflow.activeWorkflow ? Object.keys(e.selectedMetanodePortBars).map(r => e.selectedMetanodePortBars[r] ? r : null).filter(Boolean) : []
    },
    selectedConnections(e, t, {
        workflow: {
            activeWorkflow: n
        }
    }) {
        return n ? Object.keys(e.selectedConnections).map(r => n.connections[r]).filter(Boolean) : []
    },
    selectedBendpoints(e, t, n) {
        return n.workflow.activeWorkflow ? Object.keys(e.selectedBendpoints).map(r => Dpe(r)).reduce((r, o) => {
            const {
                connectionId: i,
                index: s
            } = o,
            a = r[i] ?? [];
            return a.push(s),
            r[i] = a,
            r
        }, {}) : []
    },
    selectedNodeIds(e, {
        selectedNodes: t
    }) {
        return t.map(n => n.id)
    },
    selectedAnnotationIds(e, {
        selectedAnnotations: t
    }) {
        return t.map(n => n.id)
    },
    selectedBendpointIds(e) {
        return Object.keys(e.selectedBendpoints)
    },
    singleSelectedNode(e, {
        selectedNodes: t
    }) {
        return t.length !== 1 ? null : t[0]
    },
    isNodeSelected: e => t => t in e.selectedNodes,
    isMetaNodePortBarSelected: e => t => t in e.selectedMetanodePortBars,
    isAnnotationSelected: e => t => t in e.selectedAnnotations,
    isConnectionSelected: e => t => Reflect.has(e.selectedConnections, t),
    isBendpointSelected: e => t => Reflect.has(e.selectedBendpoints, t),
    isSelectionEmpty(e, t) {
        return t.selectedNodeIds.length === 0 && t.selectedConnections.length === 0 && t.selectedAnnotationIds.length === 0 && t.selectedBendpointIds.length === 0
    }
}, Vpe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: Lpe,
            getters: Bpe,
            mutations: Rpe,
            state: Npe
        }, Symbol.toStringTag, {
            value: "Module"
        }));
let Wh = (e, t) => {
    let n = t.replace(/^\//, "").split("/").map(o => o.replace(/~1/g, "/").replace(/~0/g, "~")),
    r = n.pop();
    for (; n.length; )
        e = e[n.shift()];
    return [e, r]
};
const fp = {
    "patch.add"(e, {
        path: t,
        value: n
    }) {
        let [r, o] = Wh(e, t);
        if (Array.isArray(r))
            if (o === "-")
                r.push(n);
            else if (/^[0-9]+$/.test(o))
                r.splice(Number(o), 0, n);
            else
                throw new TypeError(`Invalid array index "${o}"`);
        else
            r[o] = n
    },
    "patch.replace"(e, {
        path: t,
        value: n
    }) {
        let [r, o] = Wh(e, t);
        r[o] = n
    },
    "patch.remove"(e, {
        path: t
    }) {
        let [n, r] = Wh(e, t);
        if (Array.isArray(n))
            if (/^[0-9]+$/.test(r))
                n.splice(Number(r), 1);
            else
                throw new TypeError(`Invalid array index "${r}"`);
        else
            delete n[r]
    },
    "patch.copy"(e, {
        from: t,
        path: n
    }) {
        let [r] = Wh(e, `${t}/`),
        o = JSON.parse(JSON.stringify(r));
        fp["patch.add"](e, {
            path: n,
            value: o
        })
    },
    "patch.move"(e, {
        from: t,
        path: n
    }) {
        let [r] = Wh(e, `${t}/`);
        fp["patch.remove"](e, {
            path: t
        }),
        fp["patch.add"](e, {
            path: n,
            value: r
        })
    },
    "patch.apply"(e, t) {
        for (let n of t) {
            let {
                op: r,
                ...o
            } = n;
            fp[`patch.${r}`](e, o)
        }
    }
}, Fpe = {
    "patch.apply"({
        commit: e
    }, t) {
        consola.trace("Applying patch", t),
        e("patch.apply", t)
    }
}, jpe = () => ({
    portTypeMenu: {
        isOpen: !1,
        nodeId: null,
        startNodeId: null,
        previewPort: null,
        props: null,
        events: {}
    },
    quickAddNodeMenu: {
        isOpen: !1,
        props: null,
        events: {}
    }
}), Wpe = {
    setPortTypeMenu(e, t) {
        e.portTypeMenu = t
    },
    setQuickAddNodeMenu(e, t) {
        e.quickAddNodeMenu = t
    },
    setPortTypeMenuPreviewPort(e, t) {
        e.portTypeMenu = {
            ...e.portTypeMenu,
            previewPort: t
        }
    }
}, zpe = {
    openPortTypeMenu({
        commit: e
    }, {
        nodeId: t,
        startNodeId: n,
        props: r,
        events: o
    }) {
        e("setPortTypeMenu", {
            isOpen: !0,
            previewPort: null,
            nodeId: t,
            startNodeId: n,
            props: r,
            events: o
        })
    },
    closePortTypeMenu({
        commit: e
    }) {
        e("setPortTypeMenu", {
            isOpen: !1,
            nodeId: null,
            previewPort: null,
            props: {},
            events: {}
        })
    },
    openQuickAddNodeMenu({
        commit: e,
        dispatch: t
    }, {
        props: n,
        events: r
    }) {
        e("setQuickAddNodeMenu", {
            isOpen: !0,
            props: n,
            events: r || {
                menuClose: () => t("closeQuickAddNodeMenu")
            }
        })
    },
    closeQuickAddNodeMenu({
        commit: e
    }) {
        e("setQuickAddNodeMenu", {
            isOpen: !1,
            props: {},
            events: {}
        })
    }
}, Hpe = {}, Upe = () => ({}), qpe = {}, Ype = {
    async saveWorkflow({
        state: e,
        dispatch: t
    }) {
        const {
            projectId: n
        } = an(e),
        r = await t("application/getActiveWorkflowSnapshot", null, {
            root: !0
        });
        await Oe.desktop.saveWorkflow({
            projectId: n,
            workflowPreviewSvg: r
        })
    },
    async closeWorkflow({
        dispatch: e,
        rootState: t
    }, n) {
        const {
            openProjects: r,
            activeProjectId: o
        } = t.application,
        i = t8({
            openProjects: r,
            activeProjectId: o,
            closingProjectIds: [n]
        });
        await Oe.desktop.closeWorkflow({
            closingProjectId: n,
            nextProjectId: i
        }) && (await e("clearProcessedUpdateNotification", {
                projectId: n
            }), await e("application/removeCanvasState", n, {
                root: !0
            }), await e("application/removeFromRootWorkflowSnapshots", {
                projectId: n
            }, {
                root: !0
            }))
    },
    executeNodeAndOpenView({
        state: e
    }, t) {
        Oe.desktop.executeNodeAndOpenView({
            projectId: e.activeWorkflow.projectId,
            nodeId: t
        })
    },
    openNodeConfiguration({
        state: e
    }, t) {
        Oe.desktop.openNodeDialog({
            projectId: e.activeWorkflow.projectId,
            nodeId: t
        })
    },
    openFlowVariableConfiguration({
        state: e
    }, t) {
        Oe.desktop.openLegacyFlowVariableDialog({
            projectId: e.activeWorkflow.projectId,
            nodeId: t
        })
    },
    openLayoutEditor({
        state: e
    }) {
        const {
            projectId: t,
            workflowId: n
        } = an(e);
        Oe.desktop.openLayoutEditor({
            projectId: t,
            workflowId: n
        })
    },
    openLayoutEditorByNodeId({
        state: e
    }, {
        nodeId: t
    }) {
        const {
            projectId: n
        } = an(e);
        Oe.desktop.openLayoutEditor({
            projectId: n,
            workflowId: t
        })
    },
    async saveWorkflowAs({
        state: e,
        dispatch: t,
        rootState: n
    }) {
        const {
            projectId: r
        } = an(e),
        o = await t("application/getActiveWorkflowSnapshot", null, {
            root: !0
        });
        await Oe.desktop.saveWorkflowAs({
            projectId: r,
            workflowPreviewSvg: o
        }),
        t("spaces/fetchWorkflowGroupContent", {
            projectId: n.application.activeProjectId
        }, {
            root: !0
        })
    }
}, Kpe = {}, Gpe = () => ({}), Xpe = {}, Jpe = {
    changeNodeState({
        state: e,
        rootGetters: t
    }, {
        action: n,
        nodes: r
    }) {
        const {
            projectId: o,
            workflowId: i
        } = an(e);
        if (Array.isArray(r))
            return Oe.node.changeNodeStates({
                projectId: o,
                nodeIds: r,
                action: n,
                workflowId: i
            });
        if (r === "all")
            return Oe.node.changeNodeStates({
                projectId: o,
                action: n,
                nodeIds: [],
                workflowId: i
            });
        if (r === "selected")
            return Oe.node.changeNodeStates({
                projectId: o,
                nodeIds: t["selection/selectedNodeIds"],
                action: n,
                workflowId: i
            });
        throw new TypeError("'nodes' has to be of type 'all' | 'selected' | Array<nodeId>]")
    },
    changeLoopState({
        state: e
    }, {
        action: t,
        nodeId: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e);
        return Oe.node.changeLoopState({
            projectId: r,
            workflowId: o,
            nodeId: n,
            action: t
        })
    },
    executeNodes({
        dispatch: e
    }, t) {
        return e("changeNodeState", {
            action: "execute",
            nodes: t
        })
    },
    openLegacyPortView({
        state: e
    }, {
        nodeId: t,
        portIndex: n,
        executeNode: r = !1
    }) {
        Oe.desktop.openLegacyPortView({
            projectId: e.activeWorkflow.projectId,
            nodeId: t,
            portIdx: n,
            executeNode: r
        })
    },
    executeNodeAndOpenView({
        state: e
    }, t) {
        Oe.desktop.executeNodeAndOpenView({
            projectId: e.activeWorkflow.projectId,
            nodeId: t
        })
    },
    resetNodes({
        dispatch: e
    }, t) {
        return e("changeNodeState", {
            action: "reset",
            nodes: t
        })
    },
    cancelNodeExecution({
        dispatch: e
    }, t) {
        return e("changeNodeState", {
            action: "cancel",
            nodes: t
        })
    },
    pauseLoopExecution({
        dispatch: e
    }, t) {
        return e("changeLoopState", {
            action: "pause",
            nodeId: t
        })
    },
    resumeLoopExecution({
        dispatch: e
    }, t) {
        return e("changeLoopState", {
            action: "resume",
            nodeId: t
        })
    },
    stepLoopExecution({
        dispatch: e
    }, t) {
        return e("changeLoopState", {
            action: "step",
            nodeId: t
        })
    }
}, Zpe = {}, Qpe = () => ({
    isDragging: !1,
    hasAbortedDrag: !1,
    movePreviewDelta: {
        x: 0,
        y: 0
    }
}), eme = {
    setMovePreview(e, {
        deltaX: t,
        deltaY: n
    }) {
        e.movePreviewDelta.x = t,
        e.movePreviewDelta.y = n
    },
    resetMovePreview(e) {
        e.movePreviewDelta = {
            x: 0,
            y: 0
        }
    },
    setHasAbortedDrag(e, t) {
        e.hasAbortedDrag = t
    },
    setIsDragging(e, t) {
        e.isDragging = t
    }
}, tme = {
    abortDrag({
        commit: e
    }) {
        e("setHasAbortedDrag", !0),
        e("setMovePreview", {
            deltaX: 0,
            deltaY: 0
        }),
        e("setIsDragging", !1)
    },
    resetAbortDrag({
        commit: e
    }) {
        e("setHasAbortedDrag", !1)
    },
    resetDragState({
        commit: e
    }) {
        e("setMovePreview", {
            deltaX: 0,
            deltaY: 0
        }),
        e("setIsDragging", !1)
    },
    async moveObjects({
        state: e,
        commit: t,
        rootGetters: n,
        dispatch: r
    }) {
        const {
            projectId: o,
            workflowId: i
        } = an(e),
        s = n["selection/selectedNodeIds"],
        a = n["selection/selectedAnnotationIds"],
        l = n["selection/selectedBendpoints"],
        c = n["selection/selectedMetanodePortBars"],
        u = {
            x: e.movePreviewDelta.x,
            y: e.movePreviewDelta.y
        };
        if (u.x === 0 && u.y === 0) {
            await r("resetDragState");
            return
        }
        try {
            await Oe.workflowCommand.Translate({
                projectId: o,
                workflowId: i,
                nodeIds: s,
                annotationIds: a,
                connectionBendpoints: l,
                metanodeInPortsBar: c.includes("in"),
                metanodeOutPortsBar: c.includes("out"),
                translation: u
            })
        } catch (f) {
            consola.log("The following error occurred: ", f),
            t("resetMovePreview")
        }
    }
}, nme = {}, rme = () => ({
    nameEditorNodeId: null,
    labelEditorNodeId: null
}), ome = {
    setNameEditorNodeId(e, t) {
        e.nameEditorNodeId = t
    },
    setLabelEditorNodeId(e, t) {
        e.labelEditorNodeId = t
    }
}, ime = {
    openNameEditor({
        commit: e
    }, t) {
        e("setNameEditorNodeId", t)
    },
    closeNameEditor({
        commit: e
    }) {
        e("setNameEditorNodeId", null)
    },
    openLabelEditor({
        commit: e
    }, t) {
        e("setLabelEditorNodeId", t)
    },
    closeLabelEditor({
        commit: e
    }) {
        e("setLabelEditorNodeId", null)
    },
    connectNodes({
        state: e
    }, {
        sourceNode: t,
        sourcePort: n,
        destNode: r,
        destPort: o
    }) {
        const {
            projectId: i,
            workflowId: s
        } = an(e);
        return Oe.workflowCommand.Connect({
            projectId: i,
            workflowId: s,
            sourceNodeId: t,
            sourcePortIdx: n,
            destinationNodeId: r,
            destinationPortIdx: o
        })
    },
    renameContainerNode({
        state: e
    }, {
        nodeId: t,
        name: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e);
        return Oe.workflowCommand.UpdateComponentOrMetanodeName({
            projectId: r,
            workflowId: o,
            nodeId: t,
            name: n
        })
    },
    renameNodeLabel({
        state: e
    }, {
        nodeId: t,
        label: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e);
        return Oe.workflowCommand.UpdateNodeLabel({
            projectId: r,
            workflowId: o,
            nodeId: t,
            label: n
        })
    },
    async addNode({
        state: e,
        dispatch: t
    }, {
        position: n,
        nodeFactory: r = null,
        spaceItemReference: o,
        sourceNodeId: i = null,
        sourcePortIdx: s = null,
        selectionMode: a = "new-only",
        isComponent: l = !1
    }) {
        const {
            projectId: c,
            workflowId: u
        } = an(e),
        f = {
            x: br.utils.snapToGrid(n.x),
            y: br.utils.snapToGrid(n.y)
        },
        m = await(l ? () => Oe.desktop.importComponent({
                    projectId: c,
                    workflowId: u,
                    x: f.x,
                    y: f.y,
                    spaceProviderId: o.providerId,
                    spaceId: o.spaceId,
                    itemId: o.itemId
                }) : () => Oe.workflowCommand.AddNode({
                    projectId: c,
                    workflowId: u,
                    position: f,
                    nodeFactory: r,
                    spaceItemReference: o,
                    sourceNodeId: i,
                    sourcePortIdx: s
                }))();
        if (!m)
            return null;
        const v = typeof m == "string" ? m : m.newNodeId;
        return a !== "none" && (a === "new-only" && await t("selection/deselectAllObjects", null, {
                root: !0
            }), await t("selection/selectNode", v, {
                root: !0
            })),
        m
    },
    replaceNode({
        state: e
    }, {
        targetNodeId: t,
        replacementNodeId: n = null,
        nodeFactory: r = null
    }) {
        const {
            projectId: o,
            workflowId: i
        } = an(e);
        return Oe.workflowCommand.ReplaceNode({
            projectId: o,
            workflowId: i,
            targetNodeId: t,
            replacementNodeId: n,
            nodeFactory: r
        })
    },
    insertNode({
        state: {
            activeWorkflow: e
        }
    }, {
        connectionId: t,
        position: n,
        nodeFactory: r,
        nodeId: o
    }) {
        const i = e.projectId,
        s = e.info.containerId;
        return Oe.workflowCommand.InsertNode({
            projectId: i,
            workflowId: s,
            connectionId: t,
            position: n,
            nodeFactory: r,
            nodeId: o
        })
    },
    addNodePort({
        state: e
    }, {
        nodeId: t,
        side: n,
        portGroup: r,
        typeId: o
    }) {
        const {
            projectId: i,
            workflowId: s
        } = an(e);
        return Oe.workflowCommand.AddPort({
            projectId: i,
            workflowId: s,
            nodeId: t,
            side: n,
            portGroup: r,
            portTypeId: o
        })
    },
    removeNodePort({
        state: e
    }, {
        nodeId: t,
        side: n,
        index: r,
        portGroup: o
    }) {
        const {
            projectId: i,
            workflowId: s
        } = an(e);
        return Oe.workflowCommand.RemovePort({
            projectId: i,
            workflowId: s,
            nodeId: t,
            side: n,
            portGroup: o,
            portIndex: r
        })
    }
}, Pv = e => {
    const {
        activeWorkflow: t,
        nodeId: n,
        property: r,
        fallbackProperty: o = r
    } = e,
    i = t.nodes[n], {
        templateId: s
    } = i,
    a = o ? i[o] : null;
    return s ? t.nodeTemplates[s][r] : a
}, sme = {
    isNodeConnected: ({
        activeWorkflow: e
    }) => t => {
        let n;
        for (const r in e.connections)
            if (n = e.connections[r], n.destNode === t || n.sourceNode === t)
                return !0;
        return !1
    },
    getNodeById: ({
        activeWorkflow: e
    }) => t => e?.nodes[t] || null,
    getNodeIcon: ({
        activeWorkflow: e
    }) => t => Pv({
        nodeId: t,
        activeWorkflow: e,
        property: "icon"
    }),
    getNodeName: ({
        activeWorkflow: e
    }) => t => Pv({
        nodeId: t,
        activeWorkflow: e,
        property: "name"
    }),
    getNodeFactory: ({
        activeWorkflow: e
    }) => t => Pv({
        nodeId: t,
        activeWorkflow: e,
        property: "nodeFactory",
        fallbackProperty: null
    }),
    getNodeType: ({
        activeWorkflow: e
    }) => t => Pv({
        activeWorkflow: e,
        nodeId: t,
        property: "type"
    })
}, dg = "hsl(50.8, 100%, 50%)", mw = "hsl(12, 4.2%, 23.3%)", TB = "hsl(0, 0%, 43.1%)", gw = "hsl(200, 5%, 76.5%)", iI = "hsl(200, 10.33%, 94.3%)", MB = "hsl(0, 0%, 100%)", fg = "hsl(188, 63%, 71.4%)", vw = "hsl(193, 60.9%, 43.1%)", PB = "hsl(182, 63.3%, 88.2%)", yw = "hsl(78, 38.7%, 75.7%)", sI = "hsl(60, 23%, 49.4%)", EB = "hsl(60, 50.8%, 87.3%)", aI = "hsl(29, 100%, 59.8%)", OB = "hsl(24, 78.2%, 48.6%)", $B = "hsl(40, 100%, 80%)", ww = "hsl(0, 100%, 64.7%)", AB = "hsl(0, 69.5%, 41.2%)", DB = "hsl(0, 91.5%, 86.1%)", bw = "hsl(206, 69.7%, 38.8%)", NB = "hsl(216, 64.9%, 29%)", RB = "hsl(205, 71.9%, 74.9%)", LB = "hsl(206, 74%, 90%)", BB = "hsl(327, 82.3%, 71.2%)", lI = "hsl(329, 71.4%, 52%)", VB = "hsl(329, 72.3%, 87.3%)", _w = "hsl(305, 27.7%, 46.1%)", FB = "hsl(295, 34.2%, 29.8%)", jB = "hsl(263, 40.4%, 77.6%)", cI = "hsl(128, 50%, 47.1%)", WB = "hsl(142, 58.7%, 29.4%)", uI = "hsl(70, 78.3%, 54.9%)", zB = "hsl(173, 37.2%, 43.7%)", HB = "hsl(183, 100%, 17.5%)", UB = "hsl(168, 57.4%, 78.8%)", kw = "hsl(0, 0%, 66.7%)", qB = "hsl(60, 0.4%, 48.4%)", dI = "hsl(220, 4.3%, 86.5%)", fI = "hsl(24, 46.4%, 67.1%)", YB = "hsl(26, 33%, 35.1%)", KB = "hsl(30, 100%, 85.1%)", xw = "hsl(0, 3%, 12%)", GB = "hsla(0, 3%, 12%, 0.8)", hI = "hsl(0, 0%, 53.3%)", XB = "hsl(195, 1.6%, 51.8%)", JB = "hsl(210, 16.7%, 97.6%)", ZB = "hsla(12, 4.2%, 23.3%, 0.5)", QB = "hsla(195, 1.6%, 51.8%, 0.4)", e7 = "hsla(200, 5%, 76.5%, 0.5)", t7 = "hsla(200, 10%, 94%, 0.4)", ugt = Object.freeze(Object.defineProperty({
            __proto__: null,
            Aquamarine: fg,
            AquamarineDark: vw,
            AquamarineLight: PB,
            Avocado: yw,
            AvocadoDark: sI,
            AvocadoLight: EB,
            Black: xw,
            BlackSemi: GB,
            Carrot: aI,
            CarrotDark: OB,
            CarrotLight: $B,
            Coral: ww,
            CoralDark: AB,
            CoralLight: DB,
            Cornflower: bw,
            CornflowerDark: NB,
            CornflowerLight: RB,
            CornflowerSemi: LB,
            DoveGray: TB,
            GrayDark: XB,
            GrayDarkSemi: QB,
            GrayLightSemi: t7,
            GrayUltraLight: JB,
            Hibiscus: BB,
            HibiscusDark: lI,
            HibiscusLight: VB,
            Lavender: _w,
            LavenderDark: FB,
            LavenderLight: jB,
            Masala: mw,
            MasalaSemi: ZB,
            Meadow: cI,
            MeadowDark: WB,
            MeadowLight: uI,
            Petrol: zB,
            PetrolDark: HB,
            PetrolLight: UB,
            Porcelain: iI,
            SilverSand: gw,
            SilverSandSemi: e7,
            Stone: kw,
            StoneDark: qB,
            StoneGray: hI,
            StoneLight: dI,
            White: MB,
            Wood: fI,
            WoodDark: YB,
            WoodLight: KB,
            Yellow: dg
        }, Symbol.toStringTag, {
            value: "Module"
        })), n7 = gw, ame = yw, lme = sI, cme = uI, ume = fg, dme = fg, fme = fg, hme = dg, pme = dI, mme = hI, gme = fI, vme = cI, yme = yw, wme = _w, bme = _w, _me = ww, kme = aI, xme = kw, Sme = kw, Cme = vw, Ime = vw, r7 = Object.freeze(Object.defineProperty({
            __proto__: null,
            Component: n7,
            Configuration: ame,
            Container: lme,
            Learner: cme,
            Loop: ume,
            LoopEnd: dme,
            LoopStart: fme,
            Manipulator: hme,
            Metanode: pme,
            MetanodeSecondary: mme,
            Other: gme,
            Predictor: vme,
            QuickForm: yme,
            ScopeEnd: wme,
            ScopeStart: bme,
            Sink: _me,
            Source: kme,
            VirtualIn: xme,
            VirtualOut: Sme,
            Visualizer: Cme,
            Widget: Ime
        }, Symbol.toStringTag, {
            value: "Module"
        })), Tme = xw, Mme = ww, o7 = Object.freeze(Object.defineProperty({
            __proto__: null,
            flowVariable: Mme,
            table: Tme
        }, Symbol.toStringTag, {
            value: "Module"
        })), Pme = (e, t) => `${e.slice(0, -1)}, ${t})`, Eme = {
default:
    mw
}, i7 = {
    ...o7,
    generic: "hsl(0, 0%, 61%)",
    inactive: "hsl(0, 100%, 50%)",
    inactiveOutline: "hsla(0, 100%, 100%, 66%)"
}, Ome = r7, $me = xw, Ame = {
    hoverBackground: Pme(iI, "90%"),
    activeBackground: "rgba(233, 241, 246, 90%)",
    activeBorder: bw
}, Dme = {
default:
    gw,
    flowVariable: i7.flowVariable
}, s7 = {
    red: "hsl(339.1, 88.4%, 43.9%)",
    yellow: dg,
    green: "hsl(127.5, 50%, 47.1%)",
    blue: "hsl(206, 69.7%, 55.9%)",
    inactive: "hsl(0, 0%, 100%)",
    inactiveBorder: "hsl(0, 0%, 48.2%)",
    background: "hsl(192, 6.8%, 85.7%)"
}, Nme = "hsla(0, 0%, 0%, 33.3%)", Rme = bw, Lme = mw, Bme = s7.red, Vme = dg, pI = {
    info: "hsla(206, 42%, 86%, 90%)",
    warning: "rgba(255 216 0 / 20%)"
}, af = {
    None: "#FFFFFF",
    SilverSand: "#C0C4C6",
    DoveGray: "#6E6E6E",
    AquamarineDark: "#2B94B1",
    CornflowerDark: "#1A417A",
    Yellow: "#FFD800",
    Carrot: "#FF9632",
    Coral: "#FF4B4B",
    MeadowLight: "#C8E632",
    Meadow: "#3CB44B",
    Avocado: "#CBD9A9",
    Petrol: "#469990",
    PetrolDark: "#005559",
    Wood: "#D2A384",
    WoodDark: "#77563C"
}, a7 = af.SilverSand, Fme = Object.freeze(Object.defineProperty({
            __proto__: null,
            Aquamarine: fg,
            AquamarineDark: vw,
            AquamarineLight: PB,
            Avocado: yw,
            AvocadoDark: sI,
            AvocadoLight: EB,
            Black: xw,
            BlackSemi: GB,
            Carrot: aI,
            CarrotDark: OB,
            CarrotLight: $B,
            Coral: ww,
            CoralDark: AB,
            CoralLight: DB,
            Cornflower: bw,
            CornflowerDark: NB,
            CornflowerLight: RB,
            CornflowerSemi: LB,
            DoveGray: TB,
            GrayDark: XB,
            GrayDarkSemi: QB,
            GrayLightSemi: t7,
            GrayUltraLight: JB,
            Hibiscus: BB,
            HibiscusDark: lI,
            HibiscusLight: VB,
            Lavender: _w,
            LavenderDark: FB,
            LavenderLight: jB,
            Masala: mw,
            MasalaSemi: ZB,
            Meadow: cI,
            MeadowDark: WB,
            MeadowLight: uI,
            Petrol: zB,
            PetrolDark: HB,
            PetrolLight: UB,
            Porcelain: iI,
            SilverSand: gw,
            SilverSandSemi: e7,
            Stone: kw,
            StoneDark: qB,
            StoneGray: hI,
            StoneLight: dI,
            White: MB,
            Wood: fI,
            WoodDark: YB,
            WoodLight: KB,
            Yellow: dg,
            annotationColorPresets: af,
            connectorColors: Dme,
            darkeningMask: Nme,
            defaultAnnotationBorderColor: a7,
            error: Bme,
            linkDecorator: $me,
            metanodeState: Lme,
            nodeBackgroundColors: Ome,
            nodeProgressBar: Rme,
            notifications: pI,
            portColors: i7,
            selection: Ame,
            text: Eme,
            trafficLight: s7,
            warning: Vme
        }, Symbol.toStringTag, {
            value: "Module"
        })), jme = () => ({
    editableAnnotationId: null
}), Wme = {
    setAnnotation(e, {
        annotationId: t,
        text: n,
        borderColor: r
    }) {
        const {
            activeWorkflow: {
                workflowAnnotations: o
            }
        } = e,
        i = o.map(s => s.id === t ? {
            ...s,
            text: n,
            borderColor: r
        }
                 : s);
        e.activeWorkflow.workflowAnnotations = i
    },
    setEditableAnnotationId(e, t) {
        e.editableAnnotationId = t
    }
}, zme = {
    async addWorkflowAnnotation({
        state: e,
        dispatch: t
    }, {
        bounds: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e), {
            newAnnotationId: i
        } = await Oe.workflowCommand.AddWorkflowAnnotation({
            projectId: r,
            workflowId: o,
            bounds: n,
            borderColor: a7
        });
        await t("selection/deselectAllObjects", null, {
            root: !0
        }),
        await t("selection/selectAnnotations", [i], {
            root: !0
        }),
        await t("setEditableAnnotationId", i)
    },
    setEditableAnnotationId({
        commit: e
    }, t) {
        e("setEditableAnnotationId", t)
    },
    transformWorkflowAnnotation({
        state: e
    }, {
        bounds: t,
        annotationId: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e);
        return Oe.workflowCommand.TransformWorkflowAnnotation({
            projectId: r,
            workflowId: o,
            annotationId: n,
            bounds: t
        })
    },
    reorderWorkflowAnnotation({
        state: e,
        rootGetters: t
    }, {
        action: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e),
        i = t["selection/selectedAnnotationIds"];
        return Oe.workflowCommand.ReorderWorkflowAnnotations({
            projectId: r,
            workflowId: o,
            action: n,
            annotationIds: i
        })
    },
    async updateAnnotation({
        state: e,
        commit: t
    }, {
        annotationId: n,
        text: r,
        borderColor: o
    }) {
        const {
            projectId: i,
            workflowId: s
        } = an(e), {
            text: a,
            borderColor: l
        } = e.activeWorkflow.workflowAnnotations.find(c => c.id === n);
        try {
            return t("setAnnotation", {
                annotationId: n,
                text: {
                    value: r,
                    contentType: z0.ContentTypeEnum.Html
                },
                borderColor: o
            }),
            await Oe.workflowCommand.UpdateWorkflowAnnotation({
                projectId: i,
                workflowId: s,
                annotationId: n,
                text: r,
                borderColor: o
            })
        } catch (c) {
            throw t("setAnnotation", {
                annotationId: n,
                text: a,
                borderColor: l
            }),
            c
        }
    }
}, Hme = {}, ny = () => (Math.random() * 2 - 1) * 25, fx = ({
    visibleFrame: e,
    clipboardContent: t
}) => {
    const {
        x: n,
        y: r
    } = br.utils.getCenteredPositionInVisibleFrame(e, t.objectBounds);
    return {
        x: n + ny(),
        y: r + ny()
    }
}, Ume = ({
    clipboardContent: e,
    visibleFrame: t
}) => {
    const {
        objectBounds: n
    } = e,
    r = 120,
    o = {
        left: n.left + r + ny(),
        top: n.top + r + ny()
    };
    return br.utils.areaCoverage({
        ...o,
        width: n.width,
        height: n.height
    }, t) >= br.constants.VISIBILITY_THRESHOLD ? {
        x: o.left,
        y: o.top
    }
     : null
}, qme = ({
    visibleFrame: e,
    clipboardContent: t,
    isWorkflowEmpty: n,
    dispatch: r
}) => n ? (consola.info("workflow is empty: paste to center"), {
    position: fx({
        visibleFrame: e,
        clipboardContent: t
    }),
    doAfterPaste: () => r("canvas/fillScreen", null, {
        root: !0
    })
}) : {
    position: Ume({
        visibleFrame: e,
        clipboardContent: t
    }) || fx({
        visibleFrame: e,
        clipboardContent: t
    })
}, Yme = (e, t, n, r) => {
    const {
        projectId: o,
        info: {
            containerId: i
        }
    } = t, {
        x: s,
        y: a
    } = n ? {
        x: n.x - fr / 2,
        y: n.y - fr / 2
    }
     : fx({
        visibleFrame: r,
        clipboardContent: {
            objectBounds: {
                width: fr,
                height: fr
            }
        }
    });
    return Oe.desktop.importURIAtWorkflowCanvas({
        uri: e,
        projectId: o,
        workflowId: i,
        x: s,
        y: a
    })
}, c$ = ag(), Kme = e => {
    const t = c$.show({
        id: "COPY_FALLBACK",
        headline: "Data copied to clipboard",
        message: "If you want to paste the data into a different Analytics Platform you need to copy the data in JSON format.",
        buttons: [{
                icon: _u(lw),
                text: " Copy data in JSON format",
                callback: () => {
                    navigator.clipboard.writeText(e).then(() => {
                        c$.remove(t)
                    })
                }
            }
        ],
        autoRemove: !0
    });
    return t
}, Gme = async e => {
    try {
        await navigator.clipboard.writeText(e)
    } catch (t) {
        typeof t == "object" && t && "name" in t && t.name === "NotAllowedError" && Kme(e),
        consola.info("Failed to write to clipboard", t)
    }
};
let u$ = new AbortController, hx = null;
const Xme = e => {
    hx = e
}, Jme = () => {
    hx?.(),
    hx = null
}, Zme = () => ({
    copyPaste: null,
    cacheClipboardContent: {},
    isClipboardBusy: !1
}), Qme = {
    setCopyPaste(e, t) {
        e.copyPaste = t
    },
    setClipboardContentCache(e, {
        cacheClipboardContentId: t,
        clipboardContent: n
    }) {
        e.cacheClipboardContent = {
            [t]: n
        }
    },
    setLastPasteBounds(e, t) {
        e.copyPaste || (e.copyPaste = {}),
        e.copyPaste.lastPasteBounds = t
    },
    setIsClipboardBusy(e, t) {
        e.isClipboardBusy = t
    }
}, ege = {
    async copyOrCutWorkflowParts({
        state: e,
        rootGetters: t,
        dispatch: n,
        commit: r
    }, {
        command: o
    }) {
        if (!["copy", "cut"].includes(o))
            throw new Error("command has to be 'copy' or 'cut'");
        const {
            projectId: i,
            workflowId: s
        } = an(e),
        a = t["selection/selectedNodeIds"],
        l = t["selection/selectedAnnotationIds"],
        c = t["selection/selectedBendpoints"];
        if (t["selection/isSelectionEmpty"])
            return;
        const u = br.getWorkflowObjectBounds({
            nodes: t["selection/selectedNodes"],
            workflowAnnotations: t["selection/selectedAnnotations"]
        });
        o === "cut" && await n("selection/deselectAllObjects", null, {
            root: !0
        });
        const f = o === "copy" ? Oe.workflowCommand.Copy : Oe.workflowCommand.Cut, {
            abortController: p,
            runAbortablePromise: m
        } = _B();
        u$.abort(),
        u$ = p;
        try {
            r("setIsClipboardBusy", !0);
            const v = `clipboard_cache_${V0()}`;
            await navigator.clipboard.writeText(JSON.stringify({
                    cacheClipboardContentId: v
                }));
            const y = await m(() => f({
                        projectId: i,
                        workflowId: s,
                        nodeIds: a,
                        annotationIds: l,
                        connectionBendpoints: c
                    })),
            w = {
                payloadIdentifier: JSON.parse(y.content).payloadIdentifier,
                projectId: i,
                workflowId: s,
                data: y.content,
                objectBounds: u
            };
            r("setCopyPaste", {
                payloadIdentifier: w.payloadIdentifier
            });
            const k = JSON.stringify(w);
            r("setClipboardContentCache", {
                cacheClipboardContentId: v,
                clipboardContent: k
            }),
            await Gme(k),
            r("setIsClipboardBusy", !1),
            Jme(),
            consola.info("Copied workflow parts", w)
        } catch (v) {
            if (v?.name === "AbortError") {
                consola.info("Aborting first copy/cut request");
                return
            }
            consola.error("Could not write to clipboard.")
        }
    },
    async pasteWorkflowParts({
        state: e,
        getters: {
            isWorkflowEmpty: t
        },
        dispatch: n,
        rootGetters: r,
        commit: o
    }, {
        position: i
    } = {
            position: null
        }) {
        if (e.isClipboardBusy) {
            Xme(() => n("pasteWorkflowParts", {
                    position: i
                }));
            return
        }
        const {
            activeWorkflow: s
        } = e;
        let a,
        l;
        try {
            l = await navigator.clipboard.readText()
        } catch {
            consola.info("Could not read from clipboard. Maybe the user did not permit it?");
            return
        }
        try {
            a = JSON.parse(l),
            a.cacheClipboardContentId && e.cacheClipboardContent[a.cacheClipboardContentId] && (a = JSON.parse(e.cacheClipboardContent[a.cacheClipboardContentId]))
        } catch {
            Yme(l, s, i, r["canvas/getVisibleFrame"]()) || consola.info("Could not parse json or URI from clipboard.");
            return
        }
        consola.info("Pasted workflow parts");
        const {
            position: c,
            doAfterPaste: u
        } = i ? {
            position: i,
            doAfterPaste: null
        }
         : qme({
            visibleFrame: r["canvas/getVisibleFrame"](),
            clipboardContent: a,
            isWorkflowEmpty: t,
            dispatch: n
        });
        o("setLastPasteBounds", {
            left: c.x,
            top: c.y,
            width: a.objectBounds.width,
            height: a.objectBounds.height
        });
        const {
            projectId: f,
            workflowId: p
        } = an(e), {
            nodeIds: m,
            annotationIds: v
        } = await Oe.workflowCommand.Paste({
            projectId: f,
            workflowId: p,
            content: a.data,
            position: c
        });
        u?.(),
        await n("selection/deselectAllObjects", null, {
            root: !0
        }),
        await n("selection/selectNodes", m, {
            root: !0
        }),
        await n("selection/selectAnnotations", v, {
            root: !0
        })
    }
}, tge = {}, nge = () => ({
    virtualBendpoints: {}
}), rge = {
    updateConnection(e, {
        connectionId: t,
        data: n
    }) {
        e.activeWorkflow.connections[t] = n
    },
    addVirtualBendpoint(e, {
        connectionId: t,
        index: n,
        position: r
    }) {
        const o = e.activeWorkflow.connections[t].bendpoints?.length ?? 0;
        e.virtualBendpoints = {
            ...e.virtualBendpoints,
            [t]: {
                ...e.virtualBendpoints[t],
                [n]: {
                    ...r,
                    currentBendpointCount: o
                }
            }
        }
    },
    removeVirtualBendpoint(e, {
        connectionId: t,
        index: n
    }) {
        delete e.virtualBendpoints[t][n],
        Object.keys(e.virtualBendpoints[t]).length === 0 && delete e.virtualBendpoints[t]
    }
}, oge = {
    addVirtualBendpoint({
        commit: e
    }, {
        position: t,
        connectionId: n,
        index: r
    }) {
        e("addVirtualBendpoint", {
            connectionId: n,
            position: t,
            index: r
        })
    },
    async addBendpoint({
        state: e,
        commit: t
    }, {
        connectionId: n,
        index: r,
        position: o
    }) {
        const {
            projectId: i,
            workflowId: s
        } = an(e),
        a = {
            x: e.movePreviewDelta.x,
            y: e.movePreviewDelta.y
        };
        await Oe.workflowCommand.AddBendpoint({
            projectId: i,
            workflowId: s,
            connectionId: n,
            position: {
                x: o.x + a.x,
                y: o.y + a.y
            },
            index: r
        }),
        t("removeVirtualBendpoint", {
            connectionId: n,
            index: r
        })
    }
}, ige = {}, sge = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, age = P("path", {
    d: "M17.25 25.572c-.41.046-.827.069-1.25.069-6.213 0-11.25-5.037-11.25-11.25S9.787 3.141 16 3.141s11.25 5.037 11.25 11.25c0 3.862-2.033 7.558-5 9.583M14.044 22l3.206 3.572-3.627 3.287"
}, null, -1), lge = [age];
function cge(e, t) {
    return _(),
    O("svg", sge, lge)
}
const uge = {
    render: cge
}, _l = "LINK_UPDATE", zh = "Linked components", kd = ag(), q_ = (e, t) => t > 1 ? `${e}s` : e, dge = () => ({
    processedUpdateNotifications: {}
}), fge = {
    setProcessedNotification(e, {
        projectId: t,
        value: n
    }) {
        e.processedUpdateNotifications[t] = n
    }
}, hge = {
    async checkForLinkedComponentUpdates({
        state: e,
        commit: t,
        dispatch: n,
        getters: r
    }, {
        auto: o = !1
    } = {}) {
        const s = r.isWritable && e.activeWorkflow.info.containsLinkedComponents, {
            projectId: a,
            workflowId: l
        } = an(e),
        c = e.processedUpdateNotifications[a];
        if (!(!s || c && o))
            try {
                const u = await Oe.workflow.getLinkUpdates({
                    projectId: a,
                    workflowId: l
                });
                if (u.length === 0) {
                    o || kd.show({
                        id: `${_l}__ALL_UP_TO_DATE`,
                        type: "success",
                        headline: zh,
                        message: "No updates available"
                    });
                    return
                }
                const f = u.some(y => y.isExecuted),
                p = u.map(y => y.id),
                m = `You have ${p.length} ${q_("update", p.length)} available`,
                v = f ? `${m}. Reset ${q_("component", p.length)} and update now?` : m;
                kd.show({
                    id: `${_l}__CHECKING`,
                    type: "warning",
                    headline: zh,
                    message: v,
                    buttons: [{
                            icon: uge,
                            text: f ? "Reset and update" : "Update",
                            callback: async() => {
                                await n("clearComponentUpdateToasts"),
                                await n("updateComponents", {
                                    nodeIds: p
                                })
                            }
                        }
                    ],
                    autoRemove: !1
                }),
                t("setProcessedNotification", {
                    projectId: a,
                    value: !0
                })
            } catch {
                kd.show({
                    id: `${_l}__CHECKING_FAILED`,
                    type: "error",
                    headline: zh,
                    message: "Problem checking for linked component updates",
                    autoRemove: !1
                })
            }
    },
    async updateComponents({
        state: e
    }, {
        nodeIds: t
    }) {
        const n = kd.show({
            id: `${_l}__STARTED`,
            headline: zh,
            message: "Updating...",
            autoRemove: !1
        }), {
            projectId: r,
            workflowId: o
        } = an(e),
        i = await Oe.workflowCommand.UpdateLinkedComponents({
            projectId: r,
            workflowId: o,
            nodeIds: t
        });
        kd.remove(n);
        const a = {
            [Tp.StatusEnum.Success]: {
                id: `${_l}__SUCCESS`,
                type: "success",
                autoRemove: !0,
                message: "Updated"
            },
            [Tp.StatusEnum.Unchanged]: {
                id: `${_l}__SUCCESS`,
                type: "success",
                autoRemove: !0,
                message: "Everything up-to-date"
            },
            [Tp.StatusEnum.Error]: {
                id: `${_l}__ERROR`,
                type: "error",
                autoRemove: !0,
                message: `Couldn't update linked ${q_("component", t.length)}. Please try again`
            }
        }
        [i.status];
        kd.show({
            ...a,
            headline: zh
        })
    },
    async linkComponent({
        state: e
    }, {
        nodeId: t
    }) {
        const {
            projectId: n,
            workflowId: r
        } = an(e);
        await Oe.desktop.openLinkComponentDialog({
            projectId: n,
            workflowId: r,
            nodeId: t
        }) && await this.dispatch("spaces/fetchWorkflowGroupContent", {
            projectId: n
        }, {
            root: !0
        })
    },
    async unlinkComponent({
        state: e
    }, {
        nodeId: t
    }) {
        const {
            projectId: n,
            workflowId: r
        } = an(e);
        await Oe.workflowCommand.UpdateComponentLinkInformation({
            projectId: n,
            workflowId: r,
            nodeId: t
        })
    },
    changeHubItemVersion({
        state: e
    }, {
        nodeId: t
    }) {
        const {
            projectId: n,
            workflowId: r
        } = an(e);
        Oe.desktop.openChangeComponentHubItemVersionDialog({
            projectId: n,
            workflowId: r,
            nodeId: t
        })
    },
    changeComponentLinkType({
        state: e
    }, {
        nodeId: t
    }) {
        const {
            projectId: n,
            workflowId: r
        } = an(e);
        Oe.desktop.openChangeComponentLinkTypeDialog({
            projectId: n,
            workflowId: r,
            nodeId: t
        })
    },
    clearComponentUpdateToasts() {
        ag().removeBy(t => t.id.startsWith(_l))
    },
    clearProcessedUpdateNotification({
        commit: e
    }, {
        projectId: t
    }) {
        e("setProcessedNotification", {
            projectId: t,
            value: !1
        })
    }
}, pge = () => ({
    ...Gpe(),
    ...jpe(),
    ...Upe(),
    ...Qpe(),
    ...rme(),
    ...Zme(),
    ...jme(),
    ...nge(),
    ...dge(),
    activeWorkflow: null,
    activeSnapshotId: null,
    tooltip: null,
    calculatedMetanodePortBarBounds: {
        in: null,
        out: null
    }
}), mge = {
    ...fp,
    ...Xpe,
    ...Wpe,
    ...qpe,
    ...eme,
    ...ome,
    ...Qme,
    ...Wme,
    ...rge,
    ...fge,
    setActiveWorkflow(e, t) {
        e.activeWorkflow = t
    },
    setActiveSnapshotId(e, t) {
        e.activeSnapshotId = t
    },
    setTooltip(e, t) {
        e.tooltip = t
    },
    setCalculatedMetanodePortBarBounds(e, t) {
        e.calculatedMetanodePortBarBounds = t
    }
}, gge = {
    ...Fpe,
    ...Jpe,
    ...zpe,
    ...Ype,
    ...tme,
    ...ime,
    ...ege,
    ...zme,
    ...oge,
    ...hge,
    undo({
        state: e
    }) {
        const {
            projectId: t,
            workflowId: n
        } = an(e);
        return Oe.workflow.undoWorkflowCommand({
            projectId: t,
            workflowId: n
        })
    },
    redo({
        state: e
    }) {
        const {
            projectId: t,
            workflowId: n
        } = an(e);
        return Oe.workflow.redoWorkflowCommand({
            projectId: t,
            workflowId: n
        })
    },
    async deleteSelectedObjects({
        state: e,
        rootGetters: t,
        dispatch: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e),
        i = t["selection/selectedNodes"],
        s = t["selection/selectedConnections"],
        a = t["selection/selectedAnnotationIds"],
        l = t["selection/selectedBendpoints"],
        c = i.filter(b => b.allowedActions.canDelete).map(b => b.id),
        u = i.filter(b => !b.allowedActions.canDelete).map(b => b.id),
        f = s.filter(b => b.allowedActions.canDelete).map(b => b.id),
        p = s.filter(b => !b.allowedActions.canDelete).map(b => b.id),
        m = Object.keys(l).reduce((b, w) => e.activeWorkflow.connections[w].allowedActions.canDelete ? {
            ...b,
            [w]: l[w]
        }
                 : b, {}),
        v = Object.keys(m).length > 0;
        (c.length || f.length || a.length || v) && (await Oe.workflowCommand.Delete({
                projectId: r,
                workflowId: o,
                nodeIds: c.length ? c : [],
                connectionIds: f.length ? f : [],
                annotationIds: a.length ? a : [],
                connectionBendpoints: m
            }), await n("selection/deselectAllObjects", null, {
                root: !0
            }));
        const y = [];
        u.length && y.push(`The following nodes can’t be deleted: [${u.join(", ")}]`),
        p.length && y.push(`The following connections can’t be deleted: [${p.join(", ")}]`),
        y.length && window.alert(y.join(`
`))
    },
    async collapseToContainer({
        state: e,
        rootGetters: t,
        dispatch: n
    }, {
        containerType: r
    }) {
        const {
            projectId: o,
            workflowId: i
        } = an(e),
        s = t["selection/selectedNodeIds"],
        a = t["selection/selectedNodes"],
        l = t["selection/selectedAnnotationIds"],
        c = t["selection/selectedBendpoints"];
        if (a.some(p => p.allowedActions.canCollapse === "resetRequired") && !window.confirm(`Creating this ${r} will reset executed nodes.`))
            return;
        await n("selection/deselectAllObjects", null, {
            root: !0
        });
        const {
            newNodeId: f
        } = await Oe.workflowCommand.Collapse({
            containerType: r,
            projectId: o,
            workflowId: i,
            nodeIds: s,
            annotationIds: l,
            connectionBendpoints: c
        });
        t["selection/isSelectionEmpty"] && (await n("selection/selectNode", f, {
                root: !0
            }), await n("openNameEditor", f))
    },
    async expandContainerNode({
        state: e,
        rootGetters: t,
        dispatch: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e),
        i = t["selection/singleSelectedNode"];
        if (i.allowedActions.canExpand === "resetRequired" && !window.confirm(`Expanding this ${i.kind} will reset executed nodes.`))
            return;
        await n("selection/deselectAllObjects", null, {
            root: !0
        });
        const {
            expandedNodeIds: s,
            expandedAnnotationIds: a
        } = await Oe.workflowCommand.Expand({
            projectId: r,
            workflowId: o,
            nodeId: i.id
        });
        t["selection/isSelectionEmpty"] && (await n("selection/selectNodes", s, {
                root: !0
            }), await n("selection/selectAnnotations", a, {
                root: !0
            }))
    },
    transformMetaNodePortBar({
        state: e
    }, {
        bounds: t,
        type: n
    }) {
        const {
            projectId: r,
            workflowId: o
        } = an(e);
        return Oe.workflowCommand.TransformMetanodePortsBar({
            projectId: r,
            workflowId: o,
            type: n,
            bounds: t
        })
    },
    async updateComponentMetadata(e, {
        projectId: t,
        workflowId: n,
        description: r,
        type: o,
        icon: i,
        inPorts: s,
        outPorts: a,
        links: l,
        tags: c
    }) {
        await Oe.workflowCommand.UpdateComponentMetadata({
            projectId: t,
            workflowId: n,
            description: r,
            type: o,
            icon: i,
            inPorts: s,
            outPorts: a,
            links: l,
            tags: c
        })
    },
    async updateWorkflowMetadata(e, {
        description: t,
        tags: n,
        links: r,
        projectId: o,
        workflowId: i
    }) {
        await Oe.workflowCommand.UpdateProjectMetadata({
            projectId: o,
            workflowId: i,
            description: t,
            tags: n,
            links: r
        })
    }
}, vge = {
    ...Zpe,
    ...Hpe,
    ...Kpe,
    ...nme,
    ...sme,
    ...tge,
    ...Hme,
    ...ige,
    isWorkflowEmpty({
        activeWorkflow: e
    }) {
        const t = Boolean(Object.keys(e?.nodes).length),
        n = Boolean(e?.workflowAnnotations.length);
        return !t && !n
    },
    isStreaming({
        activeWorkflow: e
    }) {
        return Boolean(e?.info.jobManager)
    },
    isLinked({
        activeWorkflow: e
    }) {
        return Boolean(e?.info.linked)
    },
    insideLinkedType({
        activeWorkflow: e
    }) {
        return e?.parents ? e.parents.find(({
                linked: t
            }) => t)?.containerType : null
    },
    isInsideLinked(e, t) {
        return Boolean(t.insideLinkedType)
    },
    isWritable(e, {
        isLinked: t,
        isInsideLinked: n,
        projectAndWorkflowIds: r
    }, o) {
        if (!o.application.permissions.canEditWorkflow)
            return !1;
        const i = t || n;
        if (!o.aiAssistant)
            return !i;
        const s = o.aiAssistant.build.isProcessing && Za.isEqual(o.aiAssistant.build.projectAndWorkflowIds, r);
        return !i && !s
    },
    isRemoteWorkflow({
        activeWorkflow: e
    }) {
        return Boolean(e?.info.providerType !== Hk.ProviderTypeEnum.LOCAL)
    },
    workflowBounds({
        activeWorkflow: e,
        calculatedMetanodePortBarBounds: t
    }) {
        return br.getWorkflowObjectBounds(e, {
            padding: !0,
            calculatedPortBarBounds: t
        })
    },
    projectAndWorkflowIds: e => an(e)
}, yge = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: gge,
            getters: vge,
            mutations: mge,
            state: pge
        }, Symbol.toStringTag, {
            value: "Module"
        })), wge = () => ({
    restApiBaseUrl: null
}), bge = {
    setRestApiBaseUrl(e, t) {
        e.restApiBaseUrl = t
    }
}, _ge = {
    async callService(e, {
        extensionConfig: t,
        nodeService: n,
        serviceRequest: r,
        requestParams: o
    }) {
        const {
            projectId: i,
            workflowId: s,
            nodeId: a,
            extensionType: l
        } = t;
        let c;
        return n === "NodeService.callNodeDataService" ? c = await Oe.node.callNodeDataService({
            projectId: i,
            workflowId: s,
            nodeId: a,
            extensionType: l,
            serviceType: r,
            dataServiceRequest: o
        }) : n === "NodeService.updateDataPointSelection" && (c = '{ "TODO": "TODO" }'), {
            result: JSON.parse(c)
        }
    },
    changeNodeStates({
        dispatch: e,
        rootGetters: t
    }) {
        const n = t["selection/singleSelectedNode"];
        e("workflow/executeNodes", [n.id], {
            root: !0
        })
    }
}, kge = {
    uiExtResourceLocation: (e, t, n) => ({
        resourceInfo: r
    }) => r.baseUrl ? r.baseUrl + r.path : `${e.restApiBaseUrl}/jobs/${n.application.activeProjectId}/workflow/wizard/web-resources/${r.path}`
}, xge = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: _ge,
            getters: kge,
            mutations: bge,
            state: wge
        }, Symbol.toStringTag, {
            value: "Module"
        }));
var Cf;
(e => {
    e.TypeEnum = zk.TypeEnum
})(Cf || (Cf = {}));
const Sge = () => ({}), Cge = {}, Ige = {
    async connectProvider({
        dispatch: e,
        commit: t
    }, {
        spaceProviderId: n
    }) {
        try {
            t("setIsLoadingProvider", !0);
            const r = await Oe.desktop.connectSpaceProvider({
                spaceProviderId: n
            }),
            o = r?.connected ? await e("fetchProviderSpaces", {
                id: n
            }) : {};
            t("updateSpaceProvider", {
                id: n,
                value: {
                    ...r,
                    ...o
                }
            })
        } catch (r) {
            throw consola.error("Error connecting to provider", {
                error: r
            }),
            r
        } finally {
            t("setIsLoadingProvider", !1)
        }
    },
    async disconnectProvider({
        commit: e,
        state: t
    }, {
        spaceProviderId: n
    }) {
        try {
            await Oe.desktop.disconnectSpaceProvider({
                spaceProviderId: n
            }),
            Object.entries(t.projectPath).flatMap(([l, c]) => c.spaceProviderId === n ? [l] : []).forEach(l => e("setProjectPath", {
                    projectId: l,
                    value: {
                        spaceProviderId: "local",
                        spaceId: "local",
                        itemId: "root"
                    }
                }));
            const {
                spaceProviders: o
            } = t, {
                spaces: i,
                user: s,
                ...a
            } = o[n];
            return e("setSpaceProviders", {
                ...t.spaceProviders,
                [n]: {
                    ...a,
                    connected: !1
                }
            }),
            n
        } catch (r) {
            throw consola.error("Error disconnecting from provider", {
                error: r
            }),
            r
        }
    }
}, Tge = {
    hasActiveHubSession({
        spaceProviders: e
    }) {
        return e ? Boolean(Object.values(e).find(({
                    connected: t,
                    type: n
                }) => n !== Cf.TypeEnum.LOCAL && t)) : !1
    }
}, wm = "__SPACE_BROWSER_TAB__", bm = "__LOCAL_ROOT__", Wd = {
    spaceId: "local",
    spaceProviderId: "local",
    itemId: "root"
}, Mge = [wm, bm], Pge = () => ({
    workflowGroupCache: new WeakMap,
    projectPath: {
        [bm]: Wd
    }
}), Ege = {
    setProjectPath(e, {
        projectId: t,
        value: n
    }) {
        e.projectPath = {
            ...e.projectPath,
            [t]: n
        }
    },
    removeProjectPath(e, t) {
        delete e.projectPath[t]
    },
    updateProjectPath(e, {
        projectId: t,
        value: n
    }) {
        const r = e.projectPath[t];
        return r ? (e.projectPath = {
                ...e.projectPath,
                [t]: {
                    ...r,
                    ...n
                }
            }, !0) : (consola.warn("updateProjectPath failed project was never added", t), !1)
    },
    setWorkflowGroupContent(e, {
        projectId: t,
        content: n
    }) {
        const r = e.projectPath[t];
        e.workflowGroupCache.set(r, n)
    }
}, Oge = {
    syncPathWithOpenProjects({
        commit: e,
        state: t
    }, {
        openProjects: n
    }) {
        const r = s => {
            const a = t.spaceProviders ?? {},
            l = Object.values(a).find(c => {
                const {
                    spaces: u = []
                } = c;
                return u.find(f => f.id === s)
            });
            return Boolean(l)
        };
        n.forEach(({
                projectId: s,
                origin: a
            }) => {
            if (t.projectPath[s])
                return;
            const c = a && r(a.spaceId) ? {
                spaceId: a.spaceId,
                spaceProviderId: a.providerId,
                itemId: a.ancestorItemIds?.at(0) ?? "root"
            }
             : Wd;
            e("setProjectPath", {
                projectId: s,
                value: c
            })
        });
        const o = n.map(s => s.projectId);
        Object.keys(t.projectPath).filter(s => !Mge.includes(s) && !o.includes(s)).forEach(s => {
            e("removeProjectPath", s)
        })
    }
}, $ge = {
    getWorkflowGroupContent: e => t => {
        const n = e.projectPath[t];
        return e.workflowGroupCache.has(n) ? e.workflowGroupCache.get(n) : null
    }
}, Age = () => ({
    spaceProviders: null,
    isLoadingProvider: !1,
    hasLoadedProviders: !1
}), Dge = {
    setIsLoadingProvider(e, t) {
        e.isLoadingProvider = t
    },
    setHasLoadedProviders(e, t) {
        e.hasLoadedProviders = t
    },
    updateSpaceProvider(e, {
        id: t,
        value: n
    }) {
        e.spaceProviders = {
            ...e.spaceProviders,
            [t]: {
                ...e.spaceProviders[t],
                ...n
            }
        }
    },
    setSpaceProviders(e, t) {
        e.spaceProviders = t
    }
}, Nge = {
    async loadLocalSpace({
        dispatch: e,
        commit: t
    }) {
        const r = {
            id: "local",
            name: "本地空间",
            connected: !0,
            connectionMode: "AUTOMATIC",
            local: !0,
            ...await e("fetchProviderSpaces", {
                id: Wd.spaceProviderId
            })
        };
        t("setSpaceProviders", {
            [Wd.spaceProviderId]: r
        })
    },
    refreshSpaceProviders({
        state: e,
        commit: t,
        dispatch: n
    }, {
        keepLocalSpace: r = !0
    } = {}) {
        if (e.isLoadingProvider)
            return;
        const o = e.spaceProviders[Wd.spaceProviderId],
        i = r ? {
            [Wd.spaceProviderId]: o
        }
         : null;
        t("setSpaceProviders", i),
        n("fetchAllSpaceProviders")
    },
    fetchAllSpaceProviders({
        commit: e,
        state: t
    }) {
        t.isLoadingProvider || (e("setIsLoadingProvider", !0), Oe.desktop.getSpaceProviders())
    },
    async setAllSpaceProviders({
        commit: e,
        dispatch: t
    }, n) {
        try {
            const r = Object.values(n).filter(({
                        connected: o,
                        connectionMode: i
                    }) => o || i === "AUTOMATIC").map(({
                        id: o
                    }) => o);
            for (const o of r) {
                const i = await t("fetchProviderSpaces", {
                    id: o
                });
                n[o] = {
                    ...n[o],
                    ...i
                }
            }
            e("setSpaceProviders", n),
            e("setHasLoadedProviders", !0)
        } catch (r) {
            throw e("setHasLoadedProviders", !1),
            consola.error("Error fetching providers", {
                error: r
            }),
            r
        } finally {
            e("setIsLoadingProvider", !1)
        }
    },
    async fetchProviderSpaces(e, {
        id: t
    }) {
        try {
            return await Oe.space.getSpaceProvider({
                spaceProviderId: t
            })
        } catch (n) {
            throw consola.error("Error fetching provider spaces", {
                error: n
            }),
            n
        }
    }
}, Rge = {
    getProviderInfo: e => t => {
        if (!e.projectPath.hasOwnProperty(t) || !e.spaceProviders)
            return {};
        const {
            spaceProviderId: n
        } = e.projectPath[t];
        return e.spaceProviders[n] || {}
    },
    activeProjectProvider: (e, t, n, r) => {
        if (r["application/isUnknownProject"])
            return null;
        const o = r["application/activeProjectOrigin"];
        return (e.spaceProviders ?? {})[o.providerId] ?? null
    },
    isLocalProvider: (e, t) => n => t.getProviderInfo(n).type === Cf.TypeEnum.LOCAL,
    isServerProvider: (e, t) => n => t.getProviderInfo(n).type === Cf.TypeEnum.SERVER,
    getSpaceInfo: (e, t) => n => {
        if (!e.projectPath.hasOwnProperty(n) || !e.spaceProviders)
            return {};
        const {
            spaceId: r
        } = e.projectPath[n];
        return t.getProviderInfo(n)?.spaces?.find(({
                id: s
            }) => s === r) ?? {}
    }
}, Y_ = {
    WorkflowGroup: "WorkflowGroup",
    Workflow: "Workflow",
    Component: "Component",
    Metanode: "WorkflowTemplate",
    Data: "Data"
}, Lge = () => ({
    isLoadingContent: !1,
    activeRenamedItemId: ""
}), Bge = {
    setIsLoadingContent(e, t) {
        e.isLoadingContent = t
    },
    setActiveRenamedItemId(e, t) {
        e.activeRenamedItemId = t
    }
}, Vge = {
    async fetchWorkflowGroupContentByIdTriplet({
        commit: e,
        dispatch: t
    }, {
        spaceId: n,
        spaceProviderId: r,
        itemId: o,
        retry: i = !0
    }) {
        try {
            return e("setIsLoadingContent", !0),
            await Oe.space.listWorkflowGroup({
                spaceProviderId: r,
                spaceId: n,
                itemId: o
            })
        } catch (s) {
            if (i)
                return await t("connectProvider", {
                    spaceProviderId: r
                }), await t("fetchWorkflowGroupContentByIdTriplet", {
                    spaceId: n,
                    spaceProviderId: r,
                    itemId: o,
                    retry: !1
                });
            throw consola.error("Error trying to fetch workflow group content", {
                error: s
            }),
            s
        } finally {
            e("setIsLoadingContent", !1)
        }
    },
    async fetchWorkflowGroupContent({
        commit: e,
        state: t,
        dispatch: n
    }, {
        projectId: r
    }) {
        const o = t.projectPath[r], {
            spaceId: i,
            spaceProviderId: s,
            itemId: a
        } = o,
        l = await n("fetchWorkflowGroupContentByIdTriplet", {
            spaceId: i,
            spaceProviderId: s,
            itemId: a
        });
        return e("setWorkflowGroupContent", {
            projectId: r,
            content: l
        }),
        l
    },
    async changeDirectory({
        dispatch: e,
        getters: t,
        commit: n,
        state: r
    }, {
        projectId: o,
        pathId: i
    }) {
        const s = t.pathToItemId(o, i), {
            spaceId: a,
            spaceProviderId: l
        } = r.projectPath[o],
        c = await e("fetchWorkflowGroupContentByIdTriplet", {
            spaceId: a,
            spaceProviderId: l,
            itemId: s
        });
        return n("updateProjectPath", {
            projectId: o,
            value: {
                itemId: s
            }
        }),
        n("setWorkflowGroupContent", {
            projectId: o,
            content: c
        }), {
            itemId: s
        }
    },
    async createWorkflow({
        state: e,
        dispatch: t
    }, {
        projectId: n,
        workflowName: r
    }) {
        const {
            spaceId: o,
            spaceProviderId: i,
            itemId: s
        } = e.projectPath[n];
        try {
            await t("application/updateGlobalLoader", {
                loading: !0,
                config: {
                    displayMode: "transparent"
                }
            }, {
                root: !0
            });
            const a = await Oe.space.createWorkflow({
                spaceProviderId: i,
                spaceId: o,
                itemId: s,
                itemName: r
            });
            return await t("application/updateGlobalLoader", {
                loading: !1
            }, {
                root: !0
            }),
            t("fetchWorkflowGroupContent", {
                projectId: n
            }),
            a
        } catch (a) {
            throw await t("application/updateGlobalLoader", {
                loading: !1
            }, {
                root: !0
            }),
            consola.log("Error creating workflow", {
                error: a
            }),
            a
        }
    },
    async createFolder({
        dispatch: e,
        state: t,
        commit: n
    }, {
        projectId: r
    }) {
        const {
            spaceId: o,
            spaceProviderId: i,
            itemId: s
        } = t.projectPath[r];
        try {
            n("setIsLoadingContent", !0);
            const a = await Oe.space.createWorkflowGroup({
                spaceId: o,
                spaceProviderId: i,
                itemId: s
            });
            return await e("fetchWorkflowGroupContent", {
                projectId: r
            }),
            n("setActiveRenamedItemId", a.id),
            a
        } catch (a) {
            throw n("setIsLoadingContent", !1),
            consola.log("Error creating folder", {
                error: a
            }),
            a
        }
    },
    async openWorkflow({
        rootState: e,
        state: t,
        dispatch: n,
        getters: r
    }, {
        workflowItemId: o,
        $router: i,
        projectId: s
    }) {
        const {
            spaceId: a,
            spaceProviderId: l
        } = t.projectPath[s], {
            openProjects: c
        } = e.application,
        u = c.find(f => r.isWorkflowProjectInProjectPath(f, s) && f?.origin?.itemId === o);
        if (u) {
            i.push({
                name: zo.WorkflowPage,
                params: {
                    workflowId: "root",
                    projectId: u.projectId
                }
            });
            return
        }
        await n("application/updateGlobalLoader", {
            loading: !0,
            config: {
                displayMode: "transparent"
            }
        }, {
            root: !0
        }),
        await Oe.desktop.openWorkflow({
            spaceProviderId: l,
            spaceId: a,
            itemId: o
        }),
        await n("application/updateGlobalLoader", {
            loading: !1
        }, {
            root: !0
        })
    },
    async importToWorkflowGroup({
        state: e,
        dispatch: t
    }, {
        projectId: n,
        importType: r
    }) {
        const {
            spaceId: o,
            spaceProviderId: i,
            itemId: s
        } = e.projectPath[n];
        (r === "FILES" ? await Oe.desktop.importFiles({
                spaceProviderId: i,
                spaceId: o,
                itemId: s
            }) : await Oe.desktop.importWorkflows({
                spaceProviderId: i,
                spaceId: o,
                itemId: s
            })) && await t("fetchWorkflowGroupContent", {
            projectId: n
        })
    },
    async exportSpaceItem({
        state: e,
        dispatch: t
    }, {
        projectId: n,
        itemId: r
    }) {
        const {
            spaceId: o,
            spaceProviderId: i
        } = e.projectPath[n];
        await Oe.desktop.exportSpaceItem({
            spaceProviderId: i,
            spaceId: o,
            itemId: r
        }) && await t("fetchWorkflowGroupContent", {
            projectId: n
        })
    },
    async renameItem({
        state: e,
        dispatch: t,
        commit: n
    }, {
        projectId: r,
        itemId: o,
        newName: i
    }) {
        const {
            spaceId: s,
            spaceProviderId: a
        } = e.projectPath[r];
        try {
            n("setIsLoadingContent", !0),
            await Oe.space.renameItem({
                spaceProviderId: a,
                spaceId: s,
                itemId: o,
                itemName: i
            }),
            await t("fetchWorkflowGroupContent", {
                projectId: r
            })
        } catch (l) {
            throw n("setIsLoadingContent", !1),
            consola.log("Error renaming item", {
                error: l
            }),
            l
        }
    },
    async deleteItems({
        dispatch: e,
        commit: t,
        state: n,
        rootState: r,
        getters: o
    }, {
        projectId: i,
        itemIds: s,
        $router: a
    }) {
        try {
            const {
                spaceId: l,
                spaceProviderId: c
            } = n.projectPath[i], {
                openProjects: u
            } = r.application,
            f = u.filter(y => o.isWorkflowProjectInProjectPath(y, i) && s.includes(y?.origin?.itemId)).map(({
                        projectId: y
                    }) => y),
            p = f.length > 0,
            m = p ? await e("application/forceCloseProjects", {
                projectIds: f
            }, {
                root: !0
            }) : null,
            v = p ? f.includes(i) : !1;
            t("setIsLoadingContent", !0),
            t("setActiveRenamedItemId", ""),
            await Oe.space.deleteItems({
                spaceProviderId: c,
                spaceId: l,
                itemIds: s
            }),
            await e("fetchWorkflowGroupContent", {
                projectId: v ? m ?? wm : i
            }),
            m && await a.push({
                name: zo.WorkflowPage,
                params: {
                    projectId: m,
                    workflowId: "root"
                }
            })
        } catch (l) {
            throw t("setIsLoadingContent", !1),
            consola.log("Error deleting item", {
                error: l
            }),
            l
        }
    },
    async moveOrCopyItems({
        state: e,
        dispatch: t,
        commit: n
    }, {
        projectId: r,
        itemIds: o,
        destWorkflowGroupItemId: i,
        collisionStrategy: s,
        isCopy: a
    }) {
        const {
            spaceId: l,
            spaceProviderId: c
        } = e.projectPath[r];
        try {
            n("setIsLoadingContent", !0),
            await Oe.space.moveOrCopyItems({
                spaceProviderId: c,
                spaceId: l,
                itemIds: o,
                destWorkflowGroupItemId: i,
                collisionHandling: s,
                copy: a
            }),
            await t("fetchWorkflowGroupContent", {
                projectId: r
            })
        } catch (u) {
            const f = a ? "copying" : "moving";
            throw consola.log(`Error ${f} items`, {
                error: u
            }),
            u
        } finally {
            n("setIsLoadingContent", !1)
        }
    },
    openPermissionsDialog({
        state: e
    }, {
        projectId: t,
        itemId: n
    }) {
        const {
            spaceId: r,
            spaceProviderId: o
        } = e.projectPath[t];
        Oe.desktop.openPermissionsDialog({
            spaceProviderId: o,
            spaceId: r,
            itemId: n
        })
    }
}, Fge = {
    pathToItemId: (e, t) => (n, r) => r === ".." ? t.parentWorkflowGroupId(n) : r === "." ? t.currentWorkflowGroupId(n) : r,
    isWorkflowProjectInProjectPath: (e, t) => (n, r) => {
        if (!e.projectPath.hasOwnProperty(r))
            return !1;
        const {
            spaceProviderId: o,
            spaceId: i
        } = e.projectPath[r];
        return n.origin ? n.origin.providerId === o && n.origin.spaceId === i && t.isLocalProvider(r) : !1
    },
    parentWorkflowGroupId: (e, t) => n => {
        const r = t.getWorkflowGroupContent(n);
        if (r === null)
            return null;
        const {
            path: o
        } = r;
        return o.length === 0 ? null : o.length === 1 ? "root" : o[o.length - 2].id
    },
    currentWorkflowGroupId: (e, t) => n => {
        const r = t.getWorkflowGroupContent(n);
        if (r === null)
            return null;
        const {
            path: o
        } = r;
        return o.length > 0 ? o[o.length - 1].id : "root"
    },
    getOpenedWorkflowItems: (e, t, {
        application: n
    }) => r => {
        const {
            openProjects: o
        } = n,
        i = t.getWorkflowGroupContent(r);
        if (i === null)
            return [];
        const s = i.items.filter(a => [Y_.Workflow, Y_.Component].includes(a.type)).map(a => a.id);
        return o.filter(a => t.isWorkflowProjectInProjectPath(a, r) && s.includes(a?.origin?.itemId)).map(({
                origin: a
            }) => a.itemId)
    },
    getOpenedFolderItems: (e, t, {
        application: n
    }) => r => {
        const {
            openProjects: o
        } = n,
        i = t.getWorkflowGroupContent(r);
        if (i === null)
            return [];
        const s = o.filter(a => t.isWorkflowProjectInProjectPath(a, r)).flatMap(({
                    origin: a
                }) => a.ancestorItemIds ?? []);
        return i.items.filter(a => a.type === Y_.WorkflowGroup && s.includes(a.id)).map(a => a.id)
    },
    selectionContainsFile: (e, t) => (n, r) => {
        const o = t.getWorkflowGroupContent(n);
        return o ? o.items.filter(i => r.includes(i.id)).some(i => i.type === W0.TypeEnum.Data) : !1
    },
    selectionContainsWorkflow: (e, t) => (n, r) => {
        const o = t.getWorkflowGroupContent(n);
        return o ? o.items.filter(i => r.includes(i.id)).some(i => i.type === W0.TypeEnum.Workflow) : !1
    }
}, jge = () => ({
    jobs: [],
    schedules: []
}), Wge = {
    setJobs(e, t) {
        e.jobs = t
    },
    setSchedules(e, t) {
        e.schedules = t
    }
}, zge = {
    async fetchJobs({
        state: e,
        commit: t
    }, {
        projectId: n,
        itemId: r
    }) {
        const {
            spaceId: o,
            spaceProviderId: i
        } = e.projectPath[n],
        s = await Oe.space.listJobsForWorkflow({
            spaceId: o,
            spaceProviderId: i,
            itemId: r
        });
        t("setJobs", s)
    },
    async fetchSchedules({
        state: e,
        commit: t
    }, {
        projectId: n,
        itemId: r
    }) {
        const {
            spaceId: o,
            spaceProviderId: i
        } = e.projectPath[n],
        s = await Oe.space.listSchedulesForWorkflow({
            spaceId: o,
            spaceProviderId: i,
            itemId: r
        });
        t("setSchedules", s)
    },
    displayDeployments({
        commit: e,
        dispatch: t
    }, {
        projectId: n,
        itemId: r,
        itemName: o
    }) {
        t("fetchJobs", {
            projectId: n,
            itemId: r
        }),
        t("fetchSchedules", {
            projectId: n,
            itemId: r
        }),
        e("setDeploymentsModalConfig", {
            isOpen: !0,
            name: o,
            projectId: n,
            itemId: r
        })
    },
    async deleteJob({
        state: e,
        dispatch: t
    }, {
        jobId: n,
        schedulerId: r
    }) {
        const o = e.deploymentsModalConfig.projectId, {
            spaceId: i,
            spaceProviderId: s
        } = e.projectPath[o],
        a = e.deploymentsModalConfig.itemId;
        await Oe.space.deleteJobsForWorkflow({
            spaceId: i,
            spaceProviderId: s,
            itemId: a,
            jobId: n
        }),
        await t("fetchJobs", {
            projectId: o,
            itemId: a
        }),
        r && await t("fetchSchedules", {
            projectId: o,
            itemId: a
        })
    },
    async saveJobAsWorkflow({
        state: e,
        dispatch: t,
        commit: n
    }, {
        jobId: r,
        jobName: o
    }) {
        const i = e.deploymentsModalConfig.projectId, {
            spaceId: s,
            spaceProviderId: a
        } = e.projectPath[i],
        l = e.deploymentsModalConfig.itemId;
        await Oe.desktop.saveJobAsWorkflow({
            spaceProviderId: a,
            spaceId: s,
            itemId: l,
            jobId: r,
            jobName: o
        }) && (await t("fetchWorkflowGroupContent", {
                projectId: i
            }), n("setDeploymentsModalConfig", {
                isOpen: !1,
                name: null,
                projectId: null,
                itemId: null
            }))
    },
    async editSchedule({
        state: e,
        dispatch: t
    }, {
        scheduleId: n
    }) {
        const r = e.deploymentsModalConfig.projectId, {
            spaceId: o,
            spaceProviderId: i
        } = e.projectPath[r],
        s = e.deploymentsModalConfig.itemId;
        await Oe.desktop.editSchedule({
            spaceProviderId: i,
            spaceId: o,
            itemId: s,
            scheduleId: n
        }) && await t("fetchSchedules", {
            projectId: r,
            itemId: s
        })
    },
    async deleteSchedule({
        state: e,
        dispatch: t
    }, {
        scheduleId: n
    }) {
        const r = e.deploymentsModalConfig.projectId, {
            spaceId: o,
            spaceProviderId: i
        } = e.projectPath[r],
        s = e.deploymentsModalConfig.itemId;
        await Oe.space.deleteSchedulesForWorkflow({
            spaceId: o,
            spaceProviderId: i,
            itemId: s,
            scheduleId: n
        }),
        await t("fetchSchedules", {
            projectId: r,
            itemId: s
        })
    },
    executeWorkflow({
        state: e
    }, {
        projectId: t,
        itemId: n
    }) {
        const {
            spaceId: r,
            spaceProviderId: o
        } = e.projectPath[t];
        Oe.desktop.executeWorkflow({
            spaceId: r,
            spaceProviderId: o,
            itemId: n
        })
    }
}, Hge = () => ({
    ...Sge(),
    ...Pge(),
    ...Age(),
    ...Lge(),
    ...jge(),
    createWorkflowModalConfig: {
        isOpen: !1,
        projectId: null
    },
    deploymentsModalConfig: {
        isOpen: !1,
        name: null,
        projectId: null,
        itemId: null
    }
}), Uge = {
    ...Cge,
    ...Ege,
    ...Dge,
    ...Bge,
    ...Wge,
    setCreateWorkflowModalConfig(e, t) {
        e.createWorkflowModalConfig = t
    },
    setDeploymentsModalConfig(e, t) {
        e.deploymentsModalConfig = t
    }
}, qge = {
    ...Ige,
    ...Oge,
    ...Nge,
    ...Vge,
    ...zge,
    copyBetweenSpaces({
        state: e
    }, {
        projectId: t,
        itemIds: n
    }) {
        const {
            spaceId: r,
            spaceProviderId: o
        } = e.projectPath[t];
        Oe.desktop.copyBetweenSpaces({
            spaceProviderId: o,
            spaceId: r,
            itemIds: n
        })
    },
    async moveOrCopyToSpace({
        state: e,
        dispatch: t
    }, {
        projectId: n,
        isCopy: r,
        itemIds: o
    }) {
        const {
            spaceId: i,
            spaceProviderId: s
        } = e.projectPath[n];
        await Oe.desktop.moveOrCopyToSpace({
            spaceProviderId: s,
            spaceId: i,
            isCopy: r,
            itemIds: o
        }) && await t("fetchWorkflowGroupContent", {
            projectId: n
        })
    },
    openInBrowser({
        state: e
    }, {
        projectId: t,
        itemId: n
    }) {
        const {
            spaceId: r,
            spaceProviderId: o
        } = e.projectPath[t];
        Oe.desktop.openInBrowser({
            spaceProviderId: o,
            spaceId: r,
            itemId: n
        })
    },
    openAPIDefinition({
        state: e
    }, {
        projectId: t,
        itemId: n
    }) {
        const {
            spaceId: r,
            spaceProviderId: o
        } = e.projectPath[t];
        Oe.desktop.openAPIDefinition({
            spaceProviderId: o,
            spaceId: r,
            itemId: n
        })
    }
}, Yge = {
    ...Tge,
    ...$ge,
    ...Rge,
    ...Fge
}, Kge = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: qge,
            cachedLocalSpaceProjectId: bm,
            getters: Yge,
            globalSpaceBrowserProjectId: wm,
            mutations: Uge,
            state: Hge
        }, Symbol.toStringTag, {
            value: "Module"
        })), Gge = 12, Xge = () => ({
    ...kB(),
    recommendedNodes: null
}), Jge = {
    ...xB,
    setRecommendedNodes(e, t) {
        e.recommendedNodes = t
    }
}, Zge = {
    ...SB,
    async getNodeRecommendations({
        commit: e,
        rootState: t
    }, {
        nodeId: n,
        portIdx: r,
        nodesLimit: o = Gge
    }) {
        const {
            projectId: i,
            info: {
                containerId: s
            }
        } = t.workflow.activeWorkflow, {
            availablePortTypes: a
        } = t.application,
        l = await Oe.noderepository.getNodeRecommendations({
            workflowId: s,
            projectId: i,
            nodeId: n,
            portIdx: r,
            nodesLimit: o,
            fullTemplateInfo: !0
        });
        e("setRecommendedNodes", l.map(oI(a)))
    },
    async clearRecommendedNodesAndSearchParams({
        commit: e,
        dispatch: t
    }) {
        e("setRecommendedNodes", null),
        await t("clearSearchParams")
    }
}, Qge = {
    ...CB,
    getFirstResult: (e, t) => () => t.searchIsActive ? t.getFirstSearchResult() : e.recommendedNodes?.length > 0 ? e.recommendedNodes[0] : null
}, eve = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: Zge,
            getters: Qge,
            mutations: Jge,
            state: Xge
        }, Symbol.toStringTag, {
            value: "Module"
        })), tve = () => ({
    hubID: null,
    qa: {
        conversationId: null,
        messages: [],
        statusUpdate: null,
        isProcessing: !1,
        incomingTokens: "",
        projectAndWorkflowIds: null
    },
    build: {
        conversationId: null,
        messages: [],
        statusUpdate: null,
        isProcessing: !1,
        incomingTokens: "",
        projectAndWorkflowIds: null
    }
}), nve = {
    setHubID(e, t) {
        e.hubID = t
    },
    pushMessage(e, {
        chainType: t,
        role: n,
        content: r,
        nodes: o,
        references: i,
        isError: s = !1
    }) {
        e[t].messages.push({
            role: n,
            content: r,
            nodes: o,
            references: i,
            isError: s
        })
    },
    popUserQuery(e, {
        chainType: t
    }) {
        const n = e[t].messages;
        n.at(-1)?.role === "user" && n.pop()
    },
    setStatusUpdate(e, {
        chainType: t,
        statusUpdate: n
    }) {
        e[t].statusUpdate = n
    },
    setIsProcessing(e, {
        chainType: t,
        isProcessing: n
    }) {
        e[t].isProcessing = n
    },
    addToken(e, {
        chainType: t,
        token: n
    }) {
        e[t].incomingTokens += n
    },
    setProjectAndWorkflowIds(e, {
        chainType: t,
        projectAndWorkflowIds: n
    }) {
        e[t].projectAndWorkflowIds = n
    },
    clearChain(e, {
        chainType: t
    }) {
        e[t].isProcessing = !1,
        e[t].incomingTokens = "",
        e[t].statusUpdate = !1,
        e[t].projectAndWorkflowIds = null
    },
    setConversationId(e, {
        chainType: t,
        conversationId: n
    }) {
        e[t].conversationId = n
    }
}, rve = {
    async getHubID({
        commit: e
    }) {
        e("setHubID", await Oe.desktop.getHubID())
    },
    async makeAiRequest({
        commit: e,
        state: t,
        rootGetters: n
    }, {
        chainType: r,
        message: o
    }) {
        const i = n["workflow/projectAndWorkflowIds"],
        s = n["selection/selectedNodeIds"];
        e("setIsProcessing", {
            chainType: r,
            isProcessing: !0
        }),
        e("setProjectAndWorkflowIds", {
            chainType: r,
            projectAndWorkflowIds: i
        }),
        e("pushMessage", {
            chainType: r,
            role: "user",
            content: o
        });
        const a = t[r].messages.map(({
                    role: f,
                    content: p
                }) => ({
                    role: f,
                    content: p
                })),
        l = t[r].conversationId, {
            projectId: c,
            workflowId: u
        } = i;
        try {
            await Oe.desktop.makeAiRequest({
                conversationId: l,
                chainType: r,
                projectId: c,
                workflowId: u,
                selectedNodes: s,
                messages: a
            })
        } catch (f) {
            consola.error("makeAiRequest", f),
            e("clearChain", {
                chainType: r
            }),
            e("pushMessage", {
                chainType: r,
                role: "assistant",
                content: "Sorry, something went wrong. Please try again later!",
                isError: !0
            })
        }
    },
    handleAiAssistantEvent({
        commit: e
    }, {
        chainType: t,
        data: {
            type: n,
            payload: r,
            conversation_id: o
        }
    }) {
        switch (n) {
        case "token":
            e("addToken", {
                chainType: t,
                token: r
            });
            break;
        case "result":
            e("clearChain", {
                chainType: t
            }),
            e("setConversationId", {
                chainType: t,
                conversationId: o
            }),
            r.message && e("pushMessage", {
                chainType: t,
                role: "assistant",
                content: r.message,
                nodes: r.nodes,
                references: r.references
            });
            break;
        case "error":
            e("clearChain", {
                chainType: t
            }),
            e("setConversationId", {
                chainType: t,
                conversationId: o
            }),
            e("pushMessage", {
                chainType: t,
                role: "assistant",
                content: r.message,
                isError: !0
            });
            break;
        case "status_update":
            e("setStatusUpdate", {
                chainType: t,
                statusUpdate: r.message
            });
            break
        }
    },
    async abortAiRequest({
        state: e,
        commit: t
    }, {
        chainType: n
    }) {
        const r = e[n].conversationId;
        try {
            await Oe.desktop.abortAiRequest({
                conversationId: r,
                chainType: n
            })
        } catch (o) {
            consola.error("abortAiRequest", o),
            t("clearChain", {
                chainType: n
            })
        }
        t("popUserQuery", {
            chainType: n
        })
    }
}, ove = {}, ive = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: rve,
            getters: ove,
            mutations: nve,
            state: tve
        }, Symbol.toStringTag, {
            value: "Module"
        })), d$ = "knime-ui-settings", sve = (e, t = null) => {
    const n = window?.localStorage?.getItem(e);
    return n === null ? t : JSON.parse(n)
}, ave = (e, t) => {
    window?.localStorage?.setItem(e, JSON.stringify(t))
}, lve = () => ({
    settings: {
        nodeRepositoryDisplayMode: "icon",
        nodeOutputSize: 40
    }
}), cve = {
    updateAllSettings(e, t) {
        e.settings = t
    }
}, uve = {
    fetchSettings({
        commit: e
    }) {
        const t = sve(d$);
        t !== null && e("updateAllSettings", t)
    },
    updateSetting({
        state: e,
        commit: t
    }, n) {
        t("updateAllSettings", {
            ...e.settings,
            [n.key]: n.value
        }),
        ave(d$, e.settings)
    }
}, dve = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: uve,
            mutations: cve,
            state: lve
        }, Symbol.toStringTag, {
            value: "Module"
        })), fve = () => yQ({
    modules: {
        application: {
            namespaced: !0,
            ...mpe
        },
        canvas: {
            namespaced: !0,
            ..._pe
        },
        nodeRepository: {
            namespaced: !0,
            ...Ppe
        },
        panel: {
            namespaced: !0,
            ...Ape
        },
        selection: {
            namespaced: !0,
            ...Vpe
        },
        workflow: {
            namespaced: !0,
            ...yge
        },
        spaces: {
            namespaced: !0,
            ...Kge
        },
        quickAddNodes: {
            namespaced: !0,
            ...eve
        },
        settings: {
            namespaced: !0,
            ...dve
        },
        aiAssistant: {
            namespaced: !0,
            ...ive
        },
        api: {
            namespaced: !0,
            ...xge
        }
    }
});
/*!
 * vue-router v4.1.6
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */
const Ad = typeof window < "u";
function hve(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const kn = Object.assign;
function K_(e, t) {
    const n = {};
    for (const r in t) {
        const o = t[r];
        n[r] = Os(o) ? o.map(e) : e(o)
    }
    return n
}
const Ap = () => {}, Os = Array.isArray, pve = /\/$/, mve = e => e.replace(pve, "");
function G_(e, t, n = "/") {
    let r,
    o = {},
    i = "",
    s = "";
    const a = t.indexOf("#");
    let l = t.indexOf("?");
    return a < l && a >= 0 && (l = -1),
    l > -1 && (r = t.slice(0, l), i = t.slice(l + 1, a > -1 ? a : t.length), o = e(i)),
    a > -1 && (r = r || t.slice(0, a), s = t.slice(a, t.length)),
    r = wve(r ?? t, n), {
        fullPath: r + (i && "?") + i + s,
        path: r,
        query: o,
        hash: s
    }
}
function gve(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}
function f$(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function vve(e, t, n) {
    const r = t.matched.length - 1,
    o = n.matched.length - 1;
    return r > -1 && r === o && If(t.matched[r], n.matched[o]) && l7(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}
function If(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function l7(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (!yve(e[n], t[n]))
            return !1;
    return !0
}
function yve(e, t) {
    return Os(e) ? h$(e, t) : Os(t) ? h$(t, e) : e === t
}
function h$(e, t) {
    return Os(t) ? e.length === t.length && e.every((n, r) => n === t[r]) : e.length === 1 && e[0] === t
}
function wve(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const n = t.split("/"),
    r = e.split("/");
    let o = n.length - 1,
    i,
    s;
    for (i = 0; i < r.length; i++)
        if (s = r[i], s !== ".")
            if (s === "..")
                o > 1 && o--;
            else
                break;
    return n.slice(0, o).join("/") + "/" + r.slice(i - (i === r.length ? 1 : 0)).join("/")
}
var _m;
(function (e) {
    e.pop = "pop",
    e.push = "push"
})(_m || (_m = {}));
var Dp;
(function (e) {
    e.back = "back",
    e.forward = "forward",
    e.unknown = ""
})(Dp || (Dp = {}));
function bve(e) {
    if (!e)
        if (Ad) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/",
            e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
    mve(e)
}
const _ve = /^[^#]+#/;
function kve(e, t) {
    return e.replace(_ve, "#") + t
}
function xve(e, t) {
    const n = document.documentElement.getBoundingClientRect(),
    r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const Sw = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});
function Sve(e) {
    let t;
    if ("el" in e) {
        const n = e.el,
        r = typeof n == "string" && n.startsWith("#"),
        o = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!o)
            return;
        t = xve(o, e)
    } else
        t = e;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset)
}
function p$(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const px = new Map;
function Cve(e, t) {
    px.set(e, t)
}
function Ive(e) {
    const t = px.get(e);
    return px.delete(e),
    t
}
let Tve = () => location.protocol + "//" + location.host;
function c7(e, t) {
    const {
        pathname: n,
        search: r,
        hash: o
    } = t,
    i = e.indexOf("#");
    if (i > -1) {
        let a = o.includes(e.slice(i)) ? e.slice(i).length : 1,
        l = o.slice(a);
        return l[0] !== "/" && (l = "/" + l),
        f$(l, "")
    }
    return f$(n, e) + r + o
}
function Mve(e, t, n, r) {
    let o = [],
    i = [],
    s = null;
    const a = ({
        state: p
    }) => {
        const m = c7(e, location),
        v = n.value,
        y = t.value;
        let b = 0;
        if (p) {
            if (n.value = m, t.value = p, s && s === v) {
                s = null;
                return
            }
            b = y ? p.position - y.position : 0
        } else
            r(m);
        o.forEach(w => {
            w(n.value, v, {
                delta: b,
                type: _m.pop,
                direction: b ? b > 0 ? Dp.forward : Dp.back : Dp.unknown
            })
        })
    };
    function l() {
        s = n.value
    }
    function c(p) {
        o.push(p);
        const m = () => {
            const v = o.indexOf(p);
            v > -1 && o.splice(v, 1)
        };
        return i.push(m),
        m
    }
    function u() {
        const {
            history: p
        } = window;
        p.state && p.replaceState(kn({}, p.state, {
                scroll: Sw()
            }), "")
    }
    function f() {
        for (const p of i)
            p();
        i = [],
        window.removeEventListener("popstate", a),
        window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", u), {
        pauseListeners: l,
        listen: c,
        destroy: f
    }
}
function m$(e, t, n, r = !1, o = !1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: o ? Sw() : null
    }
}
function Pve(e) {
    const {
        history: t,
        location: n
    } = window,
    r = {
        value: c7(e, n)
    },
    o = {
        value: t.state
    };
    o.value || i(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function i(l, c, u) {
        const f = e.indexOf("#"),
        p = f > -1 ? (n.host && document.querySelector("base") ? e : e.slice(f)) + l : Tve() + e + l;
        try {
            t[u ? "replaceState" : "pushState"](c, "", p),
            o.value = c
        } catch (m) {
            console.error(m),
            n[u ? "replace" : "assign"](p)
        }
    }
    function s(l, c) {
        const u = kn({}, t.state, m$(o.value.back, l, o.value.forward, !0), c, {
            position: o.value.position
        });
        i(l, u, !0),
        r.value = l
    }
    function a(l, c) {
        const u = kn({}, o.value, t.state, {
            forward: l,
            scroll: Sw()
        });
        i(u.current, u, !0);
        const f = kn({}, m$(r.value, l, null), {
            position: u.position + 1
        }, c);
        i(l, f, !1),
        r.value = l
    }
    return {
        location: r,
        state: o,
        push: a,
        replace: s
    }
}
function Eve(e) {
    e = bve(e);
    const t = Pve(e),
    n = Mve(e, t.state, t.location, t.replace);
    function r(i, s = !0) {
        s || n.pauseListeners(),
        history.go(i)
    }
    const o = kn({
        location: "",
        base: e,
        go: r,
        createHref: kve.bind(null, e)
    }, t, n);
    return Object.defineProperty(o, "location", {
        enumerable: !0,
        get: () => t.location.value
    }),
    Object.defineProperty(o, "state", {
        enumerable: !0,
        get: () => t.state.value
    }),
    o
}
function Ove(e) {
    return typeof e == "string" || e && typeof e == "object"
}
function u7(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const kl = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
}, d7 = Symbol("");
var g$;
(function (e) {
    e[e.aborted = 4] = "aborted",
    e[e.cancelled = 8] = "cancelled",
    e[e.duplicated = 16] = "duplicated"
})(g$ || (g$ = {}));
function Tf(e, t) {
    return kn(new Error, {
        type: e,
        [d7]: !0
    }, t)
}
function Aa(e, t) {
    return e instanceof Error && d7 in e && (t == null || !!(e.type & t))
}
const v$ = "[^/]+?", $ve = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}, Ave = /[.+*?^${}()[\]/\\]/g;
function Dve(e, t) {
    const n = kn({}, $ve, t),
    r = [];
    let o = n.start ? "^" : "";
    const i = [];
    for (const c of e) {
        const u = c.length ? [] : [90];
        n.strict && !c.length && (o += "/");
        for (let f = 0; f < c.length; f++) {
            const p = c[f];
            let m = 40 + (n.sensitive ? .25 : 0);
            if (p.type === 0)
                f || (o += "/"), o += p.value.replace(Ave, "\\$&"), m += 40;
            else if (p.type === 1) {
                const {
                    value: v,
                    repeatable: y,
                    optional: b,
                    regexp: w
                } = p;
                i.push({
                    name: v,
                    repeatable: y,
                    optional: b
                });
                const k = w || v$;
                if (k !== v$) {
                    m += 10;
                    try {
                        new RegExp(`(${k})`)
                    } catch (x) {
                        throw new Error(`Invalid custom RegExp for param "${v}" (${k}): ` + x.message)
                    }
                }
                let C = y ? `((?:${k})(?:/(?:${k}))*)` : `(${k})`;
                f || (C = b && c.length < 2 ? `(?:/${C})` : "/" + C),
                b && (C += "?"),
                o += C,
                m += 20,
                b && (m += -8),
                y && (m += -20),
                k === ".*" && (m += -50)
            }
            u.push(m)
        }
        r.push(u)
    }
    if (n.strict && n.end) {
        const c = r.length - 1;
        r[c][r[c].length - 1] += .7000000000000001
    }
    n.strict || (o += "/?"),
    n.end ? o += "$" : n.strict && (o += "(?:/|$)");
    const s = new RegExp(o, n.sensitive ? "" : "i");
    function a(c) {
        const u = c.match(s),
        f = {};
        if (!u)
            return null;
        for (let p = 1; p < u.length; p++) {
            const m = u[p] || "",
            v = i[p - 1];
            f[v.name] = m && v.repeatable ? m.split("/") : m
        }
        return f
    }
    function l(c) {
        let u = "",
        f = !1;
        for (const p of e) {
            (!f || !u.endsWith("/")) && (u += "/"),
            f = !1;
            for (const m of p)
                if (m.type === 0)
                    u += m.value;
                else if (m.type === 1) {
                    const {
                        value: v,
                        repeatable: y,
                        optional: b
                    } = m,
                    w = v in c ? c[v] : "";
                    if (Os(w) && !y)
                        throw new Error(`Provided param "${v}" is an array but it is not repeatable (* or + modifiers)`);
                    const k = Os(w) ? w.join("/") : w;
                    if (!k)
                        if (b)
                            p.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : f = !0);
                        else
                            throw new Error(`Missing required param "${v}"`);
                    u += k
                }
        }
        return u || "/"
    }
    return {
        re: s,
        score: r,
        keys: i,
        parse: a,
        stringify: l
    }
}
function Nve(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
        const r = t[n] - e[n];
        if (r)
            return r;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 40 + 40 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0
}
function Rve(e, t) {
    let n = 0;
    const r = e.score,
    o = t.score;
    for (; n < r.length && n < o.length; ) {
        const i = Nve(r[n], o[n]);
        if (i)
            return i;
        n++
    }
    if (Math.abs(o.length - r.length) === 1) {
        if (y$(r))
            return 1;
        if (y$(o))
            return -1
    }
    return o.length - r.length
}
function y$(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const Lve = {
    type: 0,
    value: ""
}, Bve = /[a-zA-Z0-9_]/;
function Vve(e) {
    if (!e)
        return [[]];
    if (e === "/")
        return [[Lve]];
    if (!e.startsWith("/"))
        throw new Error(`Invalid path "${e}"`);
    function t(m) {
        throw new Error(`ERR (${n})/"${c}": ${m}`)
    }
    let n = 0,
    r = n;
    const o = [];
    let i;
    function s() {
        i && o.push(i),
        i = []
    }
    let a = 0,
    l,
    c = "",
    u = "";
    function f() {
        c && (n === 0 ? i.push({
                type: 0,
                value: c
            }) : n === 1 || n === 2 || n === 3 ? (i.length > 1 && (l === "*" || l === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), i.push({
                    type: 1,
                    value: c,
                    regexp: u,
                    repeatable: l === "*" || l === "+",
                    optional: l === "*" || l === "?"
                })) : t("Invalid state to consume buffer"), c = "")
    }
    function p() {
        c += l
    }
    for (; a < e.length; ) {
        if (l = e[a++], l === "\\" && n !== 2) {
            r = n,
            n = 4;
            continue
        }
        switch (n) {
        case 0:
            l === "/" ? (c && f(), s()) : l === ":" ? (f(), n = 1) : p();
            break;
        case 4:
            p(),
            n = r;
            break;
        case 1:
            l === "(" ? n = 2 : Bve.test(l) ? p() : (f(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--);
            break;
        case 2:
            l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : n = 3 : u += l;
            break;
        case 3:
            f(),
            n = 0,
            l !== "*" && l !== "?" && l !== "+" && a--,
            u = "";
            break;
        default:
            t("Unknown state");
            break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${c}"`),
    f(),
    s(),
    o
}
function Fve(e, t, n) {
    const r = Dve(Vve(e.path), n),
    o = kn(r, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o),
    o
}
function jve(e, t) {
    const n = [],
    r = new Map;
    t = _$({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function o(u) {
        return r.get(u)
    }
    function i(u, f, p) {
        const m = !p,
        v = Wve(u);
        v.aliasOf = p && p.record;
        const y = _$(t, u),
        b = [v];
        if ("alias" in u) {
            const C = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const x of C)
                b.push(kn({}, v, {
                        components: p ? p.record.components : v.components,
                        path: x,
                        aliasOf: p ? p.record : v
                    }))
        }
        let w,
        k;
        for (const C of b) {
            const {
                path: x
            } = C;
            if (f && x[0] !== "/") {
                const S = f.record.path,
                T = S[S.length - 1] === "/" ? "" : "/";
                C.path = f.record.path + (x && T + x)
            }
            if (w = Fve(C, f, y), p ? p.alias.push(w) : (k = k || w, k !== w && k.alias.push(w), m && u.name && !b$(w) && s(u.name)), v.children) {
                const S = v.children;
                for (let T = 0; T < S.length; T++)
                    i(S[T], w, p && p.children[T])
            }
            p = p || w,
            (w.record.components && Object.keys(w.record.components).length || w.record.name || w.record.redirect) && l(w)
        }
        return k ? () => {
            s(k)
        }
         : Ap
    }
    function s(u) {
        if (u7(u)) {
            const f = r.get(u);
            f && (r.delete(u), n.splice(n.indexOf(f), 1), f.children.forEach(s), f.alias.forEach(s))
        } else {
            const f = n.indexOf(u);
            f > -1 && (n.splice(f, 1), u.record.name && r.delete(u.record.name), u.children.forEach(s), u.alias.forEach(s))
        }
    }
    function a() {
        return n
    }
    function l(u) {
        let f = 0;
        for (; f < n.length && Rve(u, n[f]) >= 0 && (u.record.path !== n[f].record.path || !f7(u, n[f])); )
            f++;
        n.splice(f, 0, u),
        u.record.name && !b$(u) && r.set(u.record.name, u)
    }
    function c(u, f) {
        let p,
        m = {},
        v,
        y;
        if ("name" in u && u.name) {
            if (p = r.get(u.name), !p)
                throw Tf(1, {
                    location: u
                });
            y = p.record.name,
            m = kn(w$(f.params, p.keys.filter(k => !k.optional).map(k => k.name)), u.params && w$(u.params, p.keys.map(k => k.name))),
            v = p.stringify(m)
        } else if ("path" in u)
            v = u.path, p = n.find(k => k.re.test(v)), p && (m = p.parse(v), y = p.record.name);
        else {
            if (p = f.name ? r.get(f.name) : n.find(k => k.re.test(f.path)), !p)
                throw Tf(1, {
                    location: u,
                    currentLocation: f
                });
            y = p.record.name,
            m = kn({}, f.params, u.params),
            v = p.stringify(m)
        }
        const b = [];
        let w = p;
        for (; w; )
            b.unshift(w.record), w = w.parent;
        return {
            name: y,
            path: v,
            params: m,
            matched: b,
            meta: Hve(b)
        }
    }
    return e.forEach(u => i(u)), {
        addRoute: i,
        resolve: c,
        removeRoute: s,
        getRoutes: a,
        getRecordMatcher: o
    }
}
function w$(e, t) {
    const n = {};
    for (const r of t)
        r in e && (n[r] = e[r]);
    return n
}
function Wve(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: zve(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in e ? e.components || null : e.component && {
        default:
            e.component
        }
    }
}
function zve(e) {
    const t = {},
    n = e.props || !1;
    if ("component" in e)
        t.default = n;
    else
        for (const r in e.components)
            t[r] = typeof n == "boolean" ? n : n[r];
    return t
}
function b$(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function Hve(e) {
    return e.reduce((t, n) => kn(t, n.meta), {})
}
function _$(e, t) {
    const n = {};
    for (const r in e)
        n[r] = r in t ? t[r] : e[r];
    return n
}
function f7(e, t) {
    return t.children.some(n => n === e || f7(e, n))
}
const h7 = /#/g, Uve = /&/g, qve = /\//g, Yve = /=/g, Kve = /\?/g, p7 = /\+/g, Gve = /%5B/g, Xve = /%5D/g, m7 = /%5E/g, Jve = /%60/g, g7 = /%7B/g, Zve = /%7C/g, v7 = /%7D/g, Qve = /%20/g;
function mI(e) {
    return encodeURI("" + e).replace(Zve, "|").replace(Gve, "[").replace(Xve, "]")
}
function e0e(e) {
    return mI(e).replace(g7, "{").replace(v7, "}").replace(m7, "^")
}
function mx(e) {
    return mI(e).replace(p7, "%2B").replace(Qve, "+").replace(h7, "%23").replace(Uve, "%26").replace(Jve, "`").replace(g7, "{").replace(v7, "}").replace(m7, "^")
}
function t0e(e) {
    return mx(e).replace(Yve, "%3D")
}
function n0e(e) {
    return mI(e).replace(h7, "%23").replace(Kve, "%3F")
}
function r0e(e) {
    return e == null ? "" : n0e(e).replace(qve, "%2F")
}
function ry(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
function o0e(e) {
    const t = {};
    if (e === "" || e === "?")
        return t;
    const r = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let o = 0; o < r.length; ++o) {
        const i = r[o].replace(p7, " "),
        s = i.indexOf("="),
        a = ry(s < 0 ? i : i.slice(0, s)),
        l = s < 0 ? null : ry(i.slice(s + 1));
        if (a in t) {
            let c = t[a];
            Os(c) || (c = t[a] = [c]),
            c.push(l)
        } else
            t[a] = l
    }
    return t
}
function k$(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = t0e(n), r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }
        (Os(r) ? r.map(i => i && mx(i)) : [r && mx(r)]).forEach(i => {
            i !== void 0 && (t += (t.length ? "&" : "") + n, i != null && (t += "=" + i))
        })
    }
    return t
}
function i0e(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        r !== void 0 && (t[n] = Os(r) ? r.map(o => o == null ? null : "" + o) : r == null ? r : "" + r)
    }
    return t
}
const s0e = Symbol(""), x$ = Symbol(""), Cw = Symbol(""), gI = Symbol(""), gx = Symbol("");
function Hh() {
    let e = [];
    function t(r) {
        return e.push(r),
        () => {
            const o = e.indexOf(r);
            o > -1 && e.splice(o, 1)
        }
    }
    function n() {
        e = []
    }
    return {
        add: t,
        list: () => e,
        reset: n
    }
}
function Ol(e, t, n, r, o) {
    const i = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
    return () => new Promise((s, a) => {
        const l = f => {
            f === !1 ? a(Tf(4, {
                    from: n,
                    to: t
                })) : f instanceof Error ? a(f) : Ove(f) ? a(Tf(2, {
                    from: t,
                    to: f
                })) : (i && r.enterCallbacks[o] === i && typeof f == "function" && i.push(f), s())
        },
        c = e.call(r && r.instances[o], t, n, l);
        let u = Promise.resolve(c);
        e.length < 3 && (u = u.then(l)),
        u.catch(f => a(f))
    })
}
function X_(e, t, n, r) {
    const o = [];
    for (const i of e)
        for (const s in i.components) {
            let a = i.components[s];
            if (!(t !== "beforeRouteEnter" && !i.instances[s]))
                if (a0e(a)) {
                    const c = (a.__vccOpts || a)[t];
                    c && o.push(Ol(c, n, r, i, s))
                } else {
                    let l = a();
                    o.push(() => l.then(c => {
                            if (!c)
                                return Promise.reject(new Error(`Couldn't resolve component "${s}" at "${i.path}"`));
                            const u = hve(c) ? c.default : c;
                            i.components[s] = u;
                            const p = (u.__vccOpts || u)[t];
                            return p && Ol(p, n, r, i, s)()
                        }))
                }
        }
    return o
}
function a0e(e) {
    return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}
function S$(e) {
    const t = Mo(Cw),
    n = Mo(gI),
    r = ne(() => t.resolve(ke(e.to))),
    o = ne(() => {
        const {
            matched: l
        } = r.value, {
            length: c
        } = l,
        u = l[c - 1],
        f = n.matched;
        if (!u || !f.length)
            return -1;
        const p = f.findIndex(If.bind(null, u));
        if (p > -1)
            return p;
        const m = C$(l[c - 2]);
        return c > 1 && C$(u) === m && f[f.length - 1].path !== m ? f.findIndex(If.bind(null, l[c - 2])) : p
    }),
    i = ne(() => o.value > -1 && d0e(n.params, r.value.params)),
    s = ne(() => o.value > -1 && o.value === n.matched.length - 1 && l7(n.params, r.value.params));
    function a(l = {}) {
        return u0e(l) ? t[ke(e.replace) ? "replace" : "push"](ke(e.to)).catch(Ap) : Promise.resolve()
    }
    return {
        route: r,
        href: ne(() => r.value.href),
        isActive: i,
        isExactActive: s,
        navigate: a
    }
}
const l0e = Fe({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
        default:
            "page"
        }
    },
    useLink: S$,
    setup(e, {
        slots: t
    }) {
        const n = es(S$(e)), {
            options: r
        } = Mo(Cw),
        o = ne(() => ({
                    [I$(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                    [I$(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
        return () => {
            const i = t.default && t.default(n);
            return e.custom ? i : dt("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: o.value
            }, i)
        }
    }
}), c0e = l0e;
function u0e(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
        !0
    }
}
function d0e(e, t) {
    for (const n in t) {
        const r = t[n],
        o = e[n];
        if (typeof r == "string") {
            if (r !== o)
                return !1
        } else if (!Os(o) || o.length !== r.length || r.some((i, s) => i !== o[s]))
            return !1
    }
    return !0
}
function C$(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const I$ = (e, t, n) => e ?? t ?? n, f0e = Fe({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
        default:
            "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {
        attrs: t,
        slots: n
    }) {
        const r = Mo(gx),
        o = ne(() => e.route || r.value),
        i = Mo(x$, 0),
        s = ne(() => {
            let c = ke(i);
            const {
                matched: u
            } = o.value;
            let f;
            for (; (f = u[c]) && !f.components; )
                c++;
            return c
        }),
        a = ne(() => o.value.matched[s.value]);
        iu(x$, ne(() => s.value + 1)),
        iu(s0e, a),
        iu(gx, o);
        const l = De();
        return Ht(() => [l.value, a.value, e.name], ([c, u, f], [p, m, v]) => {
            u && (u.instances[f] = c, m && m !== u && c && c === p && (u.leaveGuards.size || (u.leaveGuards = m.leaveGuards), u.updateGuards.size || (u.updateGuards = m.updateGuards))),
            c && u && (!m || !If(u, m) || !p) && (u.enterCallbacks[f] || []).forEach(y => y(c))
        }, {
            flush: "post"
        }),
        () => {
            const c = o.value,
            u = e.name,
            f = a.value,
            p = f && f.components[u];
            if (!p)
                return T$(n.default, {
                    Component: p,
                    route: c
                });
            const m = f.props[u],
            v = m ? m === !0 ? c.params : typeof m == "function" ? m(c) : m : null,
            b = dt(p, kn({}, v, t, {
                        onVnodeUnmounted: w => {
                            w.component.isUnmounted && (f.instances[u] = null)
                        },
                        ref: l
                    }));
            return T$(n.default, {
                Component: b,
                route: c
            }) || b
        }
    }
});
function T$(e, t) {
    if (!e)
        return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const h0e = f0e;
function p0e(e) {
    const t = jve(e.routes, e),
    n = e.parseQuery || o0e,
    r = e.stringifyQuery || k$,
    o = e.history,
    i = Hh(),
    s = Hh(),
    a = Hh(),
    l = _u(kl);
    let c = kl;
    Ad && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = K_.bind(null, le => "" + le),
    f = K_.bind(null, r0e),
    p = K_.bind(null, ry);
    function m(le, ye) {
        let ge,
        pe;
        return u7(le) ? (ge = t.getRecordMatcher(le), pe = ye) : pe = le,
        t.addRoute(pe, ge)
    }
    function v(le) {
        const ye = t.getRecordMatcher(le);
        ye && t.removeRoute(ye)
    }
    function y() {
        return t.getRoutes().map(le => le.record)
    }
    function b(le) {
        return !!t.getRecordMatcher(le)
    }
    function w(le, ye) {
        if (ye = kn({}, ye || l.value), typeof le == "string") {
            const W = G_(n, le, ye.path),
            R = t.resolve({
                path: W.path
            }, ye),
            X = o.createHref(W.fullPath);
            return kn(W, R, {
                params: p(R.params),
                hash: ry(W.hash),
                redirectedFrom: void 0,
                href: X
            })
        }
        let ge;
        if ("path" in le)
            ge = kn({}, le, {
                path: G_(n, le.path, ye.path).path
            });
        else {
            const W = kn({}, le.params);
            for (const R in W)
                W[R] == null && delete W[R];
            ge = kn({}, le, {
                params: f(le.params)
            }),
            ye.params = f(ye.params)
        }
        const pe = t.resolve(ge, ye),
        xe = le.hash || "";
        pe.params = u(p(pe.params));
        const et = gve(r, kn({}, le, {
                    hash: e0e(xe),
                    path: pe.path
                })),
        Xe = o.createHref(et);
        return kn({
            fullPath: et,
            hash: xe,
            query: r === k$ ? i0e(le.query) : le.query || {}
        }, pe, {
            redirectedFrom: void 0,
            href: Xe
        })
    }
    function k(le) {
        return typeof le == "string" ? G_(n, le, l.value.path) : kn({}, le)
    }
    function C(le, ye) {
        if (c !== le)
            return Tf(8, {
                from: ye,
                to: le
            })
    }
    function x(le) {
        return E(le)
    }
    function S(le) {
        return x(kn(k(le), {
                replace: !0
            }))
    }
    function T(le) {
        const ye = le.matched[le.matched.length - 1];
        if (ye && ye.redirect) {
            const {
                redirect: ge
            } = ye;
            let pe = typeof ge == "function" ? ge(le) : ge;
            return typeof pe == "string" && (pe = pe.includes("?") || pe.includes("#") ? pe = k(pe) : {
                    path: pe
                }, pe.params = {}),
            kn({
                query: le.query,
                hash: le.hash,
                params: "path" in pe ? {}
                 : le.params
            }, pe)
        }
    }
    function E(le, ye) {
        const ge = c = w(le),
        pe = l.value,
        xe = le.state,
        et = le.force,
        Xe = le.replace === !0,
        W = T(ge);
        if (W)
            return E(kn(k(W), {
                    state: typeof W == "object" ? kn({}, xe, W.state) : xe,
                    force: et,
                    replace: Xe
                }), ye || ge);
        const R = ge;
        R.redirectedFrom = ye;
        let X;
        return !et && vve(r, pe, ge) && (X = Tf(16, {
                to: R,
                from: pe
            }), je(pe, pe, !0, !1)),
        (X ? Promise.resolve(X) : N(R, pe)).catch(Q => Aa(Q) ? Aa(Q, 2) ? Q : Pe(Q) : de(Q, R, pe)).then(Q => {
            if (Q) {
                if (Aa(Q, 2))
                    return E(kn({
                            replace: Xe
                        }, k(Q.to), {
                            state: typeof Q.to == "object" ? kn({}, xe, Q.to.state) : xe,
                            force: et
                        }), ye || R)
            } else
                Q = K(R, pe, !0, Xe, xe);
            return F(R, pe, Q),
            Q
        })
    }
    function M(le, ye) {
        const ge = C(le, ye);
        return ge ? Promise.reject(ge) : Promise.resolve()
    }
    function N(le, ye) {
        let ge;
        const [pe, xe, et] = m0e(le, ye);
        ge = X_(pe.reverse(), "beforeRouteLeave", le, ye);
        for (const W of pe)
            W.leaveGuards.forEach(R => {
                ge.push(Ol(R, le, ye))
            });
        const Xe = M.bind(null, le, ye);
        return ge.push(Xe),
        xd(ge).then(() => {
            ge = [];
            for (const W of i.list())
                ge.push(Ol(W, le, ye));
            return ge.push(Xe),
            xd(ge)
        }).then(() => {
            ge = X_(xe, "beforeRouteUpdate", le, ye);
            for (const W of xe)
                W.updateGuards.forEach(R => {
                    ge.push(Ol(R, le, ye))
                });
            return ge.push(Xe),
            xd(ge)
        }).then(() => {
            ge = [];
            for (const W of le.matched)
                if (W.beforeEnter && !ye.matched.includes(W))
                    if (Os(W.beforeEnter))
                        for (const R of W.beforeEnter)
                            ge.push(Ol(R, le, ye));
                    else
                        ge.push(Ol(W.beforeEnter, le, ye));
            return ge.push(Xe),
            xd(ge)
        }).then(() => (le.matched.forEach(W => W.enterCallbacks = {}), ge = X_(et, "beforeRouteEnter", le, ye), ge.push(Xe), xd(ge))).then(() => {
            ge = [];
            for (const W of s.list())
                ge.push(Ol(W, le, ye));
            return ge.push(Xe),
            xd(ge)
        }).catch(W => Aa(W, 8) ? W : Promise.reject(W))
    }
    function F(le, ye, ge) {
        for (const pe of a.list())
            pe(le, ye, ge)
    }
    function K(le, ye, ge, pe, xe) {
        const et = C(le, ye);
        if (et)
            return et;
        const Xe = ye === kl,
        W = Ad ? history.state : {};
        ge && (pe || Xe ? o.replace(le.fullPath, kn({
                    scroll: Xe && W && W.scroll
                }, xe)) : o.push(le.fullPath, xe)),
        l.value = le,
        je(le, ye, ge, Xe),
        Pe()
    }
    let j;
    function G() {
        j || (j = o.listen((le, ye, ge) => {
                if (!at.listening)
                    return;
                const pe = w(le),
                xe = T(pe);
                if (xe) {
                    E(kn(xe, {
                            replace: !0
                        }), pe).catch(Ap);
                    return
                }
                c = pe;
                const et = l.value;
                Ad && Cve(p$(et.fullPath, ge.delta), Sw()),
                N(pe, et).catch(Xe => Aa(Xe, 12) ? Xe : Aa(Xe, 2) ? (E(Xe.to, pe).then(W => {
                            Aa(W, 20) && !ge.delta && ge.type === _m.pop && o.go(-1, !1)
                        }).catch(Ap), Promise.reject()) : (ge.delta && o.go(-ge.delta, !1), de(Xe, pe, et))).then(Xe => {
                    Xe = Xe || K(pe, et, !1),
                    Xe && (ge.delta && !Aa(Xe, 8) ? o.go(-ge.delta, !1) : ge.type === _m.pop && Aa(Xe, 20) && o.go(-1, !1)),
                    F(pe, et, Xe)
                }).catch(Ap)
            }))
    }
    let Y = Hh(),
    ue = Hh(),
    re;
    function de(le, ye, ge) {
        Pe(le);
        const pe = ue.list();
        return pe.length ? pe.forEach(xe => xe(le, ye, ge)) : console.error(le),
        Promise.reject(le)
    }
    function Se() {
        return re && l.value !== kl ? Promise.resolve() : new Promise((le, ye) => {
            Y.add([le, ye])
        })
    }
    function Pe(le) {
        return re || (re = !le, G(), Y.list().forEach(([ye, ge]) => le ? ge(le) : ye()), Y.reset()),
        le
    }
    function je(le, ye, ge, pe) {
        const {
            scrollBehavior: xe
        } = e;
        if (!Ad || !xe)
            return Promise.resolve();
        const et = !ge && Ive(p$(le.fullPath, 0)) || (pe || !ge) && history.state && history.state.scroll || null;
        return Ci().then(() => xe(le, ye, et)).then(Xe => Xe && Sve(Xe)).catch(Xe => de(Xe, le, ye))
    }
    const Ke = le => o.go(le);
    let Ue;
    const yt = new Set,
    at = {
        currentRoute: l,
        listening: !0,
        addRoute: m,
        removeRoute: v,
        hasRoute: b,
        getRoutes: y,
        resolve: w,
        options: e,
        push: x,
        replace: S,
        go: Ke,
        back: () => Ke(-1),
        forward: () => Ke(1),
        beforeEach: i.add,
        beforeResolve: s.add,
        afterEach: a.add,
        onError: ue.add,
        isReady: Se,
        install(le) {
            const ye = this;
            le.component("RouterLink", c0e),
            le.component("RouterView", h0e),
            le.config.globalProperties.$router = ye,
            Object.defineProperty(le.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => ke(l)
            }),
            Ad && !Ue && l.value === kl && (Ue = !0, x(o.location).catch(xe => {}));
            const ge = {};
            for (const xe in kl)
                ge[xe] = ne(() => l.value[xe]);
            le.provide(Cw, ye),
            le.provide(gI, es(ge)),
            le.provide(gx, l);
            const pe = le.unmount;
            yt.add(le),
            le.unmount = function () {
                yt.delete(le),
                yt.size < 1 && (c = kl, j && j(), j = null, l.value = kl, Ue = !1, re = !1),
                pe()
            }
        }
    };
    return at
}
function xd(e) {
    return e.reduce((t, n) => t.then(() => n()), Promise.resolve())
}
function m0e(e, t) {
    const n = [],
    r = [],
    o = [],
    i = Math.max(t.matched.length, e.matched.length);
    for (let s = 0; s < i; s++) {
        const a = t.matched[s];
        a && (e.matched.find(c => If(c, a)) ? r.push(a) : n.push(a));
        const l = e.matched[s];
        l && (t.matched.find(c => If(c, l)) || o.push(l))
    }
    return [n, r, o]
}
function g0e() {
    return Mo(Cw)
}
function dgt() {
    return Mo(gI)
}
const v0e = {
    name: "splitpanes",
    emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
    props: {
        horizontal: {
            type: Boolean
        },
        pushOtherPanes: {
            type: Boolean,
        default:
            !0
        },
        dblClickSplitter: {
            type: Boolean,
        default:
            !0
        },
        rtl: {
            type: Boolean,
        default:
            !1
        },
        firstSplitter: {
            type: Boolean
        }
    },
    provide() {
        return {
            requestUpdate: this.requestUpdate,
            onPaneAdd: this.onPaneAdd,
            onPaneRemove: this.onPaneRemove,
            onPaneClick: this.onPaneClick
        }
    },
    data: () => ({
        container: null,
        ready: !1,
        panes: [],
        touch: {
            mouseDown: !1,
            dragging: !1,
            activeSplitter: null
        },
        splitterTaps: {
            splitter: null,
            timeoutId: null
        }
    }),
    computed: {
        panesCount() {
            return this.panes.length
        },
        indexedPanes() {
            return this.panes.reduce((e, t) => (e[t.id] = t) && e, {})
        }
    },
    methods: {
        updatePaneComponents() {
            this.panes.forEach(e => {
                e.update && e.update({
                    [this.horizontal ? "height" : "width"]: `${this.indexedPanes[e.id].size}%`
                })
            })
        },
        bindEvents() {
            document.addEventListener("mousemove", this.onMouseMove, {
                passive: !1
            }),
            document.addEventListener("mouseup", this.onMouseUp),
            "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, {
                    passive: !1
                }), document.addEventListener("touchend", this.onMouseUp))
        },
        unbindEvents() {
            document.removeEventListener("mousemove", this.onMouseMove, {
                passive: !1
            }),
            document.removeEventListener("mouseup", this.onMouseUp),
            "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, {
                    passive: !1
                }), document.removeEventListener("touchend", this.onMouseUp))
        },
        onMouseDown(e, t) {
            this.bindEvents(),
            this.touch.mouseDown = !0,
            this.touch.activeSplitter = t
        },
        onMouseMove(e) {
            this.touch.mouseDown && (e.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(e)), this.$emit("resize", this.panes.map(t => ({
                            min: t.min,
                            max: t.max,
                            size: t.size
                        }))))
        },
        onMouseUp() {
            this.touch.dragging && this.$emit("resized", this.panes.map(e => ({
                        min: e.min,
                        max: e.max,
                        size: e.size
                    }))),
            this.touch.mouseDown = !1,
            setTimeout(() => {
                this.touch.dragging = !1,
                this.unbindEvents()
            }, 100)
        },
        onSplitterClick(e, t) {
            "ontouchstart" in window && (e.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === t ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e, t), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = t, this.splitterTaps.timeoutId = setTimeout(() => {
                            this.splitterTaps.splitter = null
                        }, 500)))),
            this.touch.dragging || this.$emit("splitter-click", this.panes[t])
        },
        onSplitterDblClick(e, t) {
            let n = 0;
            this.panes = this.panes.map((r, o) => (r.size = o === t ? r.max : r.min, o !== t && (n += r.min), r)),
            this.panes[t].size -= n,
            this.$emit("pane-maximize", this.panes[t]),
            this.$emit("resized", this.panes.map(r => ({
                        min: r.min,
                        max: r.max,
                        size: r.size
                    })))
        },
        onPaneClick(e, t) {
            this.$emit("pane-click", this.indexedPanes[t])
        },
        getCurrentMouseDrag(e) {
            const t = this.container.getBoundingClientRect(), {
                clientX: n,
                clientY: r
            } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
            return {
                x: n - t.left,
                y: r - t.top
            }
        },
        getCurrentDragPercentage(e) {
            e = e[this.horizontal ? "y" : "x"];
            const t = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
            return this.rtl && !this.horizontal && (e = t - e),
            e * 100 / t
        },
        calculatePanesSize(e) {
            const t = this.touch.activeSplitter;
            let n = {
                prevPanesSize: this.sumPrevPanesSize(t),
                nextPanesSize: this.sumNextPanesSize(t),
                prevReachedMinPanes: 0,
                nextReachedMinPanes: 0
            };
            const r = 0 + (this.pushOtherPanes ? 0 : n.prevPanesSize),
            o = 100 - (this.pushOtherPanes ? 0 : n.nextPanesSize),
            i = Math.max(Math.min(this.getCurrentDragPercentage(e), o), r);
            let s = [t, t + 1],
            a = this.panes[s[0]] || null,
            l = this.panes[s[1]] || null;
            const c = a.max < 100 && i >= a.max + n.prevPanesSize,
            u = l.max < 100 && i <= 100 - (l.max + this.sumNextPanesSize(t + 1));
            if (c || u) {
                c ? (a.size = a.max, l.size = Math.max(100 - a.max - n.prevPanesSize - n.nextPanesSize, 0)) : (a.size = Math.max(100 - l.max - n.prevPanesSize - this.sumNextPanesSize(t + 1), 0), l.size = l.max);
                return
            }
            if (this.pushOtherPanes) {
                const f = this.doPushOtherPanes(n, i);
                if (!f)
                    return;
                ({
                    sums: n,
                    panesToResize: s
                } = f),
                a = this.panes[s[0]] || null,
                l = this.panes[s[1]] || null
            }
            a !== null && (a.size = Math.min(Math.max(i - n.prevPanesSize - n.prevReachedMinPanes, a.min), a.max)),
            l !== null && (l.size = Math.min(Math.max(100 - i - n.nextPanesSize - n.nextReachedMinPanes, l.min), l.max))
        },
        doPushOtherPanes(e, t) {
            const n = this.touch.activeSplitter,
            r = [n, n + 1];
            return t < e.prevPanesSize + this.panes[r[0]].min && (r[0] = this.findPrevExpandedPane(n).index, e.prevReachedMinPanes = 0, r[0] < n && this.panes.forEach((o, i) => {
                    i > r[0] && i <= n && (o.size = o.min, e.prevReachedMinPanes += o.min)
                }), e.prevPanesSize = this.sumPrevPanesSize(r[0]), r[0] === void 0) ? (e.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((o, i) => {
                    i > 0 && i <= n && (o.size = o.min, e.prevReachedMinPanes += o.min)
                }), this.panes[r[1]].size = 100 - e.prevReachedMinPanes - this.panes[0].min - e.prevPanesSize - e.nextPanesSize, null) : t > 100 - e.nextPanesSize - this.panes[r[1]].min && (r[1] = this.findNextExpandedPane(n).index, e.nextReachedMinPanes = 0, r[1] > n + 1 && this.panes.forEach((o, i) => {
                    i > n && i < r[1] && (o.size = o.min, e.nextReachedMinPanes += o.min)
                }), e.nextPanesSize = this.sumNextPanesSize(r[1] - 1), r[1] === void 0) ? (e.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((o, i) => {
                    i < this.panesCount - 1 && i >= n + 1 && (o.size = o.min, e.nextReachedMinPanes += o.min)
                }), this.panes[r[0]].size = 100 - e.prevPanesSize - e.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e.nextPanesSize, null) : {
                sums: e,
                panesToResize: r
            }
        },
        sumPrevPanesSize(e) {
            return this.panes.reduce((t, n, r) => t + (r < e ? n.size : 0), 0)
        },
        sumNextPanesSize(e) {
            return this.panes.reduce((t, n, r) => t + (r > e + 1 ? n.size : 0), 0)
        },
        findPrevExpandedPane(e) {
            return [...this.panes].reverse().find(t => t.index < e && t.size > t.min) || {}
        },
        findNextExpandedPane(e) {
            return this.panes.find(t => t.index > e + 1 && t.size > t.min) || {}
        },
        checkSplitpanesNodes() {
            Array.from(this.container.children).forEach(e => {
                const t = e.classList.contains("splitpanes__pane"),
                n = e.classList.contains("splitpanes__splitter");
                !t && !n && (e.parentNode.removeChild(e), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."))
            })
        },
        addSplitter(e, t, n = !1) {
            const r = e - 1,
            o = document.createElement("div");
            o.classList.add("splitpanes__splitter"),
            n || (o.onmousedown = i => this.onMouseDown(i, r), typeof window < "u" && "ontouchstart" in window && (o.ontouchstart = i => this.onMouseDown(i, r)), o.onclick = i => this.onSplitterClick(i, r + 1)),
            this.dblClickSplitter && (o.ondblclick = i => this.onSplitterDblClick(i, r + 1)),
            t.parentNode.insertBefore(o, t)
        },
        removeSplitter(e) {
            e.onmousedown = void 0,
            e.onclick = void 0,
            e.ondblclick = void 0,
            e.parentNode.removeChild(e)
        },
        redoSplitters() {
            const e = Array.from(this.container.children);
            e.forEach(n => {
                n.className.includes("splitpanes__splitter") && this.removeSplitter(n)
            });
            let t = 0;
            e.forEach(n => {
                n.className.includes("splitpanes__pane") && (!t && this.firstSplitter ? this.addSplitter(t, n, !0) : t && this.addSplitter(t, n), t++)
            })
        },
        requestUpdate({
            target: e,
            ...t
        }) {
            const n = this.indexedPanes[e._.uid];
            Object.entries(t).forEach(([r, o]) => n[r] = o)
        },
        onPaneAdd(e) {
            let t = -1;
            Array.from(e.$el.parentNode.children).some(o => (o.className.includes("splitpanes__pane") && t++, o === e.$el));
            const n = parseFloat(e.minSize),
            r = parseFloat(e.maxSize);
            this.panes.splice(t, 0, {
                id: e._.uid,
                index: t,
                min: isNaN(n) ? 0 : n,
                max: isNaN(r) ? 100 : r,
                size: e.size === null ? null : parseFloat(e.size),
                givenSize: e.size,
                update: e.update
            }),
            this.panes.forEach((o, i) => o.index = i),
            this.ready && this.$nextTick(() => {
                this.redoSplitters(),
                this.resetPaneSizes({
                    addedPane: this.panes[t]
                }),
                this.$emit("pane-add", {
                    index: t,
                    panes: this.panes.map(o => ({
                            min: o.min,
                            max: o.max,
                            size: o.size
                        }))
                })
            })
        },
        onPaneRemove(e) {
            const t = this.panes.findIndex(r => r.id === e._.uid),
            n = this.panes.splice(t, 1)[0];
            this.panes.forEach((r, o) => r.index = o),
            this.$nextTick(() => {
                this.redoSplitters(),
                this.resetPaneSizes({
                    removedPane: {
                        ...n,
                        index: t
                    }
                }),
                this.$emit("pane-remove", {
                    removed: n,
                    panes: this.panes.map(r => ({
                            min: r.min,
                            max: r.max,
                            size: r.size
                        }))
                })
            })
        },
        resetPaneSizes(e = {}) {
            !e.addedPane && !e.removedPane ? this.initialPanesSizing() : this.panes.some(t => t.givenSize !== null || t.min || t.max < 100) ? this.equalizeAfterAddOrRemove(e) : this.equalize(),
            this.ready && this.$emit("resized", this.panes.map(t => ({
                        min: t.min,
                        max: t.max,
                        size: t.size
                    })))
        },
        equalize() {
            const e = 100 / this.panesCount;
            let t = 0;
            const n = [],
            r = [];
            this.panes.forEach(o => {
                o.size = Math.max(Math.min(e, o.max), o.min),
                t -= o.size,
                o.size >= o.max && n.push(o.id),
                o.size <= o.min && r.push(o.id)
            }),
            t > .1 && this.readjustSizes(t, n, r)
        },
        initialPanesSizing() {
            let e = 100;
            const t = [],
            n = [];
            let r = 0;
            this.panes.forEach(i => {
                e -= i.size,
                i.size !== null && r++,
                i.size >= i.max && t.push(i.id),
                i.size <= i.min && n.push(i.id)
            });
            let o = 100;
            e > .1 && (this.panes.forEach(i => {
                    i.size === null && (i.size = Math.max(Math.min(e / (this.panesCount - r), i.max), i.min)),
                    o -= i.size
                }), o > .1 && this.readjustSizes(e, t, n))
        },
        equalizeAfterAddOrRemove({
            addedPane: e,
            removedPane: t
        } = {}) {
            let n = 100 / this.panesCount,
            r = 0;
            const o = [],
            i = [];
            e && e.givenSize !== null && (n = (100 - e.givenSize) / (this.panesCount - 1)),
            this.panes.forEach(s => {
                r -= s.size,
                s.size >= s.max && o.push(s.id),
                s.size <= s.min && i.push(s.id)
            }),
            !(Math.abs(r) < .1) && (this.panes.forEach(s => {
                    e && e.givenSize !== null && e.id === s.id || (s.size = Math.max(Math.min(n, s.max), s.min)),
                    r -= s.size,
                    s.size >= s.max && o.push(s.id),
                    s.size <= s.min && i.push(s.id)
                }), r > .1 && this.readjustSizes(r, o, i))
        },
        readjustSizes(e, t, n) {
            let r;
            e > 0 ? r = e / (this.panesCount - t.length) : r = e / (this.panesCount - n.length),
            this.panes.forEach((o, i) => {
                if (e > 0 && !t.includes(o.id)) {
                    const s = Math.max(Math.min(o.size + r, o.max), o.min),
                    a = s - o.size;
                    e -= a,
                    o.size = s
                } else if (!n.includes(o.id)) {
                    const s = Math.max(Math.min(o.size + r, o.max), o.min),
                    a = s - o.size;
                    e -= a,
                    o.size = s
                }
                o.update({
                    [this.horizontal ? "height" : "width"]: `${this.indexedPanes[o.id].size}%`
                })
            }),
            Math.abs(e) > .1 && this.$nextTick(() => {
                this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.")
            })
        }
    },
    watch: {
        panes: {
            deep: !0,
            immediate: !1,
            handler() {
                this.updatePaneComponents()
            }
        },
        horizontal() {
            this.updatePaneComponents()
        },
        firstSplitter() {
            this.redoSplitters()
        },
        dblClickSplitter(e) {
            [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, n) => {
                t.ondblclick = e ? r => this.onSplitterDblClick(r, n) : void 0
            })
        }
    },
    beforeUnmount() {
        this.ready = !1
    },
    mounted() {
        this.container = this.$refs.container,
        this.checkSplitpanesNodes(),
        this.redoSplitters(),
        this.resetPaneSizes(),
        this.$emit("ready"),
        this.ready = !0
    },
    render() {
        return dt("div", {
            ref: "container",
            class: ["splitpanes", `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`, {
                    "splitpanes--dragging": this.touch.dragging
                }
            ]
        }, this.$slots.default())
    }
}, y0e = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r, o] of t)
        n[r] = o;
    return n
}, w0e = {
    name: "pane",
    inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
    props: {
        size: {
            type: [Number, String],
        default:
            null
        },
        minSize: {
            type: [Number, String],
        default:
            0
        },
        maxSize: {
            type: [Number, String],
        default:
            100
        }
    },
    data: () => ({
        style: {}
    }),
    mounted() {
        this.onPaneAdd(this)
    },
    beforeUnmount() {
        this.onPaneRemove(this)
    },
    methods: {
        update(e) {
            this.style = e
        }
    },
    computed: {
        sizeNumber() {
            return this.size || this.size === 0 ? parseFloat(this.size) : null
        },
        minSizeNumber() {
            return parseFloat(this.minSize)
        },
        maxSizeNumber() {
            return parseFloat(this.maxSize)
        }
    },
    watch: {
        sizeNumber(e) {
            this.requestUpdate({
                target: this,
                size: e
            })
        },
        minSizeNumber(e) {
            this.requestUpdate({
                target: this,
                min: e
            })
        },
        maxSizeNumber(e) {
            this.requestUpdate({
                target: this,
                max: e
            })
        }
    }
};
function b0e(e, t, n, r, o, i) {
    return _(),
    O("div", {
        class: "splitpanes__pane",
        onClick: t[0] || (t[0] = s => i.onPaneClick(s, e._.uid)),
        style: Yt(e.style)
    }, [Ye(e.$slots, "default")], 4)
}
const J_ = y0e(w0e, [["render", b0e]]);
const _0e = Fe({
    __name: "SplitPanel",
    props: {
        id: {},
        direction: {
        default:
            "left"
        },
        secondarySize: {
        default:
            40
        },
        secondaryMinSize: {
        default:
            15
        },
        mainMinSize: {
        default:
            25
        },
        withTransition: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["update:secondarySize"],
    setup(e, {
        emit: t
    }) {
        const n = e,
        r = De(n.secondarySize),
        o = De(n.secondarySize),
        i = ne(() => 100 - r.value),
        s = ne(() => i.value === 100),
        a = ne(() => n.direction === "left" || n.direction === "up"),
        l = ne(() => n.direction === "up" || n.direction === "down"),
        c = () => {
            o.value = r.value,
            r.value = 0
        },
        u = () => {
            r.value = Math.max(n.secondaryMinSize, o.value)
        },
        f = () => {
            s.value ? u() : c()
        },
        p = ({
            size: v
        }) => {
            if (v < n.secondaryMinSize && v > 0) {
                r.value = 0;
                return
            }
            o.value = v,
            t("update:secondarySize", v)
        },
        m = ({
            size: v
        }) => {
            r.value = v
        };
        return (v, y) => (_(), H(ke(v0e), {
                id: v.id,
                class: he(["split-panel", {
                            "is-closed": s.value,
                            "unset-transition": !v.withTransition,
                            "left-facing-splitter": v.direction === "left",
                            "right-facing-splitter": v.direction === "right",
                            "down-facing-splitter": v.direction === "down",
                            "up-facing-splitter": v.direction === "up"
                        }
                    ]),
                "dbl-click-splitter": !1,
                horizontal: l.value,
                onSplitterClick: f,
                onResized: y[0] || (y[0] = b => p(b[a.value ? 0 : 1])),
                onResize: y[1] || (y[1] = b => m(b[a.value ? 0 : 1]))
            }, {
            default:
                oe(() => [a.value ? (_(), H(ke(J_), {
                                key: 0,
                                size: r.value,
                                class: he(["secondary-panel", {
                                            "will-snap": r.value < v.secondaryMinSize
                                        }
                                    ])
                            }, {
                            default:
                                oe(() => [s.value ? J("", !0) : Ye(v.$slots, "secondary", {
                                            key: 0
                                        }, void 0, !0)]),
                                _: 3
                            }, 8, ["size", "class"])) : J("", !0), z(ke(J_), {
                            size: i.value,
                            "min-size": v.mainMinSize,
                            class: "main-panel"
                        }, {
                        default:
                            oe(() => [Ye(v.$slots, "default", {}, void 0, !0)]),
                            _: 3
                        }, 8, ["size", "min-size"]), a.value ? J("", !0) : (_(), H(ke(J_), {
                                key: 1,
                                size: r.value,
                                class: he(["secondary-panel", {
                                            "will-snap": r.value < v.secondaryMinSize
                                        }
                                    ])
                            }, {
                            default:
                                oe(() => [s.value ? J("", !0) : Ye(v.$slots, "secondary", {
                                            key: 0
                                        }, void 0, !0)]),
                                _: 3
                            }, 8, ["size", "class"]))]),
                _: 3
            }, 8, ["id", "horizontal", "class"]))
    }
});
const k0e = te(_0e, [["__scopeId", "data-v-5c6a7207"]]), x0e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, S0e = P("path", {
    d: "M21.435 11.922v-8c0-1.1-.9-2-2-2h-12c-1.1 0-2 .9-2 2v11c0 2.344.883 3 3 3M6.023 2.51l8.923 8.924m9.013 6.714 1.048-1.391-1.8-1.785-1.395 1.063-2.063-.845-.211-1.732-2.573.001-.225 1.733-2.099.871-1.388-1.055-1.78 1.786 1.063 1.359-.884 2.102-1.706.216-.004 2.57 1.7.211.87 2.104-1.025 1.404 1.802 1.795 1.39-1.048 2.067.85.223 1.721 2.573-.001.23-1.726 2.08-.864 1.409 1.037 1.788-1.801-1.055-1.382.857-2.072 1.714-.224-.003-2.576-1.719-.225z"
}, null, -1), C0e = P("circle", {
    cx: "18.254",
    cy: "21.768",
    r: "2.997"
}, null, -1), I0e = [S0e, C0e];
function T0e(e, t) {
    return _(),
    O("svg", x0e, I0e)
}
const M0e = {
    render: T0e
}, P0e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, E0e = P("path", {
    d: "m16 2 12.124 7v14L16 30 3.876 23V9zm0 28V16m-2.376 1.372L3.876 23M28.124 9 16 16m2.613 1.508L28.124 23M3.876 9 16 16m0-2.506V2"
}, null, -1), O0e = [E0e];
function $0e(e, t) {
    return _(),
    O("svg", P0e, O0e)
}
const A0e = {
    render: $0e
}, D0e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, N0e = P("path", {
    d: "M20 26.5v-13c0-.825-.675-1.5-1.5-1.5h-13c-.825 0-1.5.675-1.5 1.5v13c0 .825.675 1.5 1.5 1.5h13c.825 0 1.5-.675 1.5-1.5zm2.5-2.5c.825 0 1.5-.675 1.5-1.5v-13c0-.825-.675-1.5-1.5-1.5h-13C8.675 8 8 8.675 8 9.5M26.5 20c.825 0 1.5-.675 1.5-1.5v-13c0-.825-.675-1.5-1.5-1.5h-13c-.825 0-1.5.675-1.5 1.5m-7.294 7.206 14.588 14.588"
}, null, -1), R0e = [N0e];
function L0e(e, t) {
    return _(),
    O("svg", D0e, R0e)
}
const B0e = {
    render: L0e
}, V0e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, F0e = P("path", {
    d: "m19.632 19.85-.08.202-.203.08-3.482 1.368 3.482 1.368.203.08.08.203L21 26.633l1.368-3.482.08-.203.203-.08 3.482-1.368-3.482-1.368-.203-.08-.08-.203L21 16.367l-1.368 3.482Z"
}, null, -1), j0e = P("path", {
    d: "M3.5 17v13h26V4h-13"
}, null, -1), W0e = P("path", {
    d: "m8.232 8.402-.078.252-.252.078L2.191 10.5l5.711 1.768.252.078.078.252L10 18.309l1.768-5.711.078-.252.252-.078 5.711-1.768-5.711-1.768-.252-.078-.078-.252L10 2.691 8.232 8.402Z"
}, null, -1), z0e = [F0e, j0e, W0e];
function H0e(e, t) {
    return _(),
    O("svg", V0e, z0e)
}
const U0e = {
    render: H0e
}, q0e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Y0e = P("path", {
    "stroke-linejoin": "round",
    d: "M25.428 17.175h-22M12.832 25.175H3.157M29.428 21.175h-26M29.428 13.175h-26M29.428 9.175h-26M29.428 5.175h-26"
}, null, -1), K0e = [Y0e];
function G0e(e, t) {
    return _(),
    O("svg", q0e, K0e)
}
const X0e = {
    render: G0e
}, po = () => wa(), d0 = "org.knime.ui.feature", J0e = {
    [`${d0}.embedded_views_and_dialogs`]: !1,
    [`${d0}.ai_assistant`]: !0,
    [`${d0}.ai_assistant_installed`]: !1
}, Uh = (e, t) => (e.state.application.featureFlags || J0e)[`${d0}.${t}`], y7 = e => ({
    shouldDisplayEmbeddedDialogs: () => Uh(e, "embedded_views_and_dialogs"),
    shouldDisplayEmbeddedViews: () => Uh(e, "embedded_views_and_dialogs"),
    shouldLoadPageBuilder: () => Uh(e, "embedded_views_and_dialogs"),
    isKaiPermitted: () => Uh(e, "ai_assistant"),
    isKaiInstalled: () => Uh(e, "ai_assistant_installed")
}), Z0e = () => {
    const e = wa();
    return y7(e)
}, Q0e = ({
    app: e,
    $store: t
}) => {
    e.config.globalProperties.$features = y7(t)
}, eye = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, tye = P("path", {
    d: "m21.5 27-11-11 11-11"
}, null, -1), nye = [tye];
function rye(e, t) {
    return _(),
    O("svg", eye, nye)
}
const w7 = {
    render: rye
}, oye = {
    class: "panel"
}, iye = ["title", "disabled"], sye = Fe({
    __name: "LeftCollapsiblePanel",
    props: {
        expanded: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
            type: Boolean,
        default:
            !1
        },
        width: {
        default:
            "250px"
        },
        title: {
        default:
            null
        }
    },
    emits: ["toggleExpand"],
    setup(e) {
        return (t, n) => (_(), O("div", oye, [P("div", {
                        class: "container",
                        style: Yt({
                            width: t.expanded ? t.width : 0
                        })
                    }, [P("div", {
                                class: "hidden-content",
                                style: Yt({
                                    width: t.width
                                })
                            }, [Ye(t.$slots, "default", {}, void 0, !0)], 4)], 4), P("button", {
                        title: t.expanded ? null : t.title,
                        disabled: t.disabled,
                        onClick: n[0] || (n[0] = r => t.$emit("toggleExpand"))
                    }, [z(ke(w7), {
                                style: Yt({
                                    transform: t.expanded ? null : "scaleX(-1)"
                                })
                            }, null, 8, ["style"])], 8, iye)]))
    }
});
const aye = te(sye, [["__scopeId", "data-v-640bd9d5"]]), lye = Fe({
    __name: "SidebarExtensionPanel",
    setup(e) {
        const t = po(),
        n = ne(() => t.state.panel.isExtensionPanelOpen);
        return lg({
            onEscape() {
                t.dispatch("panel/closeExtensionPanel")
            }
        }),
        (r, o) => {
            const i = B("PortalTarget");
            return n.value ? (_(), H(i, {
                    key: 0,
                    tag: "div",
                    name: "extension-panel",
                    class: "extension-panel"
                })) : J("", !0)
        }
    }
});
const cye = te(lye, [["__scopeId", "data-v-bfc8c880"]]), uye = {};
function dye(e, t) {
    return _(),
    O("div")
}
const qh = te(uye, [["render", dye]]), fye = {
    class: "sidebar-wrapper"
}, hye = ["title", "onClick"], pye = Fe({
    __name: "Sidebar",
    setup(e) {
        const t = (C, x) => C ? [x] : [],
        n = Ha({
            loader: () => Ks(() => import("./ContextAwareDescription-3018c89c.js"), ["./ContextAwareDescription-3018c89c.js", "./NodeDescription-22891d06.js", "./CloseButton-3f01b06f.js", "./CloseButton-c3052ed0.css", "./arrow-right-0785f3ac.js", "./trash-c1de9387.js", "./NodeDescription-33bec20a.css", "./Tag-c0ba7798.js", "./Tag-d95c2428.css", "./pencil-ca93310a.js", "./ContextAwareDescription-3d892d1f.css"], import.meta.url),
            loadingComponent: qh
        }),
        r = Ha({
            loader: () => Ks(() => import("./NodeRepository-b609d124.js"), ["./NodeRepository-b609d124.js", "./NodeDescription-22891d06.js", "./CloseButton-3f01b06f.js", "./CloseButton-c3052ed0.css", "./arrow-right-0785f3ac.js", "./trash-c1de9387.js", "./NodeDescription-33bec20a.css", "./DraggableNodeTemplate-762b6846.js", "./Tag-c0ba7798.js", "./Tag-d95c2428.css", "./NodeRepository-1a7e8a04.css"], import.meta.url),
            loadingComponent: qh
        }),
        o = Ha({
            loader: () => Ks(() => import("./NodeDialogWrapper-713801b7.js"), ["./NodeDialogWrapper-713801b7.js", "./NodeDialogWrapper-39facd8d.css"], import.meta.url),
            loadingComponent: qh
        }),
        i = Ha({
            loader: () => Ks(() => import("./SidebarSpaceExplorer-723c783f.js"), ["./SidebarSpaceExplorer-723c783f.js", "./SpaceExplorer-8f8b6a5c.js", "./trash-c1de9387.js", "./pencil-ca93310a.js", "./computer-desktop-f6256e82.js", "./house-1d05c0b5.js", "./house-ff15d853.css", "./SpaceExplorer-94ebb666.css"], import.meta.url),
            loadingComponent: qh
        }),
        s = Ha({
            loader: () => Ks(() => import("./KaiSidebar-475bcd17.js"), ["./KaiSidebar-475bcd17.js", "./NodeDescription-22891d06.js", "./CloseButton-3f01b06f.js", "./CloseButton-c3052ed0.css", "./arrow-right-0785f3ac.js", "./trash-c1de9387.js", "./NodeDescription-33bec20a.css", "./DraggableNodeTemplate-762b6846.js", "./KaiSidebar-0e8a0b58.css"], import.meta.url),
            loadingComponent: qh
        }),
        a = Z0e(),
        l = po(),
        c = ne(() => l.state.panel.activeTab),
        u = ne(() => l.state.panel.expanded),
        f = ne(() => l.state.panel.isExtensionPanelOpen),
        p = ne(() => l.state.application.activeProjectId),
        m = ne(() => l.state.application.permissions),
        v = ne(() => l.getters["workflow/isWorkflowEmpty"]);
        Ht(v, () => {
            v.value && l.dispatch("panel/setCurrentProjectActiveTab", wn.NODE_REPOSITORY)
        }, {
            immediate: !0
        });
        const y = C => {
            const x = () => v.value ? wn.NODE_REPOSITORY : wn.CONTEXT_AWARE_DESCRIPTION;
            return p.value ? (c.value[p.value] || x()) === C : !1
        },
        b = C => {
            y(C) && u.value ? l.commit("panel/closePanel") : l.dispatch("panel/setCurrentProjectActiveTab", C),
            l.dispatch("panel/closeExtensionPanel")
        },
        w = ne(() => [{
                        name: wn.CONTEXT_AWARE_DESCRIPTION,
                        title: "描述",
                        icon: X0e,
                        isActive: y(wn.CONTEXT_AWARE_DESCRIPTION),
                        isExpanded: u.value,
                        onClick: () => b(wn.CONTEXT_AWARE_DESCRIPTION)
                    }, ...t(m.value.canAccessNodeRepository, {
                        name: wn.NODE_REPOSITORY,
                        title: "节点",
                        icon: B0e,
                        isActive: y(wn.NODE_REPOSITORY),
                        isExpanded: u.value,
                        onClick: () => b(wn.NODE_REPOSITORY)
                    }), ...t(a.shouldDisplayEmbeddedDialogs(), {
                        name: wn.NODE_DIALOG,
                        title: "节点对话框",
                        icon: M0e,
                        isActive: y(wn.NODE_DIALOG),
                        isExpanded: u.value,
                        onClick: () => b(wn.NODE_DIALOG)
                    }), ...t(m.value.canAccessSpaceExplorer && F6(), {
                        name: wn.SPACE_EXPLORER,
                        title: "空间浏览",
                        icon: A0e,
                        isActive: y(wn.SPACE_EXPLORER),
                        isExpanded: u.value,
                        onClick: () => b(wn.SPACE_EXPLORER)
                    }), ...t(a.isKaiPermitted() && j6() && m.value.canAccessKAIPanel, {
                        name: wn.KAI,
                        title: "AI 助手",
                        icon: U0e,
                        isActive: y(wn.KAI),
                        isExpanded: u.value,
                        onClick: () => b(wn.KAI)
                    })]),
        k = C => w.value.find(x => x.name === C);
        return (C, x) => (_(), O("div", fye, [P("nav", null, [P("ul", null, [(_(!0), O(Le, null, $t(w.value, S => (_(), O("li", {
                                                        key: S.title,
                                                        title: S.title,
                                                        class: he({
                                                            active: S.isActive,
                                                            expanded: S.isExpanded
                                                        }),
                                                        onClick: S.onClick
                                                    }, [(_(), H(Kt(S.icon)))], 10, hye))), 128))])]), z(aye, {
                        id: "left-panel",
                        width: "360px",
                        title: "打开侧边栏",
                        expanded: u.value,
                        disabled: f.value,
                        onToggleExpand: x[0] || (x[0] = S => ke(l).commit("panel/toggleExpanded"))
                    }, {
                    default:
                        oe(() => [z(Qm, {
                                    name: "tab",
                                    tag: "span"
                                }, {
                                default:
                                    oe(() => [k(ke(wn).CONTEXT_AWARE_DESCRIPTION) ? Cn((_(), H(ke(n), {
                                                        key: "context-aware-description"
                                                    }, null, 512)), [[Kn, y(ke(wn).CONTEXT_AWARE_DESCRIPTION)]]) : J("", !0), k(ke(wn).NODE_REPOSITORY) && y(ke(wn).NODE_REPOSITORY) ? Cn((_(), H(ke(r), {
                                                        key: "node-repository"
                                                    }, null, 512)), [[Kn, y(ke(wn).NODE_REPOSITORY)]]) : J("", !0), k(ke(wn).NODE_DIALOG) ? Cn((_(), H(ke(o), {
                                                        key: "node-dialog"
                                                    }, null, 512)), [[Kn, y(ke(wn).NODE_DIALOG)]]) : J("", !0), k(ke(wn).SPACE_EXPLORER) ? Cn((_(), H(ke(i), {
                                                        key: "space-explorer"
                                                    }, null, 512)), [[Kn, y(ke(wn).SPACE_EXPLORER)]]) : J("", !0), k(ke(wn).KAI) ? Cn((_(), H(ke(s), {
                                                        key: "ai-chat"
                                                    }, null, 512)), [[Kn, y(ke(wn).KAI)]]) : J("", !0)]),
                                    _: 1
                                })]),
                        _: 1
                    }, 8, ["expanded", "disabled"]), z(cye)]))
    }
});
const mye = te(pye, [["__scopeId", "data-v-e25225ad"]]), gye = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, vye = P("path", {
    d: "M4.742 29V3l22.517 13L4.742 29zm0 0V3l22.516 13z"
}, null, -1), yye = [vye];
function wye(e, t) {
    return _(),
    O("svg", gye, yye)
}
const b7 = {
    render: wye
}, bye = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#3E3A39",
    viewBox: "0 0 32 32"
}, _ye = P("path", {
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    d: "M7.6 9.6 25 27M23.6 9H9c-1.1 0-2 .9-2 2v14.6c0 1.1.9 2 2 2h14.6c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2Z"
}, null, -1), kye = P("circle", {
    cx: "27.5",
    cy: "6",
    r: "3",
    fill: "#D30D52",
    stroke: "none"
}, null, -1), xye = [_ye, kye];
function Sye(e, t) {
    return _(),
    O("svg", bye, xye)
}
const _7 = {
    render: Sye
}, Cye = 5;
let M$, P$, Z_;
const Iye = Fe({
    data() {
        return {
            isMouseDown: !1,
            wasDragged: !1
        }
    },
    methods: {
        onMouseDown(e) {
            Z_ = this.$refs.carousel,
            this.isMouseDown = !0,
            this.wasDragged = !1,
            M$ = e.pageX,
            P$ = Z_.scrollLeft
        },
        onMouseEnd(e) {
            this.wasDragged && e.preventDefault(),
            this.isMouseDown = !1
        },
        onMouseMove(e) {
            if (!this.isMouseDown)
                return;
            e.preventDefault();
            const n = e.pageX - M$;
            (this.wasDragged || Math.abs(n) > Cye) && (this.wasDragged = !0, Z_.scrollLeft = P$ - n)
        },
        onDragStart(e) {
            e.preventDefault()
        }
    }
});
const Tye = {
    class: "shadow-wrapper"
};
function Mye(e, t, n, r, o, i) {
    return _(),
    O("div", Tye, [P("div", {
                ref: "carousel",
                class: he(["carousel", {
                            "is-mouse-down": e.isMouseDown
                        }
                    ]),
                onMousedown: t[0] || (t[0] = (...s) => e.onMouseDown && e.onMouseDown(...s)),
                onMousemove: t[1] || (t[1] = (...s) => e.onMouseMove && e.onMouseMove(...s)),
                onClickCapture: t[2] || (t[2] = (...s) => e.onMouseEnd && e.onMouseEnd(...s)),
                onMouseleave: t[3] || (t[3] = (...s) => e.onMouseEnd && e.onMouseEnd(...s)),
                onDragstart: t[4] || (t[4] = (...s) => e.onDragStart && e.onDragStart(...s))
            }, [Ye(e.$slots, "default", {}, void 0, !0)], 34)])
}
const Pye = te(Iye, [["render", Mye], ["__scopeId", "data-v-c4989b0e"]]);
const Eye = {
    components: {
        Carousel: Pye
    },
    props: {
        disabled: {
            type: Boolean,
        default:
            !1
        },
        modelValue: {
            type: String,
        default:
            ""
        },
        name: {
            type: String,
        default:
            "value"
        },
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e = []) {
                return Array.isArray(e) ? e.every(t => t.value) : !1
            }
        }
    },
    emits: ["update:modelValue"],
    created() {
        const e = this.possibleValues.find(t => !t.disabled);
        consola.trace("TabBar: Setting initial tab", e),
        this.$emit("update:modelValue", e ? e.value : null)
    },
    methods: {
        onChange(e) {
            consola.trace("TabBar value changed to", e),
            this.$emit("update:modelValue", e)
        }
    }
}, Oye = {
    class: "tab-bar"
}, $ye = {
    class: "overflow"
}, Aye = ["title"], Dye = ["name", "value", "disabled", "checked", "onChange"];
function Nye(e, t, n, r, o, i) {
    const s = B("Carousel");
    return _(),
    H(s, null, {
    default:
        oe(() => [P("div", Oye, [P("div", $ye, [(_(!0), O(Le, null, $t(n.possibleValues, a => (_(), O("label", {
                                                    key: a.value,
                                                    title: a.title
                                                }, [P("input", {
                                                            name: n.name,
                                                            value: a.value,
                                                            disabled: n.disabled || a.disabled,
                                                            type: "radio",
                                                            checked: a.value === n.modelValue,
                                                            onChange: l => i.onChange(a.value)
                                                        }, null, 40, Dye), P("span", null, [a.icon ? (_(), H(Kt(a.icon), {
                                                                        key: 0
                                                                    })) : J("", !0), mt(" " + Re(a.label), 1)])], 8, Aye))), 128))])])]),
        _: 1
    })
}
const Rye = te(Eye, [["render", Nye], ["__scopeId", "data-v-dcfe2c15"]]), Lye = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Bye = P("path", {
    d: "M29.5 16c0-2.2-4.4-9-13.5-9S2.5 13.8 2.5 16m27 0c0 2.2-4.4 9-13.5 9S2.5 18.2 2.5 16"
}, null, -1), Vye = P("circle", {
    cx: "16",
    cy: "16",
    r: "4.5"
}, null, -1), Fye = [Bye, Vye];
function jye(e, t) {
    return _(),
    O("svg", Lye, Fye)
}
const Wye = {
    render: jye
}, Yh = 9, zye = 1.4, Hye = {
    props: {
        type: {
            type: String,
        default:
            "table"
        },
        color: {
            type: String,
        default:
            ""
        },
        filled: {
            type: Boolean,
        default:
            !0
        }
    },
    computed: {
        portSize() {
            return Yh
        },
        strokeWidth() {
            return zye
        },
        trianglePath() {
            let [e, t, n, r] = [-Yh / 2, -Yh / 2, Yh / 2, Yh / 2];
            const o = Math.sqrt(5) / 2,
            i = o / 2 + 1 / 4;
            let {
                strokeWidth: s
            } = this;
            return e += s / 2,
            n -= s * o,
            t += s * i,
            r -= s * i,
`${e},${t} ${n},${0} ${e},${r}`
        },
        portColor() {
            return o7[this.type] || this.color
        },
        fillColor() {
            return this.filled ? this.portColor : "transparent"
        }
    }
}, Uye = ["points", "fill", "stroke", "stroke-width"], qye = ["r", "fill", "stroke", "stroke-width"], Yye = ["width", "height", "x", "y", "fill", "stroke", "stroke-width"];
function Kye(e, t, n, r, o, i) {
    return n.type === "table" ? (_(), O("polygon", Bt({
                key: 0,
                points: i.trianglePath,
                fill: i.fillColor,
                stroke: i.portColor,
                "stroke-width": i.strokeWidth
            }, e.$attrs), null, 16, Uye)) : n.type === "flowVariable" ? (_(), O("circle", Bt({
                key: 1,
                r: i.portSize / 2 - i.strokeWidth / 2,
                fill: i.fillColor,
                stroke: i.portColor,
                "stroke-width": i.strokeWidth
            }, e.$attrs), null, 16, qye)) : (_(), O("rect", Bt({
                key: 2,
                width: i.portSize - i.strokeWidth,
                height: i.portSize - i.strokeWidth,
                x: -i.portSize / 2 + i.strokeWidth / 2,
                y: -i.portSize / 2 + i.strokeWidth / 2,
                fill: i.fillColor,
                stroke: i.portColor,
                "stroke-width": i.strokeWidth
            }, e.$attrs), null, 16, Yye))
}
const k7 = te(Hye, [["render", Kye]]);
const Gye = {
    components: {
        PortIcon: k7
    },
    props: {
        port: {
            type: Object,
            required: !0,
            validator: e => (typeof e.inactive == "boolean" || !e.inactive) && typeof e.typeId == "string"
        },
        isSelected: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        ...ut("application", {
            portTypes: "availablePortTypes"
        }),
        portKind() {
            return this.portTypes[this.port.typeId].kind
        },
        portColor() {
            return this.portKind === "other" ? this.portTypes[this.port.typeId].color : this.$colors.portColors[this.portKind]
        },
        shouldFill() {
            return this.portKind === "flowVariable" && this.port.index === 0 ? !0 : !this.port.optional
        },
        trafficLight() {
            return {
                IDLE: "red",
                CONFIGURED: "yellow",
                EXECUTING: "blue",
                QUEUED: "yellow",
                HALTED: "green",
                EXECUTED: "green"
            }
            [this.port.nodeState]
        },
        outlineX() {
            let e = 0;
            return this.trafficLight && (e -= 1),
            this.portKind === "table" && (e -= 1),
            e
        }
    }
}, Xye = e => (ir("data-v-69dac9f5"), e = e(), sr(), e), Jye = {
    class: "port"
}, Zye = ["cx"], Qye = ["x", "y", "width", "height"], e1e = {
    class: "scale"
}, t1e = ["stroke", "d"], n1e = ["stroke", "d"], r1e = {
    key: 2
}, o1e = {
    transform: "translate(-5.5, 0)",
    fill: "none"
}, i1e = Xye(() => P("circle", {
            r: "3.75",
            fill: "white"
        }, null, -1)), s1e = ["fill"], a1e = ["d", "stroke", "transform"];
function l1e(e, t, n, r, o, i) {
    const s = B("PortIcon");
    return _(),
    O("g", Jye, [n.isSelected ? (_(), O("circle", {
                    key: 0,
                    class: "port-outline",
                    cx: i.outlineX,
                    r: "9.5"
                }, null, 8, Zye)) : J("", !0), P("rect", {
                x: -e.$shapes.portSize / 2,
                y: -e.$shapes.portSize / 2 - 1,
                width: e.$shapes.portSize,
                height: e.$shapes.portSize + 2,
                class: "hover-area",
                "data-hide-in-workflow-preview": ""
            }, null, 8, Qye), P("g", e1e, [z(s, {
                        type: i.portKind,
                        color: i.portColor,
                        filled: i.shouldFill
                    }, null, 8, ["type", "color", "filled"]), n.port.inactive ? (_(), O("path", {
                            key: 0,
                            "stroke-width": "3",
                            stroke: e.$colors.portColors.inactiveOutline,
                            d: `M-${e.$shapes.portSize / 2},-${e.$shapes.portSize / 2} l${e.$shapes.portSize},${e.$shapes.portSize}
           m-${e.$shapes.portSize},0 l${e.$shapes.portSize},-${e.$shapes.portSize}`
                        }, null, 8, t1e)) : J("", !0), n.port.inactive ? (_(), O("path", {
                            key: 1,
                            "stroke-width": "1.5",
                            stroke: e.$colors.portColors.inactive,
                            d: `M-${e.$shapes.portSize / 2},-${e.$shapes.portSize / 2} l${e.$shapes.portSize},${e.$shapes.portSize}
           m-${e.$shapes.portSize},0 l${e.$shapes.portSize},-${e.$shapes.portSize}`
                        }, null, 8, n1e)) : J("", !0), i.trafficLight ? (_(), O("g", r1e, [P("g", o1e, [i1e, P("circle", {
                                            r: "3",
                                            fill: e.$colors.trafficLight[i.trafficLight]
                                        }, null, 8, s1e), P("path", {
                                            d: `M2.5,0a1,1 0 0 0 -5,0a1,1 0 0 0 5,0${i.trafficLight === "yellow" || i.trafficLight === "green" ? "h-5" : ""}`,
                                            fill: "none",
                                            stroke: e.$colors.darkeningMask,
                                            transform: i.trafficLight === "yellow" ? "rotate(90)" : null
                                        }, null, 8, a1e)])])) : J("", !0)])])
}
const hg = te(Gye, [["render", l1e], ["__scopeId", "data-v-69dac9f5"]]), km = (e, t = null) => ({
    render() {
        const n = {
            ...e
        };
        delete n.nodeState;
        const r = dt(hg, {
            port: n
        }),
        o = this.$shapes.portSize,
        i = {
            viewBox: `-${o / 2} -${o / 2} ${o} ${o}`,
            style: t && `width: ${t}px`
        };
        return dt("svg", {
            ...i
        }, [r])
    }
}), rh = e => e.kind === vf.KindEnum.Metanode, fgt = e => e.kind === vf.KindEnum.Component, x7 = (e, t) => rh(e) ? e.outPorts[t].nodeState === j0.NodeStateEnum.CONFIGURED : e.allowedActions.canExecute, S7 = (e, t) => rh(e) ? e.outPorts[t].nodeState : e.state?.executionState;
const c1e = 9, u1e = e => ({
    value: String(e.index),
    icon: km(e, c1e),
    label: `${e.index}: ${e.name}`
}), d1e = {
    components: {
        TabBar: Rye
    },
    model: {
        prop: "modelValue",
        event: "update:modelValue"
    },
    props: {
        node: {
            type: Object,
        default:
            () => ({})
        },
        modelValue: {
            type: String,
        default:
            null
        },
        disabled: {
            type: Boolean,
        default:
            !1
        },
        hasViewTab: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["update:modelValue"],
    computed: {
        possibleTabValues() {
            if (!this.node || !this.node.outPorts.length)
                return [];
            let {
                outPorts: e
            } = this.node;
            const t = rh(this.node),
            n = (t ? e : e.slice(1)).map(u1e);
            return [].concat(this.hasViewTab && this.$features.shouldDisplayEmbeddedViews() ? {
                value: "view",
                label: "View",
                icon: Wye
            }
                 : null).concat(n).concat(t ? null : {
                value: "0",
                label: "Flow Variables",
                icon: _7
            }).filter(Boolean)
        }
    }
};
function f1e(e, t, n, r, o, i) {
    const s = B("TabBar");
    return _(),
    H(s, {
        name: "output-port",
        "model-value": n.modelValue,
        disabled: n.disabled,
        "possible-values": i.possibleTabValues,
        "onUpdate:modelValue": t[0] || (t[0] = a => e.$emit("update:modelValue", a))
    }, null, 8, ["model-value", "disabled", "possible-values"])
}
const h1e = te(d1e, [["render", f1e], ["__scopeId", "data-v-ad74a47d"]]);
var vx;
(function (e) {
    e.ERROR = "error",
    e.WARN = "warn"
})(vx || (vx = {}));
class vI {
    constructor(t = null, n = null, r = null) {
        this.extensionConfig = t,
        this.callableService = n,
        this.callablePushEvent = r,
        this.eventCallbacksMap = new Map
    }
    async callService(t) {
        if (!this.extensionConfig) {
            const i = this.createAlert({
                subtitle: "缺少扩展配置",
                message: "没有分机配置就无法调用服务"
            });
            return this.sendError(i),
            Promise.resolve({})
        }
        if (!this.callableService) {
            const i = this.createAlert({
                message: "Callable service is not available",
                subtitle: "Service not found"
            });
            return this.sendError(i),
            Promise.resolve({})
        }
        const n = await this.executeServiceCall(t), {
            error: r,
            result: o
        } = n || {};
        return r && this.sendError(r),
        Promise.resolve({
            result: o
        })
    }
    executeServiceCall(t) {
        return this.callableService(...t)
    }
    registerDataGetter(t) {
        this.dataGetter = t
    }
    getData() {
        return Promise.resolve(typeof this.dataGetter == "function" ? this.dataGetter() : null)
    }
    onServiceEvent(t) {
        (this.eventCallbacksMap.get(t.eventType) || []).forEach(r => {
            r(t)
        })
    }
    addEventCallback(t, n) {
        this.eventCallbacksMap.set(t, [...this.eventCallbacksMap.get(t) || [], n])
    }
    removeEventCallback(t, n) {
        this.eventCallbacksMap.set(t, (this.eventCallbacksMap.get(t) || []).filter(r => r !== n))
    }
    resetEventCallbacksByType(t) {
        this.eventCallbacksMap.set(t, [])
    }
    resetEventCallbacks() {
        this.eventCallbacksMap.clear()
    }
    pushEvent(t) {
        if (!this.extensionConfig) {
            const n = this.createAlert({
                subtitle: "Missing extension config",
                message: "Cannot push event without extension config"
            });
            return this.sendError(n),
            Promise.resolve({})
        }
        if (!this.callablePushEvent) {
            const n = this.createAlert({
                subtitle: "Push event failed",
                message: "Push event is not available"
            });
            return this.sendError(n),
            Promise.resolve({})
        }
        return this.callablePushEvent(Object.assign({
                callerId: this.serviceId
            }, t))
    }
    sendError(t) {
        this.callablePushEvent ? this.callablePushEvent({
            callerId: this.serviceId,
            alert: t,
            type: "alert"
        }) : console.error(t)
    }
    sendWarning(t) {
        this.callablePushEvent ? this.callablePushEvent({
            callerId: this.serviceId,
            alert: t,
            type: "alert"
        }) : console.warn(t)
    }
    createAlert(t) {
        var n,
        r;
        const {
            type: o = vx.ERROR,
            message: i,
            code: s,
            subtitle: a
        } = t;
        return {
            nodeId: ((n = this.extensionConfig) === null || n === void 0 ? void 0 : n.nodeId) || "MISSING",
            nodeInfo: ((r = this.extensionConfig) === null || r === void 0 ? void 0 : r.nodeInfo) || {},
            type: o,
            message: i,
            code: s,
            subtitle: a
        }
    }
    get serviceId() {
        const {
            nodeId: t,
            projectId: n,
            workflowId: r,
            extensionType: o
        } = this.extensionConfig || {};
        return `${t}.${n}.${r}.${o}`
    }
}
var E$;
(function (e) {
    e.CALL_NODE_DATA_SERVICE = "NodeService.callNodeDataService",
    e.CALL_NODE_SELECTION_SERVICE = "NodeService.updateDataPointSelection"
})(E$ || (E$ = {}));
var O$;
(function (e) {
    e.INITIAL_DATA = "initial_data",
    e.DATA = "data",
    e.APPLY_DATA = "apply_data"
})(O$ || (O$ = {}));
var $$;
(function (e) {
    e.ADD = "ADD",
    e.REMOVE = "REMOVE",
    e.REPLACE = "REPLACE"
})($$ || ($$ = {}));
var A$;
(function (e) {
    e.DIALOG = "dialog",
    e.VIEW = "view"
})(A$ || (A$ = {}));
var D$;
(function (e) {
    e.DataEvent = "DataEvent",
    e.SelectionEvent = "SelectionEvent"
})(D$ || (D$ = {}));
var N$;
(function (e) {
    e.HTML = "HTML",
    e.VUE_COMPONENT_LIB = "VUE_COMPONENT_LIB"
})(N$ || (N$ = {}));
let R$ = 0;
const C7 = () => (R$ += 1, R$), p1e = "2.0", m1e = (e, t = []) => ({
    jsonrpc: p1e,
    method: e,
    params: t,
    id: C7()
}), yx = "knimeUIExtension", g1e = 1e4, v1e = Object.freeze(Object.defineProperty({
            __proto__: null,
            UI_EXT_POST_MESSAGE_PREFIX: yx,
            UI_EXT_POST_MESSAGE_TIMEOUT: g1e
        }, Symbol.toStringTag, {
            value: "Module"
        }));
class y1e extends vI {
    constructor(t = null, n = null, r = null) {
        super(t, n, r),
        this.boundOnMessageFromIFrame = this.onMessageFromIFrame.bind(this),
        window.addEventListener("message", this.boundOnMessageFromIFrame)
    }
    setIFrameWindow(t) {
        this.iFrameWindow = t
    }
    updateEventListener() {
        window.removeEventListener("message", this.boundOnMessageFromIFrame),
        window.addEventListener("message", this.boundOnMessageFromIFrame)
    }
    checkMessageSource(t) {
        return t.source !== this.iFrameWindow
    }
    async onMessageFromIFrame(t) {
        var n;
        if (this.checkMessageSource(t))
            return;
        const {
            data: r
        } = t;
        switch ((n = r.type) === null || n === void 0 ? void 0 : n.replace(`${yx}:`, "")) {
        case "ready":
            this.postMessage({
                payload: this.extensionConfig,
                messageType: "init"
            });
            break;
        case "callService": {
                const {
                    payload: {
                        requestId: i,
                        serviceParams: s
                    }
                } = r,
                a = await this.callService(s);
                this.postMessage({
                    payload: {
                        response: a,
                        requestId: i
                    },
                    messageType: "callServiceResponse"
                })
            }
            break;
        case "event": {
                const {
                    payload: {
                        event: i
                    }
                } = r;
                this.pushEvent(i)
            }
            break;
        case "imageGenerated":
            this.imageGeneratedCallback !== null && this.imageGeneratedCallback(r.payload),
            this.imageGeneratedCallback = null;
            break
        }
    }
    registerImageGeneratedCallback(t) {
        this.imageGeneratedCallback = t
    }
    onServiceEvent(t) {
        const n = typeof t == "string" ? JSON.parse(t) : t;
        this.postMessage({
            payload: n,
            messageType: "serviceEvent"
        })
    }
    destroy() {
        window.removeEventListener("message", this.boundOnMessageFromIFrame),
        this.iFrameWindow = null
    }
    postMessage(t) {
        const {
            payload: n,
            messageType: r
        } = t;
        this.iFrameWindow.postMessage({
            type: `${yx}:${r}`,
            payload: n
        }, "*")
    }
}
var L$;
(function (e) {
    e.NUMERIC = "NUMERIC",
    e.NOMINAL = "NOMINAL"
})(L$ || (L$ = {}));
var w1e = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
};
const xm = w1e, I7 = {};
for (const e of Object.keys(xm))
    I7[xm[e]] = e;
const ft = {
    rgb: {
        channels: 3,
        labels: "rgb"
    },
    hsl: {
        channels: 3,
        labels: "hsl"
    },
    hsv: {
        channels: 3,
        labels: "hsv"
    },
    hwb: {
        channels: 3,
        labels: "hwb"
    },
    cmyk: {
        channels: 4,
        labels: "cmyk"
    },
    xyz: {
        channels: 3,
        labels: "xyz"
    },
    lab: {
        channels: 3,
        labels: "lab"
    },
    lch: {
        channels: 3,
        labels: "lch"
    },
    hex: {
        channels: 1,
        labels: ["hex"]
    },
    keyword: {
        channels: 1,
        labels: ["keyword"]
    },
    ansi16: {
        channels: 1,
        labels: ["ansi16"]
    },
    ansi256: {
        channels: 1,
        labels: ["ansi256"]
    },
    hcg: {
        channels: 3,
        labels: ["h", "c", "g"]
    },
    apple: {
        channels: 3,
        labels: ["r16", "g16", "b16"]
    },
    gray: {
        channels: 1,
        labels: ["gray"]
    }
};
var T7 = ft;
for (const e of Object.keys(ft)) {
    if (!("channels" in ft[e]))
        throw new Error("missing channels property: " + e);
    if (!("labels" in ft[e]))
        throw new Error("missing channel labels property: " + e);
    if (ft[e].labels.length !== ft[e].channels)
        throw new Error("channel and label counts mismatch: " + e);
    const {
        channels: t,
        labels: n
    } = ft[e];
    delete ft[e].channels,
    delete ft[e].labels,
    Object.defineProperty(ft[e], "channels", {
        value: t
    }),
    Object.defineProperty(ft[e], "labels", {
        value: n
    })
}
ft.rgb.hsl = function (e) {
    const t = e[0] / 255,
    n = e[1] / 255,
    r = e[2] / 255,
    o = Math.min(t, n, r),
    i = Math.max(t, n, r),
    s = i - o;
    let a,
    l;
    i === o ? a = 0 : t === i ? a = (n - r) / s : n === i ? a = 2 + (r - t) / s : r === i && (a = 4 + (t - n) / s),
    a = Math.min(a * 60, 360),
    a < 0 && (a += 360);
    const c = (o + i) / 2;
    return i === o ? l = 0 : c <= .5 ? l = s / (i + o) : l = s / (2 - i - o),
    [a, l * 100, c * 100]
};
ft.rgb.hsv = function (e) {
    let t,
    n,
    r,
    o,
    i;
    const s = e[0] / 255,
    a = e[1] / 255,
    l = e[2] / 255,
    c = Math.max(s, a, l),
    u = c - Math.min(s, a, l),
    f = function (p) {
        return (c - p) / 6 / u + 1 / 2
    };
    return u === 0 ? (o = 0, i = 0) : (i = u / c, t = f(s), n = f(a), r = f(l), s === c ? o = r - n : a === c ? o = 1 / 3 + t - r : l === c && (o = 2 / 3 + n - t), o < 0 ? o += 1 : o > 1 && (o -= 1)),
    [o * 360, i * 100, c * 100]
};
ft.rgb.hwb = function (e) {
    const t = e[0],
    n = e[1];
    let r = e[2];
    const o = ft.rgb.hsl(e)[0],
    i = 1 / 255 * Math.min(t, Math.min(n, r));
    return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)),
    [o, i * 100, r * 100]
};
ft.rgb.cmyk = function (e) {
    const t = e[0] / 255,
    n = e[1] / 255,
    r = e[2] / 255,
    o = Math.min(1 - t, 1 - n, 1 - r),
    i = (1 - t - o) / (1 - o) || 0,
    s = (1 - n - o) / (1 - o) || 0,
    a = (1 - r - o) / (1 - o) || 0;
    return [i * 100, s * 100, a * 100, o * 100]
};
function b1e(e, t) {
    return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2
}
ft.rgb.keyword = function (e) {
    const t = I7[e];
    if (t)
        return t;
    let n = 1 / 0,
    r;
    for (const o of Object.keys(xm)) {
        const i = xm[o],
        s = b1e(e, i);
        s < n && (n = s, r = o)
    }
    return r
};
ft.keyword.rgb = function (e) {
    return xm[e]
};
ft.rgb.xyz = function (e) {
    let t = e[0] / 255,
    n = e[1] / 255,
    r = e[2] / 255;
    t = t > .04045 ? ((t + .055) / 1.055) ** 2.4 : t / 12.92,
    n = n > .04045 ? ((n + .055) / 1.055) ** 2.4 : n / 12.92,
    r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92;
    const o = t * .4124 + n * .3576 + r * .1805,
    i = t * .2126 + n * .7152 + r * .0722,
    s = t * .0193 + n * .1192 + r * .9505;
    return [o * 100, i * 100, s * 100]
};
ft.rgb.lab = function (e) {
    const t = ft.rgb.xyz(e);
    let n = t[0],
    r = t[1],
    o = t[2];
    n /= 95.047,
    r /= 100,
    o /= 108.883,
    n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116,
    r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116,
    o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
    const i = 116 * r - 16,
    s = 500 * (n - r),
    a = 200 * (r - o);
    return [i, s, a]
};
ft.hsl.rgb = function (e) {
    const t = e[0] / 360,
    n = e[1] / 100,
    r = e[2] / 100;
    let o,
    i,
    s;
    if (n === 0)
        return s = r * 255, [s, s, s];
    r < .5 ? o = r * (1 + n) : o = r + n - r * n;
    const a = 2 * r - o,
    l = [0, 0, 0];
    for (let c = 0; c < 3; c++)
        i = t + 1 / 3 *  - (c - 1), i < 0 && i++, i > 1 && i--, 6 * i < 1 ? s = a + (o - a) * 6 * i : 2 * i < 1 ? s = o : 3 * i < 2 ? s = a + (o - a) * (2 / 3 - i) * 6 : s = a, l[c] = s * 255;
    return l
};
ft.hsl.hsv = function (e) {
    const t = e[0];
    let n = e[1] / 100,
    r = e[2] / 100,
    o = n;
    const i = Math.max(r, .01);
    r *= 2,
    n *= r <= 1 ? r : 2 - r,
    o *= i <= 1 ? i : 2 - i;
    const s = (r + n) / 2,
    a = r === 0 ? 2 * o / (i + o) : 2 * n / (r + n);
    return [t, a * 100, s * 100]
};
ft.hsv.rgb = function (e) {
    const t = e[0] / 60,
    n = e[1] / 100;
    let r = e[2] / 100;
    const o = Math.floor(t) % 6,
    i = t - Math.floor(t),
    s = 255 * r * (1 - n),
    a = 255 * r * (1 - n * i),
    l = 255 * r * (1 - n * (1 - i));
    switch (r *= 255, o) {
    case 0:
        return [r, l, s];
    case 1:
        return [a, r, s];
    case 2:
        return [s, r, l];
    case 3:
        return [s, a, r];
    case 4:
        return [l, s, r];
    case 5:
        return [r, s, a]
    }
};
ft.hsv.hsl = function (e) {
    const t = e[0],
    n = e[1] / 100,
    r = e[2] / 100,
    o = Math.max(r, .01);
    let i,
    s;
    s = (2 - n) * r;
    const a = (2 - n) * o;
    return i = n * o,
    i /= a <= 1 ? a : 2 - a,
    i = i || 0,
    s /= 2,
    [t, i * 100, s * 100]
};
ft.hwb.rgb = function (e) {
    const t = e[0] / 360;
    let n = e[1] / 100,
    r = e[2] / 100;
    const o = n + r;
    let i;
    o > 1 && (n /= o, r /= o);
    const s = Math.floor(6 * t),
    a = 1 - r;
    i = 6 * t - s,
    s & 1 && (i = 1 - i);
    const l = n + i * (a - n);
    let c,
    u,
    f;
    switch (s) {
    default:
    case 6:
    case 0:
        c = a,
        u = l,
        f = n;
        break;
    case 1:
        c = l,
        u = a,
        f = n;
        break;
    case 2:
        c = n,
        u = a,
        f = l;
        break;
    case 3:
        c = n,
        u = l,
        f = a;
        break;
    case 4:
        c = l,
        u = n,
        f = a;
        break;
    case 5:
        c = a,
        u = n,
        f = l;
        break
    }
    return [c * 255, u * 255, f * 255]
};
ft.cmyk.rgb = function (e) {
    const t = e[0] / 100,
    n = e[1] / 100,
    r = e[2] / 100,
    o = e[3] / 100,
    i = 1 - Math.min(1, t * (1 - o) + o),
    s = 1 - Math.min(1, n * (1 - o) + o),
    a = 1 - Math.min(1, r * (1 - o) + o);
    return [i * 255, s * 255, a * 255]
};
ft.xyz.rgb = function (e) {
    const t = e[0] / 100,
    n = e[1] / 100,
    r = e[2] / 100;
    let o,
    i,
    s;
    return o = t * 3.2406 + n * -1.5372 + r *  - .4986,
    i = t *  - .9689 + n * 1.8758 + r * .0415,
    s = t * .0557 + n *  - .204 + r * 1.057,
    o = o > .0031308 ? 1.055 * o ** (1 / 2.4) - .055 : o * 12.92,
    i = i > .0031308 ? 1.055 * i ** (1 / 2.4) - .055 : i * 12.92,
    s = s > .0031308 ? 1.055 * s ** (1 / 2.4) - .055 : s * 12.92,
    o = Math.min(Math.max(0, o), 1),
    i = Math.min(Math.max(0, i), 1),
    s = Math.min(Math.max(0, s), 1),
    [o * 255, i * 255, s * 255]
};
ft.xyz.lab = function (e) {
    let t = e[0],
    n = e[1],
    r = e[2];
    t /= 95.047,
    n /= 100,
    r /= 108.883,
    t = t > .008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116,
    n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116,
    r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116;
    const o = 116 * n - 16,
    i = 500 * (t - n),
    s = 200 * (n - r);
    return [o, i, s]
};
ft.lab.xyz = function (e) {
    const t = e[0],
    n = e[1],
    r = e[2];
    let o,
    i,
    s;
    i = (t + 16) / 116,
    o = n / 500 + i,
    s = i - r / 200;
    const a = i ** 3,
    l = o ** 3,
    c = s ** 3;
    return i = a > .008856 ? a : (i - 16 / 116) / 7.787,
    o = l > .008856 ? l : (o - 16 / 116) / 7.787,
    s = c > .008856 ? c : (s - 16 / 116) / 7.787,
    o *= 95.047,
    i *= 100,
    s *= 108.883,
    [o, i, s]
};
ft.lab.lch = function (e) {
    const t = e[0],
    n = e[1],
    r = e[2];
    let o;
    o = Math.atan2(r, n) * 360 / 2 / Math.PI,
    o < 0 && (o += 360);
    const s = Math.sqrt(n * n + r * r);
    return [t, s, o]
};
ft.lch.lab = function (e) {
    const t = e[0],
    n = e[1],
    o = e[2] / 360 * 2 * Math.PI,
    i = n * Math.cos(o),
    s = n * Math.sin(o);
    return [t, i, s]
};
ft.rgb.ansi16 = function (e, t = null) {
    const [n, r, o] = e;
    let i = t === null ? ft.rgb.hsv(e)[2] : t;
    if (i = Math.round(i / 50), i === 0)
        return 30;
    let s = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
    return i === 2 && (s += 60),
    s
};
ft.hsv.ansi16 = function (e) {
    return ft.rgb.ansi16(ft.hsv.rgb(e), e[2])
};
ft.rgb.ansi256 = function (e) {
    const t = e[0],
    n = e[1],
    r = e[2];
    return t === n && n === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5)
};
ft.ansi16.rgb = function (e) {
    let t = e % 10;
    if (t === 0 || t === 7)
        return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    const n = (~~(e > 50) + 1) * .5,
    r = (t & 1) * n * 255,
    o = (t >> 1 & 1) * n * 255,
    i = (t >> 2 & 1) * n * 255;
    return [r, o, i]
};
ft.ansi256.rgb = function (e) {
    if (e >= 232) {
        const i = (e - 232) * 10 + 8;
        return [i, i, i]
    }
    e -= 16;
    let t;
    const n = Math.floor(e / 36) / 5 * 255,
    r = Math.floor((t = e % 36) / 6) / 5 * 255,
    o = t % 6 / 5 * 255;
    return [n, r, o]
};
ft.rgb.hex = function (e) {
    const n = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(n.length) + n
};
ft.hex.rgb = function (e) {
    const t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t)
        return [0, 0, 0];
    let n = t[0];
    t[0].length === 3 && (n = n.split("").map(a => a + a).join(""));
    const r = parseInt(n, 16),
    o = r >> 16 & 255,
    i = r >> 8 & 255,
    s = r & 255;
    return [o, i, s]
};
ft.rgb.hcg = function (e) {
    const t = e[0] / 255,
    n = e[1] / 255,
    r = e[2] / 255,
    o = Math.max(Math.max(t, n), r),
    i = Math.min(Math.min(t, n), r),
    s = o - i;
    let a,
    l;
    return s < 1 ? a = i / (1 - s) : a = 0,
    s <= 0 ? l = 0 : o === t ? l = (n - r) / s % 6 : o === n ? l = 2 + (r - t) / s : l = 4 + (t - n) / s,
    l /= 6,
    l %= 1,
    [l * 360, s * 100, a * 100]
};
ft.hsl.hcg = function (e) {
    const t = e[1] / 100,
    n = e[2] / 100,
    r = n < .5 ? 2 * t * n : 2 * t * (1 - n);
    let o = 0;
    return r < 1 && (o = (n - .5 * r) / (1 - r)),
    [e[0], r * 100, o * 100]
};
ft.hsv.hcg = function (e) {
    const t = e[1] / 100,
    n = e[2] / 100,
    r = t * n;
    let o = 0;
    return r < 1 && (o = (n - r) / (1 - r)),
    [e[0], r * 100, o * 100]
};
ft.hcg.rgb = function (e) {
    const t = e[0] / 360,
    n = e[1] / 100,
    r = e[2] / 100;
    if (n === 0)
        return [r * 255, r * 255, r * 255];
    const o = [0, 0, 0],
    i = t % 1 * 6,
    s = i % 1,
    a = 1 - s;
    let l = 0;
    switch (Math.floor(i)) {
    case 0:
        o[0] = 1,
        o[1] = s,
        o[2] = 0;
        break;
    case 1:
        o[0] = a,
        o[1] = 1,
        o[2] = 0;
        break;
    case 2:
        o[0] = 0,
        o[1] = 1,
        o[2] = s;
        break;
    case 3:
        o[0] = 0,
        o[1] = a,
        o[2] = 1;
        break;
    case 4:
        o[0] = s,
        o[1] = 0,
        o[2] = 1;
        break;
    default:
        o[0] = 1,
        o[1] = 0,
        o[2] = a
    }
    return l = (1 - n) * r,
    [(n * o[0] + l) * 255, (n * o[1] + l) * 255, (n * o[2] + l) * 255]
};
ft.hcg.hsv = function (e) {
    const t = e[1] / 100,
    n = e[2] / 100,
    r = t + n * (1 - t);
    let o = 0;
    return r > 0 && (o = t / r),
    [e[0], o * 100, r * 100]
};
ft.hcg.hsl = function (e) {
    const t = e[1] / 100,
    r = e[2] / 100 * (1 - t) + .5 * t;
    let o = 0;
    return r > 0 && r < .5 ? o = t / (2 * r) : r >= .5 && r < 1 && (o = t / (2 * (1 - r))),
    [e[0], o * 100, r * 100]
};
ft.hcg.hwb = function (e) {
    const t = e[1] / 100,
    n = e[2] / 100,
    r = t + n * (1 - t);
    return [e[0], (r - t) * 100, (1 - r) * 100]
};
ft.hwb.hcg = function (e) {
    const t = e[1] / 100,
    r = 1 - e[2] / 100,
    o = r - t;
    let i = 0;
    return o < 1 && (i = (r - o) / (1 - o)),
    [e[0], o * 100, i * 100]
};
ft.apple.rgb = function (e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255]
};
ft.rgb.apple = function (e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535]
};
ft.gray.rgb = function (e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255]
};
ft.gray.hsl = function (e) {
    return [0, 0, e[0]]
};
ft.gray.hsv = ft.gray.hsl;
ft.gray.hwb = function (e) {
    return [0, 100, e[0]]
};
ft.gray.cmyk = function (e) {
    return [0, 0, 0, e[0]]
};
ft.gray.lab = function (e) {
    return [e[0], 0, 0]
};
ft.gray.hex = function (e) {
    const t = Math.round(e[0] / 100 * 255) & 255,
    r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".substring(r.length) + r
};
ft.rgb.gray = function (e) {
    return [(e[0] + e[1] + e[2]) / 3 / 255 * 100]
};
const oy = T7;
function _1e() {
    const e = {},
    t = Object.keys(oy);
    for (let n = t.length, r = 0; r < n; r++)
        e[t[r]] = {
            distance: -1,
            parent: null
        };
    return e
}
function k1e(e) {
    const t = _1e(),
    n = [e];
    for (t[e].distance = 0; n.length; ) {
        const r = n.pop(),
        o = Object.keys(oy[r]);
        for (let i = o.length, s = 0; s < i; s++) {
            const a = o[s],
            l = t[a];
            l.distance === -1 && (l.distance = t[r].distance + 1, l.parent = r, n.unshift(a))
        }
    }
    return t
}
function x1e(e, t) {
    return function (n) {
        return t(e(n))
    }
}
function S1e(e, t) {
    const n = [t[e].parent, e];
    let r = oy[t[e].parent][e],
    o = t[e].parent;
    for (; t[o].parent; )
        n.unshift(t[o].parent), r = x1e(oy[t[o].parent][o], r), o = t[o].parent;
    return r.conversion = n,
    r
}
var C1e = function (e) {
    const t = k1e(e),
    n = {},
    r = Object.keys(t);
    for (let o = r.length, i = 0; i < o; i++) {
        const s = r[i];
        t[s].parent !== null && (n[s] = S1e(s, t))
    }
    return n
};
const wx = T7, I1e = C1e, Kh = {}, T1e = Object.keys(wx);
function M1e(e) {
    const t = function (...n) {
        const r = n[0];
        return r == null ? r : (r.length > 1 && (n = r), e(n))
    };
    return "conversion" in e && (t.conversion = e.conversion),
    t
}
function P1e(e) {
    const t = function (...n) {
        const r = n[0];
        if (r == null)
            return r;
        r.length > 1 && (n = r);
        const o = e(n);
        if (typeof o == "object")
            for (let i = o.length, s = 0; s < i; s++)
                o[s] = Math.round(o[s]);
        return o
    };
    return "conversion" in e && (t.conversion = e.conversion),
    t
}
T1e.forEach(e => {
    Kh[e] = {},
    Object.defineProperty(Kh[e], "channels", {
        value: wx[e].channels
    }),
    Object.defineProperty(Kh[e], "labels", {
        value: wx[e].labels
    });
    const t = I1e(e);
    Object.keys(t).forEach(r => {
        const o = t[r];
        Kh[e][r] = P1e(o),
        Kh[e][r].raw = M1e(o)
    })
});
Object.assign({
    generateRequestId: C7,
    createJsonRpcRequest: m1e
}, v1e);
const E1e = ({
    vueInstance: e,
    componentName: t
}) => Boolean(e.component(t)), O1e = ({
    vueInstance: e,
    componentName: t,
    component: n
}) => {
    e.component(t, n)
}, $1e = ({
    url: e
}) => new Promise((t, n) => {
    const r = window.document.createElement("script");
    r.async = !0,
    r.addEventListener("load", () => {
        t(r)
    }),
    r.addEventListener("error", () => {
        n(new Error(`Script loading of "${e}" failed`)),
        window.document.head.removeChild(r)
    }),
    r.src = e,
    window.document.head.appendChild(r)
}), A1e = async({
    resourceLocation: e,
    componentName: t,
    onLoad: n = null
}) => {
    const r = ii()?.appContext.app;
    if (E1e({
            vueInstance: r,
            componentName: t
        }))
        return Promise.resolve(r.component(t));
    await $1e({
        url: e
    });
    const o = window[t];
    if (!o)
        throw new Error(`Component "${t}" loading failed. Script invalid.`);
    return n?.({
        component: o
    }),
    O1e({
        vueInstance: r,
        componentName: t,
        component: o
    }),
    delete window[t],
    Promise.resolve(o)
}, M7 = ({
    resourceLocation: e,
    componentName: t,
    asyncComponentOptions: n = {},
    onLoad: r = null
}) => Ha({
    loader: () => A1e({
        window,
        resourceLocation: e,
        componentName: t,
        onLoad: r
    }),
    ...n
}), D1e = {
    props: {
        initialData: {
            type: Object,
            required: !0
        }
    }
}, N1e = ["src"];
function R1e(e, t, n, r, o, i) {
    return _(),
    O("iframe", {
        src: n.initialData.src,
        style: Yt(n.initialData.style)
    }, null, 12, N1e)
}
const L1e = te(D1e, [["render", R1e]]);
let Q_ = null;
const B1e = Fe({
    components: {
        IFramePortView: L1e
    },
    provide() {
        return {
            getKnimeService: () => this.getKnimeService()
        }
    },
    props: {
        renderKey: {
            type: String,
            required: !0
        },
        viewConfigLoaderFn: {
            type: Function,
            required: !0
        },
        initKnimeService: {
            type: Function,
            required: !0
        },
        resourceLocationResolver: {
            type: Function,
            required: !0
        },
        loadOnMount: {
            type: Boolean,
        default:
            !0
        },
        overrideComponentName: {
            type: [String, null],
        default:
            null
        }
    },
    emits: {
        stateChange: e => !0
    },
    data() {
        return {
            componentName: null,
            initialData: null,
            getKnimeService: null
        }
    },
    watch: {
        componentName(e) {
            if (e && !this.$options.components[e])
                throw new Error(`Component ${e} hasn't been loaded properly`)
        },
        async renderKey() {
            await this.loadView()
        }
    },
    async mounted() {
        this.loadOnMount && await this.loadView()
    },
    unmounted() {
        Q_ = null
    },
    methods: {
        async loadView() {
            let e = this.renderKey;
            Q_ = e,
            this.$emit("stateChange", {
                state: "loading",
                portKey: e
            }),
            this.initialData = null,
            this.componentName = null;
            try {
                const t = await this.viewConfigLoaderFn();
                if (e !== Q_)
                    return;
                const n = t.resourceInfo.type;
                if (n === "HTML")
                    this.initialData = {
                        src: this.resourceLocationResolver(t),
                        style: t.iframeStyle
                    },
                this.componentName = "IFramePortView";
                else if (n === "VUE_COMPONENT_LIB")
                    this.componentName = await this.renderDynamicViewComponent(t);
                else
                    throw new Error("unknown resource type");
                this.$emit("stateChange", {
                    state: "ready",
                    portKey: e
                })
            } catch (t) {
                this.$emit("stateChange", {
                    state: "error",
                    message: t,
                    portKey: e
                })
            }
        },
        async renderDynamicViewComponent(e) {
            const t = this.initKnimeService(e);
            return this.getKnimeService = () => t,
            await this.setupDynamicComponent(e),
            e.initialData && (this.initialData = JSON.parse(e.initialData).result),
            this.overrideComponentName || e.resourceInfo.id
        },
        async setupDynamicComponent(e) {
            const {
                resourceInfo: t
            } = e,
            n = this.resourceLocationResolver({
                resourceInfo: t
            }),
            r = this.overrideComponentName || t.id,
            o = await M7({
                resourceLocation: n,
                componentName: r
            });
            this.$options.components[r] = o
        }
    }
});
function V1e(e, t, n, r, o, i) {
    return e.componentName ? (_(), H(Kt(e.componentName), {
            key: 0,
            "initial-data": e.initialData
        }, null, 8, ["initial-data"])) : J("", !0)
}
const F1e = te(B1e, [["render", V1e]]), j1e = Fe({
    components: {
        ViewLoader: F1e
    },
    props: {
        projectId: {
            type: String,
            required: !0
        },
        workflowId: {
            type: String,
            required: !0
        },
        selectedNode: {
            type: Object,
            required: !0
        },
        selectedPortIndex: {
            type: Number,
            required: !0
        },
        selectedViewIndex: {
            type: Number,
            required: !0
        },
        uniquePortKey: {
            type: String,
            required: !0
        }
    },
    emits: ["stateChange"],
    data() {
        return {
            error: null
        }
    },
    watch: {
        uniquePortKey() {
            this.error = null
        }
    },
    methods: {
        async viewConfigLoaderFn() {
            const e = await Oe.port.getPortView({
                projectId: this.projectId,
                workflowId: this.workflowId,
                nodeId: this.selectedNode.id,
                portIdx: this.selectedPortIndex,
                viewIdx: this.selectedViewIndex
            });
            return this.modifyPortViewSettings(e),
            e
        },
        modifyPortViewSettings(e) {
            if (typeof e != "object" || typeof e == "object" && !("initialData" in e) || !e.initialData || typeof e.initialData != "string")
                return;
            const t = JSON.parse(e.initialData),
            n = t?.result?.settings;
            n?.selectionMode === "EDIT" && (n.selectionMode = "OFF", e.initialData = JSON.stringify(t))
        },
        resourceLocationResolver({
            resourceInfo: e
        }) {
            return this.$store.getters["api/uiExtResourceLocation"]({
                resourceInfo: e
            })
        },
        onStateChange(e) {
            this.uniquePortKey === e.portKey && this.$emit("stateChange", e)
        },
        initKnimeService(e) {
            return new vI(e, async(t, n, r) => {
                const o = await Oe.port.callPortDataService({
                    projectId: this.projectId,
                    workflowId: this.workflowId,
                    nodeId: this.selectedNode.id,
                    portIdx: this.selectedPortIndex,
                    viewIdx: this.selectedViewIndex,
                    serviceType: n,
                    dataServiceRequest: r
                });
                return {
                    result: JSON.parse(o)
                }
            }, t => (consola.warn("Notifications not yet implemented"), this.error = t.alert.subtitle, this.$emit("stateChange", {
                        state: "error",
                        message: this.error
                    }), Promise.resolve("")))
        }
    }
});
function W1e(e, t, n, r, o, i) {
    const s = B("ViewLoader");
    return e.error ? J("", !0) : (_(), H(s, {
            key: 0,
            "render-key": e.uniquePortKey,
            "init-knime-service": e.initKnimeService,
            "view-config-loader-fn": e.viewConfigLoaderFn,
            "resource-location-resolver": e.resourceLocationResolver,
            onStateChange: e.onStateChange
        }, null, 8, ["render-key", "init-knime-service", "view-config-loader-fn", "resource-location-resolver", "onStateChange"]))
}
const z1e = te(j1e, [["render", W1e]]), P7 = ({
    portTypes: e,
    port: t
}) => e[t.typeId], yI = ({
    portTypes: e,
    port: t
}) => {
    const {
        kind: n
    } = P7({
        portTypes: e,
        port: t
    });
    return n === "flowVariable"
}, E7 = ({
    portTypes: e,
    port: t
}) => {
    try {
        const {
            views: n
        } = P7({
            portTypes: e,
            port: t
        });
        return Boolean(n) || yI({
            portTypes: e,
            port: t
        })
    } catch {
        return !1
    }
}, H1e = (e, t) => e.isDragging ? {
    error: {
        type: "NODE",
        code: "NODE_DRAGGING",
        message: "Node output will be loaded after moving is completed"
    }
}
 : t(e), U1e = (e, t) => {
    const {
        selectedNodes: n
    } = e;
    if (!n)
        return t(e);
    if (n.length === 0)
        return {
            error: {
                type: "NODE",
                code: "NO_NODE_SELECTED",
                message: "要显示节点输出，请选择已配置或执行的节点."
            }
        };
    if (n.length > 1)
        return {
            error: {
                type: "NODE",
                code: "MULTIPLE_NODES_SELECTED",
                message: "要显示节点输出，请仅选择一个节点."
            }
        };
    const r = n[0];
    return t({
        ...e,
        selectedNode: r
    })
}, q1e = (e, t) => {
    const {
        selectedNode: n,
        portTypes: r
    } = e;
    return !n || !r ? t(e) : n.outPorts.length > 0 ? n.outPorts.some(i => E7({
            portTypes: r,
            port: i
        })) ? t(e) : {
        error: {
            type: "NODE",
            code: "NO_SUPPORTED_PORTS",
            message: "所选节点没有支持的输出端口."
        }
    }
     : {
        error: {
            type: "NODE",
            code: "NO_OUTPUT_PORTS",
            message: "所选节点没有输出端口."
        }
    }
}, Y1e = (e, t) => {
    const {
        selectedNode: n,
        selectedPortIndex: r
    } = e;
    if (!n)
        return t(e);
    const o = n.outPorts[r];
    return !o || r === void 0 || r === null ? {
        error: {
            type: "PORT",
            code: "NO_PORT_SELECTED",
            message: "未选择端口"
        }
    }
     : t({
        ...e,
        selectedPort: o
    })
}, K1e = (e, t) => {
    const {
        selectedPort: n,
        portTypes: r
    } = e;
    return !n || !r ? t(e) : n.inactive ? {
        error: {
            type: "PORT",
            code: "PORT_INACTIVE",
            message: "此输出端口处于非活动状态，因此没有可用于显示的输出数据."
        }
    }
     : E7({
        portTypes: r,
        port: n
    }) ? n.portContentVersion === void 0 ? {
        error: {
            type: "PORT",
            code: "NO_DATA",
            message: "此输出端口没有要显示的数据"
        }
    }
     : t(e) : {
        error: {
            type: "PORT",
            code: "NO_SUPPORTED_VIEW",
            message: "任何现代查看器都不支持输出端口上的数据."
        }
    }
}, O7 = (e, t) => {
    const {
        selectedNode: n,
        selectedPort: r,
        portTypes: o,
        selectedPortIndex: i
    } = e;
    if (!n)
        return t(e);
    const s = (l, c) => l && !yI({
        portTypes: o,
        port: c
    }) ? {
        error: {
            type: "NODE",
            code: "NODE_UNCONFIGURED",
            message: "请先配置所选节点."
        }
    }
     : t(e);
    if (n.kind === "metanode") {
        const l = n.outPorts[i],
        c = l.nodeState === "IDLE";
        return s(c, l)
    }
    const a = n.state?.executionState === "IDLE";
    return s(a, r)
}, $7 = (e, t) => {
    const {
        selectedPort: n,
        selectedNode: r,
        portTypes: o
    } = e;
    if (yI({
            portTypes: o,
            port: n
        }))
        return t(e);
    const i = r.state.executionState;
    return i === "QUEUED" || i === "EXECUTING" ? {
        error: {
            type: "NODE",
            code: "NODE_BUSY",
            message: "输出在执行后可用."
        }
    }
     : t(e)
}, wI = (...e) => t => {
    const n = i => (s, a) => l => i({
        ...s,
        ...l
    }, a),
    r = i => i;
    return e.map(n).reduceRight((i, s) => s(t, i), r)
}, G1e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, X1e = P("path", {
    "stroke-linejoin": "round",
    d: "M27.5 24.25v4h-25V7.5h5"
}, null, -1), J1e = P("path", {
    "stroke-linejoin": "round",
    d: "M11 4h19v16H11z"
}, null, -1), Z1e = [X1e, J1e];
function Q1e(e, t) {
    return _(),
    O("svg", G1e, Z1e)
}
const B$ = {
    render: Q1e
};
let V$ = 0;
const ewe = Fe({
    props: {
        id: {
            type: String,
        default:
            null
        },
        modelValue: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e) ? e.every(t => t.hasOwnProperty("id") && t.hasOwnProperty("text")) : !1
            }
        }
    },
    emits: ["update:modelValue"],
    computed: {
        inputName() {
            return this.name || `wc-radio-${this.count}`
        }
    },
    beforeCreate() {
        V$ += 1,
        this.count = V$
    },
    methods: {
        onInput(e) {
            const t = e.target.value;
            this.$emit("update:modelValue", t)
        }
    }
});
const twe = e => (ir("data-v-395cde0f"), e = e(), sr(), e), nwe = ["id"], rwe = ["checked", "value", "name", "disabled"], owe = ["title"], iwe = twe(() => P("br", null, null, -1));
function swe(e, t, n, r, o, i) {
    return _(),
    O("div", {
        id: e.id,
        role: "radiogroup"
    }, [(_(!0), O(Le, null, $t(e.possibleValues, s => (_(), O("label", {
                                key: `radio-${s.id}`,
                                class: "radio-group-label"
                            }, [P("input", {
                                        ref_for: !0,
                                        ref: "input",
                                        checked: e.modelValue === s.id,
                                        value: s.id,
                                        name: e.inputName,
                                        disabled: e.disabled || s.disabled,
                                        type: "radio",
                                        onChange: t[0] || (t[0] = (...a) => e.onInput && e.onInput(...a))
                                    }, null, 40, rwe), P("span", {
                                        title: s.text
                                    }, Re(s.text), 9, owe), Ye(e.$slots, "default", {
                                        item: s
                                    }, void 0, !0), s.subtext ? (_(), O(Le, {
                                            key: 0
                                        }, [iwe, P("span", null, Re(s.subtext), 1)], 64)) : J("", !0)]))), 128))], 8, nwe)
}
const A7 = te(ewe, [["render", swe], ["__scopeId", "data-v-395cde0f"]]), awe = Fe({
    components: {
        BaseRadioButtons: A7
    },
    props: {
        id: {
            type: String,
        default:
            null
        },
        modelValue: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        possibleValues: {
            type: Array,
        default:
            () => []
        },
        compact: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["update:modelValue"]
});
function lwe(e, t, n, r, o, i) {
    const s = B("BaseRadioButtons");
    return _(),
    H(s, {
        id: e.id,
        ref: "radioButton",
        "possible-values": e.possibleValues,
        "model-value": e.modelValue,
        name: e.name,
        disabled: e.disabled,
        class: he(["value-switch", {
                    disabled: e.disabled,
                    compact: e.compact,
                    normal: !e.compact
                }
            ]),
        "onUpdate:modelValue": t[0] || (t[0] = a => e.$emit("update:modelValue", a))
    }, {
    default:
        oe(a => [Ye(e.$slots, "default", wu(tc(a)), void 0, !0)]),
        _: 3
    }, 8, ["id", "possible-values", "model-value", "name", "disabled", "class"])
}
const cwe = te(awe, [["render", lwe], ["__scopeId", "data-v-4f75205f"]]), uwe = (e, t) => rh(e) ? e.outPorts[t].nodeState === j0.NodeStateEnum.CONFIGURED ? "configured" : "executed" : e.state.executionState === Wk.ExecutionStateEnum.CONFIGURED ? "configured" : "executed", D7 = (e, t, n) => {
    const r = uwe(t, n),
    o = e.descriptorMapping[r],
    i = s => !s.isSpecView && r === "configured";
    return o.map(s => {
        const a = e.descriptors.at(s);
        return {
            id: s.toString(),
            text: a.label,
            disabled: i(a),
            canDetach: !a.isSpecView
        }
    })
}, dwe = e => (ir("data-v-788d9553"), e = e(), sr(), e), fwe = {
    class: "tab-toggles"
}, hwe = dwe(() => P("span", null, "Open in new window", -1)), pwe = Fe({
    __name: "PortViewTabToggles",
    props: {
        uniquePortKey: {},
        viewDescriptors: {},
        viewDescriptorMapping: {},
        selectedNode: {},
        selectedPortIndex: {}
    },
    emits: ["openViewInNewWindow"],
    setup(e, {
        emit: t
    }) {
        const n = e,
        r = De(null),
        o = ne(() => D7({
                    descriptors: n.viewDescriptors,
                    descriptorMapping: n.viewDescriptorMapping
                }, n.selectedNode, n.selectedPortIndex)),
        i = () => {
            r.value = o.value.at(0) ? Number(o.value.at(0).id) : null
        };
        Ht(ca(n, "uniquePortKey"), () => {
            i()
        }),
        Ur(() => {
            i()
        });
        const s = (a = null) => {
            const l = a === null ? r.value : Number(a.id);
            t("openViewInNewWindow", l)
        };
        return (a, l) => (_(), O(Le, null, [P("div", fwe, [o.value.length > 1 ? (_(), H(cwe, {
                                    key: 0,
                                    ref_key: "tabToggles",
                                    ref: o,
                                    class: "value-switch",
                                    compact: "",
                                    "model-value": r.value === null ? null : r.value.toString(),
                                    "possible-values": o.value,
                                    "onUpdate:modelValue": l[0] || (l[0] = c => r.value = Number(c))
                                }, tC({
                                        _: 2
                                    }, [ke(Xae).canDetachPortViews() ? {
                                                name: "default",
                                                fn: oe(({
                                                        item: c
                                                    }) => [z(Pr, {
                                                            class: "open-window",
                                                            disabled: !c.canDetach || c.disabled,
                                                            title: `Open ${c.text} view in new window`,
                                                            onClick: u => s(c)
                                                        }, {
                                                        default:
                                                            oe(() => [z(ke(B$))]),
                                                            _: 2
                                                        }, 1032, ["disabled", "title", "onClick"])]),
                                                key: "0"
                                            }
                                             : void 0]), 1032, ["model-value", "possible-values"])) : (_(), H(Pr, {
                                    key: 1,
                                    "with-border": "",
                                    class: "fallback-open-window",
                                    title: "Open port view in new window",
                                    onClick: l[1] || (l[1] = c => s(null))
                                }, {
                                default:
                                    oe(() => [z(ke(B$)), hwe]),
                                    _: 1
                                }))]), Ye(a.$slots, "default", {
                        activeView: r.value
                    }, void 0, !0)], 64))
    }
});
const mwe = te(pwe, [["__scopeId", "data-v-788d9553"]]), gwe = ({
    selectedNode: e,
    portTypes: t,
    selectedPortIndex: n
}) => {
    const o = wI(q1e, Y1e, K1e, O7, $7)({
        selectedNode: e,
        portTypes: t,
        selectedPortIndex: n
    })();
    return Object.freeze(o)
}, bI = Fe({
    components: {
        PortViewLoader: z1e,
        PortViewTabToggles: mwe,
        Button: Pr,
        PlayIcon: b7
    },
    inheritAttrs: !1,
    props: {
        projectId: {
            type: String,
            required: !1,
        default:
            "Missing project ID"
        },
        workflowId: {
            type: String,
            required: !0
        },
        selectedNode: {
            type: Object,
            required: !0
        },
        selectedPortIndex: {
            type: Number,
            required: !0
        },
        availablePortTypes: {
            type: Object,
            required: !0
        }
    },
    emits: {
        outputStateChange: e => !0,
        executeNode: () => !0
    },
    data() {
        return {
            portViewState: null
        }
    },
    computed: {
        ...ut("application", ["permissions"]),
        uniquePortKey() {
            const {
                portContentVersion: e
            } = this.selectedNode.outPorts[this.selectedPortIndex];
            return [this.projectId, this.workflowId, this.selectedNode.id, this.selectedPortIndex, e].join("/")
        },
        hasNoDataValidationError() {
            return this.validationError && this.validationError.code === "NO_DATA"
        },
        validationError() {
            const {
                error: e
            } = gwe({
                selectedNode: this.selectedNode,
                portTypes: this.availablePortTypes,
                selectedPortIndex: this.selectedPortIndex
            });
            return e || null
        },
        selectedPort() {
            return this.validationError ? null : this.selectedNode.outPorts[this.selectedPortIndex]
        },
        fullPortObject() {
            return ri(this.availablePortTypes)(this.selectedPort.typeId)
        },
        portViews() {
            return this.fullPortObject.views
        },
        shouldShowExecuteAction() {
            if (!this.permissions.canEditWorkflow || this.validationError && !this.hasNoDataValidationError)
                return !1;
            const e = x7(this.selectedNode, this.selectedPortIndex);
            if (this.hasNoDataValidationError)
                return e;
            const t = this.fullPortObject.kind === "flowVariable";
            return e && !t
        }
    },
    watch: {
        validationError: {
            immediate: !0,
            handler() {
                this.validationError ? this.$emit("outputStateChange", {
                    loading: this.validationError.code === "NODE_BUSY",
                    message: this.validationError.message,
                    error: this.validationError
                }) : this.$emit("outputStateChange", null)
            }
        }
    },
    methods: {
        onPortViewLoaderStateChange(e) {
            switch (this.portViewState = e, this.portViewState?.state) {
            case "loading": {
                    this.$emit("outputStateChange", {
                        message: "Loading data",
                        loading: !0
                    });
                    return
                }
            case "error": {
                    this.$emit("outputStateChange", {
                        message: this.portViewState.message
                    });
                    return
                }
            default:
                this.$emit("outputStateChange", null)
            }
        },
        openViewInNewWindow(e) {
            Oe.desktop.openPortView({
                projectId: this.projectId,
                nodeId: this.selectedNode.id,
                viewIndex: e,
                portIndex: this.selectedPortIndex
            })
        }
    }
}), F$ = () => {
    to(e => ({
            "600549b6": e.hasNoDataValidationError ? 0 : "130px"
        }))
}, j$ = bI.setup;
bI.setup = j$ ? (e, t) => (F$(), j$(e, t)) : F$;
const vwe = e => (ir("data-v-df2334ee"), e = e(), sr(), e), ywe = {
    key: 1,
    class: "execute-node-action"
}, wwe = vwe(() => P("span", null, "To show the output, please execute the selected node.", -1));
function bwe(e, t, n, r, o, i) {
    const s = B("PortViewLoader"),
    a = B("PortViewTabToggles"),
    l = B("PlayIcon"),
    c = B("Button");
    return _(),
    O(Le, null, [e.validationError ? J("", !0) : (_(), H(a, {
                    key: 0,
                    "selected-node": e.selectedNode,
                    "selected-port-index": e.selectedPortIndex,
                    "unique-port-key": e.uniquePortKey,
                    "view-descriptors": e.portViews.descriptors,
                    "view-descriptor-mapping": e.portViews.descriptorMapping,
                    onOpenViewInNewWindow: e.openViewInNewWindow
                }, {
                default:
                    oe(({
                            activeView: u
                        }) => [!e.validationError && u !== null ? (_(), H(s, Bt({
                                        key: 0
                                    }, e.$attrs, {
                                        "unique-port-key": `${e.uniquePortKey}/${u}`,
                                        "project-id": e.projectId,
                                        "workflow-id": e.workflowId,
                                        "selected-node": e.selectedNode,
                                        "selected-port-index": e.selectedPortIndex,
                                        "selected-view-index": u,
                                        onStateChange: e.onPortViewLoaderStateChange
                                    }), null, 16, ["unique-port-key", "project-id", "workflow-id", "selected-node", "selected-port-index", "selected-view-index", "onStateChange"])) : J("", !0)]),
                    _: 1
                }, 8, ["selected-node", "selected-port-index", "unique-port-key", "view-descriptors", "view-descriptor-mapping", "onOpenViewInNewWindow"])), e.shouldShowExecuteAction ? (_(), O("div", ywe, [wwe, z(c, {
                            class: "action-button",
                            primary: "",
                            compact: "",
                            onClick: t[0] || (t[0] = u => e.$emit("executeNode"))
                        }, {
                        default:
                            oe(() => [z(l), mt(" Execute ")]),
                            _: 1
                        })])) : J("", !0)], 64)
}
const _we = te(bI, [["render", bwe], ["__scopeId", "data-v-df2334ee"]]), bx = (e, t) => {
    if (typeof t == "string" && (t = t.split(".")), t.length > 1) {
        let n = t.shift();
        return typeof e[n] > "u" ? null : bx(e[n], t)
    } else
        return e[t[0]]
}, N7 = (e, t, n) => {
    if (typeof t == "string" && (t = t.split(".")), t.length > 1) {
        let r = t.shift();
        e[r] = typeof e[r] == "object" ? e[r] : {},
        N7(e[r], t, n)
    } else {
        if (typeof e[t[0]] > "u")
            throw Error("Provided key does not exist!");
        e[t[0]] = n
    }
}, kwe = e => (e?.viewRepresentation?.required && (e.viewRepresentation.required = !1), e);
let _x = ({
    columns: e
}, t) => e.forEach(({
        content: n
    }) => n.forEach(r => {
        let {
            type: o,
            nodeID: i,
            layout: s
        } = r;
        ["row", "JSONLayoutRow"].includes(o) ? _x(r, t) : ["nestedLayout", "JSONLayoutHTMLContent"].includes(o) ? s?.rows?.forEach(a => _x(a, t)) : i && t.push(i)
    }));
function W$(e) {
    let {
        rows: t
    } = e?.wizardPageContent?.webNodePageConfiguration?.layout || {},
    n = [];
    return t?.forEach(r => _x(r, n)),
    n
}
const xwe = e => {
    const t = document.querySelector("#knime-layout").cloneNode(!0);
    t.querySelectorAll(".reporting-replaceable").forEach(r => {
        const o = r.getAttribute("node-id");
        e[o] && r.replaceChildren(new DOMParser().parseFromString(e[o], "text/html").body.firstChild)
    });
    let n = "";
    for (const r of document.styleSheets) {
        n += "<style>";
        for (const o of r.cssRules)
            n += o.cssText;
        n += `</style>
`
    }
    return n += t.outerHTML,
    n
}, Swe = !0, Cwe = () => ({
    page: null,
    isDialogLayout: !1,
    isReporting: !1,
    generatedReportActionId: null,
    isWebNode: !1,
    resourceBaseUrl: "",
    webNodesLoading: [],
    pageValueGetters: {},
    pageValidators: {},
    pageValidationErrorSetters: {},
    nodesReExecuting: [],
    reExecutionUpdates: 0,
    reportingContent: {},
    imageGenerationWaiting: []
}), Iwe = {
    nodesReExecuting: e => e.nodesReExecuting,
    reExecutionUpdates: e => e.reExecutionUpdates
}, Twe = {
    setPage(e, t) {
        e.page = t,
        e.reportingContent = {},
        e.imageGenerationWaiting = [];
        const n = t?.wizardPageContent?.webNodes;
        typeof n == "object" && (e.pageValidators = {}, e.pageValueGetters = {}),
        e.isDialogLayout = Boolean(t?.wizardPageContent?.nodeViews?.DIALOG),
        e.generatedReportActionId = t?.wizardPageContent?.webNodePageConfiguration?.generatedReportActionId,
        e.isReporting = Boolean(e.generatedReportActionId),
        e.isWebNode = Boolean(n && Object.keys(n).length)
    },
    setResourceBaseUrl(e, t) {
        e.resourceBaseUrl = t
    },
    updateViewConfig(e, {
        nodeId: t,
        update: n,
        config: r,
        type: o,
        viewType: i = "webNodes"
    } = {}) {
        if (n) {
            let s = e.page.wizardPageContent[i][t];
            for (let [a, l] of Object.entries(n))
                try {
                    N7(s, a, l)
                } catch {
                    consola.error(`WebNode[type: ${o}, id: ${t}]: Value not updated because the provided key was invalid. Key:`, a)
                }
            return
        }
        consola.debug("pagebuilder/updateWebNode replacing web node content."),
        e.page.wizardPageContent[i][t] = kwe(r)
    },
    setWebNodeLoading(e, {
        nodeId: t,
        loading: n
    }) {
        let r = e.webNodesLoading.indexOf(t);
        r === -1 && n ? e.webNodesLoading.push(t) : r >= 0 && !n && e.webNodesLoading.splice(r, 1)
    },
    addValueGetter(e, {
        nodeId: t,
        valueGetter: n
    }) {
        e.pageValueGetters[t] = n
    },
    removeValueGetter(e, t) {
        delete e.pageValueGetters[t]
    },
    addValidator(e, {
        nodeId: t,
        validator: n
    }) {
        e.pageValidators[t] = n
    },
    removeValidator(e, t) {
        delete e.pageValidators[t]
    },
    addValidationErrorSetter(e, {
        nodeId: t,
        errorSetter: n
    }) {
        e.pageValidationErrorSetters[t] = n
    },
    removeValidationErrorSetter(e, t) {
        delete e.pageValidationErrorSetters[t]
    },
    setNodesReExecuting(e, t) {
        t === !0 ? t = Object.keys(e.page?.wizardPageContent?.webNodes || {}) : t?.length || (t = []);
        let n = t.length !== e.nodesReExecuting.length,
        r = t.some(o => e.nodesReExecuting.indexOf(o) < 0);
        (n || r) && (e.nodesReExecuting = t),
        e.reExecutionUpdates = t?.length ? e.reExecutionUpdates + 1 : 0
    },
    setReportingContent(e, {
        nodeId: t,
        reportingContent: n
    }) {
        e.reportingContent[t] = n
    },
    addImageGenerationWaiting(e, {
        nodeId: t
    }) {
        e.imageGenerationWaiting.push(t)
    }
}, Mwe = {
    setPage({
        state: e,
        commit: t,
        dispatch: n
    }, {
        page: r
    }) {
        consola.trace("PageBuilder: Set page via action: ", r),
        t("setPage", r),
        e.isReporting && (t("addImageGenerationWaiting", {
                nodeId: "layout"
            }), Object.keys(r?.wizardPageContent?.webNodes).forEach(o => {
                t("addImageGenerationWaiting", {
                    nodeId: o
                })
            }), Object.keys(r?.wizardPageContent?.nodeViews).forEach(o => {
                t("addImageGenerationWaiting", {
                    nodeId: o
                })
            })),
        n("interactivity/clear"),
        r?.wizardPageContent && r.wizardPageContent.webNodePageConfiguration?.selectionTranslators?.forEach(i => {
            n("interactivity/registerSelectionTranslator", {
                translator: i
            })
        })
    },
    updatePage({
        commit: e,
        dispatch: t,
        state: n
    }, {
        page: r = {},
        nodeIds: o
    }) {
        consola.trace("PageBuilder: Update page via action: ", r);
        let {
            webNodes: i,
            nodeViews: s,
            webNodePageConfiguration: a
        } = r?.wizardPageContent || r;
        o.forEach(f => {
            let p = {
                nodeId: f,
                config: i?.[f]
            };
            (s?.[f] || n.page.wizardPageContent.nodeViews?.[f]) && (p.config = s?.[f], p.viewType = "nodeViews"),
            e("updateViewConfig", p)
        });
        let {
            selectionTranslators: l
        } = a || {};
        l && t("interactivity/updateSelectionTranslators", {
            translators: l
        });
        let c = W$(n.page);
        W$(r).some(f => !c.includes(f)) && t("alert/showAlert", {
            type: "warn",
            message: "Currently, nodes are missing from the composite view layout. That could interfere with reactive nodes."
        })
    },
    updateNodeViewConfig({
        commit: e,
        dispatch: t
    }, {
        nodeView: n
    }) {
        e("updateViewConfig", {
            viewType: "nodeViews",
            update: n,
            nodeId: "VIEW"
        }),
        t("pagebuilder/dialog/cleanSettings", null, {
            root: !0
        })
    },
    setResourceBaseUrl({
        commit: e
    }, {
        resourceBaseUrl: t
    }) {
        consola.trace("PageBuilder: Set resourceBaseUrl via action:", t),
        e("setResourceBaseUrl", t)
    },
    updateWebNode({
        commit: e
    }, t) {
        consola.trace(`WebNode[type: ${t.type}, id: ${t.nodeId}]: Updated value via action:`, t),
        e("updateViewConfig", t)
    },
    setWebNodeLoading({
        commit: e
    }, {
        nodeId: t,
        loading: n
    }) {
        consola.trace(`PageBuilder: setting loading state of ${t} via action: `, n),
        e("setWebNodeLoading", {
            nodeId: t,
            loading: n
        })
    },
    addValueGetter({
        commit: e
    }, {
        nodeId: t,
        valueGetter: n
    }) {
        consola.trace("PageBuilder: add value getter via action: ", t),
        e("addValueGetter", {
            nodeId: t,
            valueGetter: n
        })
    },
    removeValueGetter({
        commit: e
    }, {
        nodeId: t
    }) {
        consola.trace("PageBuilder: remove value getter via action: ", t),
        e("removeValueGetter", t)
    },
    async getViewValues({
        state: e
    }) {
        let t = Object.values(e.pageValueGetters).map(r => r());
        return await Promise.all(t).then(r => r.reduce((o, i) => (o[i.nodeId] = i.value, o), {})).catch(r => (consola.error(`Could not retrieve all view values: ${r}`), {}))
    },
    addValidator({
        commit: e
    }, {
        nodeId: t,
        validator: n
    }) {
        consola.trace("PageBuilder: add validator via action: ", t),
        e("addValidator", {
            nodeId: t,
            validator: n
        })
    },
    removeValidator({
        commit: e
    }, {
        nodeId: t
    }) {
        consola.trace("PageBuilder: remove validator via action: ", t),
        e("removeValidator", t)
    },
    async getValidity({
        state: e
    }) {
        let t = Object.values(e.pageValidators).map(r => r());
        return await Promise.all(t).then(r => r.reduce((o, i) => (o[i.nodeId] = i.isValid, o), {})).catch(r => (consola.error(`Page validation failed: ${r}`), {}))
    },
    addValidationErrorSetter({
        commit: e
    }, {
        nodeId: t,
        errorSetter: n
    }) {
        consola.trace("PageBuilder: add validation error setter via action: ", t),
        e("addValidationErrorSetter", {
            nodeId: t,
            errorSetter: n
        })
    },
    removeValidationErrorSetter({
        commit: e
    }, {
        nodeId: t
    }) {
        consola.trace("PageBuilder: remove validation error setter via action: ", t),
        e("removeValidationErrorSetter", t)
    },
    setValidationErrors({
        state: e
    }, {
        page: t
    }) {
        const n = [];
        for (const r in t) {
            let o = t[r].error || t[r];
            typeof e.pageValidationErrorSetters[r] == "function" && n.push(e.pageValidationErrorSetters[r](o))
        }
        return Promise.all(n).then(() => !0).catch(() => !1)
    },
    triggerReExecution({
        dispatch: e
    }, {
        nodeId: t
    }) {
        try {
            consola.debug(`Pagebuilder: re-execution triggered by node ${t}`),
            e("api/triggerReExecution", {
                nodeId: t
            }, {
                root: !0
            })
        } catch {
            consola.debug("Pagebuilder: re-execution failed.")
        }
    },
    setNodesReExecuting({
        commit: e
    }, t) {
        consola.debug("PageBuilder: setting re-executing nodes via action: ", t),
        e("setNodesReExecuting", t)
    },
    setReportingContent({
        state: e,
        commit: t
    }, {
        nodeId: n,
        reportingContent: r
    }) {
        if (t("setReportingContent", {
                nodeId: n,
                reportingContent: r
            }), e.imageGenerationWaiting.splice(e.imageGenerationWaiting.indexOf(n), 1), e.imageGenerationWaiting.length === 0) {
            let o = xwe(e.reportingContent);
            o = decodeURIComponent(encodeURIComponent(o)),
            window.EquoCommService.send(e.generatedReportActionId, o)
        }
    }
}, Pwe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: Mwe,
            getters: Iwe,
            mutations: Twe,
            namespaced: Swe,
            state: Cwe
        }, Symbol.toStringTag, {
            value: "Module"
        })), Ewe = !0, iy = (e, {
    id: t,
    subscriberOnly: n
}) => {
    e[t] || (e[t] = {
            subscribers: []
        }),
    !n && !e[t].data && (e[t].data = {
            elements: []
        })
}, R7 = (e, {
    id: t,
    filterIds: n,
    changedIds: r
}) => {
    let o;
    if (e[t] && (o = e[t].data), !o || !n)
        return o;
    if (r && !n.some(s => r.includes(s)))
        return null;
    let i = o.elements.filter(s => n.includes(s.id));
    return {
        selectionMethod: o.selectionMethod,
        elements: i
    }
}, z$ = (e, {
    id: t,
    data: n,
    skipCallback: r,
    changedIds: o
}) => {
    if (e[t]) {
        let i = [];
        e[t].subscribers.forEach((s, a) => {
            if (!r || s.callback !== r) {
                let l = n;
                if (o && (l = R7(e, {
                            id: t,
                            filterIds: s.filterIds,
                            changedIds: o
                        })), l)
                    try {
                        s.callback(t, l)
                    } catch {
                        i.push(a)
                    }
            }
        }),
        i.reverse().forEach(s => e[t].subscribers.splice(s, 1))
    }
}, Owe = (e, {
    id: t,
    data: n
}) => {
    let r = [];
    return n.elements.forEach(o => {
        if (typeof o.id < "u")
            if (e[t] && e[t].data) {
                let i = e[t].data.elements.filter(s => o.id === s.id);
                (!i.length || JSON.stringify(o) !== JSON.stringify(i[0])) && r.push(o.id)
            } else
                r.push(o.id)
    }),
    r
}, $we = (e, {
    id: t,
    rowsToRemove: n
}) => {
    let r = [],
    o = e[t].data,
    i = o.elements.length;
    for (; i--; ) {
        let s = o.elements[i].rows || [],
        a = s.filter(l => !n.includes(l));
        r = r.concat(n.filter(l => s.includes(l))),
        a.length < 1 ? o.elements.splice(i, 1) : o.elements[i].rows = a
    }
    return r
}, Awe = (e, {
    id: t,
    rowsToRemove: n
}) => {
    let r = e[t].data,
    o = r.partial.filter(s => !n.includes(s)),
    i = n.filter(s => r.partial.includes(s));
    return o.length < 1 ? delete r.partial : r.partial = o,
    i
}, Dwe = (e, {
    id: t,
    rowsToAdd: n
}) => {
    let r = [],
    o = e[t].data;
    (!o.elements || o.elements.length < 1) && (o.elements = [{
                type: "row",
                rows: []
            }
        ]);
    for (let i of o.elements)
        if (typeof i.id > "u") {
            let s = i.rows || [];
            r = n.filter(a => !s.includes(a)),
            i.rows = s.concat(r);
            break
        }
    return r
}, Nwe = (e, {
    id: t,
    rowsToAdd: n
}) => {
    let r = e[t].data,
    o = r.partial || [],
    i = n.filter(s => !o.includes(s));
    return !r.partial && i.length > 0 && (r.partial = []),
    r.partial = r.partial.concat(i),
    i
}, Rwe = ({
    data: e,
    addedRows: t,
    removedRows: n,
    partialAddedRows: r,
    partialRemovedRows: o
}) => {
    if (Boolean(n.length + t.length + o.length + r.length)) {
        let s = {
            selectionMethod: e.selectionMethod,
            changeSet: {}
        };
        return n.length && (s.changeSet.removed = n),
        t.length && (s.changeSet.added = t),
        o.length && (s.changeSet.partialRemoved = o),
        r.length && (s.changeSet.partialAdded = r),
        typeof e.mappedEvent < "u" && (s.mappedEvent = e.mappedEvent),
        s
    } else
        return null
}, Lwe = (e, {
    id: t,
    data: n
}) => {
    let r = n.changeSet.added && n.changeSet.added.length,
    o = n.changeSet.partialAdded && n.changeSet.partialAdded.length;
    if (!e[t] || !e[t].data)
        if (r || o)
            iy(e, {
                id: t
            }), e[t].data.selectionMethod = n.selectionMethod, o && (e[t].data.partial = []);
        else
            return null;
    let i = n.changeSet.removed && n.changeSet.removed.length,
    s = n.changeSet.partialRemoved && n.changeSet.partialRemoved.length,
    a = e[t].data,
    l = [];
    a && a.elements && i && (l = $we(e, {
            id: t,
            rowsToRemove: n.changeSet.removed
        }));
    let c = [];
    a && a.partial && s && (c = Awe(e, {
            id: t,
            rowsToRemove: n.changeSet.partialRemoved
        }));
    let u = [];
    r && (u = Dwe(e, {
            id: t,
            rowsToAdd: n.changeSet.added
        }));
    let f = [];
    return o && (f = Nwe(e, {
            id: t,
            rowsToAdd: n.changeSet.partialAdded
        })),
    Rwe({
        data: n,
        addedRows: u,
        removedRows: l,
        partialAddedRows: f,
        partialRemovedRows: c
    })
}, kx = function (e) {
    let t = [];
    return e && e.elements && e.elements.forEach(n => {
        n.rows && (t = t.concat(n.rows))
    }),
    t
}, Bwe = function (e, {
    addedRows: t,
    removedRows: n,
    mapping: r,
    curElementTarget: o
}) {
    let i = kx(o);
    e.added = [],
    t.forEach(s => {
        if (r[s]) {
            let a = r[s].filter(l => !i.includes(l));
            e.added = e.added.concat(a)
        }
    }),
    e.removed = [],
    n.forEach(s => {
        if (r[s]) {
            let a = r[s].filter(l => i.includes(l));
            e.removed = e.removed.concat(a)
        }
    })
}, Vwe = function (e, {
    mapping: t,
    addedRows: n,
    removedRows: r,
    curElementSource: o,
    curElementTarget: i
}) {
    let s = kx(o),
    a = kx(i),
    l = [];
    e.added = [],
    e.removed = [];
    for (let u in t) {
        let f = t[u].every(y => a.includes(y)),
        p = t[u].some(y => a.includes(y));
        i && i.partial && (p = p || t[u].some(y => i.partial.includes(y)));
        let m = t[u].some(y => n.includes(y)),
        v = t[u].some(y => r.includes(y));
        f && m && !s.includes(u) && e.added.push(u),
        !f && v && s.includes(u) && e.removed.push(u),
        !f && p && l.push(u)
    }
    let c = [];
    o && o.partial && (c = o.partial),
    e.partialAdded = l.filter(u => !c.includes(u)),
    e.partialRemoved = c.filter(u => !l.includes(u))
}, Fwe = function (e, {
    mapping: t,
    sourceToTarget: n,
    curElementSource: r,
    curElementTarget: o
}) {
    if (!e || !e.changeSet)
        throw new Error("Selection event could not be mapped because no change set was present.");
    let i = {
        selectionMethod: "selection",
        changeSet: {}
    },
    s = [];
    e.changeSet && e.changeSet.added && (s = e.changeSet.added);
    let a = [];
    return e.changeSet && e.changeSet.removed && (a = e.changeSet.removed),
    e.changeSet && e.changeSet.partialRemoved && e.changeSet.partialRemoved.forEach(l => {
        s.includes(l) || a.push(l)
    }),
    n ? Bwe(i.changeSet, {
        addedRows: s,
        removedRows: a,
        mapping: t,
        curElementTarget: o
    }) : Vwe(i.changeSet, {
        mapping: t,
        addedRows: s,
        removedRows: a,
        curElementSource: r,
        curElementTarget: o
    }),
    i.changeSet.added && i.changeSet.added.length < 1 && delete i.changeSet.added,
    i.changeSet.removed && i.changeSet.removed.length < 1 && delete i.changeSet.removed,
    i.changeSet.partialAdded && i.changeSet.partialAdded.length < 1 && delete i.changeSet.partialAdded,
    i.changeSet.partialRemoved && i.changeSet.partialRemoved.length < 1 && delete i.changeSet.partialRemoved,
    i
}, L7 = function ({
    dispatch: e,
    getters: t
}, {
    data: n,
    translator: r,
    targetId: o,
    sourceToTarget: i,
    skipCallback: s
}) {
    let a = n;
    if (!r.forward && r.mapping) {
        let c = t.getPublishedData(`selection-${r.sourceID}`),
        u = t.getPublishedData(`selection-${o}`);
        if (a = Fwe(n, {
                mapping: r.mapping,
                sourceToTarget: i,
                curElementSource: c,
                curElementTarget: u
            }), !a)
            return
    }
    a.mappedEvent = r.sourceID;
    let l = i ? `selection-${o}` : `selection-${r.sourceID}`;
    e("publish", {
        id: l,
        data: a,
        skipCallback: s
    })
}, B7 = function ({
    dispatch: e,
    getters: t
}, {
    translator: n
}) {
    let r = (o, i) => {
        !i || i.mappedEvent === n.sourceID || n.targetIDs.forEach(s => {
            L7({
                dispatch: e,
                getters: t
            }, {
                data: i,
                translator: n,
                targetId: s,
                sourceToTarget: !0,
                skipCallback: r
            })
        })
    };
    return r
}, V7 = function ({
    dispatch: e,
    getters: t
}, {
    translator: n,
    targetId: r
}) {
    let o = (i, s) => {
        !s || s.mappedEvent === n.sourceID || L7({
            dispatch: e,
            getters: t
        }, {
            data: s,
            translator: n,
            targetId: r,
            sourceToTarget: !1,
            skipCallback: o
        })
    };
    return o
}, jwe = function ({
    dispatch: e,
    getters: t
}, {
    translator: n
}) {
    e("subscribe", {
        id: `selection-${n.sourceID}`,
        callback: B7({
            dispatch: e,
            getters: t
        }, {
            translator: n
        }),
        isTranslator: !0
    })
}, Wwe = function ({
    dispatch: e,
    getters: t
}, {
    translator: n,
    targetId: r
}) {
    e("subscribe", {
        id: `selection-${r}`,
        callback: V7({
            dispatch: e,
            getters: t
        }, {
            translator: n,
            targetId: r
        }),
        isTranslator: !0
    })
}, zwe = function ({
    dispatch: e,
    commit: t,
    getters: n
}, {
    translator: r,
    clear: o
}) {
    t("updateSubscriber", {
        id: `selection-${r.sourceID}`,
        callback: B7({
            dispatch: e,
            getters: n
        }, {
            translator: r
        }),
        isTranslator: !0,
        clear: o
    })
}, Hwe = function ({
    dispatch: e,
    commit: t,
    getters: n
}, {
    translator: r,
    targetId: o,
    clear: i
}) {
    t("updateSubscriber", {
        id: `selection-${o}`,
        callback: V7({
            dispatch: e,
            getters: n
        }, {
            translator: r,
            targetId: o
        }),
        isTranslator: !0,
        clear: i
    })
}, Uwe = () => ({}), qwe = {
    addSubscriber(e, {
        id: t,
        callback: n,
        elementFilter: r,
        isTranslator: o
    }) {
        iy(e, {
            id: t,
            subscriberOnly: !0
        }),
        e[t].subscribers.push({
            callback: n,
            filterIds: r,
            isTranslator: o
        })
    },
    updateSubscriber(e, {
        id: t,
        callback: n,
        elementFilter: r,
        isTranslator: o,
        clear: i
    }) {
        e[t] && (i && (e[t].subscribers = e[t].subscribers.filter(s => !s.isTranslator), e[t].data = {
                    elements: []
                }), e[t].subscribers.push({
                callback: n,
                filterIds: r,
                isTranslator: o
            }))
    },
    removeSubscriber(e, {
        id: t,
        callback: n
    }) {
        if (e[t]) {
            let r = e[t].subscribers.findIndex(o => o.callback === n);
            r >= 0 && e[t].subscribers.splice(r, 1),
            e[t].subscribers.length === 0 && !e[t].data && delete e[t]
        }
    },
    updateData(e, {
        id: t,
        data: n
    }) {
        iy(e, {
            id: t
        }),
        e[t].data = n
    },
    clear(e) {
        Object.keys(e).forEach(t => {
            delete e[t]
        })
    }
}, Ywe = {
    subscribe({
        commit: e,
        state: t
    }, {
        id: n,
        callback: r,
        elementFilter: o,
        isTranslator: i
    }) {
        if (e("addSubscriber", {
                id: n,
                callback: r,
                elementFilter: o,
                isTranslator: i
            }), t[n].data) {
            let s = R7(t, {
                id: n,
                filterIds: o
            });
            s || (s = {}),
            s.reevaluate = !0,
            r(n, s)
        }
    },
    unsubscribe({
        commit: e
    }, {
        id: t,
        callback: n
    }) {
        e("removeSubscriber", {
            id: t,
            callback: n
        })
    },
    publish({
        commit: e,
        state: t
    }, {
        id: n,
        data: r,
        skipCallback: o
    }) {
        if (r.changeSet) {
            let i = Lwe(t, {
                id: n,
                data: r
            });
            i && z$(t, {
                id: n,
                data: i,
                skipCallback: o
            })
        } else {
            if (!r.elements)
                throw new Error("Invalid payload for publishing interactivity event");
            let i = Owe(t, {
                id: n,
                data: r
            });
            if (i.length < 1)
                return;
            (!t[n] || !t[n].data) && iy(t, {
                id: n
            }),
            e("updateData", {
                id: n,
                data: r
            }),
            z$(t, {
                id: n,
                data: r,
                skipCallback: o,
                changedIds: i
            })
        }
    },
    updateFilter({
        getters: e,
        state: t,
        dispatch: n
    }, {
        id: r,
        data: o,
        callback: i
    }) {
        let s = [],
        a = !1;
        t[r] && t[r].data && (s = e.getPublishedData(r).elements.map(l => o.id === l.id ? (a = !0, JSON.parse(JSON.stringify(o))) : l)),
        a || s.push(JSON.parse(JSON.stringify(o))),
        n("publish", {
            id: r,
            data: {
                elements: s
            },
            callback: i
        })
    },
    registerSelectionTranslator({
        dispatch: e,
        getters: t
    }, {
        translator: n
    }) {
        !n.sourceID || !n.targetIDs || !n.forward && !n.mapping || (jwe({
                dispatch: e,
                getters: t
            }, {
                translator: n
            }), n.targetIDs.forEach(r => {
                Wwe({
                    dispatch: e,
                    getters: t
                }, {
                    translator: n,
                    targetId: r
                })
            }))
    },
    updateSelectionTranslators({
        dispatch: e,
        commit: t,
        getters: n,
        state: r
    }, {
        translators: o
    }) {
        let i = new Set([]);
        o.forEach(s => {
            if (typeof r[`selection-${s.sourceID}`] > "u") {
                e("registerSelectionTranslator", {
                    translator: s
                });
                return
            }
            zwe({
                dispatch: e,
                commit: t,
                getters: n
            }, {
                translator: s,
                clear: !i.has(s.sourceID)
            }),
            i.add(s.sourceID),
            s.targetIDs.forEach(a => {
                Hwe({
                    dispatch: e,
                    commit: t,
                    getters: n
                }, {
                    translator: s,
                    targetId: a,
                    clear: !i.has(a)
                }),
                i.add(a)
            })
        })
    },
    clear({
        commit: e
    }) {
        e("clear")
    }
}, Kwe = {
    getPublishedData: e => t => e[t] && e[t].data ? JSON.parse(JSON.stringify(e[t].data)) : null
}, Gwe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: Ywe,
            getters: Kwe,
            mutations: qwe,
            namespaced: Ewe,
            state: Uwe
        }, Symbol.toStringTag, {
            value: "Module"
        })), Xwe = !0, Jwe = () => ({
    alert: null
}), Zwe = {
    showAlert(e, t) {
        e.alert = t
    },
    closeAlert(e) {
        e.alert = null
    }
}, Qwe = {
    showAlert({
        commit: e
    }, t) {
        e("showAlert", t)
    },
    closeAlert({
        commit: e,
        state: t
    }, n) {
        t.alert.callback && t.alert.callback(n),
        e("closeAlert")
    }
}, ebe = {
    alertAsMessage: e => {
        if (!e.alert)
            return null;
        let {
            message: t,
            type: n = "UNKNOWN",
            subtitle: r,
            nodeId: o
        } = e.alert,
        i = n === "warn" ? "WARNING" : n.toUpperCase(),
        s = "",
        a;
        return r ? (s = r, a = t || "") : t ? s = t : a = "No further information available. Please check the workflow configuration.", {
            message: `${i} ${s}`,
            details: a,
            count: 1,
            id: o,
            type: n,
            showCollapser: Boolean(a),
            showCloseButton: !0
        }
    }
}, tbe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: Qwe,
            getters: ebe,
            mutations: Zwe,
            namespaced: Xwe,
            state: Jwe
        }, Symbol.toStringTag, {
            value: "Module"
        })), nbe = !0, rbe = () => ({
    services: {}
}), obe = {
    registerService(e, t) {
        e.services[t.serviceId] = t
    },
    deregisterService(e, t) {
        delete e.services[t.serviceId]
    }
}, ibe = {
    registerService({
        commit: e
    }, {
        service: t
    }) {
        NO.trace("PageBuilder: registerService via action: ", t),
        e("registerService", t)
    },
    deregisterService({
        commit: e
    }, {
        service: t
    }) {
        NO.trace("PageBuilder: deregisterService via action: ", t),
        e("deregisterService", t)
    },
    pushEvent({
        state: e
    }, {
        event: t,
        callerId: n
    }) {
        return Promise.all(Object.values(e.services).filter(r => r.serviceId !== n).map(r => r.onServiceEvent(t)))
    }
}, sbe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: ibe,
            mutations: obe,
            namespaced: nbe,
            state: rbe
        }, Symbol.toStringTag, {
            value: "Module"
        })), abe = !0, lbe = () => ({
    applySettings: null,
    dirtySettings: !1,
    dirtyModelSettings: !1
}), cbe = {
    dirtySettings(e, t) {
        e.dirtySettings = !0,
        t && (e.dirtyModelSettings = !0)
    },
    cleanSettings(e) {
        e.dirtySettings = !1,
        e.dirtyModelSettings = !1
    },
    setApplySettings(e, t) {
        e.applySettings = t
    }
}, ube = {
    dirtySettings({
        commit: e
    }, t) {
        e("dirtySettings", t)
    },
    cleanSettings({
        commit: e
    }) {
        e("cleanSettings")
    },
    setApplySettings({
        commit: e
    }, {
        applySettings: t
    }) {
        e("setApplySettings", t)
    },
    callApplySettings({
        state: e
    }) {
        return e.applySettings()
    }
}, dbe = Object.freeze(Object.defineProperty({
            __proto__: null,
            actions: ube,
            mutations: cbe,
            namespaced: abe,
            state: lbe
        }, Symbol.toStringTag, {
            value: "Module"
        })), fbe = e => ({
        type: "JSONLayoutRow",
        additionalStyles: [],
        additionalClasses: [],
        columns: [{
                content: [e],
                widthXS: 12,
                additionalStyles: [],
                additionalClasses: []
            }
        ]
    }), hbe = (e = []) => {
    let t = e.map(n => n.type === "view" || n.type === "JSONLayoutViewContent" ? fbe(n) : n);
    return t.length < 2 ? e : t
};
const pbe = {
    props: {
        level: {
            type: String,
        default:
            "local"
        },
        active: {
            type: Boolean,
        default:
            !1
        },
        type: {
            type: String,
        default:
            "error"
        }
    },
    emits: ["clickAway"],
    methods: {
        onClickAway(e) {
            e.target === this.$refs.overlay && this.$emit("clickAway")
        }
    }
};
function mbe(e, t, n, r, o, i) {
    return _(),
    O("div", {
        class: he(["container", n.level, n.type, {
                    active: n.active
                }
            ]),
        onClick: t[0] || (t[0] = (...s) => i.onClickAway && i.onClickAway(...s))
    }, [z(ho, {
                name: "fade"
            }, {
            default:
                oe(() => [n.active ? (_(), O("div", {
                                key: 0,
                                ref: "overlay",
                                class: he(["overlay", n.level, n.type])
                            }, null, 2)) : J("", !0)]),
                _: 1
            }), z(ho, {
                name: "slide-fade"
            }, {
            default:
                oe(() => [n.active ? (_(), O("div", {
                                key: 0,
                                class: he(["alert-body", n.level])
                            }, [Ye(e.$slots, "popoverContent", {}, void 0, !0)], 2)) : J("", !0)]),
                _: 3
            })], 2)
}
const F7 = te(pbe, [["render", mbe], ["__scopeId", "data-v-8c2a94fe"]]), gbe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, vbe = P("path", {
    d: "m16 11.172-.001 8.325M16 3.34 1.382 28.66h29.236z"
}, null, -1), ybe = P("path", {
    "stroke-linecap": "round",
    "stroke-width": "1.6",
    d: "M15.988 23.972h0"
}, null, -1), wbe = [vbe, ybe];
function bbe(e, t) {
    return _(),
    O("svg", gbe, wbe)
}
const _I = {
    render: bbe
};
const _be = {
    components: {
        Popover: F7,
        SignWarningIcon: _I
    },
    props: {
        active: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["showAlert"],
    methods: {
        showAlert() {
            this.$emit("showAlert")
        }
    }
};
function kbe(e, t, n, r, o, i) {
    const s = B("SignWarningIcon"),
    a = B("Popover");
    return _(),
    H(a, {
        active: n.active,
        class: he(["node-popover", {
                    active: n.active
                }
            ]),
        type: "error"
    }, {
        popoverContent: oe(() => [P("div", {
                    class: "error-wrapper",
                    title: "Click to see more details.",
                    onClick: t[0] || (t[0] = (...l) => i.showAlert && i.showAlert(...l))
                }, [z(s, {
                            class: "icon"
                        })])]),
        _: 1
    }, 8, ["active", "class"])
}
const j7 = te(_be, [["render", kbe], ["__scopeId", "data-v-e6682a75"]]);
var xx = {}, xbe = {
    get exports() {
        return xx
    },
    set exports(e) {
        xx = e
    }
}, Iw = {}, Sx = {}, Sbe = {
    get exports() {
        return Sx
    },
    set exports(e) {
        Sx = e
    }
};
(function (e) {
    (function (t) {
        if (typeof window > "u")
            return;
        var n = 0,
        r = !1,
        o = !1,
        i = "message",
        s = i.length,
        a = "[iFrameSizer]",
        l = a.length,
        c = null,
        u = window.requestAnimationFrame,
        f = {
            max: 1,
            scroll: 1,
            bodyScroll: 1,
            documentElementScroll: 1
        },
        p = {},
        m = null,
        v = {
            autoResize: !0,
            bodyBackground: null,
            bodyMargin: null,
            bodyMarginV1: 8,
            bodyPadding: null,
            checkOrigin: !0,
            inPageLinks: !1,
            enablePublicMethods: !0,
            heightCalculationMethod: "bodyOffset",
            id: "iFrameResizer",
            interval: 32,
            log: !1,
            maxHeight: 1 / 0,
            maxWidth: 1 / 0,
            minHeight: 0,
            minWidth: 0,
            resizeFrom: "parent",
            scrolling: !1,
            sizeHeight: !0,
            sizeWidth: !1,
            warningTimeout: 5e3,
            tolerance: 0,
            widthCalculationMethod: "scroll",
            onClose: function () {
                return !0
            },
            onClosed: function () {},
            onInit: function () {},
            onMessage: function () {
                M("onMessage function not defined")
            },
            onResized: function () {},
            onScroll: function () {
                return !0
            }
        };
        function y() {
            return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver
        }
        function b(R, X, Q) {
            R.addEventListener(X, Q, !1)
        }
        function w(R, X, Q) {
            R.removeEventListener(X, Q, !1)
        }
        function k() {
            var R = ["moz", "webkit", "o", "ms"],
            X;
            for (X = 0; X < R.length && !u; X += 1)
                u = window[R[X] + "RequestAnimationFrame"];
            u ? u = u.bind(window) : T("setup", "RequestAnimationFrame not supported")
        }
        function C(R) {
            var X = "Host page: " + R;
            return window.top !== window.self && (window.parentIFrame && window.parentIFrame.getId ? X = window.parentIFrame.getId() + ": " + R : X = "Nested host page: " + R),
            X
        }
        function x(R) {
            return a + "[" + C(R) + "]"
        }
        function S(R) {
            return p[R] ? p[R].log : r
        }
        function T(R, X) {
            N("log", R, X, S(R))
        }
        function E(R, X) {
            N("info", R, X, S(R))
        }
        function M(R, X) {
            N("warn", R, X, !0)
        }
        function N(R, X, Q, Z) {
            Z === !0 && typeof window.console == "object" && console[R](x(X), Q)
        }
        function F(R) {
            function X() {
                function tt() {
                    Se(on),
                    ue(_t),
                    mr("onResized", on)
                }
                be("Height"),
                be("Width"),
                Pe(tt, on, "init")
            }
            function Q() {
                var tt = ln.substr(l).split(":"),
                Tt = tt[1] ? parseInt(tt[1], 10) : 0,
                mn = p[tt[0]] && p[tt[0]].iframe,
                hn = getComputedStyle(mn);
                return {
                    iframe: mn,
                    id: tt[0],
                    height: Tt + Z(hn) + fe(hn),
                    width: tt[2],
                    type: tt[3]
                }
            }
            function Z(tt) {
                if (tt.boxSizing !== "border-box")
                    return 0;
                var Tt = tt.paddingTop ? parseInt(tt.paddingTop, 10) : 0,
                mn = tt.paddingBottom ? parseInt(tt.paddingBottom, 10) : 0;
                return Tt + mn
            }
            function fe(tt) {
                if (tt.boxSizing !== "border-box")
                    return 0;
                var Tt = tt.borderTopWidth ? parseInt(tt.borderTopWidth, 10) : 0,
                mn = tt.borderBottomWidth ? parseInt(tt.borderBottomWidth, 10) : 0;
                return Tt + mn
            }
            function be(tt) {
                var Tt = Number(p[_t]["max" + tt]),
                mn = Number(p[_t]["min" + tt]),
                hn = tt.toLowerCase(),
                $ = Number(on[hn]);
                T(_t, "Checking " + hn + " is in range " + mn + "-" + Tt),
                $ < mn && ($ = mn, T(_t, "Set " + hn + " to min value")),
                $ > Tt && ($ = Tt, T(_t, "Set " + hn + " to max value")),
                on[hn] = "" + $
            }
            function Ee() {
                function tt() {
                    function hn() {
                        var D = 0,
                        q = !1;
                        for (T(_t, "Checking connection is from allowed list of origins: " + mn); D < mn.length; D++)
                            if (mn[D] === Tt) {
                                q = !0;
                                break
                            }
                        return q
                    }
                    function $() {
                        var D = p[_t] && p[_t].remoteHost;
                        return T(_t, "Checking connection is from: " + D),
                        Tt === D
                    }
                    return mn.constructor === Array ? hn() : $()
                }
                var Tt = R.origin,
                mn = p[_t] && p[_t].checkOrigin;
                if (mn && "" + Tt != "null" && !tt())
                    throw new Error("Unexpected message received from: " + Tt + " for " + on.iframe.id + ". Message was: " + R.data + ". This error can be disabled by setting the checkOrigin: false option or by providing of array of trusted domains.");
                return !0
            }
            function Me() {
                return a === ("" + ln).substr(0, l) && ln.substr(l).split(":")[0]in p
            }
            function we() {
                var tt = on.type in {
                    true: 1,
                    false: 1,
                    undefined: 1
                };
                return tt && T(_t, "Ignoring init message from meta parent page"),
                tt
            }
            function He(tt) {
                return ln.substr(ln.indexOf(":") + s + tt)
            }
            function We(tt) {
                T(_t, "onMessage passed: {iframe: " + on.iframe.id + ", message: " + tt + "}"),
                mr("onMessage", {
                    iframe: on.iframe,
                    message: JSON.parse(tt)
                }),
                T(_t, "--")
            }
            function Je() {
                var tt = document.body.getBoundingClientRect(),
                Tt = on.iframe.getBoundingClientRect();
                return JSON.stringify({
                    iframeHeight: Tt.height,
                    iframeWidth: Tt.width,
                    clientHeight: Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
                    clientWidth: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                    offsetTop: parseInt(Tt.top - tt.top, 10),
                    offsetLeft: parseInt(Tt.left - tt.left, 10),
                    scrollTop: window.pageYOffset,
                    scrollLeft: window.pageXOffset,
                    documentHeight: document.documentElement.clientHeight,
                    documentWidth: document.documentElement.clientWidth,
                    windowHeight: window.innerHeight,
                    windowWidth: window.innerWidth
                })
            }
            function qe(tt, Tt) {
                function mn() {
                    je("Send Page Info", "pageInfo:" + Je(), tt, Tt)
                }
                le(mn, 32, Tt)
            }
            function wt() {
                function tt($, D) {
                    function q() {
                        p[hn] ? qe(p[hn].iframe, hn) : Tt()
                    }
                    ["scroll", "resize"].forEach(function (ie) {
                        T(hn, $ + ie + " listener for sendPageInfo"),
                        D(window, ie, q)
                    })
                }
                function Tt() {
                    tt("Remove ", w)
                }
                function mn() {
                    tt("Add ", b)
                }
                var hn = _t;
                mn(),
                p[hn] && (p[hn].stopPageInfo = Tt)
            }
            function Et() {
                p[_t] && p[_t].stopPageInfo && (p[_t].stopPageInfo(), delete p[_t].stopPageInfo)
            }
            function bt() {
                var tt = !0;
                return on.iframe === null && (M(_t, "IFrame (" + on.id + ") not found"), tt = !1),
                tt
            }
            function ze(tt) {
                var Tt = tt.getBoundingClientRect();
                return Y(_t), {
                    x: Math.floor(Number(Tt.left) + Number(c.x)),
                    y: Math.floor(Number(Tt.top) + Number(c.y))
                }
            }
            function Ze(tt) {
                function Tt() {
                    c = D,
                    Lt(),
                    T(_t, "--")
                }
                function mn() {
                    return {
                        x: Number(on.width) + $.x,
                        y: Number(on.height) + $.y
                    }
                }
                function hn() {
                    window.parentIFrame ? window.parentIFrame["scrollTo" + (tt ? "Offset" : "")](D.x, D.y) : M(_t, "Unable to scroll to requested position, window.parentIFrame not found")
                }
                var $ = tt ? ze(on.iframe) : {
                    x: 0,
                    y: 0
                },
                D = mn();
                T(_t, "Reposition requested from iFrame (offset x:" + $.x + " y:" + $.y + ")"),
                window.top !== window.self ? hn() : Tt()
            }
            function Lt() {
                mr("onScroll", c) !== !1 ? ue(_t) : re()
            }
            function pn(tt) {
                function Tt() {
                    var q = ze(D);
                    T(_t, "Moving to in page link (#" + hn + ") at x: " + q.x + " y: " + q.y),
                    c = {
                        x: q.x,
                        y: q.y
                    },
                    Lt(),
                    T(_t, "--")
                }
                function mn() {
                    window.parentIFrame ? window.parentIFrame.moveToAnchor(hn) : T(_t, "In page link #" + hn + " not found and window.parentIFrame not found")
                }
                var hn = tt.split("#")[1] || "",
                $ = decodeURIComponent(hn),
                D = document.getElementById($) || document.getElementsByName($)[0];
                D ? Tt() : window.top !== window.self ? mn() : T(_t, "In page link #" + hn + " not found")
            }
            function mr(tt, Tt) {
                return K(_t, tt, Tt)
            }
            function vo() {
                switch (p[_t] && p[_t].firstRun && $o(), on.type) {
                case "close":
                    G(on.iframe);
                    break;
                case "message":
                    We(He(6));
                    break;
                case "autoResize":
                    p[_t].autoResize = JSON.parse(He(9));
                    break;
                case "scrollTo":
                    Ze(!1);
                    break;
                case "scrollToOffset":
                    Ze(!0);
                    break;
                case "pageInfo":
                    qe(p[_t] && p[_t].iframe, _t),
                    wt();
                    break;
                case "pageInfoStop":
                    Et();
                    break;
                case "inPageLink":
                    pn(He(9));
                    break;
                case "reset":
                    de(on);
                    break;
                case "init":
                    X(),
                    mr("onInit", on.iframe);
                    break;
                default:
                    X()
                }
            }
            function Pn(tt) {
                var Tt = !0;
                return p[tt] || (Tt = !1, M(on.type + " No settings for " + tt + ". Message was: " + ln)),
                Tt
            }
            function Jn() {
                for (var tt in p)
                    je("iFrame requested init", Ke(tt), p[tt].iframe, tt)
            }
            function $o() {
                p[_t] && (p[_t].firstRun = !1)
            }
            var ln = R.data,
            on = {},
            _t = null;
            ln === "[iFrameResizerChild]Ready" ? Jn() : Me() ? (on = Q(), _t = on.id, p[_t] && (p[_t].loaded = !0), !we() && Pn(_t) && (T(_t, "Received: " + ln), bt() && Ee() && vo())) : E(_t, "Ignored: " + ln)
        }
        function K(R, X, Q) {
            var Z = null,
            fe = null;
            if (p[R])
                if (Z = p[R][X], typeof Z == "function")
                    fe = Z(Q);
                else
                    throw new TypeError(X + " on iFrame[" + R + "] is not a function");
            return fe
        }
        function j(R) {
            var X = R.id;
            delete p[X]
        }
        function G(R) {
            var X = R.id;
            if (K(X, "onClose", X) === !1) {
                T(X, "Close iframe cancelled by onClose event");
                return
            }
            T(X, "Removing iFrame: " + X);
            try {
                R.parentNode && R.parentNode.removeChild(R)
            } catch (Q) {
                M(Q)
            }
            K(X, "onClosed", X),
            T(X, "--"),
            j(R)
        }
        function Y(R) {
            c === null && (c = {
                    x: window.pageXOffset !== t ? window.pageXOffset : document.documentElement.scrollLeft,
                    y: window.pageYOffset !== t ? window.pageYOffset : document.documentElement.scrollTop
                }, T(R, "Get page position: " + c.x + "," + c.y))
        }
        function ue(R) {
            c !== null && (window.scrollTo(c.x, c.y), T(R, "Set page position: " + c.x + "," + c.y), re())
        }
        function re() {
            c = null
        }
        function de(R) {
            function X() {
                Se(R),
                je("reset", "reset", R.iframe, R.id)
            }
            T(R.id, "Size reset requested by " + (R.type === "init" ? "host page" : "iFrame")),
            Y(R.id),
            Pe(X, R, "reset")
        }
        function Se(R) {
            function X(be) {
                if (!R.id) {
                    T("undefined", "messageData id not set");
                    return
                }
                R.iframe.style[be] = R[be] + "px",
                T(R.id, "IFrame (" + fe + ") " + be + " set to " + R[be] + "px")
            }
            function Q(be) {
                !o && R[be] === "0" && (o = !0, T(fe, "Hidden iFrame detected, creating visibility listener"), ye())
            }
            function Z(be) {
                X(be),
                Q(be)
            }
            var fe = R.iframe.id;
            p[fe] && (p[fe].sizeHeight && Z("height"), p[fe].sizeWidth && Z("width"))
        }
        function Pe(R, X, Q) {
            Q !== X.type && u && !window.jasmine ? (T(X.id, "Requesting animation frame"), u(R)) : R()
        }
        function je(R, X, Q, Z, fe) {
            function be() {
                var We = p[Z] && p[Z].targetOrigin;
                T(Z, "[" + R + "] Sending msg to iframe[" + Z + "] (" + X + ") targetOrigin: " + We),
                Q.contentWindow.postMessage(a + X, We)
            }
            function Ee() {
                M(Z, "[" + R + "] IFrame(" + Z + ") not found")
            }
            function Me() {
                Q && "contentWindow" in Q && Q.contentWindow !== null ? be() : Ee()
            }
            function we() {
                function We() {
                    p[Z] && !p[Z].loaded && !He && (He = !0, M(Z, "IFrame has not responded within " + p[Z].warningTimeout / 1e3 + " seconds. Check iFrameResizer.contentWindow.js has been loaded in iFrame. This message can be ignored if everything is working, or you can set the warningTimeout option to a higher value or zero to suppress this warning."))
                }
                fe && p[Z] && p[Z].warningTimeout && (p[Z].msgTimeout = setTimeout(We, p[Z].warningTimeout))
            }
            var He = !1;
            Z = Z || Q.id,
            p[Z] && (Me(), we())
        }
        function Ke(R) {
            return R + ":" + p[R].bodyMarginV1 + ":" + p[R].sizeWidth + ":" + p[R].log + ":" + p[R].interval + ":" + p[R].enablePublicMethods + ":" + p[R].autoResize + ":" + p[R].bodyMargin + ":" + p[R].heightCalculationMethod + ":" + p[R].bodyBackground + ":" + p[R].bodyPadding + ":" + p[R].tolerance + ":" + p[R].inPageLinks + ":" + p[R].resizeFrom + ":" + p[R].widthCalculationMethod
        }
        function Ue(R, X) {
            function Q() {
                function Ze(pn) {
                    p[ze][pn] !== 1 / 0 && p[ze][pn] !== 0 && (R.style[pn] = p[ze][pn] + "px", T(ze, "Set " + pn + " = " + p[ze][pn] + "px"))
                }
                function Lt(pn) {
                    if (p[ze]["min" + pn] > p[ze]["max" + pn])
                        throw new Error("Value for min" + pn + " can not be greater than max" + pn)
                }
                Lt("Height"),
                Lt("Width"),
                Ze("maxHeight"),
                Ze("minHeight"),
                Ze("maxWidth"),
                Ze("minWidth")
            }
            function Z() {
                var Ze = X && X.id || v.id + n++;
                return document.getElementById(Ze) !== null && (Ze += n++),
                Ze
            }
            function fe(Ze) {
                return Ze === "" && (R.id = Ze = Z(), r = (X || {}).log, T(Ze, "Added missing iframe ID: " + Ze + " (" + R.src + ")")),
                Ze
            }
            function be() {
                switch (T(ze, "IFrame scrolling " + (p[ze] && p[ze].scrolling ? "enabled" : "disabled") + " for " + ze), R.style.overflow = (p[ze] && p[ze].scrolling) === !1 ? "hidden" : "auto", p[ze] && p[ze].scrolling) {
                case "omit":
                    break;
                case !0:
                    R.scrolling = "yes";
                    break;
                case !1:
                    R.scrolling = "no";
                    break;
                default:
                    R.scrolling = p[ze] ? p[ze].scrolling : "no"
                }
            }
            function Ee() {
                (typeof(p[ze] && p[ze].bodyMargin) == "number" || (p[ze] && p[ze].bodyMargin) === "0") && (p[ze].bodyMarginV1 = p[ze].bodyMargin, p[ze].bodyMargin = "" + p[ze].bodyMargin + "px")
            }
            function Me() {
                var Ze = p[ze] && p[ze].firstRun,
                Lt = p[ze] && p[ze].heightCalculationMethod in f;
                !Ze && Lt && de({
                    iframe: R,
                    height: 0,
                    width: 0,
                    type: "init"
                })
            }
            function we() {
                p[ze] && (p[ze].iframe.iFrameResizer = {
                        close: G.bind(null, p[ze].iframe),
                        removeListeners: j.bind(null, p[ze].iframe),
                        resize: je.bind(null, "Window resize", "resize", p[ze].iframe),
                        moveToAnchor: function (Ze) {
                            je("Move to anchor", "moveToAnchor:" + Ze, p[ze].iframe, ze)
                        },
                        sendMessage: function (Ze) {
                            Ze = JSON.stringify(Ze),
                            je("Send Message", "message:" + Ze, p[ze].iframe, ze)
                        }
                    })
            }
            function He(Ze) {
                function Lt() {
                    je("iFrame.onload", Ze, R, t, !0),
                    Me()
                }
                function pn(vo) {
                    if (R.parentNode) {
                        var Pn = new vo(function (Jn) {
                            Jn.forEach(function ($o) {
                                var ln = Array.prototype.slice.call($o.removedNodes);
                                ln.forEach(function (on) {
                                    on === R && G(R)
                                })
                            })
                        });
                        Pn.observe(R.parentNode, {
                            childList: !0
                        })
                    }
                }
                var mr = y();
                mr && pn(mr),
                b(R, "load", Lt),
                je("init", Ze, R, t, !0)
            }
            function We(Ze) {
                if (typeof Ze != "object")
                    throw new TypeError("Options is not an object")
            }
            function Je(Ze) {
                for (var Lt in v)
                    Object.prototype.hasOwnProperty.call(v, Lt) && (p[ze][Lt] = Object.prototype.hasOwnProperty.call(Ze, Lt) ? Ze[Lt] : v[Lt])
            }
            function qe(Ze) {
                return Ze === "" || Ze.match(/^(about:blank|javascript:|file:\/\/)/) !== null ? "*" : Ze
            }
            function wt(Ze) {
                var Lt = Ze.split("Callback");
                if (Lt.length === 2) {
                    var pn = "on" + Lt[0].charAt(0).toUpperCase() + Lt[0].slice(1);
                    this[pn] = this[Ze],
                    delete this[Ze],
                    M(ze, "Deprecated: '" + Ze + "' has been renamed '" + pn + "'. The old method will be removed in the next major version.")
                }
            }
            function Et(Ze) {
                Ze = Ze || {},
                p[ze] = {
                    firstRun: !0,
                    iframe: R,
                    remoteHost: R.src && R.src.split("/").slice(0, 3).join("/")
                },
                We(Ze),
                Object.keys(Ze).forEach(wt, Ze),
                Je(Ze),
                p[ze] && (p[ze].targetOrigin = p[ze].checkOrigin === !0 ? qe(p[ze].remoteHost) : "*")
            }
            function bt() {
                return ze in p && "iFrameResizer" in R
            }
            var ze = fe(R.id);
            bt() ? M(ze, "Ignored iFrame, already setup.") : (Et(X), be(), Q(), Ee(), He(Ke(ze)), we())
        }
        function yt(R, X) {
            m === null && (m = setTimeout(function () {
                    m = null,
                    R()
                }, X))
        }
        var at = {};
        function le(R, X, Q) {
            at[Q] || (at[Q] = setTimeout(function () {
                    at[Q] = null,
                    R()
                }, X))
        }
        function ye() {
            function R() {
                function fe(be) {
                    function Ee(we) {
                        return (p[be] && p[be].iframe.style[we]) === "0px"
                    }
                    function Me(we) {
                        return we.offsetParent !== null
                    }
                    p[be] && Me(p[be].iframe) && (Ee("height") || Ee("width")) && je("Visibility change", "resize", p[be].iframe, be)
                }
                Object.keys(p).forEach(function (be) {
                    fe(be)
                })
            }
            function X(fe) {
                T("window", "Mutation observed: " + fe[0].target + " " + fe[0].type),
                yt(R, 16)
            }
            function Q() {
                var fe = document.querySelector("body"),
                be = {
                    attributes: !0,
                    attributeOldValue: !1,
                    characterData: !0,
                    characterDataOldValue: !1,
                    childList: !0,
                    subtree: !0
                },
                Ee = new Z(X);
                Ee.observe(fe, be)
            }
            var Z = y();
            Z && Q()
        }
        function ge(R) {
            function X() {
                xe("Window " + R, "resize")
            }
            T("window", "Trigger event: " + R),
            yt(X, 16)
        }
        function pe() {
            function R() {
                xe("Tab Visable", "resize")
            }
            document.visibilityState !== "hidden" && (T("document", "Trigger event: Visiblity change"), yt(R, 16))
        }
        function xe(R, X) {
            function Q(Z) {
                return p[Z] && p[Z].resizeFrom === "parent" && p[Z].autoResize && !p[Z].firstRun
            }
            Object.keys(p).forEach(function (Z) {
                Q(Z) && je(R, X, p[Z].iframe, Z)
            })
        }
        function et() {
            b(window, "message", F),
            b(window, "resize", function () {
                ge("resize")
            }),
            b(document, "visibilitychange", pe),
            b(document, "-webkit-visibilitychange", pe)
        }
        function Xe() {
            function R(Z, fe) {
                function be() {
                    if (fe.tagName) {
                        if (fe.tagName.toUpperCase() !== "IFRAME")
                            throw new TypeError("Expected <IFRAME> tag, found <" + fe.tagName + ">")
                    } else
                        throw new TypeError("Object is not a valid DOM element")
                }
                fe && (be(), Ue(fe, Z), Q.push(fe))
            }
            function X(Z) {
                Z && Z.enablePublicMethods && M("enablePublicMethods option has been removed, public methods are now always available in the iFrame")
            }
            var Q;
            return k(),
            et(),
            function (fe, be) {
                switch (Q = [], X(fe), typeof be) {
                case "undefined":
                case "string":
                    Array.prototype.forEach.call(document.querySelectorAll(be || "iframe"), R.bind(t, fe));
                    break;
                case "object":
                    R(fe, be);
                    break;
                default:
                    throw new TypeError("Unexpected data type (" + typeof be + ")")
                }
                return Q
            }
        }
        function W(R) {
            R.fn ? R.fn.iFrameResize || (R.fn.iFrameResize = function (Q) {
                function Z(fe, be) {
                    Ue(be, Q)
                }
                return this.filter("iframe").each(Z).end()
            }) : E("", "Unable to bind to jQuery, it is not fully loaded.")
        }
        window.jQuery && W(window.jQuery),
        typeof t == "function" && t.amd ? t([], Xe) : e.exports = Xe(),
        window.iFrameResize = window.iFrameResize || Xe()
    })()
})(Sbe);
var Cx = {}, Cbe = {
    get exports() {
        return Cx
    },
    set exports(e) {
        Cx = e
    }
};
(function (e) {
    (function (t) {
        if (typeof window > "u")
            return;
        var n = !0,
        r = 10,
        o = "",
        i = 0,
        s = "",
        a = null,
        l = "",
        c = !1,
        u = {
            resize: 1,
            click: 1
        },
        f = 128,
        p = !0,
        m = 1,
        v = "bodyOffset",
        y = v,
        b = !0,
        w = "",
        k = {},
        C = 32,
        x = null,
        S = !1,
        T = "[iFrameSizer]",
        E = T.length,
        M = "",
        N = {
            max: 1,
            min: 1,
            bodyScroll: 1,
            documentElementScroll: 1
        },
        F = "child",
        K = window.parent,
        j = "*",
        G = 0,
        Y = !1,
        ue = null,
        re = 16,
        de = 1,
        Se = "scroll",
        Pe = Se,
        je = window,
        Ke = function () {
            Z("onMessage function not defined")
        },
        Ue = function () {},
        yt = function () {},
        at = {
            height: function () {
                return Z("Custom height calculation function not defined"),
                document.documentElement.offsetHeight
            },
            width: function () {
                return Z("Custom width calculation function not defined"),
                document.body.scrollWidth
            }
        },
        le = {},
        ye = !1;
        function ge() {}
        try {
            var pe = Object.create({}, {
                passive: {
                    get: function () {
                        ye = !0
                    }
                }
            });
            window.addEventListener("test", ge, pe),
            window.removeEventListener("test", ge, pe)
        } catch {}
        function xe(ce, Ie, Ve, kt) {
            ce.addEventListener(Ie, Ve, ye ? kt || {}
                 : !1)
        }
        function et(ce, Ie, Ve) {
            ce.removeEventListener(Ie, Ve, !1)
        }
        function Xe(ce) {
            return ce.charAt(0).toUpperCase() + ce.slice(1)
        }
        function W(ce) {
            var Ie,
            Ve,
            kt,
            Qt = null,
            qn = 0,
            Qn = function () {
                qn = R(),
                Qt = null,
                kt = ce.apply(Ie, Ve),
                Qt || (Ie = Ve = null)
            };
            return function () {
                var ar = R();
                qn || (qn = ar);
                var Nn = re - (ar - qn);
                return Ie = this,
                Ve = arguments,
                Nn <= 0 || Nn > re ? (Qt && (clearTimeout(Qt), Qt = null), qn = ar, kt = ce.apply(Ie, Ve), Qt || (Ie = Ve = null)) : Qt || (Qt = setTimeout(Qn, Nn)),
                kt
            }
        }
        var R = Date.now || function () {
            return new Date().getTime()
        };
        function X(ce) {
            return T + "[" + M + "] " + ce
        }
        function Q(ce) {
            S && typeof window.console == "object" && console.log(X(ce))
        }
        function Z(ce) {
            typeof window.console == "object" && console.warn(X(ce))
        }
        function fe() {
            be(),
            Q("Initialising iFrame (" + location.href + ")"),
            Me(),
            We(),
            He("background", o),
            He("padding", l),
            mr(),
            bt(),
            ze(),
            Je(),
            Pn(),
            Ze(),
            k = vo(),
            Ae("init", "Init message from host page"),
            Ue()
        }
        function be() {
            function ce(Ve) {
                return Ve === "true"
            }
            var Ie = w.substr(E).split(":");
            M = Ie[0],
            i = t !== Ie[1] ? Number(Ie[1]) : i,
            c = t !== Ie[2] ? ce(Ie[2]) : c,
            S = t !== Ie[3] ? ce(Ie[3]) : S,
            C = t !== Ie[4] ? Number(Ie[4]) : C,
            n = t !== Ie[6] ? ce(Ie[6]) : n,
            s = Ie[7],
            y = t !== Ie[8] ? Ie[8] : y,
            o = Ie[9],
            l = Ie[10],
            G = t !== Ie[11] ? Number(Ie[11]) : G,
            k.enable = t !== Ie[12] ? ce(Ie[12]) : !1,
            F = t !== Ie[13] ? Ie[13] : F,
            Pe = t !== Ie[14] ? Ie[14] : Pe
        }
        function Ee(ce) {
            var Ie = ce.split("Callback");
            if (Ie.length === 2) {
                var Ve = "on" + Ie[0].charAt(0).toUpperCase() + Ie[0].slice(1);
                this[Ve] = this[ce],
                delete this[ce],
                Z("Deprecated: '" + ce + "' has been renamed '" + Ve + "'. The old method will be removed in the next major version.")
            }
        }
        function Me() {
            function ce() {
                var Ve = window.iFrameResizer;
                Q("Reading data from page: " + JSON.stringify(Ve)),
                Object.keys(Ve).forEach(Ee, Ve),
                Ke = "onMessage" in Ve ? Ve.onMessage : Ke,
                Ue = "onReady" in Ve ? Ve.onReady : Ue,
                j = "targetOrigin" in Ve ? Ve.targetOrigin : j,
                y = "heightCalculationMethod" in Ve ? Ve.heightCalculationMethod : y,
                Pe = "widthCalculationMethod" in Ve ? Ve.widthCalculationMethod : Pe
            }
            function Ie(Ve, kt) {
                return typeof Ve == "function" && (Q("Setup custom " + kt + "CalcMethod"), at[kt] = Ve, Ve = "custom"),
                Ve
            }
            "iFrameResizer" in window && Object === window.iFrameResizer.constructor && (ce(), y = Ie(y, "height"), Pe = Ie(Pe, "width")),
            Q("TargetOrigin for parent set to: " + j)
        }
        function we(ce, Ie) {
            return Ie.indexOf("-") !== -1 && (Z("Negative CSS value ignored for " + ce), Ie = ""),
            Ie
        }
        function He(ce, Ie) {
            t !== Ie && Ie !== "" && Ie !== "null" && (document.body.style[ce] = Ie, Q("Body " + ce + ' set to "' + Ie + '"'))
        }
        function We() {
            t === s && (s = i + "px"),
            He("margin", we("margin", s))
        }
        function Je() {
            document.documentElement.style.height = "",
            document.body.style.height = "",
            Q('HTML & body height set to "auto"')
        }
        function qe(ce) {
            var Ie = {
                add: function (Ve) {
                    function kt() {
                        Ae(ce.eventName, ce.eventType)
                    }
                    le[Ve] = kt,
                    xe(window, Ve, kt, {
                        passive: !0
                    })
                },
                remove: function (Ve) {
                    var kt = le[Ve];
                    delete le[Ve],
                    et(window, Ve, kt)
                }
            };
            ce.eventNames && Array.prototype.map ? (ce.eventName = ce.eventNames[0], ce.eventNames.map(Ie[ce.method])) : Ie[ce.method](ce.eventName),
            Q(Xe(ce.method) + " event listener: " + ce.eventType)
        }
        function wt(ce) {
            qe({
                method: ce,
                eventType: "Animation Start",
                eventNames: ["animationstart", "webkitAnimationStart"]
            }),
            qe({
                method: ce,
                eventType: "Animation Iteration",
                eventNames: ["animationiteration", "webkitAnimationIteration"]
            }),
            qe({
                method: ce,
                eventType: "Animation End",
                eventNames: ["animationend", "webkitAnimationEnd"]
            }),
            qe({
                method: ce,
                eventType: "Input",
                eventName: "input"
            }),
            qe({
                method: ce,
                eventType: "Mouse Up",
                eventName: "mouseup"
            }),
            qe({
                method: ce,
                eventType: "Mouse Down",
                eventName: "mousedown"
            }),
            qe({
                method: ce,
                eventType: "Orientation Change",
                eventName: "orientationchange"
            }),
            qe({
                method: ce,
                eventType: "Print",
                eventName: ["afterprint", "beforeprint"]
            }),
            qe({
                method: ce,
                eventType: "Ready State Change",
                eventName: "readystatechange"
            }),
            qe({
                method: ce,
                eventType: "Touch Start",
                eventName: "touchstart"
            }),
            qe({
                method: ce,
                eventType: "Touch End",
                eventName: "touchend"
            }),
            qe({
                method: ce,
                eventType: "Touch Cancel",
                eventName: "touchcancel"
            }),
            qe({
                method: ce,
                eventType: "Transition Start",
                eventNames: ["transitionstart", "webkitTransitionStart", "MSTransitionStart", "oTransitionStart", "otransitionstart"]
            }),
            qe({
                method: ce,
                eventType: "Transition Iteration",
                eventNames: ["transitioniteration", "webkitTransitionIteration", "MSTransitionIteration", "oTransitionIteration", "otransitioniteration"]
            }),
            qe({
                method: ce,
                eventType: "Transition End",
                eventNames: ["transitionend", "webkitTransitionEnd", "MSTransitionEnd", "oTransitionEnd", "otransitionend"]
            }),
            F === "child" && qe({
                method: ce,
                eventType: "IFrame Resized",
                eventName: "resize"
            })
        }
        function Et(ce, Ie, Ve, kt) {
            return Ie !== ce && (ce in Ve || (Z(ce + " is not a valid option for " + kt + "CalculationMethod."), ce = Ie), Q(kt + ' calculation method set to "' + ce + '"')),
            ce
        }
        function bt() {
            y = Et(y, v, $, "height")
        }
        function ze() {
            Pe = Et(Pe, Se, D, "width")
        }
        function Ze() {
            n === !0 ? (wt("add"), ln()) : Q("Auto Resize disabled")
        }
        function Lt() {
            a !== null && a.disconnect()
        }
        function pn() {
            wt("remove"),
            Lt(),
            clearInterval(x)
        }
        function mr() {
            var ce = document.createElement("div");
            ce.style.clear = "both",
            ce.style.display = "block",
            ce.style.height = "0",
            document.body.appendChild(ce)
        }
        function vo() {
            function ce() {
                return {
                    x: window.pageXOffset !== t ? window.pageXOffset : document.documentElement.scrollLeft,
                    y: window.pageYOffset !== t ? window.pageYOffset : document.documentElement.scrollTop
                }
            }
            function Ie(Nn) {
                var Rn = Nn.getBoundingClientRect(),
                En = ce();
                return {
                    x: parseInt(Rn.left, 10) + parseInt(En.x, 10),
                    y: parseInt(Rn.top, 10) + parseInt(En.y, 10)
                }
            }
            function Ve(Nn) {
                function Rn(no) {
                    var ll = Ie(no);
                    Q("Moving to in page link (#" + En + ") at x: " + ll.x + " y: " + ll.y),
                    gt(ll.y, ll.x, "scrollToOffset")
                }
                var En = Nn.split("#")[1] || Nn,
                Jt = decodeURIComponent(En),
                Ao = document.getElementById(Jt) || document.getElementsByName(Jt)[0];
                t !== Ao ? Rn(Ao) : (Q("In page link (#" + En + ") not found in iFrame, so sending to parent"), gt(0, 0, "inPageLink", "#" + En))
            }
            function kt() {
                location.hash !== "" && location.hash !== "#" && Ve(location.href)
            }
            function Qt() {
                function Nn(Rn) {
                    function En(Jt) {
                        Jt.preventDefault(),
                        Ve(this.getAttribute("href"))
                    }
                    Rn.getAttribute("href") !== "#" && xe(Rn, "click", En)
                }
                Array.prototype.forEach.call(document.querySelectorAll('a[href^="#"]'), Nn)
            }
            function qn() {
                xe(window, "hashchange", kt)
            }
            function Qn() {
                setTimeout(kt, f)
            }
            function ar() {
                Array.prototype.forEach && document.querySelectorAll ? (Q("Setting up location.hash handlers"), Qt(), qn(), Qn()) : Z("In page linking not fully supported in this browser! (See README.md for IE8 workaround)")
            }
            return k.enable ? ar() : Q("In page linking not enabled"), {
                findTarget: Ve
            }
        }
        function Pn() {
            Q("Enable public methods"),
            je.parentIFrame = {
                autoResize: function (Ie) {
                    return Ie === !0 && n === !1 ? (n = !0, Ze()) : Ie === !1 && n === !0 && (n = !1, pn()),
                    gt(0, 0, "autoResize", JSON.stringify(n)),
                    n
                },
                close: function () {
                    gt(0, 0, "close")
                },
                getId: function () {
                    return M
                },
                getPageInfo: function (Ie) {
                    typeof Ie == "function" ? (yt = Ie, gt(0, 0, "pageInfo")) : (yt = function () {}, gt(0, 0, "pageInfoStop"))
                },
                moveToAnchor: function (Ie) {
                    k.findTarget(Ie)
                },
                reset: function () {
                    gr("parentIFrame.reset")
                },
                scrollTo: function (Ie, Ve) {
                    gt(Ve, Ie, "scrollTo")
                },
                scrollToOffset: function (Ie, Ve) {
                    gt(Ve, Ie, "scrollToOffset")
                },
                sendMessage: function (Ie, Ve) {
                    gt(0, 0, "message", JSON.stringify(Ie), Ve)
                },
                setHeightCalculationMethod: function (Ie) {
                    y = Ie,
                    bt()
                },
                setWidthCalculationMethod: function (Ie) {
                    Pe = Ie,
                    ze()
                },
                setTargetOrigin: function (Ie) {
                    Q("Set targetOrigin: " + Ie),
                    j = Ie
                },
                size: function (Ie, Ve) {
                    var kt = "" + (Ie || "") + (Ve ? "," + Ve : "");
                    Ae("size", "parentIFrame.size(" + kt + ")", Ie, Ve)
                }
            }
        }
        function Jn() {
            C !== 0 && (Q("setInterval: " + C + "ms"), x = setInterval(function () {
                    Ae("interval", "setInterval: " + C)
                }, Math.abs(C)))
        }
        function $o() {
            function ce(Jt) {
                function Ao(no) {
                    no.complete === !1 && (Q("Attach listeners to " + no.src), no.addEventListener("load", Qt, !1), no.addEventListener("error", qn, !1), Nn.push(no))
                }
                Jt.type === "attributes" && Jt.attributeName === "src" ? Ao(Jt.target) : Jt.type === "childList" && Array.prototype.forEach.call(Jt.target.querySelectorAll("img"), Ao)
            }
            function Ie(Jt) {
                Nn.splice(Nn.indexOf(Jt), 1)
            }
            function Ve(Jt) {
                Q("Remove listeners from " + Jt.src),
                Jt.removeEventListener("load", Qt, !1),
                Jt.removeEventListener("error", qn, !1),
                Ie(Jt)
            }
            function kt(Jt, Ao, no) {
                Ve(Jt.target),
                Ae(Ao, no + ": " + Jt.target.src, t, t)
            }
            function Qt(Jt) {
                kt(Jt, "imageLoad", "Image loaded")
            }
            function qn(Jt) {
                kt(Jt, "imageLoadFailed", "Image load failed")
            }
            function Qn(Jt) {
                Ae("mutationObserver", "mutationObserver: " + Jt[0].target + " " + Jt[0].type),
                Jt.forEach(ce)
            }
            function ar() {
                var Jt = document.querySelector("body"),
                Ao = {
                    attributes: !0,
                    attributeOldValue: !1,
                    characterData: !0,
                    characterDataOldValue: !1,
                    childList: !0,
                    subtree: !0
                };
                return En = new Rn(Qn),
                Q("Create body MutationObserver"),
                En.observe(Jt, Ao),
                En
            }
            var Nn = [],
            Rn = window.MutationObserver || window.WebKitMutationObserver,
            En = ar();
            return {
                disconnect: function () {
                    "disconnect" in En && (Q("Disconnect body MutationObserver"), En.disconnect(), Nn.forEach(Ve))
                }
            }
        }
        function ln() {
            var ce = 0 > C;
            window.MutationObserver || window.WebKitMutationObserver ? ce ? Jn() : a = $o() : (Q("MutationObserver not supported in this browser!"), Jn())
        }
        function on(ce, Ie) {
            var Ve = 0;
            return Ie = Ie || document.body,
            Ve = document.defaultView.getComputedStyle(Ie, null),
            Ve = Ve !== null ? Ve[ce] : 0,
            parseInt(Ve, r)
        }
        function _t(ce) {
            ce > re / 2 && (re = 2 * ce, Q("Event throttle increased to " + re + "ms"))
        }
        function tt(ce, Ie) {
            for (var Ve = Ie.length, kt = 0, Qt = 0, qn = Xe(ce), Qn = R(), ar = 0; ar < Ve; ar++)
                kt = Ie[ar].getBoundingClientRect()[ce] + on("margin" + qn, Ie[ar]), kt > Qt && (Qt = kt);
            return Qn = R() - Qn,
            Q("Parsed " + Ve + " HTML elements"),
            Q("Element position calculated in " + Qn + "ms"),
            _t(Qn),
            Qt
        }
        function Tt(ce) {
            return [ce.bodyOffset(), ce.bodyScroll(), ce.documentElementOffset(), ce.documentElementScroll()]
        }
        function mn(ce, Ie) {
            function Ve() {
                return Z("No tagged elements (" + Ie + ") found on page"),
                document.querySelectorAll("body *")
            }
            var kt = document.querySelectorAll("[" + Ie + "]");
            return kt.length === 0 && Ve(),
            tt(ce, kt)
        }
        function hn() {
            return document.querySelectorAll("body *")
        }
        var $ = {
            bodyOffset: function () {
                return document.body.offsetHeight + on("marginTop") + on("marginBottom")
            },
            offset: function () {
                return $.bodyOffset()
            },
            bodyScroll: function () {
                return document.body.scrollHeight
            },
            custom: function () {
                return at.height()
            },
            documentElementOffset: function () {
                return document.documentElement.offsetHeight
            },
            documentElementScroll: function () {
                return document.documentElement.scrollHeight
            },
            max: function () {
                return Math.max.apply(null, Tt($))
            },
            min: function () {
                return Math.min.apply(null, Tt($))
            },
            grow: function () {
                return $.max()
            },
            lowestElement: function () {
                return Math.max($.bodyOffset() || $.documentElementOffset(), tt("bottom", hn()))
            },
            taggedElement: function () {
                return mn("bottom", "data-iframe-height")
            }
        },
        D = {
            bodyScroll: function () {
                return document.body.scrollWidth
            },
            bodyOffset: function () {
                return document.body.offsetWidth
            },
            custom: function () {
                return at.width()
            },
            documentElementScroll: function () {
                return document.documentElement.scrollWidth
            },
            documentElementOffset: function () {
                return document.documentElement.offsetWidth
            },
            scroll: function () {
                return Math.max(D.bodyScroll(), D.documentElementScroll())
            },
            max: function () {
                return Math.max.apply(null, Tt(D))
            },
            min: function () {
                return Math.min.apply(null, Tt(D))
            },
            rightMostElement: function () {
                return tt("right", hn())
            },
            taggedElement: function () {
                return mn("right", "data-iframe-width")
            }
        };
        function q(ce, Ie, Ve, kt) {
            function Qt() {
                m = En,
                de = Jt,
                gt(m, de, ce)
            }
            function qn() {
                function Ao(no, ll) {
                    var nd = Math.abs(no - ll) <= G;
                    return !nd
                }
                return En = t !== Ve ? Ve : $[y](),
                Jt = t !== kt ? kt : D[Pe](),
                Ao(m, En) || c && Ao(de, Jt)
            }
            function Qn() {
                return !(ce in {
                    init: 1,
                    interval: 1,
                    size: 1
                })
            }
            function ar() {
                return y in N || c && Pe in N
            }
            function Nn() {
                Q("No change in size detected")
            }
            function Rn() {
                Qn() && ar() ? gr(Ie) : ce in {
                    interval: 1
                }
                 || Nn()
            }
            var En,
            Jt;
            qn() || ce === "init" ? (it(), Qt()) : Rn()
        }
        var ie = W(q);
        function Ae(ce, Ie, Ve, kt) {
            function Qt() {
                ce in {
                    reset: 1,
                    resetPage: 1,
                    init: 1
                }
                 || Q("Trigger event: " + Ie)
            }
            function qn() {
                return Y && ce in u
            }
            qn() ? Q("Trigger event cancelled: " + ce) : (Qt(), ce === "init" ? q(ce, Ie, Ve, kt) : ie(ce, Ie, Ve, kt))
        }
        function it() {
            Y || (Y = !0, Q("Trigger event lock on")),
            clearTimeout(ue),
            ue = setTimeout(function () {
                Y = !1,
                Q("Trigger event lock off"),
                Q("--")
            }, f)
        }
        function vt(ce) {
            m = $[y](),
            de = D[Pe](),
            gt(m, de, ce)
        }
        function gr(ce) {
            var Ie = y;
            y = v,
            Q("Reset trigger event: " + ce),
            it(),
            vt("reset"),
            y = Ie
        }
        function gt(ce, Ie, Ve, kt, Qt) {
            function qn() {
                t === Qt ? Qt = j : Q("Message targetOrigin: " + Qt)
            }
            function Qn() {
                var ar = ce + ":" + Ie,
                Nn = M + ":" + ar + ":" + Ve + (t !== kt ? ":" + kt : "");
                Q("Sending message to host page (" + Nn + ")"),
                K.postMessage(T + Nn, Qt)
            }
            qn(),
            Qn()
        }
        function Zn(ce) {
            var Ie = {
                init: function () {
                    w = ce.data,
                    K = ce.source,
                    fe(),
                    p = !1,
                    setTimeout(function () {
                        b = !1
                    }, f)
                },
                reset: function () {
                    b ? Q("Page reset ignored by init") : (Q("Page size reset by host page"), vt("resetPage"))
                },
                resize: function () {
                    Ae("resizeParent", "Parent window requested size check")
                },
                moveToAnchor: function () {
                    k.findTarget(Qt())
                },
                inPageLink: function () {
                    this.moveToAnchor()
                },
                pageInfo: function () {
                    var En = Qt();
                    Q("PageInfoFromParent called from parent: " + En),
                    yt(JSON.parse(En)),
                    Q(" --")
                },
                message: function () {
                    var En = Qt();
                    Q("onMessage called from parent: " + En),
                    Ke(JSON.parse(En)),
                    Q(" --")
                }
            };
            function Ve() {
                return T === ("" + ce.data).substr(0, E)
            }
            function kt() {
                return ce.data.split("]")[1].split(":")[0]
            }
            function Qt() {
                return ce.data.substr(ce.data.indexOf(":") + 1)
            }
            function qn() {
                return !e.exports && "iFrameResize" in window || "jQuery" in window && "iFrameResize" in window.jQuery.prototype
            }
            function Qn() {
                return ce.data.split(":")[2]in {
                    true: 1,
                    false: 1
                }
            }
            function ar() {
                var Rn = kt();
                Rn in Ie ? Ie[Rn]() : !qn() && !Qn() && Z("Unexpected message (" + ce.data + ")")
            }
            function Nn() {
                p === !1 ? ar() : Qn() ? Ie.init() : Q('Ignored message of type "' + kt() + '". Received before initialization.')
            }
            Ve() && Nn()
        }
        function Sr() {
            document.readyState !== "loading" && window.parent.postMessage("[iFrameResizerChild]Ready", "*")
        }
        xe(window, "message", Zn),
        xe(window, "readystatechange", Sr),
        Sr()
    })()
})(Cbe);
var W7 = Sx;
Iw.iframeResize = W7;
Iw.iframeResizer = W7;
Iw.iframeResizerContentWindow = Cx;
(function (e) {
    e.exports = Iw
})(xbe);
const Ibe = `window.knimeResourceBaseUrl = '%RESOURCEBASEURL%';
window.pageBuilderPresent = true;

window.knimeLoader = (function () {
    var origin = '%ORIGIN%';
    var namespace = '%NAMESPACE%';
    var nodeId = '%NODEID%';
    var knimeLoaderCount = '%LIBCOUNT%';

    var postResponse = function (error) {
        var postMessageOrigin = origin;
        if (!postMessageOrigin || postMessageOrigin.indexOf('file:') > -1) {
            postMessageOrigin = '*';
        }
        parent.postMessage({
            nodeId: nodeId,
            type: 'load',
            error: error
        }, postMessageOrigin);
    };

    if (knimeLoaderCount === 0) {
        postResponse();
    }

    return function knimeLoader(success) {
        knimeLoaderCount--;
        if (!success) {
            var scriptErrorMsg = 'Script could not be loaded';
            postResponse(scriptErrorMsg);
            throw new Error(scriptErrorMsg);
        }
        if (knimeLoaderCount === 0) {
            var view = window[namespace];
            if (!view) {
                var referenceErrorMsg = 'No view found under namespace ' + namespace;
                postResponse(referenceErrorMsg);
                throw new ReferenceError(referenceErrorMsg);
            }
            postResponse();
        }
    };
})();
    `, Tbe = `/* eslint-disable complexity */
(function () {
    var messageFromParent = function (event) {
        if (!event || !event.origin) {
            return;
        }
        var origin = '%ORIGIN%';
        var data = event.data;
        var originMatch = event.origin === origin || event.origin === '*' || event.origin.indexOf('file:') >= 0;
        if (!originMatch || !data) {
            return;
        }
        var namespace = data.namespace;
        var nodeId = data.nodeId;
        var postMessageOrigin = origin;
        if (!postMessageOrigin || postMessageOrigin.indexOf('file:') > -1) {
            postMessageOrigin = '*';
        }
        var postMessageResponse = function (resp) {
            resp.nodeId = nodeId;
            parent.postMessage(resp, postMessageOrigin);
        };
        var postErrorResponse = function (type, errMsg) {
            var resp = {
                isValid: false,
                nodeId: nodeId,
                type: type,
                error: errMsg
            };
            parent.postMessage(resp, postMessageOrigin);
        };
        if (data.type === 'init') {
            if (window[namespace] && typeof window[namespace][data.initMethodName] === 'function') {
                try {
                    var viewRepresentation = JSON.parse(data.viewRepresentation);
                    var viewValue = JSON.parse(data.viewValue);
                    window[namespace][data.initMethodName](viewRepresentation, viewValue);
                } catch (err) {
                    postErrorResponse(data.type, 'View initialization failed: ' + err);
                }
            } else {
                postErrorResponse(data.type, 'Init method not present in view.');
            }
        } else if (data.type === 'validate') {
            var validResp = {
                isValid: true,
                type: 'validate'
            };
            // optional method; some views don't have (i.e. some quickforms)
            if (window[namespace] && typeof window[namespace][data.validateMethodName] === 'function') {
                try {
                    validResp.isValid = window[namespace][data.validateMethodName]();
                    postMessageResponse(validResp);
                } catch (err) {
                    postErrorResponse(data.type, 'View could not be validated: ' + err);
                }
            } else {
                postMessageResponse(validResp);
            }
        } else if (data.type === 'getValue') {
            if (window[namespace] && typeof window[namespace][data.getViewValueMethodName] === 'function') {
                try {
                    postMessageResponse({
                        value: window[namespace][data.getViewValueMethodName](),
                        type: 'getValue'
                    });
                } catch (err) {
                    postErrorResponse(data.type, 'Value could not be retrieved from view: ' + err);
                }
            } else {
                postErrorResponse(data.type, 'Value method not present in view.');
            }
        } else if (data.type === 'setValidationError') {
            var errorMessagePrefix = 'View error message could not be set: ';
            // optional method; some views don't have (i.e. some quickforms)
            if (window[namespace] && typeof window[namespace][data.setValidationErrorMethodName] === 'function') {
                try {
                    window[namespace][data.setValidationErrorMethodName](data.errorMessage);
                    postMessageResponse(data);
                } catch (err) {
                    postErrorResponse(data.type, errorMessagePrefix + err);
                }
            } else {
                postErrorResponse(data.type, errorMessagePrefix + 'Method does not exist.');
            }
        }
    };
    window.addEventListener('message', messageFromParent);
})();
    `, Mbe = `/*
 * File: iframeResizer.contentWindow.js
 * Desc: Include this file in any page being loaded into an iframe
 *       to force the iframe to resize to the content size.
 * Requires: iframeResizer.js on host page.
 * Doc: https://github.com/davidjbradshaw/iframe-resizer
 * Author: David J. Bradshaw - dave@bradshaw.net
 *
 */

// eslint-disable-next-line sonarjs/cognitive-complexity, no-shadow-restricted-names;(function(undefined) {
  if (typeof window === 'undefined') return // don't run for server side render

  var autoResize = true,
    base = 10,
    bodyBackground = '',
    bodyMargin = 0,
    bodyMarginStr = '',
    bodyObserver = null,
    bodyPadding = '',
    calculateWidth = false,
    doubleEventList = { resize: 1, click: 1 },
    eventCancelTimer = 128,
    firstRun = true,
    height = 1,
    heightCalcModeDefault = 'bodyOffset',
    heightCalcMode = heightCalcModeDefault,
    initLock = true,
    initMsg = '',
    inPageLinks = {},
    interval = 32,
    intervalTimer = null,
    logging = false,
    msgID = '[iFrameSizer]', // Must match host page msg ID
    msgIdLen = msgID.length,
    myID = '',
    resetRequiredMethods = {
      max: 1,
      min: 1,
      bodyScroll: 1,
      documentElementScroll: 1
    },
    resizeFrom = 'child',
    sendPermit = true,
    target = window.parent,
    targetOriginDefault = '*',
    tolerance = 0,
    triggerLocked = false,
    triggerLockedTimer = null,
    throttledTimer = 16,
    width = 1,
    widthCalcModeDefault = 'scroll',
    widthCalcMode = widthCalcModeDefault,
    win = window,
    onMessage = function() {
      warn('onMessage function not defined')
    },
    onReady = function() {},
    onPageInfo = function() {},
    customCalcMethods = {
      height: function() {
        warn('Custom height calculation function not defined')
        return document.documentElement.offsetHeight
      },
      width: function() {
        warn('Custom width calculation function not defined')
        return document.body.scrollWidth
      }
    },
    eventHandlersByName = {},
    passiveSupported = false

  function noop() {}

  try {
    var options = Object.create(
      {},
      {
        passive: {
          get: function() {
            passiveSupported = true
          }
        }
      }
    )
    window.addEventListener('test', noop, options)
    window.removeEventListener('test', noop, options)
  } catch (error) {
    /* */
  }

  function addEventListener(el, evt, func, options) {
    el.addEventListener(evt, func, passiveSupported ? options || {} : false)
  }

  function removeEventListener(el, evt, func) {
    el.removeEventListener(evt, func, false)
  }

  function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1)
  }

  // Based on underscore.js
  function throttle(func) {
    var context,
      args,
      result,
      timeout = null,
      previous = 0,
      later = function() {
        previous = getNow()
        timeout = null
        result = func.apply(context, args)
        if (!timeout) {
          // eslint-disable-next-line no-multi-assign
          context = args = null
        }
      }

    return function() {
      var now = getNow()

      if (!previous) {
        previous = now
      }

      var remaining = throttledTimer - (now - previous)

      context = this
      args = arguments

      if (remaining <= 0 || remaining > throttledTimer) {
        if (timeout) {
          clearTimeout(timeout)
          timeout = null
        }

        previous = now
        result = func.apply(context, args)

        if (!timeout) {
          // eslint-disable-next-line no-multi-assign
          context = args = null
        }
      } else if (!timeout) {
        timeout = setTimeout(later, remaining)
      }

      return result
    }
  }

  var getNow =
    Date.now ||
    function() {
      /* istanbul ignore next */ // Not testable in PhantonJS
      return new Date().getTime()
    }

  function formatLogMsg(msg) {
    return msgID + '[' + myID + '] ' + msg
  }

  function log(msg) {
    if (logging && 'object' === typeof window.console) {
      // eslint-disable-next-line no-console
      console.log(formatLogMsg(msg))
    }
  }

  function warn(msg) {
    if ('object' === typeof window.console) {
      // eslint-disable-next-line no-console
      console.warn(formatLogMsg(msg))
    }
  }

  function init() {
    readDataFromParent()
    log('Initialising iFrame (' + location.href + ')')
    readDataFromPage()
    setMargin()
    setBodyStyle('background', bodyBackground)
    setBodyStyle('padding', bodyPadding)
    injectClearFixIntoBodyElement()
    checkHeightMode()
    checkWidthMode()
    stopInfiniteResizingOfIFrame()
    setupPublicMethods()
    startEventListeners()
    inPageLinks = setupInPageLinks()
    sendSize('init', 'Init message from host page')
    onReady()
  }

  function readDataFromParent() {
    function strBool(str) {
      return 'true' === str
    }

    var data = initMsg.substr(msgIdLen).split(':')

    myID = data[0]
    bodyMargin = undefined !== data[1] ? Number(data[1]) : bodyMargin // For V1 compatibility
    calculateWidth = undefined !== data[2] ? strBool(data[2]) : calculateWidth
    logging = undefined !== data[3] ? strBool(data[3]) : logging
    interval = undefined !== data[4] ? Number(data[4]) : interval
    autoResize = undefined !== data[6] ? strBool(data[6]) : autoResize
    bodyMarginStr = data[7]
    heightCalcMode = undefined !== data[8] ? data[8] : heightCalcMode
    bodyBackground = data[9]
    bodyPadding = data[10]
    tolerance = undefined !== data[11] ? Number(data[11]) : tolerance
    inPageLinks.enable = undefined !== data[12] ? strBool(data[12]) : false
    resizeFrom = undefined !== data[13] ? data[13] : resizeFrom
    widthCalcMode = undefined !== data[14] ? data[14] : widthCalcMode
  }

  function depricate(key) {
    var splitName = key.split('Callback')

    if (splitName.length === 2) {
      var name =
        'on' + splitName[0].charAt(0).toUpperCase() + splitName[0].slice(1)
      this[name] = this[key]
      delete this[key]
      warn(
        "Deprecated: '" +
          key +
          "' has been renamed '" +
          name +
          "'. The old method will be removed in the next major version."
      )
    }
  }

  function readDataFromPage() {
    function readData() {
      var data = window.iFrameResizer

      log('Reading data from page: ' + JSON.stringify(data))
      Object.keys(data).forEach(depricate, data)

      onMessage = 'onMessage' in data ? data.onMessage : onMessage
      onReady = 'onReady' in data ? data.onReady : onReady
      targetOriginDefault =
        'targetOrigin' in data ? data.targetOrigin : targetOriginDefault
      heightCalcMode =
        'heightCalculationMethod' in data
          ? data.heightCalculationMethod
          : heightCalcMode
      widthCalcMode =
        'widthCalculationMethod' in data
          ? data.widthCalculationMethod
          : widthCalcMode
    }

    function setupCustomCalcMethods(calcMode, calcFunc) {
      if ('function' === typeof calcMode) {
        log('Setup custom ' + calcFunc + 'CalcMethod')
        customCalcMethods[calcFunc] = calcMode
        calcMode = 'custom'
      }

      return calcMode
    }

    if (
      'iFrameResizer' in window &&
      Object === window.iFrameResizer.constructor
    ) {
      readData()
      heightCalcMode = setupCustomCalcMethods(heightCalcMode, 'height')
      widthCalcMode = setupCustomCalcMethods(widthCalcMode, 'width')
    }

    log('TargetOrigin for parent set to: ' + targetOriginDefault)
  }

  function chkCSS(attr, value) {
    if (-1 !== value.indexOf('-')) {
      warn('Negative CSS value ignored for ' + attr)
      value = ''
    }
    return value
  }

  function setBodyStyle(attr, value) {
    if (undefined !== value && '' !== value && 'null' !== value) {
      document.body.style[attr] = value
      log('Body ' + attr + ' set to "' + value + '"')
    }
  }

  function setMargin() {
    // If called via V1 script, convert bodyMargin from int to str
    if (undefined === bodyMarginStr) {
      bodyMarginStr = bodyMargin + 'px'
    }

    setBodyStyle('margin', chkCSS('margin', bodyMarginStr))
  }

  function stopInfiniteResizingOfIFrame() {
    document.documentElement.style.height = ''
    document.body.style.height = ''
    log('HTML & body height set to "auto"')
  }

  function manageTriggerEvent(options) {
    var listener = {
      add: function(eventName) {
        function handleEvent() {
          sendSize(options.eventName, options.eventType)
        }

        eventHandlersByName[eventName] = handleEvent

        addEventListener(window, eventName, handleEvent, { passive: true })
      },
      remove: function(eventName) {
        var handleEvent = eventHandlersByName[eventName]
        delete eventHandlersByName[eventName]

        removeEventListener(window, eventName, handleEvent)
      }
    }

    if (options.eventNames && Array.prototype.map) {
      options.eventName = options.eventNames[0]
      options.eventNames.map(listener[options.method])
    } else {
      listener[options.method](options.eventName)
    }

    log(
      capitalizeFirstLetter(options.method) +
        ' event listener: ' +
        options.eventType
    )
  }

  function manageEventListeners(method) {
    manageTriggerEvent({
      method: method,
      eventType: 'Animation Start',
      eventNames: ['animationstart', 'webkitAnimationStart']
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Animation Iteration',
      eventNames: ['animationiteration', 'webkitAnimationIteration']
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Animation End',
      eventNames: ['animationend', 'webkitAnimationEnd']
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Input',
      eventName: 'input'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Mouse Up',
      eventName: 'mouseup'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Mouse Down',
      eventName: 'mousedown'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Orientation Change',
      eventName: 'orientationchange'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Print',
      eventName: ['afterprint', 'beforeprint']
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Ready State Change',
      eventName: 'readystatechange'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Touch Start',
      eventName: 'touchstart'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Touch End',
      eventName: 'touchend'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Touch Cancel',
      eventName: 'touchcancel'
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Transition Start',
      eventNames: [
        'transitionstart',
        'webkitTransitionStart',
        'MSTransitionStart',
        'oTransitionStart',
        'otransitionstart'
      ]
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Transition Iteration',
      eventNames: [
        'transitioniteration',
        'webkitTransitionIteration',
        'MSTransitionIteration',
        'oTransitionIteration',
        'otransitioniteration'
      ]
    })
    manageTriggerEvent({
      method: method,
      eventType: 'Transition End',
      eventNames: [
        'transitionend',
        'webkitTransitionEnd',
        'MSTransitionEnd',
        'oTransitionEnd',
        'otransitionend'
      ]
    })
    if ('child' === resizeFrom) {
      manageTriggerEvent({
        method: method,
        eventType: 'IFrame Resized',
        eventName: 'resize'
      })
    }
  }

  function checkCalcMode(calcMode, calcModeDefault, modes, type) {
    if (calcModeDefault !== calcMode) {
      if (!(calcMode in modes)) {
        warn(
          calcMode + ' is not a valid option for ' + type + 'CalculationMethod.'
        )
        calcMode = calcModeDefault
      }
      log(type + ' calculation method set to "' + calcMode + '"')
    }

    return calcMode
  }

  function checkHeightMode() {
    heightCalcMode = checkCalcMode(
      heightCalcMode,
      heightCalcModeDefault,
      getHeight,
      'height'
    )
  }

  function checkWidthMode() {
    widthCalcMode = checkCalcMode(
      widthCalcMode,
      widthCalcModeDefault,
      getWidth,
      'width'
    )
  }

  function startEventListeners() {
    if (true === autoResize) {
      manageEventListeners('add')
      setupMutationObserver()
    } else {
      log('Auto Resize disabled')
    }
  }

  //   function stopMsgsToParent() {
  //     log('Disable outgoing messages')
  //     sendPermit = false
  //   }

  //   function removeMsgListener() {
  //     log('Remove event listener: Message')
  //     removeEventListener(window, 'message', receiver)
  //   }

  function disconnectMutationObserver() {
    if (null !== bodyObserver) {
      /* istanbul ignore next */ // Not testable in PhantonJS
      bodyObserver.disconnect()
    }
  }

  function stopEventListeners() {
    manageEventListeners('remove')
    disconnectMutationObserver()
    clearInterval(intervalTimer)
  }

  //   function teardown() {
  //     stopMsgsToParent()
  //     removeMsgListener()
  //     if (true === autoResize) stopEventListeners()
  //   }

  function injectClearFixIntoBodyElement() {
    var clearFix = document.createElement('div')
    clearFix.style.clear = 'both'
    // Guard against the following having been globally redefined in CSS.
    clearFix.style.display = 'block'
    clearFix.style.height = '0'
    document.body.appendChild(clearFix)
  }

  function setupInPageLinks() {
    function getPagePosition() {
      return {
        x:
          window.pageXOffset !== undefined
            ? window.pageXOffset
            : document.documentElement.scrollLeft,
        y:
          window.pageYOffset !== undefined
            ? window.pageYOffset
            : document.documentElement.scrollTop
      }
    }

    function getElementPosition(el) {
      var elPosition = el.getBoundingClientRect(),
        pagePosition = getPagePosition()

      return {
        x: parseInt(elPosition.left, 10) + parseInt(pagePosition.x, 10),
        y: parseInt(elPosition.top, 10) + parseInt(pagePosition.y, 10)
      }
    }

    function findTarget(location) {
      function jumpToTarget(target) {
        var jumpPosition = getElementPosition(target)

        log(
          'Moving to in page link (#' +
            hash +
            ') at x: ' +
            jumpPosition.x +
            ' y: ' +
            jumpPosition.y
        )
        sendMsg(jumpPosition.y, jumpPosition.x, 'scrollToOffset') // X&Y reversed at sendMsg uses height/width
      }

      var hash = location.split('#')[1] || location, // Remove # if present
        hashData = decodeURIComponent(hash),
        target =
          document.getElementById(hashData) ||
          document.getElementsByName(hashData)[0]

      if (undefined !== target) {
        jumpToTarget(target)
      } else {
        log(
          'In page link (#' +
            hash +
            ') not found in iFrame, so sending to parent'
        )
        sendMsg(0, 0, 'inPageLink', '#' + hash)
      }
    }

    function checkLocationHash() {
      if ('' !== location.hash && '#' !== location.hash) {
        findTarget(location.href)
      }
    }

    function bindAnchors() {
      function setupLink(el) {
        function linkClicked(e) {
          e.preventDefault()

          /* jshint validthis:true */
          findTarget(this.getAttribute('href'))
        }

        if ('#' !== el.getAttribute('href')) {
          addEventListener(el, 'click', linkClicked)
        }
      }

      Array.prototype.forEach.call(
        document.querySelectorAll('a[href^="#"]'),
        setupLink
      )
    }

    function bindLocationHash() {
      addEventListener(window, 'hashchange', checkLocationHash)
    }

    function initCheck() {
      // Check if page loaded with location hash after init resize
      setTimeout(checkLocationHash, eventCancelTimer)
    }

    function enableInPageLinks() {
      /* istanbul ignore else */ // Not testable in phantonJS
      if (Array.prototype.forEach && document.querySelectorAll) {
        log('Setting up location.hash handlers')
        bindAnchors()
        bindLocationHash()
        initCheck()
      } else {
        warn(
          'In page linking not fully supported in this browser! (See README.md for IE8 workaround)'
        )
      }
    }

    if (inPageLinks.enable) {
      enableInPageLinks()
    } else {
      log('In page linking not enabled')
    }

    return {
      findTarget: findTarget
    }
  }

  function setupPublicMethods() {
    log('Enable public methods')

    win.parentIFrame = {
      autoResize: function autoResizeF(resize) {
        if (true === resize && false === autoResize) {
          autoResize = true
          startEventListeners()
        } else if (false === resize && true === autoResize) {
          autoResize = false
          stopEventListeners()
        }
        sendMsg(0, 0, 'autoResize', JSON.stringify(autoResize))
        return autoResize
      },

      close: function closeF() {
        sendMsg(0, 0, 'close')
        // teardown()
      },

      getId: function getIdF() {
        return myID
      },

      getPageInfo: function getPageInfoF(callback) {
        if ('function' === typeof callback) {
          onPageInfo = callback
          sendMsg(0, 0, 'pageInfo')
        } else {
          onPageInfo = function() {}
          sendMsg(0, 0, 'pageInfoStop')
        }
      },

      moveToAnchor: function moveToAnchorF(hash) {
        inPageLinks.findTarget(hash)
      },

      reset: function resetF() {
        resetIFrame('parentIFrame.reset')
      },

      scrollTo: function scrollToF(x, y) {
        sendMsg(y, x, 'scrollTo') // X&Y reversed at sendMsg uses height/width
      },

      scrollToOffset: function scrollToF(x, y) {
        sendMsg(y, x, 'scrollToOffset') // X&Y reversed at sendMsg uses height/width
      },

      sendMessage: function sendMessageF(msg, targetOrigin) {
        sendMsg(0, 0, 'message', JSON.stringify(msg), targetOrigin)
      },

      setHeightCalculationMethod: function setHeightCalculationMethodF(
        heightCalculationMethod
      ) {
        heightCalcMode = heightCalculationMethod
        checkHeightMode()
      },

      setWidthCalculationMethod: function setWidthCalculationMethodF(
        widthCalculationMethod
      ) {
        widthCalcMode = widthCalculationMethod
        checkWidthMode()
      },

      setTargetOrigin: function setTargetOriginF(targetOrigin) {
        log('Set targetOrigin: ' + targetOrigin)
        targetOriginDefault = targetOrigin
      },

      size: function sizeF(customHeight, customWidth) {
        var valString =
          '' + (customHeight || '') + (customWidth ? ',' + customWidth : '')
        sendSize(
          'size',
          'parentIFrame.size(' + valString + ')',
          customHeight,
          customWidth
        )
      }
    }
  }

  function initInterval() {
    if (0 !== interval) {
      log('setInterval: ' + interval + 'ms')
      intervalTimer = setInterval(function() {
        sendSize('interval', 'setInterval: ' + interval)
      }, Math.abs(interval))
    }
  }

  // Not testable in PhantomJS
  /* istanbul ignore next */
  function setupBodyMutationObserver() {
    function addImageLoadListners(mutation) {
      function addImageLoadListener(element) {
        if (false === element.complete) {
          log('Attach listeners to ' + element.src)
          element.addEventListener('load', imageLoaded, false)
          element.addEventListener('error', imageError, false)
          elements.push(element)
        }
      }

      if (mutation.type === 'attributes' && mutation.attributeName === 'src') {
        addImageLoadListener(mutation.target)
      } else if (mutation.type === 'childList') {
        Array.prototype.forEach.call(
          mutation.target.querySelectorAll('img'),
          addImageLoadListener
        )
      }
    }

    function removeFromArray(element) {
      elements.splice(elements.indexOf(element), 1)
    }

    function removeImageLoadListener(element) {
      log('Remove listeners from ' + element.src)
      element.removeEventListener('load', imageLoaded, false)
      element.removeEventListener('error', imageError, false)
      removeFromArray(element)
    }

    function imageEventTriggered(event, type, typeDesc) {
      removeImageLoadListener(event.target)
      sendSize(type, typeDesc + ': ' + event.target.src, undefined, undefined)
    }

    function imageLoaded(event) {
      imageEventTriggered(event, 'imageLoad', 'Image loaded')
    }

    function imageError(event) {
      imageEventTriggered(event, 'imageLoadFailed', 'Image load failed')
    }

    function mutationObserved(mutations) {
      sendSize(
        'mutationObserver',
        'mutationObserver: ' + mutations[0].target + ' ' + mutations[0].type
      )

      // Deal with WebKit / Blink asyncing image loading when tags are injected into the page
      mutations.forEach(addImageLoadListners)
    }

    function createMutationObserver() {
      var target = document.querySelector('body'),
        config = {
          attributes: true,
          attributeOldValue: false,
          characterData: true,
          characterDataOldValue: false,
          childList: true,
          subtree: true
        }

      observer = new MutationObserver(mutationObserved)

      log('Create body MutationObserver')
      observer.observe(target, config)

      return observer
    }

    var elements = [],
      MutationObserver =
        window.MutationObserver || window.WebKitMutationObserver,
      observer = createMutationObserver()

    return {
      disconnect: function() {
        if ('disconnect' in observer) {
          log('Disconnect body MutationObserver')
          observer.disconnect()
          elements.forEach(removeImageLoadListener)
        }
      }
    }
  }

  function setupMutationObserver() {
    var forceIntervalTimer = 0 > interval

    // Not testable in PhantomJS
    /* istanbul ignore if */ if (
      window.MutationObserver ||
      window.WebKitMutationObserver
    ) {
      if (forceIntervalTimer) {
        initInterval()
      } else {
        bodyObserver = setupBodyMutationObserver()
      }
    } else {
      log('MutationObserver not supported in this browser!')
      initInterval()
    }
  }

  // document.documentElement.offsetHeight is not reliable, so
  // we have to jump through hoops to get a better value.
  function getComputedStyle(prop, el) {
    var retVal = 0
    el = el || document.body // Not testable in phantonJS

    retVal = document.defaultView.getComputedStyle(el, null)
    retVal = null !== retVal ? retVal[prop] : 0

    return parseInt(retVal, base)
  }

  function chkEventThottle(timer) {
    if (timer > throttledTimer / 2) {
      throttledTimer = 2 * timer
      log('Event throttle increased to ' + throttledTimer + 'ms')
    }
  }

  // Idea from https://github.com/guardian/iframe-messenger
  function getMaxElement(side, elements) {
    var elementsLength = elements.length,
      elVal = 0,
      maxVal = 0,
      Side = capitalizeFirstLetter(side),
      timer = getNow()

    for (var i = 0; i < elementsLength; i++) {
      elVal =
        elements[i].getBoundingClientRect()[side] +
        getComputedStyle('margin' + Side, elements[i])
      if (elVal > maxVal) {
        maxVal = elVal
      }
    }

    timer = getNow() - timer

    log('Parsed ' + elementsLength + ' HTML elements')
    log('Element position calculated in ' + timer + 'ms')

    chkEventThottle(timer)

    return maxVal
  }

  function getAllMeasurements(dimention) {
    return [
      dimention.bodyOffset(),
      dimention.bodyScroll(),
      dimention.documentElementOffset(),
      dimention.documentElementScroll()
    ]
  }

  function getTaggedElements(side, tag) {
    function noTaggedElementsFound() {
      warn('No tagged elements (' + tag + ') found on page')
      return document.querySelectorAll('body *')
    }

    var elements = document.querySelectorAll('[' + tag + ']')

    if (0 === elements.length) noTaggedElementsFound()

    return getMaxElement(side, elements)
  }

  function getAllElements() {
    return document.querySelectorAll('body *')
  }

  var getHeight = {
      bodyOffset: function getBodyOffsetHeight() {
        return (
          document.body.offsetHeight +
          getComputedStyle('marginTop') +
          getComputedStyle('marginBottom')
        )
      },

      offset: function() {
        return getHeight.bodyOffset() // Backwards compatability
      },

      bodyScroll: function getBodyScrollHeight() {
        return document.body.scrollHeight
      },

      custom: function getCustomWidth() {
        return customCalcMethods.height()
      },

      documentElementOffset: function getDEOffsetHeight() {
        return document.documentElement.offsetHeight
      },

      documentElementScroll: function getDEScrollHeight() {
        return document.documentElement.scrollHeight
      },

      max: function getMaxHeight() {
        return Math.max.apply(null, getAllMeasurements(getHeight))
      },

      min: function getMinHeight() {
        return Math.min.apply(null, getAllMeasurements(getHeight))
      },

      grow: function growHeight() {
        return getHeight.max() // Run max without the forced downsizing
      },

      lowestElement: function getBestHeight() {
        return Math.max(
          getHeight.bodyOffset() || getHeight.documentElementOffset(),
          getMaxElement('bottom', getAllElements())
        )
      },

      taggedElement: function getTaggedElementsHeight() {
        return getTaggedElements('bottom', 'data-iframe-height')
      }
    },
    getWidth = {
      bodyScroll: function getBodyScrollWidth() {
        return document.body.scrollWidth
      },

      bodyOffset: function getBodyOffsetWidth() {
        return document.body.offsetWidth
      },

      custom: function getCustomWidth() {
        return customCalcMethods.width()
      },

      documentElementScroll: function getDEScrollWidth() {
        return document.documentElement.scrollWidth
      },

      documentElementOffset: function getDEOffsetWidth() {
        return document.documentElement.offsetWidth
      },

      scroll: function getMaxWidth() {
        return Math.max(getWidth.bodyScroll(), getWidth.documentElementScroll())
      },

      max: function getMaxWidth() {
        return Math.max.apply(null, getAllMeasurements(getWidth))
      },

      min: function getMinWidth() {
        return Math.min.apply(null, getAllMeasurements(getWidth))
      },

      rightMostElement: function rightMostElement() {
        return getMaxElement('right', getAllElements())
      },

      taggedElement: function getTaggedElementsWidth() {
        return getTaggedElements('right', 'data-iframe-width')
      }
    }

  function sizeIFrame(
    triggerEvent,
    triggerEventDesc,
    customHeight,
    customWidth
  ) {
    function resizeIFrame() {
      height = currentHeight
      width = currentWidth

      sendMsg(height, width, triggerEvent)
    }

    function isSizeChangeDetected() {
      function checkTolarance(a, b) {
        var retVal = Math.abs(a - b) <= tolerance
        return !retVal
      }

      currentHeight =
        undefined !== customHeight ? customHeight : getHeight[heightCalcMode]()
      currentWidth =
        undefined !== customWidth ? customWidth : getWidth[widthCalcMode]()

      return (
        checkTolarance(height, currentHeight) ||
        (calculateWidth && checkTolarance(width, currentWidth))
      )
    }

    function isForceResizableEvent() {
      return !(triggerEvent in { init: 1, interval: 1, size: 1 })
    }

    function isForceResizableCalcMode() {
      return (
        heightCalcMode in resetRequiredMethods ||
        (calculateWidth && widthCalcMode in resetRequiredMethods)
      )
    }

    function logIgnored() {
      log('No change in size detected')
    }

    function checkDownSizing() {
      if (isForceResizableEvent() && isForceResizableCalcMode()) {
        resetIFrame(triggerEventDesc)
      } else if (!(triggerEvent in { interval: 1 })) {
        logIgnored()
      }
    }

    var currentHeight, currentWidth

    if (isSizeChangeDetected() || 'init' === triggerEvent) {
      lockTrigger()
      resizeIFrame()
    } else {
      checkDownSizing()
    }
  }

  var sizeIFrameThrottled = throttle(sizeIFrame)

  function sendSize(triggerEvent, triggerEventDesc, customHeight, customWidth) {
    function recordTrigger() {
      if (!(triggerEvent in { reset: 1, resetPage: 1, init: 1 })) {
        log('Trigger event: ' + triggerEventDesc)
      }
    }

    function isDoubleFiredEvent() {
      return triggerLocked && triggerEvent in doubleEventList
    }

    if (!isDoubleFiredEvent()) {
      recordTrigger()
      if (triggerEvent === 'init') {
        sizeIFrame(triggerEvent, triggerEventDesc, customHeight, customWidth)
      } else {
        sizeIFrameThrottled(
          triggerEvent,
          triggerEventDesc,
          customHeight,
          customWidth
        )
      }
    } else {
      log('Trigger event cancelled: ' + triggerEvent)
    }
  }

  function lockTrigger() {
    if (!triggerLocked) {
      triggerLocked = true
      log('Trigger event lock on')
    }
    clearTimeout(triggerLockedTimer)
    triggerLockedTimer = setTimeout(function() {
      triggerLocked = false
      log('Trigger event lock off')
      log('--')
    }, eventCancelTimer)
  }

  function triggerReset(triggerEvent) {
    height = getHeight[heightCalcMode]()
    width = getWidth[widthCalcMode]()

    sendMsg(height, width, triggerEvent)
  }

  function resetIFrame(triggerEventDesc) {
    var hcm = heightCalcMode
    heightCalcMode = heightCalcModeDefault

    log('Reset trigger event: ' + triggerEventDesc)
    lockTrigger()
    triggerReset('reset')

    heightCalcMode = hcm
  }

  function sendMsg(height, width, triggerEvent, msg, targetOrigin) {
    function setTargetOrigin() {
      if (undefined === targetOrigin) {
        targetOrigin = targetOriginDefault
      } else {
        log('Message targetOrigin: ' + targetOrigin)
      }
    }

    function sendToParent() {
      var size = height + ':' + width,
        message =
          myID +
          ':' +
          size +
          ':' +
          triggerEvent +
          (undefined !== msg ? ':' + msg : '')

      log('Sending message to host page (' + message + ')')
      target.postMessage(msgID + message, targetOrigin)
    }

    if (true === sendPermit) {
      setTargetOrigin()
      sendToParent()
    }
  }

  function receiver(event) {
    var processRequestFromParent = {
      init: function initFromParent() {
        initMsg = event.data
        target = event.source

        init()
        firstRun = false
        setTimeout(function() {
          initLock = false
        }, eventCancelTimer)
      },

      reset: function resetFromParent() {
        if (!initLock) {
          log('Page size reset by host page')
          triggerReset('resetPage')
        } else {
          log('Page reset ignored by init')
        }
      },

      resize: function resizeFromParent() {
        sendSize('resizeParent', 'Parent window requested size check')
      },

      moveToAnchor: function moveToAnchorF() {
        inPageLinks.findTarget(getData())
      },
      inPageLink: function inPageLinkF() {
        this.moveToAnchor()
      }, // Backward compatability

      pageInfo: function pageInfoFromParent() {
        var msgBody = getData()
        log('PageInfoFromParent called from parent: ' + msgBody)
        onPageInfo(JSON.parse(msgBody))
        log(' --')
      },

      message: function messageFromParent() {
        var msgBody = getData()

        log('onMessage called from parent: ' + msgBody)
        // eslint-disable-next-line sonarjs/no-extra-arguments
        onMessage(JSON.parse(msgBody))
        log(' --')
      }
    }

    function isMessageForUs() {
      return msgID === ('' + event.data).substr(0, msgIdLen) // ''+ Protects against non-string messages
    }

    function getMessageType() {
      return event.data.split(']')[1].split(':')[0]
    }

    function getData() {
      return event.data.substr(event.data.indexOf(':') + 1)
    }

    function isMiddleTier() {
      return (
        (!(typeof module !== 'undefined' && module.exports) &&
          'iFrameResize' in window) ||
        ('jQuery' in window && 'iFrameResize' in window.jQuery.prototype)
      )
    }

    function isInitMsg() {
      // Test if this message is from a child below us. This is an ugly test, however, updating
      // the message format would break backwards compatibity.
      return event.data.split(':')[2] in { true: 1, false: 1 }
    }

    function callFromParent() {
      var messageType = getMessageType()

      if (messageType in processRequestFromParent) {
        processRequestFromParent[messageType]()
      } else if (!isMiddleTier() && !isInitMsg()) {
        warn('Unexpected message (' + event.data + ')')
      }
    }

    function processMessage() {
      if (false === firstRun) {
        callFromParent()
      } else if (isInitMsg()) {
        processRequestFromParent.init()
      } else {
        log(
          'Ignored message of type "' +
            getMessageType() +
            '". Received before initialization.'
        )
      }
    }

    if (isMessageForUs()) {
      processMessage()
    }
  }

  // Normally the parent kicks things off when it detects the iFrame has loaded.
  // If this script is async-loaded, then tell parent page to retry init.
  function chkLateLoaded() {
    if ('loading' !== document.readyState) {
      window.parent.postMessage('[iFrameResizerChild]Ready', '*')
    }
  }

  addEventListener(window, 'message', receiver)
  addEventListener(window, 'readystatechange', chkLateLoaded)
  chkLateLoaded()

  
})()
    `, Pbe = `window.onerror = (function () {
    var origin = '%ORIGIN%';
    var nodeId = '%NODEID%';
    return function (msg) {
        var loadingErrRegExp = new this.RegExp(/load timeout/gmi);
        var postErrorResponse = function (errMsg) {
            var resp = {
                nodeId: nodeId,
                type: 'error',
                isValid: false,
                error: errMsg
            };
            var postMessageOrigin = origin;
            if (!postMessageOrigin || postMessageOrigin.indexOf('file:') > -1) {
                postMessageOrigin = '*';
            }
            parent.postMessage(resp, postMessageOrigin);
        };

        if (loadingErrRegExp.test(msg)) {
            postErrorResponse('Required web resources timed out and could not be loaded.');
        }
    };
})();
    `, Ebe = `window.alert = (function () {
    var origin = '%ORIGIN%';
    var nodeId = '%NODEID%';
    return function (msg) {
        var loadingErrRegExp = new this.RegExp(/error/gmi);
        var postResponse = function (message, level) {
            var resp = {
                nodeId: nodeId,
                type: 'alert',
                message: message,
                level: level
            };
            var postMessageOrigin = origin;
            if (!postMessageOrigin || postMessageOrigin.indexOf('file:') > -1) {
                postMessageOrigin = '*';
            }
            parent.postMessage(resp, postMessageOrigin);
        };

        if (loadingErrRegExp.test(msg)) {
            postResponse(msg, 'error');
        } else {
            postResponse(msg, 'info');
        }
    };
})();
`;
const Obe = 3e4, $be = 5e3, Abe = 5e3, Dbe = {
    components: {
        AlertLocal: j7
    },
    props: {
        viewConfig: {
        default:
            () => ({}),
            type: Object
        },
        nodeConfig: {
        default:
            () => ({}),
            type: Object
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        }
    },
    data() {
        return {
            alert: null
        }
    },
    computed: {
        ...ut("pagebuilder", ["page"]),
        ...zt({
            currentJobId: "wizardExecution/currentJobId",
            authParameter: "oauth/authParameter"
        }),
        iframeId() {
            return this.nodeId && `node-${this.nodeId.replace(/(:)/g, "-")}`
        },
        nodeJsLibs() {
            return this.nodeConfig.javascriptLibraries || []
        },
        nodeStylesheets() {
            return this.nodeConfig.stylesheets || []
        },
        autoHeight() {
            return !this.isSingleView && this.viewConfig.resizeMethod?.startsWith("view")
        },
        classes() {
            let e = [];
            return this.autoHeight || e.push("full-height"),
            e
        },
        origin() {
            let e = window.origin;
            return (!e || e === "null") && (e = window.location.origin),
            e.includes("file:") && (e = "*"),
            e
        },
        isSingleView() {
            return this.page?.wizardPageContent?.isSingleView
        },
        displayAlert() {
            return this.alert?.type === "error"
        }
    },
    mounted() {
        this.autoHeight && this.initIFrameResize(),
        this.$store.dispatch("pagebuilder/setWebNodeLoading", {
            nodeId: this.nodeId,
            loading: !0
        }),
        window.addEventListener("message", this.messageFromIframe),
        this.document = this.$refs.iframe.contentDocument,
        this.injectContent(),
        this.$store.dispatch("pagebuilder/addValidator", {
            nodeId: this.nodeId,
            validator: this.validate
        }),
        this.$store.dispatch("pagebuilder/addValueGetter", {
            nodeId: this.nodeId,
            valueGetter: this.getValue
        }),
        this.$store.dispatch("pagebuilder/addValidationErrorSetter", {
            nodeId: this.nodeId,
            errorSetter: this.setValidationError
        });
        let e = this.$store.getters["pagebuilder/interactivity/getPublishedData"],
        t = this.$store.state.settings,
        n = this.$store.getters["wizardExecution/workflowPath"],
        r = this.$store.getters["api/repository"],
        o = this.$store.getters["api/user"],
        i = this.$store.getters["api/downloadResourceLink"],
        s = this.$store.getters["api/uploadResourceLink"],
        a = this.$store.getters["settings/getCustomSketcherPath"];
        (!window.KnimePageBuilderAPI || window.KnimePageBuilderAPI.teardown(this.currentJobId)) && (window.KnimePageBuilderAPI = {
                interactivityGetPublishedData(l) {
                    return e(l)
                },
                getDefaultMountId() {
                    return typeof t > "u" ? null : t.defaultMountId
                },
                getWorkflow() {
                    return typeof n == "string" ? n : null
                },
                getRepository({
                    path: l,
                    filter: c
                }) {
                    return typeof r == "function" ? r({
                        path: l,
                        filter: c
                    }) : null
                },
                getUser() {
                    return typeof o == "function" ? o() : Promise.resolve(null)
                },
                getDownloadLink({
                    resourceId: l,
                    nodeId: c
                }) {
                    return typeof i == "function" ? i({
                        resourceId: l,
                        nodeId: c
                    }) : null
                },
                getUploadLink({
                    resourceId: l,
                    nodeId: c
                }) {
                    return typeof s == "function" ? s({
                        resourceId: l,
                        nodeId: c
                    }) : null
                },
                getCustomSketcherPath() {
                    return typeof a == "string" ? a : null
                },
                teardown(l) {
                    return l !== this.currentJobId
                },
                currentJobId: this.currentJobId
            })
    },
    beforeUnmount() {
        window.removeEventListener("message", this.messageFromIframe),
        this.$store.dispatch("pagebuilder/removeValidator", {
            nodeId: this.nodeId
        }),
        this.$store.dispatch("pagebuilder/removeValueGetter", {
            nodeId: this.nodeId
        }),
        this.$store.dispatch("pagebuilder/removeValidationErrorSetter", {
            nodeId: this.nodeId
        }),
        window.KnimePageBuilderAPI?.teardown(this.currentJobId) && delete window.KnimePageBuilderAPI
    },
    methods: {
        injectContent() {
            const e = this.$store.state.pagebuilder.resourceBaseUrl;
            let t = this.computeStyles(e),
            n = this.computeScripts(e),
            r = `<script>${Pbe.replace("'%ORIGIN%'", JSON.stringify(this.origin)).replace("'%NODEID%'", JSON.stringify(this.nodeId))}<\/script>`,
            o = `<script>${Ebe.replace("'%ORIGIN%'", JSON.stringify(this.origin)).replace("'%NODEID%'", JSON.stringify(this.nodeId))}<\/script>`,
            i = `<script>${Ibe.replace("'%RESOURCEBASEURL%'", JSON.stringify(e)).replace("'%ORIGIN%'", JSON.stringify(this.origin)).replace("'%NAMESPACE%'", JSON.stringify(this.nodeConfig.namespace)).replace("'%NODEID%'", JSON.stringify(this.nodeId)).replace("'%LIBCOUNT%'", this.nodeJsLibs.length)}<\/script>`,
            s = `<script>${Tbe.replace("'%ORIGIN%'", JSON.stringify(this.origin))}<\/script>`,
            a = this.autoHeight ? `<script>${Mbe}<\/script>` : "";
            this.document.write(`<!doctype html>
                <html lang="en-US">
                <meta charset="utf-8">
                <head>
                  ${t}
                  ${s}
                  ${i}
                  ${o}
                  ${r}
                  ${a}
                  <title></title>
                </head>
                <body></body>
                ${n}
                </html>`),
            this.document.close()
        },
        computeStyles(e) {
            let t = this.nodeStylesheets.map(n => {
                let r = `${e}${encodeURI(n)}`;
                return this.accessToken && (r += `?${this.authParameter}=${this.accessToken}`),
`<link type="text/css" rel="stylesheet" href="${r}">`
            });
            return this.nodeConfig.customCSS?.length && t.push(`<style>${this.nodeConfig.customCSS.replace(/<(\/style)\b/gi, "\\00003c$1")}</style>`),
            t.join("")
        },
        computeScripts(e, t) {
            let n = this.nodeJsLibs.map(r => {
                let o = `${e}${r}`;
                return t && (o += `?${this.authParameter}=${t}`),
                `<script src="${o}" 
                        onload="knimeLoader(true)" 
                        onerror="knimeLoader(false)">
                        <\/script>`
            });
            return n.push(`<script>
                if (typeof knimeService !== 'undefined') {
                    knimeService.resourceBaseUrl = '${e}';
                    knimeService.nodeId = '${this.nodeId}';
                }
            <\/script>`),
            n.join("")
        },
        initIFrameResize() {
            const t = "lowestElement";
            let n = this.viewConfig,
            r = 4,
            o = t;
            n.resizeMethod && (o = n.resizeMethod.substring(r, r + 1).toLowerCase() + n.resizeMethod.substring(r + 1)),
            o === "lowestElementIEMax" && (o = t);
            let i = {
                log: !1,
                checkOrigin: [window.origin],
                resizeFrom: "child",
                warningTimeout: 0,
                autoResize: n.autoResize,
                scrolling: n.scrolling,
                heightCalculationMethod: o,
                sizeHeight: n.sizeHeight,
                tolerance: n.resizeTolerance || 5
            };
            n.minWidth && (i.minWidth = n.minWidth),
            n.maxWidth && (i.maxWidth = n.maxWidth),
            n.minHeight && (i.minHeight = n.minHeight),
            n.maxHeight && (i.maxHeight = n.maxHeight),
            xx.iframeResizer(i, this.$refs.iframe)
        },
        messageFromIframe(e) {
            if (!e || !e.origin)
                return;
            const t = e.data;
            !(e.origin === this.origin || e.origin === "*" || e.origin.includes("file:")) || !t || !t.type || t.nodeId !== this.nodeId || (t.error && this.handleAlert(t), t.type === "load" ? (consola.debug(`View resource loading for ${this.nodeId} completed`), this.document.defaultView.postMessage({
                        nodeId: this.nodeId,
                        namespace: this.nodeConfig.namespace,
                        initMethodName: this.nodeConfig.initMethodName,
                        viewRepresentation: JSON.stringify(this.nodeConfig.viewRepresentation),
                        viewValue: JSON.stringify(this.nodeConfig.viewValue),
                        type: "init"
                    }, this.origin), this.$store.dispatch("pagebuilder/setWebNodeLoading", {
                        nodeId: this.nodeId,
                        loading: !1
                    })) : t.type === "validate" ? this.validateCallback(t) : t.type === "getValue" ? this.getValueCallback(t) : t.type === "setValidationError" ? this.setValidationErrorCallback(t) : t.type === "alert" ? this.handleAlert(t) : t.type.startsWith("interactivity") && this.handleInteractivity(e))
        },
        validate() {
            return new Promise(e => {
                this.validateCallback = ({
                    isValid: t
                }) => {
                    t || this.setLocalError("View validation failed."),
                    window.clearTimeout(this.cancelValidate),
                    e({
                        nodeId: this.nodeId,
                        isValid: t
                    })
                },
                this.document.defaultView.postMessage({
                    nodeId: this.nodeId,
                    namespace: this.nodeConfig.namespace,
                    validateMethodName: this.nodeConfig.validateMethodName,
                    type: "validate"
                }, this.origin),
                this.cancelValidate = window.setTimeout(() => {
                    this.setLocalError("View is not responding."),
                    e({
                        nodeId: this.nodeId,
                        isValid: !1
                    })
                }, $be)
            })
        },
        getValue() {
            return new Promise((e, t) => {
                this.getValueCallback = ({
                    error: n,
                    value: r
                }) => {
                    window.clearTimeout(this.cancelValueGetter),
                    n ? (this.setLocalError(n), t(new Error(n))) : e({
                        nodeId: this.nodeId,
                        value: r
                    })
                },
                this.document.defaultView.postMessage({
                    nodeId: this.nodeId,
                    namespace: this.nodeConfig.namespace,
                    getViewValueMethodName: this.nodeConfig.getViewValueMethodName,
                    type: "getValue"
                }, this.origin),
                this.cancelValueGetter = window.setTimeout(() => {
                    let n = "Value could not be retrieved in the allocated time.";
                    this.setLocalError(n),
                    t(new Error(n))
                }, Obe)
            })
        },
        setValidationError(e) {
            return new Promise((t, n) => {
                this.setValidationErrorCallback = ({
                    error: r
                }) => {
                    window.clearTimeout(this.cancelSetValidatorError),
                    r ? (this.setLocalError(r), n(new Error(r))) : t(!0)
                },
                this.document.defaultView.postMessage({
                    nodeId: this.nodeId,
                    namespace: this.nodeConfig.namespace,
                    setValidationErrorMethodName: this.nodeConfig.setValidationErrorMethodName,
                    type: "setValidationError",
                    errorMessage: e
                }, this.origin),
                this.cancelSetValidatorError = window.setTimeout(() => {
                    let r = "Validation error message could not be set in the allocated time.";
                    this.setLocalError(r),
                    n(new Error(r))
                }, Abe)
            })
        },
        setLocalError(e) {
            this.handleAlert({
                message: e,
                level: "error"
            })
        },
        handleAlert(e) {
            let t = JSON.parse(JSON.stringify(e));
            this.alert = {
                ...t,
                type: t.level === "error" || t.error ? "error" : "warn",
                nodeInfo: this.nodeConfig.nodeInfo,
                message: t.message || t.error
            },
            this.alert.type === "warn" && this.showAlert()
        },
        handleInteractivity(e) {
            switch (e.data.type) {
            case "interactivitySubscribe":
                consola.trace("subscribe to event", this.nodeId, e.data),
                this.$store.dispatch("pagebuilder/interactivity/subscribe", {
                    id: e.data.id,
                    callback: this.interactivityInformIframe,
                    elementFilter: e.data.elementFilter
                });
                break;
            case "interactivityUnsubscribe":
                consola.trace("unsubscribe from event", this.nodeId, e.data),
                this.$store.dispatch("pagebuilder/interactivity/unsubscribe", {
                    id: e.data.id,
                    callback: this.interactivityInformIframe
                });
                break;
            case "interactivityPublish":
                consola.trace("publish event called", this.nodeId, e.data),
                this.$store.dispatch("pagebuilder/interactivity/publish", {
                    id: e.data.id,
                    data: e.data.payload,
                    skipCallback: this.interactivityInformIframe
                });
                break;
            case "interactivityRegisterSelectionTranslator":
                consola.trace("interactivityRegisterSelectionTranslator"),
                this.$store.dispatch("pagebuilder/interactivity/registerSelectionTranslator", {
                    translator: e.data.translator
                });
                break
            }
        },
        interactivityInformIframe(e, t) {
            let n = {
                nodeId: this.nodeId,
                type: "interactivityEvent",
                id: e,
                payload: JSON.parse(JSON.stringify(t))
            };
            this.document.defaultView.postMessage(n, this.origin)
        },
        showAlert() {
            this.$store.dispatch("pagebuilder/alert/showAlert", {
                ...this.alert,
                callback: this.closeAlert
            })
        },
        closeAlert(e) {
            e && (this.alert = null)
        }
    }
}, Nbe = ["id"];
function Rbe(e, t, n, r, o, i) {
    const s = B("AlertLocal");
    return _(),
    O("div", {
        class: he(["frame-container", {
                    "single-view": i.isSingleView
                }, {
                    "with-alert": i.displayAlert
                }
            ])
    }, [P("iframe", {
                id: i.iframeId,
                ref: "iframe",
                class: he(i.classes)
            }, null, 10, Nbe), z(s, {
                active: i.displayAlert,
                onShowAlert: i.showAlert
            }, null, 8, ["active", "onShowAlert"])], 2)
}
const Lbe = te(Dbe, [["render", Rbe], ["__scopeId", "data-v-999217e9"]]);
const Bbe = {
    props: {
        id: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        modelValue: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        labelSize: {
            type: String,
        default:
            "regular",
            validator: e => ["regular", "large"].includes(e)
        }
    },
    emits: ["update:modelValue"],
    computed: {
        classes() {
            return ["checkbox", this.labelSize, {
                    disabled: this.disabled
                }
            ]
        }
    },
    methods: {
        onInput(e) {
            let {
                checked: t
            } = e.target;
            consola.trace("Checkbox value changed to", t),
            this.$emit("update:modelValue", t)
        },
        isChecked() {
            return this.$refs.input.checked
        }
    }
}, Vbe = ["id", "name", "checked", "disabled"];
function Fbe(e, t, n, r, o, i) {
    return _(),
    O("label", {
        class: he(i.classes)
    }, [P("input", {
                id: n.id,
                ref: "input",
                name: n.name,
                checked: n.modelValue,
                disabled: n.disabled,
                type: "checkbox",
                onChange: t[0] || (t[0] = (...s) => i.onInput && i.onInput(...s))
            }, null, 40, Vbe), P("span", null, [Ye(e.$slots, "default", {}, void 0, !0)])], 2)
}
const Tw = te(Bbe, [["render", Fbe], ["__scopeId", "data-v-e644a11d"]]), H$ = "boolean", jbe = {
    components: {
        Checkbox: Tw
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.viewRepresentation && e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                boolean: !0
            }),
            type: Object
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || ""
        },
        value() {
            return this.valuePair[H$]
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: H$,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = typeof this.value == "boolean";
            return {
                isValid: e,
                errorMessage: e ? null : "Input is not responding."
            }
        }
    }
}, Wbe = ["title"];
function zbe(e, t, n, r, o, i) {
    const s = B("Checkbox");
    return _(),
    H(s, {
        ref: "form",
        "label-size": "large",
        "model-value": i.value,
        title: i.description,
        "onUpdate:modelValue": i.onChange
    }, {
    default:
        oe(() => [P("span", {
                    title: i.label
                }, Re(i.label), 9, Wbe)]),
        _: 1
    }, 8, ["model-value", "title", "onUpdate:modelValue"])
}
const Hbe = te(jbe, [["render", zbe]]);
const Ube = {
    provide: {
        largeLabels: !1
    },
    props: {
        text: {
        default:
            "",
            type: String
        }
    }
};
function qbe(e, t, n, r, o, i) {
    return _(),
    O("fieldset", null, [P("legend", null, [mt(Re(n.text) + " ", 1), Ye(e.$slots, "icon")]), Ye(e.$slots, "default")])
}
const mc = te(Ube, [["render", qbe], ["__scopeId", "data-v-047002fc"]]);
const Ybe = {
    props: {
        error: {
        default:
            null,
            type: String
        }
    }
};
function Kbe(e, t, n, r, o, i) {
    return _(),
    O("span", null, Re(n.error || ""), 1)
}
const Lr = te(Ybe, [["render", Kbe], ["__scopeId", "data-v-c85e0e7a"]]);
const Gbe = "KNIME Server login credentials could not be fetched!", U$ = "Please correct input for ", Xbe = {
    components: {
        Fieldset: mc,
        Label: Xn,
        InputField: wf,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({}),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    data() {
        return {
            serverCredentialsFetchError: !1,
            serverCredentialsErrorMessage: null,
            useMagicPassword: !0
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description
        },
        promptUsername() {
            return this.viewRep.promptUsername || !1
        },
        useServerLoginCredentials() {
            return this.viewRep.useServerLoginCredentials || !1
        },
        noDisplay() {
            return this.viewRep.noDisplay || !1
        },
        value() {
            return this.valuePair || this.viewRep.defaultValue
        }
    },
    mounted() {
        this.checkServerCredentials()
    },
    methods: {
        checkServerCredentials() {
            this.useServerLoginCredentials && !this.viewRep.defaultValue && (this.serverCredentialsFetchError = !0)
        },
        onChange() {},
        onUsernameChange(e) {
            if (e !== this.viewRep.defaultValue.username) {
                const t = {
                    nodeId: this.nodeId,
                    type: "username",
                    value: e
                };
                this.$emit("updateWidget", t)
            }
        },
        onPasswordChange(e) {
            if (this.useMagicPassword = !1, e !== this.viewRep.defaultValue.magicDefaultPassword) {
                const t = {
                    nodeId: this.nodeId,
                    type: "magicDefaultPassword",
                    value: e
                };
                this.$emit("updateWidget", t)
            }
        },
        validate() {
            let e = this.$refs.passwordForm,
            t = this.$refs.usernameForm, {
                isValid: n
            } = e.validate(),
            r = n ? "" : `${U$}password.`;
            if (this.promptUsername) {
                let {
                    isValid: o
                } = t.validate();
                o || (n = !1, r = `${U$}username${r ? " and password" : ""}.`)
            }
            return this.useServerLoginCredentials && this.serverCredentialsFetchError && (this.serverCredentialsErrorMessage = Gbe), {
                isValid: n,
                errorMessage: r
            }
        }
    }
};
function Jbe(e, t, n, r, o, i) {
    const s = B("InputField"),
    a = B("Label"),
    l = B("ErrorMessage"),
    c = B("Fieldset");
    return _(),
    H(c, {
        class: he([{
                    hide: i.noDisplay
                }
            ]),
        text: i.label
    }, {
    default:
        oe(() => [i.promptUsername ? (_(), H(a, {
                        key: 0,
                        class: "label",
                        text: "User",
                        large: ""
                    }, {
                    default:
                        oe(({
                                labelForId: u
                            }) => [z(s, {
                                    id: u,
                                    ref: "usernameForm",
                                    "model-value": i.value.username,
                                    "is-valid": n.isValid,
                                    title: i.description,
                                    "onUpdate:modelValue": i.onUsernameChange
                                }, null, 8, ["id", "model-value", "is-valid", "title", "onUpdate:modelValue"])]),
                        _: 1
                    })) : J("", !0), z(a, {
                    class: "label",
                    text: "Password",
                    large: ""
                }, {
                default:
                    oe(({
                            labelForId: u
                        }) => [z(s, {
                                id: u,
                                ref: "passwordForm",
                                type: "password",
                                "model-value": i.value.magicDefaultPassword,
                                "is-valid": n.isValid,
                                title: i.description,
                                "onUpdate:modelValue": i.onPasswordChange
                            }, null, 8, ["id", "model-value", "is-valid", "title", "onUpdate:modelValue"])]),
                    _: 1
                }), z(l, {
                    class: "error-message",
                    error: n.errorMessage || o.serverCredentialsErrorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["class", "text"])
}
const Zbe = te(Xbe, [["render", Jbe], ["__scopeId", "data-v-deda3c20"]]);
function fa(e) {
    return fa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t
    }
     : function (t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    },
    fa(e)
}
function dr(e) {
    if (e === null || e === !0 || e === !1)
        return NaN;
    var t = Number(e);
    return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t)
}
function bn(e, t) {
    if (t.length < e)
        throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present")
}
function Mn(e) {
    bn(1, arguments);
    var t = Object.prototype.toString.call(e);
    return e instanceof Date || fa(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN))
}
function Qbe(e, t) {
    bn(2, arguments);
    var n = Mn(e).getTime(),
    r = dr(t);
    return new Date(n + r)
}
var e_e = {};
function pg() {
    return e_e
}
function t_e(e) {
    var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return t.setUTCFullYear(e.getFullYear()),
    e.getTime() - t.getTime()
}
var n_e = 6e4, r_e = 36e5, o_e = 1e3;
function i_e(e) {
    return bn(1, arguments),
    e instanceof Date || fa(e) === "object" && Object.prototype.toString.call(e) === "[object Date]"
}
function z7(e) {
    if (bn(1, arguments), !i_e(e) && typeof e != "number")
        return !1;
    var t = Mn(e);
    return !isNaN(Number(t))
}
function s_e(e, t) {
    bn(2, arguments);
    var n = dr(t);
    return Qbe(e, -n)
}
function Mf(e) {
    bn(1, arguments);
    var t = 1,
    n = Mn(e),
    r = n.getUTCDay(),
    o = (r < t ? 7 : 0) + r - t;
    return n.setUTCDate(n.getUTCDate() - o),
    n.setUTCHours(0, 0, 0, 0),
    n
}
function a_e(e) {
    bn(1, arguments);
    var t = Mn(e),
    n = t.getUTCFullYear(),
    r = new Date(0);
    r.setUTCFullYear(n + 1, 0, 4),
    r.setUTCHours(0, 0, 0, 0);
    var o = Mf(r),
    i = new Date(0);
    i.setUTCFullYear(n, 0, 4),
    i.setUTCHours(0, 0, 0, 0);
    var s = Mf(i);
    return t.getTime() >= o.getTime() ? n + 1 : t.getTime() >= s.getTime() ? n : n - 1
}
function l_e(e) {
    bn(1, arguments);
    var t = a_e(e),
    n = new Date(0);
    n.setUTCFullYear(t, 0, 4),
    n.setUTCHours(0, 0, 0, 0);
    var r = Mf(n);
    return r
}
var c_e = 6048e5;
function u_e(e) {
    bn(1, arguments);
    var t = Mn(e),
    n = Mf(t).getTime() - l_e(t).getTime();
    return Math.round(n / c_e) + 1
}
function $u(e, t) {
    var n,
    r,
    o,
    i,
    s,
    a,
    l,
    c;
    bn(1, arguments);
    var u = pg(),
    f = dr((n = (r = (o = (i = t?.weekStartsOn) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (a = s.options) === null || a === void 0 ? void 0 : a.weekStartsOn) !== null && o !== void 0 ? o : u.weekStartsOn) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(f >= 0 && f <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var p = Mn(e),
    m = p.getUTCDay(),
    v = (m < f ? 7 : 0) + m - f;
    return p.setUTCDate(p.getUTCDate() - v),
    p.setUTCHours(0, 0, 0, 0),
    p
}
function H7(e, t) {
    var n,
    r,
    o,
    i,
    s,
    a,
    l,
    c;
    bn(1, arguments);
    var u = Mn(e),
    f = u.getUTCFullYear(),
    p = pg(),
    m = dr((n = (r = (o = (i = t?.firstWeekContainsDate) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (a = s.options) === null || a === void 0 ? void 0 : a.firstWeekContainsDate) !== null && o !== void 0 ? o : p.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = p.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
    if (!(m >= 1 && m <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var v = new Date(0);
    v.setUTCFullYear(f + 1, 0, m),
    v.setUTCHours(0, 0, 0, 0);
    var y = $u(v, t),
    b = new Date(0);
    b.setUTCFullYear(f, 0, m),
    b.setUTCHours(0, 0, 0, 0);
    var w = $u(b, t);
    return u.getTime() >= y.getTime() ? f + 1 : u.getTime() >= w.getTime() ? f : f - 1
}
function d_e(e, t) {
    var n,
    r,
    o,
    i,
    s,
    a,
    l,
    c;
    bn(1, arguments);
    var u = pg(),
    f = dr((n = (r = (o = (i = t?.firstWeekContainsDate) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (a = s.options) === null || a === void 0 ? void 0 : a.firstWeekContainsDate) !== null && o !== void 0 ? o : u.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1),
    p = H7(e, t),
    m = new Date(0);
    m.setUTCFullYear(p, 0, f),
    m.setUTCHours(0, 0, 0, 0);
    var v = $u(m, t);
    return v
}
var f_e = 6048e5;
function h_e(e, t) {
    bn(1, arguments);
    var n = Mn(e),
    r = $u(n, t).getTime() - d_e(n, t).getTime();
    return Math.round(r / f_e) + 1
}
var q$ = function (t, n) {
    switch (t) {
    case "P":
        return n.date({
            width: "short"
        });
    case "PP":
        return n.date({
            width: "medium"
        });
    case "PPP":
        return n.date({
            width: "long"
        });
    case "PPPP":
    default:
        return n.date({
            width: "full"
        })
    }
}, U7 = function (t, n) {
    switch (t) {
    case "p":
        return n.time({
            width: "short"
        });
    case "pp":
        return n.time({
            width: "medium"
        });
    case "ppp":
        return n.time({
            width: "long"
        });
    case "pppp":
    default:
        return n.time({
            width: "full"
        })
    }
}, p_e = function (t, n) {
    var r = t.match(/(P+)(p+)?/) || [],
    o = r[1],
    i = r[2];
    if (!i)
        return q$(t, n);
    var s;
    switch (o) {
    case "P":
        s = n.dateTime({
            width: "short"
        });
        break;
    case "PP":
        s = n.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        s = n.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        s = n.dateTime({
            width: "full"
        });
        break
    }
    return s.replace("{{date}}", q$(o, n)).replace("{{time}}", U7(i, n))
}, m_e = {
    p: U7,
    P: p_e
};
const Y$ = m_e;
var g_e = ["D", "DD"], v_e = ["YY", "YYYY"];
function y_e(e) {
    return g_e.indexOf(e) !== -1
}
function w_e(e) {
    return v_e.indexOf(e) !== -1
}
function K$(e, t, n) {
    if (e === "YYYY")
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "YY")
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "D")
        throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "DD")
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}
var b_e = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}, __e = function (t, n, r) {
    var o,
    i = b_e[t];
    return typeof i == "string" ? o = i : n === 1 ? o = i.one : o = i.other.replace("{{count}}", n.toString()),
    r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + o : o + " ago" : o
};
const k_e = __e;
function e2(e) {
    return function () {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        n = t.width ? String(t.width) : e.defaultWidth,
        r = e.formats[n] || e.formats[e.defaultWidth];
        return r
    }
}
var x_e = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}, S_e = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}, C_e = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}, I_e = {
    date: e2({
        formats: x_e,
        defaultWidth: "full"
    }),
    time: e2({
        formats: S_e,
        defaultWidth: "full"
    }),
    dateTime: e2({
        formats: C_e,
        defaultWidth: "full"
    })
};
const T_e = I_e;
var M_e = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}, P_e = function (t, n, r, o) {
    return M_e[t]
};
const E_e = P_e;
function Gh(e) {
    return function (t, n) {
        var r = n != null && n.context ? String(n.context) : "standalone",
        o;
        if (r === "formatting" && e.formattingValues) {
            var i = e.defaultFormattingWidth || e.defaultWidth,
            s = n != null && n.width ? String(n.width) : i;
            o = e.formattingValues[s] || e.formattingValues[i]
        } else {
            var a = e.defaultWidth,
            l = n != null && n.width ? String(n.width) : e.defaultWidth;
            o = e.values[l] || e.values[a]
        }
        var c = e.argumentCallback ? e.argumentCallback(t) : t;
        return o[c]
    }
}
var O_e = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}, $_e = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, A_e = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, D_e = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, N_e = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}, R_e = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}, L_e = function (t, n) {
    var r = Number(t),
    o = r % 100;
    if (o > 20 || o < 10)
        switch (o % 10) {
        case 1:
            return r + "st";
        case 2:
            return r + "nd";
        case 3:
            return r + "rd"
        }
    return r + "th"
}, B_e = {
    ordinalNumber: L_e,
    era: Gh({
        values: O_e,
        defaultWidth: "wide"
    }),
    quarter: Gh({
        values: $_e,
        defaultWidth: "wide",
        argumentCallback: function (t) {
            return t - 1
        }
    }),
    month: Gh({
        values: A_e,
        defaultWidth: "wide"
    }),
    day: Gh({
        values: D_e,
        defaultWidth: "wide"
    }),
    dayPeriod: Gh({
        values: N_e,
        defaultWidth: "wide",
        formattingValues: R_e,
        defaultFormattingWidth: "wide"
    })
};
const V_e = B_e;
function Xh(e) {
    return function (t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        r = n.width,
        o = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth],
        i = t.match(o);
        if (!i)
            return null;
        var s = i[0],
        a = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth],
        l = Array.isArray(a) ? j_e(a, function (f) {
            return f.test(s)
        }) : F_e(a, function (f) {
            return f.test(s)
        }),
        c;
        c = e.valueCallback ? e.valueCallback(l) : l,
        c = n.valueCallback ? n.valueCallback(c) : c;
        var u = t.slice(s.length);
        return {
            value: c,
            rest: u
        }
    }
}
function F_e(e, t) {
    for (var n in e)
        if (e.hasOwnProperty(n) && t(e[n]))
            return n
}
function j_e(e, t) {
    for (var n = 0; n < e.length; n++)
        if (t(e[n]))
            return n
}
function W_e(e) {
    return function (t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        r = t.match(e.matchPattern);
        if (!r)
            return null;
        var o = r[0],
        i = t.match(e.parsePattern);
        if (!i)
            return null;
        var s = e.valueCallback ? e.valueCallback(i[0]) : i[0];
        s = n.valueCallback ? n.valueCallback(s) : s;
        var a = t.slice(o.length);
        return {
            value: s,
            rest: a
        }
    }
}
var z_e = /^(\d+)(th|st|nd|rd)?/i, H_e = /\d+/i, U_e = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}, q_e = {
    any: [/^b/i, /^(a|c)/i]
}, Y_e = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}, K_e = {
    any: [/1/i, /2/i, /3/i, /4/i]
}, G_e = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, X_e = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}, J_e = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, Z_e = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, Q_e = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, e2e = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}, t2e = {
    ordinalNumber: W_e({
        matchPattern: z_e,
        parsePattern: H_e,
        valueCallback: function (t) {
            return parseInt(t, 10)
        }
    }),
    era: Xh({
        matchPatterns: U_e,
        defaultMatchWidth: "wide",
        parsePatterns: q_e,
        defaultParseWidth: "any"
    }),
    quarter: Xh({
        matchPatterns: Y_e,
        defaultMatchWidth: "wide",
        parsePatterns: K_e,
        defaultParseWidth: "any",
        valueCallback: function (t) {
            return t + 1
        }
    }),
    month: Xh({
        matchPatterns: G_e,
        defaultMatchWidth: "wide",
        parsePatterns: X_e,
        defaultParseWidth: "any"
    }),
    day: Xh({
        matchPatterns: J_e,
        defaultMatchWidth: "wide",
        parsePatterns: Z_e,
        defaultParseWidth: "any"
    }),
    dayPeriod: Xh({
        matchPatterns: Q_e,
        defaultMatchWidth: "any",
        parsePatterns: e2e,
        defaultParseWidth: "any"
    })
};
const n2e = t2e;
var r2e = {
    code: "en-US",
    formatDistance: k_e,
    formatLong: T_e,
    formatRelative: E_e,
    localize: V_e,
    match: n2e,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const o2e = r2e;
function i2e(e, t) {
    if (e == null)
        throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e
}
function s2e(e) {
    bn(1, arguments);
    var t = Mn(e),
    n = t.getDate();
    return n
}
function a2e(e) {
    bn(1, arguments);
    var t = Mn(e),
    n = t.getFullYear(),
    r = t.getMonth(),
    o = new Date(0);
    return o.setFullYear(n, r + 1, 0),
    o.setHours(0, 0, 0, 0),
    o.getDate()
}
function l2e(e) {
    bn(1, arguments);
    var t = Mn(e),
    n = t.getMonth();
    return n
}
function c2e(e) {
    return bn(1, arguments),
    Mn(e).getFullYear()
}
function t2(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = Mn(t);
    return n.getTime() > r.getTime()
}
function n2(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = Mn(t);
    return n.getTime() < r.getTime()
}
function G$(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function u2e(e, t) {
    if (e) {
        if (typeof e == "string")
            return G$(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return G$(e, t)
    }
}
function X$(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
        if (Array.isArray(e) || (n = u2e(e)) || t && e && typeof e.length == "number") {
            n && (e = n);
            var r = 0,
            o = function () {};
            return {
                s: o,
                n: function () {
                    return r >= e.length ? {
                        done: !0
                    }
                     : {
                        done: !1,
                        value: e[r++]
                    }
                },
                e: function (c) {
                    throw c
                },
                f: o
            }
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    var i = !0,
    s = !1,
    a;
    return {
        s: function () {
            n = n.call(e)
        },
        n: function () {
            var c = n.next();
            return i = c.done,
            c
        },
        e: function (c) {
            s = !0,
            a = c
        },
        f: function () {
            try {
                !i && n.return != null && n.return()
            } finally {
                if (s)
                    throw a
            }
        }
    }
}
function ot(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function Ix(e, t) {
    return Ix = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, o) {
        return r.__proto__ = o,
        r
    },
    Ix(e, t)
}
function dn(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    t && Ix(e, t)
}
function sy(e) {
    return sy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    },
    sy(e)
}
function d2e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})),
        !0
    } catch {
        return !1
    }
}
function f2e(e, t) {
    if (t && (fa(t) === "object" || typeof t == "function"))
        return t;
    if (t !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return ot(e)
}
function fn(e) {
    var t = d2e();
    return function () {
        var r = sy(e),
        o;
        if (t) {
            var i = sy(this).constructor;
            o = Reflect.construct(r, arguments, i)
        } else
            o = r.apply(this, arguments);
        return f2e(this, o)
    }
}
function nn(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function h2e(e, t) {
    if (fa(e) !== "object" || e === null)
        return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t || "default");
        if (fa(r) !== "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
function q7(e) {
    var t = h2e(e, "string");
    return fa(t) === "symbol" ? t : String(t)
}
function J$(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value" in r && (r.writable = !0),
        Object.defineProperty(e, q7(r.key), r)
    }
}
function rn(e, t, n) {
    return t && J$(e.prototype, t),
    n && J$(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
function Qe(e, t, n) {
    return t = q7(t),
    t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
var p2e = 10, Y7 = function () {
    function e() {
        nn(this, e),
        Qe(this, "priority", void 0),
        Qe(this, "subPriority", 0)
    }
    return rn(e, [{
                key: "validate",
                value: function (n, r) {
                    return !0
                }
            }
        ]),
    e
}
(), m2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n(r, o, i, s, a) {
        var l;
        return nn(this, n),
        l = t.call(this),
        l.value = r,
        l.validateValue = o,
        l.setValue = i,
        l.priority = s,
        a && (l.subPriority = a),
        l
    }
    return rn(n, [{
                key: "validate",
                value: function (o, i) {
                    return this.validateValue(o, this.value, i)
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return this.setValue(o, i, this.value, s)
                }
            }
        ]),
    n
}
(Y7), g2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", p2e),
        Qe(ot(r), "subPriority", -1),
        r
    }
    return rn(n, [{
                key: "set",
                value: function (o, i) {
                    if (i.timestampIsSet)
                        return o;
                    var s = new Date(0);
                    return s.setFullYear(o.getUTCFullYear(), o.getUTCMonth(), o.getUTCDate()),
                    s.setHours(o.getUTCHours(), o.getUTCMinutes(), o.getUTCSeconds(), o.getUTCMilliseconds()),
                    s
                }
            }
        ]),
    n
}
(Y7), vn = function () {
    function e() {
        nn(this, e),
        Qe(this, "incompatibleTokens", void 0),
        Qe(this, "priority", void 0),
        Qe(this, "subPriority", void 0)
    }
    return rn(e, [{
                key: "run",
                value: function (n, r, o, i) {
                    var s = this.parse(n, r, o, i);
                    return s ? {
                        setter: new m2e(s.value, this.validate, this.set, this.priority, this.subPriority),
                        rest: s.rest
                    }
                     : null
                }
            }, {
                key: "validate",
                value: function (n, r, o) {
                    return !0
                }
            }
        ]),
    e
}
(), v2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 140),
        Qe(ot(r), "incompatibleTokens", ["R", "u", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "G":
                    case "GG":
                    case "GGG":
                        return s.era(o, {
                            width: "abbreviated"
                        }) || s.era(o, {
                            width: "narrow"
                        });
                    case "GGGGG":
                        return s.era(o, {
                            width: "narrow"
                        });
                    case "GGGG":
                    default:
                        return s.era(o, {
                            width: "wide"
                        }) || s.era(o, {
                            width: "abbreviated"
                        }) || s.era(o, {
                            width: "narrow"
                        })
                    }
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return i.era = s,
                    o.setUTCFullYear(s, 0, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), _r = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
}, Xs = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function kr(e, t) {
    return e && {
        value: t(e.value),
        rest: e.rest
    }
}
function or(e, t) {
    var n = t.match(e);
    return n ? {
        value: parseInt(n[0], 10),
        rest: t.slice(n[0].length)
    }
     : null
}
function Js(e, t) {
    var n = t.match(e);
    if (!n)
        return null;
    if (n[0] === "Z")
        return {
            value: 0,
            rest: t.slice(1)
        };
    var r = n[1] === "+" ? 1 : -1,
    o = n[2] ? parseInt(n[2], 10) : 0,
    i = n[3] ? parseInt(n[3], 10) : 0,
    s = n[5] ? parseInt(n[5], 10) : 0;
    return {
        value: r * (o * r_e + i * n_e + s * o_e),
        rest: t.slice(n[0].length)
    }
}
function K7(e) {
    return or(_r.anyDigitsSigned, e)
}
function pr(e, t) {
    switch (e) {
    case 1:
        return or(_r.singleDigit, t);
    case 2:
        return or(_r.twoDigits, t);
    case 3:
        return or(_r.threeDigits, t);
    case 4:
        return or(_r.fourDigits, t);
    default:
        return or(new RegExp("^\\d{1," + e + "}"), t)
    }
}
function ay(e, t) {
    switch (e) {
    case 1:
        return or(_r.singleDigitSigned, t);
    case 2:
        return or(_r.twoDigitsSigned, t);
    case 3:
        return or(_r.threeDigitsSigned, t);
    case 4:
        return or(_r.fourDigitsSigned, t);
    default:
        return or(new RegExp("^-?\\d{1," + e + "}"), t)
    }
}
function kI(e) {
    switch (e) {
    case "morning":
        return 4;
    case "evening":
        return 17;
    case "pm":
    case "noon":
    case "afternoon":
        return 12;
    case "am":
    case "midnight":
    case "night":
    default:
        return 0
    }
}
function G7(e, t) {
    var n = t > 0,
    r = n ? t : 1 - t,
    o;
    if (r <= 50)
        o = e || 100;
    else {
        var i = r + 50,
        s = Math.floor(i / 100) * 100,
        a = e >= i % 100;
        o = e + s - (a ? 100 : 0)
    }
    return n ? o : 1 - o
}
function X7(e) {
    return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
var y2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 130),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    var a = function (c) {
                        return {
                            year: c,
                            isTwoDigitYear: i === "yy"
                        }
                    };
                    switch (i) {
                    case "y":
                        return kr(pr(4, o), a);
                    case "yo":
                        return kr(s.ordinalNumber(o, {
                                unit: "year"
                            }), a);
                    default:
                        return kr(pr(i.length, o), a)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i.isTwoDigitYear || i.year > 0
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    var a = o.getUTCFullYear();
                    if (s.isTwoDigitYear) {
                        var l = G7(s.year, a);
                        return o.setUTCFullYear(l, 0, 1),
                        o.setUTCHours(0, 0, 0, 0),
                        o
                    }
                    var c = !("era" in i) || i.era === 1 ? s.year : 1 - s.year;
                    return o.setUTCFullYear(c, 0, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), w2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 130),
        Qe(ot(r), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    var a = function (c) {
                        return {
                            year: c,
                            isTwoDigitYear: i === "YY"
                        }
                    };
                    switch (i) {
                    case "Y":
                        return kr(pr(4, o), a);
                    case "Yo":
                        return kr(s.ordinalNumber(o, {
                                unit: "year"
                            }), a);
                    default:
                        return kr(pr(i.length, o), a)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i.isTwoDigitYear || i.year > 0
                }
            }, {
                key: "set",
                value: function (o, i, s, a) {
                    var l = H7(o, a);
                    if (s.isTwoDigitYear) {
                        var c = G7(s.year, l);
                        return o.setUTCFullYear(c, 0, a.firstWeekContainsDate),
                        o.setUTCHours(0, 0, 0, 0),
                        $u(o, a)
                    }
                    var u = !("era" in i) || i.era === 1 ? s.year : 1 - s.year;
                    return o.setUTCFullYear(u, 0, a.firstWeekContainsDate),
                    o.setUTCHours(0, 0, 0, 0),
                    $u(o, a)
                }
            }
        ]),
    n
}
(vn), b2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 130),
        Qe(ot(r), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i) {
                    return ay(i === "R" ? 4 : i.length, o)
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    var a = new Date(0);
                    return a.setUTCFullYear(s, 0, 4),
                    a.setUTCHours(0, 0, 0, 0),
                    Mf(a)
                }
            }
        ]),
    n
}
(vn), _2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 130),
        Qe(ot(r), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i) {
                    return ay(i === "u" ? 4 : i.length, o)
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCFullYear(s, 0, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), k2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 120),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "Q":
                    case "QQ":
                        return pr(i.length, o);
                    case "Qo":
                        return s.ordinalNumber(o, {
                            unit: "quarter"
                        });
                    case "QQQ":
                        return s.quarter(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.quarter(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "QQQQQ":
                        return s.quarter(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "QQQQ":
                    default:
                        return s.quarter(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.quarter(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.quarter(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 4
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMonth((s - 1) * 3, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), x2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 120),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "q":
                    case "qq":
                        return pr(i.length, o);
                    case "qo":
                        return s.ordinalNumber(o, {
                            unit: "quarter"
                        });
                    case "qqq":
                        return s.quarter(o, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.quarter(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "qqqqq":
                        return s.quarter(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "qqqq":
                    default:
                        return s.quarter(o, {
                            width: "wide",
                            context: "standalone"
                        }) || s.quarter(o, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.quarter(o, {
                            width: "narrow",
                            context: "standalone"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 4
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMonth((s - 1) * 3, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), S2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]),
        Qe(ot(r), "priority", 110),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    var a = function (c) {
                        return c - 1
                    };
                    switch (i) {
                    case "M":
                        return kr(or(_r.month, o), a);
                    case "MM":
                        return kr(pr(2, o), a);
                    case "Mo":
                        return kr(s.ordinalNumber(o, {
                                unit: "month"
                            }), a);
                    case "MMM":
                        return s.month(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.month(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "MMMMM":
                        return s.month(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "MMMM":
                    default:
                        return s.month(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.month(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.month(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 11
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMonth(s, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), C2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 110),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    var a = function (c) {
                        return c - 1
                    };
                    switch (i) {
                    case "L":
                        return kr(or(_r.month, o), a);
                    case "LL":
                        return kr(pr(2, o), a);
                    case "Lo":
                        return kr(s.ordinalNumber(o, {
                                unit: "month"
                            }), a);
                    case "LLL":
                        return s.month(o, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.month(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "LLLLL":
                        return s.month(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "LLLL":
                    default:
                        return s.month(o, {
                            width: "wide",
                            context: "standalone"
                        }) || s.month(o, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.month(o, {
                            width: "narrow",
                            context: "standalone"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 11
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMonth(s, 1),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn);
function I2e(e, t, n) {
    bn(2, arguments);
    var r = Mn(e),
    o = dr(t),
    i = h_e(r, n) - o;
    return r.setUTCDate(r.getUTCDate() - i * 7),
    r
}
var T2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 100),
        Qe(ot(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "w":
                        return or(_r.week, o);
                    case "wo":
                        return s.ordinalNumber(o, {
                            unit: "week"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 53
                }
            }, {
                key: "set",
                value: function (o, i, s, a) {
                    return $u(I2e(o, s, a), a)
                }
            }
        ]),
    n
}
(vn);
function M2e(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = dr(t),
    o = u_e(n) - r;
    return n.setUTCDate(n.getUTCDate() - o * 7),
    n
}
var P2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 100),
        Qe(ot(r), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "I":
                        return or(_r.week, o);
                    case "Io":
                        return s.ordinalNumber(o, {
                            unit: "week"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 53
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return Mf(M2e(o, s))
                }
            }
        ]),
    n
}
(vn), E2e = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], O2e = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], $2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 90),
        Qe(ot(r), "subPriority", 1),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "d":
                        return or(_r.date, o);
                    case "do":
                        return s.ordinalNumber(o, {
                            unit: "date"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    var s = o.getUTCFullYear(),
                    a = X7(s),
                    l = o.getUTCMonth();
                    return a ? i >= 1 && i <= O2e[l] : i >= 1 && i <= E2e[l]
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCDate(s),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), A2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 90),
        Qe(ot(r), "subpriority", 1),
        Qe(ot(r), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "D":
                    case "DD":
                        return or(_r.dayOfYear, o);
                    case "Do":
                        return s.ordinalNumber(o, {
                            unit: "date"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    var s = o.getUTCFullYear(),
                    a = X7(s);
                    return a ? i >= 1 && i <= 366 : i >= 1 && i <= 365
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMonth(0, s),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn);
function xI(e, t, n) {
    var r,
    o,
    i,
    s,
    a,
    l,
    c,
    u;
    bn(2, arguments);
    var f = pg(),
    p = dr((r = (o = (i = (s = n?.weekStartsOn) !== null && s !== void 0 ? s : n == null || (a = n.locale) === null || a === void 0 || (l = a.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && i !== void 0 ? i : f.weekStartsOn) !== null && o !== void 0 ? o : (c = f.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
    if (!(p >= 0 && p <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var m = Mn(e),
    v = dr(t),
    y = m.getUTCDay(),
    b = v % 7,
    w = (b + 7) % 7,
    k = (w < p ? 7 : 0) + v - y;
    return m.setUTCDate(m.getUTCDate() + k),
    m
}
var D2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 90),
        Qe(ot(r), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "E":
                    case "EE":
                    case "EEE":
                        return s.day(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "EEEEE":
                        return s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "EEEEEE":
                        return s.day(o, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "EEEE":
                    default:
                        return s.day(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 6
                }
            }, {
                key: "set",
                value: function (o, i, s, a) {
                    return o = xI(o, s, a),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), N2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 90),
        Qe(ot(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s, a) {
                    var l = function (u) {
                        var f = Math.floor((u - 1) / 7) * 7;
                        return (u + a.weekStartsOn + 6) % 7 + f
                    };
                    switch (i) {
                    case "e":
                    case "ee":
                        return kr(pr(i.length, o), l);
                    case "eo":
                        return kr(s.ordinalNumber(o, {
                                unit: "day"
                            }), l);
                    case "eee":
                        return s.day(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "eeeee":
                        return s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "eeeeee":
                        return s.day(o, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "eeee":
                    default:
                        return s.day(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 6
                }
            }, {
                key: "set",
                value: function (o, i, s, a) {
                    return o = xI(o, s, a),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), R2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 90),
        Qe(ot(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s, a) {
                    var l = function (u) {
                        var f = Math.floor((u - 1) / 7) * 7;
                        return (u + a.weekStartsOn + 6) % 7 + f
                    };
                    switch (i) {
                    case "c":
                    case "cc":
                        return kr(pr(i.length, o), l);
                    case "co":
                        return kr(s.ordinalNumber(o, {
                                unit: "day"
                            }), l);
                    case "ccc":
                        return s.day(o, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.day(o, {
                            width: "short",
                            context: "standalone"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "ccccc":
                        return s.day(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "cccccc":
                        return s.day(o, {
                            width: "short",
                            context: "standalone"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "cccc":
                    default:
                        return s.day(o, {
                            width: "wide",
                            context: "standalone"
                        }) || s.day(o, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.day(o, {
                            width: "short",
                            context: "standalone"
                        }) || s.day(o, {
                            width: "narrow",
                            context: "standalone"
                        })
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 6
                }
            }, {
                key: "set",
                value: function (o, i, s, a) {
                    return o = xI(o, s, a),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn);
function L2e(e, t) {
    bn(2, arguments);
    var n = dr(t);
    n % 7 === 0 && (n = n - 7);
    var r = 1,
    o = Mn(e),
    i = o.getUTCDay(),
    s = n % 7,
    a = (s + 7) % 7,
    l = (a < r ? 7 : 0) + n - i;
    return o.setUTCDate(o.getUTCDate() + l),
    o
}
var B2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 90),
        Qe(ot(r), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    var a = function (c) {
                        return c === 0 ? 7 : c
                    };
                    switch (i) {
                    case "i":
                    case "ii":
                        return pr(i.length, o);
                    case "io":
                        return s.ordinalNumber(o, {
                            unit: "day"
                        });
                    case "iii":
                        return kr(s.day(o, {
                                width: "abbreviated",
                                context: "formatting"
                            }) || s.day(o, {
                                width: "short",
                                context: "formatting"
                            }) || s.day(o, {
                                width: "narrow",
                                context: "formatting"
                            }), a);
                    case "iiiii":
                        return kr(s.day(o, {
                                width: "narrow",
                                context: "formatting"
                            }), a);
                    case "iiiiii":
                        return kr(s.day(o, {
                                width: "short",
                                context: "formatting"
                            }) || s.day(o, {
                                width: "narrow",
                                context: "formatting"
                            }), a);
                    case "iiii":
                    default:
                        return kr(s.day(o, {
                                width: "wide",
                                context: "formatting"
                            }) || s.day(o, {
                                width: "abbreviated",
                                context: "formatting"
                            }) || s.day(o, {
                                width: "short",
                                context: "formatting"
                            }) || s.day(o, {
                                width: "narrow",
                                context: "formatting"
                            }), a)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 7
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o = L2e(o, s),
                    o.setUTCHours(0, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), V2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 80),
        Qe(ot(r), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "a":
                    case "aa":
                    case "aaa":
                        return s.dayPeriod(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "aaaaa":
                        return s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "aaaa":
                    default:
                        return s.dayPeriod(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCHours(kI(s), 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), F2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 80),
        Qe(ot(r), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "b":
                    case "bb":
                    case "bbb":
                        return s.dayPeriod(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "bbbbb":
                        return s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "bbbb":
                    default:
                        return s.dayPeriod(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCHours(kI(s), 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), j2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 80),
        Qe(ot(r), "incompatibleTokens", ["a", "b", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "B":
                    case "BB":
                    case "BBB":
                        return s.dayPeriod(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "BBBBB":
                        return s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "BBBB":
                    default:
                        return s.dayPeriod(o, {
                            width: "wide",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(o, {
                            width: "narrow",
                            context: "formatting"
                        })
                    }
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCHours(kI(s), 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), W2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 70),
        Qe(ot(r), "incompatibleTokens", ["H", "K", "k", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "h":
                        return or(_r.hour12h, o);
                    case "ho":
                        return s.ordinalNumber(o, {
                            unit: "hour"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 12
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    var a = o.getUTCHours() >= 12;
                    return a && s < 12 ? o.setUTCHours(s + 12, 0, 0, 0) : !a && s === 12 ? o.setUTCHours(0, 0, 0, 0) : o.setUTCHours(s, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), z2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 70),
        Qe(ot(r), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "H":
                        return or(_r.hour23h, o);
                    case "Ho":
                        return s.ordinalNumber(o, {
                            unit: "hour"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 23
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCHours(s, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), H2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 70),
        Qe(ot(r), "incompatibleTokens", ["h", "H", "k", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "K":
                        return or(_r.hour11h, o);
                    case "Ko":
                        return s.ordinalNumber(o, {
                            unit: "hour"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 11
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    var a = o.getUTCHours() >= 12;
                    return a && s < 12 ? o.setUTCHours(s + 12, 0, 0, 0) : o.setUTCHours(s, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), U2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 70),
        Qe(ot(r), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "k":
                        return or(_r.hour24h, o);
                    case "ko":
                        return s.ordinalNumber(o, {
                            unit: "hour"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 1 && i <= 24
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    var a = s <= 24 ? s % 24 : s;
                    return o.setUTCHours(a, 0, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), q2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 60),
        Qe(ot(r), "incompatibleTokens", ["t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "m":
                        return or(_r.minute, o);
                    case "mo":
                        return s.ordinalNumber(o, {
                            unit: "minute"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 59
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMinutes(s, 0, 0),
                    o
                }
            }
        ]),
    n
}
(vn), Y2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 50),
        Qe(ot(r), "incompatibleTokens", ["t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i, s) {
                    switch (i) {
                    case "s":
                        return or(_r.second, o);
                    case "so":
                        return s.ordinalNumber(o, {
                            unit: "second"
                        });
                    default:
                        return pr(i.length, o)
                    }
                }
            }, {
                key: "validate",
                value: function (o, i) {
                    return i >= 0 && i <= 59
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCSeconds(s, 0),
                    o
                }
            }
        ]),
    n
}
(vn), K2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 30),
        Qe(ot(r), "incompatibleTokens", ["t", "T"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i) {
                    var s = function (l) {
                        return Math.floor(l * Math.pow(10, -i.length + 3))
                    };
                    return kr(pr(i.length, o), s)
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return o.setUTCMilliseconds(s),
                    o
                }
            }
        ]),
    n
}
(vn), G2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 10),
        Qe(ot(r), "incompatibleTokens", ["t", "T", "x"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i) {
                    switch (i) {
                    case "X":
                        return Js(Xs.basicOptionalMinutes, o);
                    case "XX":
                        return Js(Xs.basic, o);
                    case "XXXX":
                        return Js(Xs.basicOptionalSeconds, o);
                    case "XXXXX":
                        return Js(Xs.extendedOptionalSeconds, o);
                    case "XXX":
                    default:
                        return Js(Xs.extended, o)
                    }
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return i.timestampIsSet ? o : new Date(o.getTime() - s)
                }
            }
        ]),
    n
}
(vn), X2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 10),
        Qe(ot(r), "incompatibleTokens", ["t", "T", "X"]),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o, i) {
                    switch (i) {
                    case "x":
                        return Js(Xs.basicOptionalMinutes, o);
                    case "xx":
                        return Js(Xs.basic, o);
                    case "xxxx":
                        return Js(Xs.basicOptionalSeconds, o);
                    case "xxxxx":
                        return Js(Xs.extendedOptionalSeconds, o);
                    case "xxx":
                    default:
                        return Js(Xs.extended, o)
                    }
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return i.timestampIsSet ? o : new Date(o.getTime() - s)
                }
            }
        ]),
    n
}
(vn), J2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 40),
        Qe(ot(r), "incompatibleTokens", "*"),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o) {
                    return K7(o)
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return [new Date(s * 1e3), {
                            timestampIsSet: !0
                        }
                    ]
                }
            }
        ]),
    n
}
(vn), Z2e = function (e) {
    dn(n, e);
    var t = fn(n);
    function n() {
        var r;
        nn(this, n);
        for (var o = arguments.length, i = new Array(o), s = 0; s < o; s++)
            i[s] = arguments[s];
        return r = t.call.apply(t, [this].concat(i)),
        Qe(ot(r), "priority", 20),
        Qe(ot(r), "incompatibleTokens", "*"),
        r
    }
    return rn(n, [{
                key: "parse",
                value: function (o) {
                    return K7(o)
                }
            }, {
                key: "set",
                value: function (o, i, s) {
                    return [new Date(s), {
                            timestampIsSet: !0
                        }
                    ]
                }
            }
        ]),
    n
}
(vn), Q2e = {
    G: new v2e,
    y: new y2e,
    Y: new w2e,
    R: new b2e,
    u: new _2e,
    Q: new k2e,
    q: new x2e,
    M: new S2e,
    L: new C2e,
    w: new T2e,
    I: new P2e,
    d: new $2e,
    D: new A2e,
    E: new D2e,
    e: new N2e,
    c: new R2e,
    i: new B2e,
    a: new V2e,
    b: new F2e,
    B: new j2e,
    h: new W2e,
    H: new z2e,
    K: new H2e,
    k: new U2e,
    m: new q2e,
    s: new Y2e,
    S: new K2e,
    X: new G2e,
    x: new X2e,
    t: new J2e,
    T: new Z2e
}, eke = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, tke = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, nke = /^'([^]*?)'?$/, rke = /''/g, oke = /\S/, ike = /[a-zA-Z]/;
function ske(e, t, n, r) {
    var o,
    i,
    s,
    a,
    l,
    c,
    u,
    f,
    p,
    m,
    v,
    y,
    b,
    w,
    k,
    C,
    x,
    S;
    bn(3, arguments);
    var T = String(e),
    E = String(t),
    M = pg(),
    N = (o = (i = r?.locale) !== null && i !== void 0 ? i : M.locale) !== null && o !== void 0 ? o : o2e;
    if (!N.match)
        throw new RangeError("locale must contain match property");
    var F = dr((s = (a = (l = (c = r?.firstWeekContainsDate) !== null && c !== void 0 ? c : r == null || (u = r.locale) === null || u === void 0 || (f = u.options) === null || f === void 0 ? void 0 : f.firstWeekContainsDate) !== null && l !== void 0 ? l : M.firstWeekContainsDate) !== null && a !== void 0 ? a : (p = M.locale) === null || p === void 0 || (m = p.options) === null || m === void 0 ? void 0 : m.firstWeekContainsDate) !== null && s !== void 0 ? s : 1);
    if (!(F >= 1 && F <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var K = dr((v = (y = (b = (w = r?.weekStartsOn) !== null && w !== void 0 ? w : r == null || (k = r.locale) === null || k === void 0 || (C = k.options) === null || C === void 0 ? void 0 : C.weekStartsOn) !== null && b !== void 0 ? b : M.weekStartsOn) !== null && y !== void 0 ? y : (x = M.locale) === null || x === void 0 || (S = x.options) === null || S === void 0 ? void 0 : S.weekStartsOn) !== null && v !== void 0 ? v : 0);
    if (!(K >= 0 && K <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (E === "")
        return T === "" ? Mn(n) : new Date(NaN);
    var j = {
        firstWeekContainsDate: F,
        weekStartsOn: K,
        locale: N
    },
    G = [new g2e],
    Y = E.match(tke).map(function (pe) {
        var xe = pe[0];
        if (xe in Y$) {
            var et = Y$[xe];
            return et(pe, N.formatLong)
        }
        return pe
    }).join("").match(eke),
    ue = [],
    re = X$(Y),
    de;
    try {
        var Se = function () {
            var xe = de.value;
            !(r != null && r.useAdditionalWeekYearTokens) && w_e(xe) && K$(xe, E, e),
            !(r != null && r.useAdditionalDayOfYearTokens) && y_e(xe) && K$(xe, E, e);
            var et = xe[0],
            Xe = Q2e[et];
            if (Xe) {
                var W = Xe.incompatibleTokens;
                if (Array.isArray(W)) {
                    var R = ue.find(function (Q) {
                        return W.includes(Q.token) || Q.token === et
                    });
                    if (R)
                        throw new RangeError("The format string mustn't contain `".concat(R.fullToken, "` and `").concat(xe, "` at the same time"))
                } else if (Xe.incompatibleTokens === "*" && ue.length > 0)
                    throw new RangeError("The format string mustn't contain `".concat(xe, "` and any other token at the same time"));
                ue.push({
                    token: et,
                    fullToken: xe
                });
                var X = Xe.run(T, xe, N.match, j);
                if (!X)
                    return {
                        v: new Date(NaN)
                    };
                G.push(X.setter),
                T = X.rest
            } else {
                if (et.match(ike))
                    throw new RangeError("Format string contains an unescaped latin alphabet character `" + et + "`");
                if (xe === "''" ? xe = "'" : et === "'" && (xe = ake(xe)), T.indexOf(xe) === 0)
                    T = T.slice(xe.length);
                else
                    return {
                        v: new Date(NaN)
                    }
            }
        };
        for (re.s(); !(de = re.n()).done; ) {
            var Pe = Se();
            if (fa(Pe) === "object")
                return Pe.v
        }
    } catch (pe) {
        re.e(pe)
    } finally {
        re.f()
    }
    if (T.length > 0 && oke.test(T))
        return new Date(NaN);
    var je = G.map(function (pe) {
        return pe.priority
    }).sort(function (pe, xe) {
        return xe - pe
    }).filter(function (pe, xe, et) {
        return et.indexOf(pe) === xe
    }).map(function (pe) {
        return G.filter(function (xe) {
            return xe.priority === pe
        }).sort(function (xe, et) {
            return et.subPriority - xe.subPriority
        })
    }).map(function (pe) {
        return pe[0]
    }),
    Ke = Mn(n);
    if (isNaN(Ke.getTime()))
        return new Date(NaN);
    var Ue = s_e(Ke, t_e(Ke)),
    yt = {},
    at = X$(je),
    le;
    try {
        for (at.s(); !(le = at.n()).done; ) {
            var ye = le.value;
            if (!ye.validate(Ue, j))
                return new Date(NaN);
            var ge = ye.set(Ue, yt, j);
            Array.isArray(ge) ? (Ue = ge[0], i2e(yt, ge[1])) : Ue = ge
        }
    } catch (pe) {
        at.e(pe)
    } finally {
        at.f()
    }
    return Ue
}
function ake(e) {
    return e.match(nke)[1].replace(rke, "'")
}
function lke(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = dr(t),
    o = n.getFullYear(),
    i = n.getDate(),
    s = new Date(0);
    s.setFullYear(o, r, 15),
    s.setHours(0, 0, 0, 0);
    var a = a2e(s);
    return n.setMonth(r, Math.min(i, a)),
    n
}
function cke(e, t) {
    if (bn(2, arguments), fa(t) !== "object" || t === null)
        throw new RangeError("values parameter must be an object");
    var n = Mn(e);
    return isNaN(n.getTime()) ? new Date(NaN) : (t.year != null && n.setFullYear(t.year), t.month != null && (n = lke(n, t.month)), t.date != null && n.setDate(dr(t.date)), t.hours != null && n.setHours(dr(t.hours)), t.minutes != null && n.setMinutes(dr(t.minutes)), t.seconds != null && n.setSeconds(dr(t.seconds)), t.milliseconds != null && n.setMilliseconds(dr(t.milliseconds)), n)
}
function Z$(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = dr(t);
    return n.setHours(r),
    n
}
function Q$(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = dr(t);
    return n.setMilliseconds(r),
    n
}
function eA(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = dr(t);
    return n.setMinutes(r),
    n
}
function tA(e, t) {
    bn(2, arguments);
    var n = Mn(e),
    r = dr(t);
    return n.setSeconds(r),
    n
}
var ly = {}, uke = {
    get exports() {
        return ly
    },
    set exports(e) {
        ly = e
    }
}, Un = {}, dke = {
    get exports() {
        return Un
    },
    set exports(e) {
        Un = e
    }
};
(function (e) {
    function t(n) {
        return n && n.__esModule ? n : {
        default:
            n
        }
    }
    e.exports = t,
    e.exports.__esModule = !0,
    e.exports.default = e.exports
})(dke);
var cy = {}, fke = {
    get exports() {
        return cy
    },
    set exports(e) {
        cy = e
    }
}, uy = {}, hke = {
    get exports() {
        return uy
    },
    set exports(e) {
        uy = e
    }
}, dy = {}, pke = {
    get exports() {
        return dy
    },
    set exports(e) {
        dy = e
    }
};
(function (e) {
    function t(n) {
        return e.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (r) {
            return typeof r
        }
         : function (r) {
            return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
        },
        e.exports.__esModule = !0,
        e.exports.default = e.exports,
        t(n)
    }
    e.exports = t,
    e.exports.__esModule = !0,
    e.exports.default = e.exports
})(pke);
var zr = {}, mke = {
    get exports() {
        return zr
    },
    set exports(e) {
        zr = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r, o) {
        if (o.length < r)
            throw new TypeError(r + " argument" + (r > 1 ? "s" : "") + " required, but only " + o.length + " present")
    }
    e.exports = t.default
})(mke, zr);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = i;
    var r = n(dy),
    o = n(zr);
    function i(s) {
        return (0, o.default)(1, arguments),
        s instanceof Date || (0, r.default)(s) === "object" && Object.prototype.toString.call(s) === "[object Date]"
    }
    e.exports = t.default
})(hke, uy);
var Ti = {}, gke = {
    get exports() {
        return Ti
    },
    set exports(e) {
        Ti = e
    }
};
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = i;
    var r = n(dy),
    o = n(zr);
    function i(s) {
        (0, o.default)(1, arguments);
        var a = Object.prototype.toString.call(s);
        return s instanceof Date || (0, r.default)(s) === "object" && a === "[object Date]" ? new Date(s.getTime()) : typeof s == "number" || a === "[object Number]" ? new Date(s) : ((typeof s == "string" || a === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN))
    }
    e.exports = t.default
})(gke, Ti);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = s;
    var r = n(uy),
    o = n(Ti),
    i = n(zr);
    function s(a) {
        if ((0, i.default)(1, arguments), !(0, r.default)(a) && typeof a != "number")
            return !1;
        var l = (0, o.default)(a);
        return !isNaN(Number(l))
    }
    e.exports = t.default
})(fke, cy);
var fy = {}, vke = {
    get exports() {
        return fy
    },
    set exports(e) {
        fy = e
    }
}, hy = {}, yke = {
    get exports() {
        return hy
    },
    set exports(e) {
        hy = e
    }
}, ha = {}, wke = {
    get exports() {
        return ha
    },
    set exports(e) {
        ha = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r) {
        if (r === null || r === !0 || r === !1)
            return NaN;
        var o = Number(r);
        return isNaN(o) ? o : o < 0 ? Math.ceil(o) : Math.floor(o)
    }
    e.exports = t.default
})(wke, ha);
const bke = og(ha);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = s;
    var r = n(ha),
    o = n(Ti),
    i = n(zr);
    function s(a, l) {
        (0, i.default)(2, arguments);
        var c = (0, o.default)(a).getTime(),
        u = (0, r.default)(l);
        return new Date(c + u)
    }
    e.exports = t.default
})(yke, hy);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = s;
    var r = n(hy),
    o = n(zr),
    i = n(ha);
    function s(a, l) {
        (0, o.default)(2, arguments);
        var c = (0, i.default)(l);
        return (0, r.default)(a, -c)
    }
    e.exports = t.default
})(vke, fy);
var py = {}, _ke = {
    get exports() {
        return py
    },
    set exports(e) {
        py = e
    }
}, my = {}, kke = {
    get exports() {
        return my
    },
    set exports(e) {
        my = e
    }
};
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = s;
    var r = n(Ti),
    o = n(zr),
    i = 864e5;
    function s(a) {
        (0, o.default)(1, arguments);
        var l = (0, r.default)(a),
        c = l.getTime();
        l.setUTCMonth(0, 1),
        l.setUTCHours(0, 0, 0, 0);
        var u = l.getTime(),
        f = c - u;
        return Math.floor(f / i) + 1
    }
    e.exports = t.default
})(kke, my);
var gy = {}, xke = {
    get exports() {
        return gy
    },
    set exports(e) {
        gy = e
    }
}, Pf = {}, Ske = {
    get exports() {
        return Pf
    },
    set exports(e) {
        Pf = e
    }
};
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = i;
    var r = n(Ti),
    o = n(zr);
    function i(s) {
        (0, o.default)(1, arguments);
        var a = 1,
        l = (0, r.default)(s),
        c = l.getUTCDay(),
        u = (c < a ? 7 : 0) + c - a;
        return l.setUTCDate(l.getUTCDate() - u),
        l.setUTCHours(0, 0, 0, 0),
        l
    }
    e.exports = t.default
})(Ske, Pf);
var vy = {}, Cke = {
    get exports() {
        return vy
    },
    set exports(e) {
        vy = e
    }
}, Sm = {}, Ike = {
    get exports() {
        return Sm
    },
    set exports(e) {
        Sm = e
    }
};
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = s;
    var r = n(Ti),
    o = n(zr),
    i = n(Pf);
    function s(a) {
        (0, o.default)(1, arguments);
        var l = (0, r.default)(a),
        c = l.getUTCFullYear(),
        u = new Date(0);
        u.setUTCFullYear(c + 1, 0, 4),
        u.setUTCHours(0, 0, 0, 0);
        var f = (0, i.default)(u),
        p = new Date(0);
        p.setUTCFullYear(c, 0, 4),
        p.setUTCHours(0, 0, 0, 0);
        var m = (0, i.default)(p);
        return l.getTime() >= f.getTime() ? c + 1 : l.getTime() >= m.getTime() ? c : c - 1
    }
    e.exports = t.default
})(Ike, Sm);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = s;
    var r = n(Sm),
    o = n(Pf),
    i = n(zr);
    function s(a) {
        (0, i.default)(1, arguments);
        var l = (0, r.default)(a),
        c = new Date(0);
        c.setUTCFullYear(l, 0, 4),
        c.setUTCHours(0, 0, 0, 0);
        var u = (0, o.default)(c);
        return u
    }
    e.exports = t.default
})(Cke, vy);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = l;
    var r = n(Ti),
    o = n(Pf),
    i = n(vy),
    s = n(zr),
    a = 6048e5;
    function l(c) {
        (0, s.default)(1, arguments);
        var u = (0, r.default)(c),
        f = (0, o.default)(u).getTime() - (0, i.default)(u).getTime();
        return Math.round(f / a) + 1
    }
    e.exports = t.default
})(xke, gy);
var yy = {}, Tke = {
    get exports() {
        return yy
    },
    set exports(e) {
        yy = e
    }
}, Ef = {}, Mke = {
    get exports() {
        return Ef
    },
    set exports(e) {
        Ef = e
    }
}, ed = {};
Object.defineProperty(ed, "__esModule", {
    value: !0
});
ed.getDefaultOptions = Pke;
ed.setDefaultOptions = Eke;
var J7 = {};
function Pke() {
    return J7
}
function Eke(e) {
    J7 = e
}
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = a;
    var r = n(Ti),
    o = n(zr),
    i = n(ha),
    s = ed;
    function a(l, c) {
        var u,
        f,
        p,
        m,
        v,
        y,
        b,
        w;
        (0, o.default)(1, arguments);
        var k = (0, s.getDefaultOptions)(),
        C = (0, i.default)((u = (f = (p = (m = c?.weekStartsOn) !== null && m !== void 0 ? m : c == null || (v = c.locale) === null || v === void 0 || (y = v.options) === null || y === void 0 ? void 0 : y.weekStartsOn) !== null && p !== void 0 ? p : k.weekStartsOn) !== null && f !== void 0 ? f : (b = k.locale) === null || b === void 0 || (w = b.options) === null || w === void 0 ? void 0 : w.weekStartsOn) !== null && u !== void 0 ? u : 0);
        if (!(C >= 0 && C <= 6))
            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        var x = (0, r.default)(l),
        S = x.getUTCDay(),
        T = (S < C ? 7 : 0) + S - C;
        return x.setUTCDate(x.getUTCDate() - T),
        x.setUTCHours(0, 0, 0, 0),
        x
    }
    e.exports = t.default
})(Mke, Ef);
var wy = {}, Oke = {
    get exports() {
        return wy
    },
    set exports(e) {
        wy = e
    }
}, Cm = {}, $ke = {
    get exports() {
        return Cm
    },
    set exports(e) {
        Cm = e
    }
};
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = l;
    var r = n(Ti),
    o = n(zr),
    i = n(Ef),
    s = n(ha),
    a = ed;
    function l(c, u) {
        var f,
        p,
        m,
        v,
        y,
        b,
        w,
        k;
        (0, o.default)(1, arguments);
        var C = (0, r.default)(c),
        x = C.getUTCFullYear(),
        S = (0, a.getDefaultOptions)(),
        T = (0, s.default)((f = (p = (m = (v = u?.firstWeekContainsDate) !== null && v !== void 0 ? v : u == null || (y = u.locale) === null || y === void 0 || (b = y.options) === null || b === void 0 ? void 0 : b.firstWeekContainsDate) !== null && m !== void 0 ? m : S.firstWeekContainsDate) !== null && p !== void 0 ? p : (w = S.locale) === null || w === void 0 || (k = w.options) === null || k === void 0 ? void 0 : k.firstWeekContainsDate) !== null && f !== void 0 ? f : 1);
        if (!(T >= 1 && T <= 7))
            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        var E = new Date(0);
        E.setUTCFullYear(x + 1, 0, T),
        E.setUTCHours(0, 0, 0, 0);
        var M = (0, i.default)(E, u),
        N = new Date(0);
        N.setUTCFullYear(x, 0, T),
        N.setUTCHours(0, 0, 0, 0);
        var F = (0, i.default)(N, u);
        return C.getTime() >= M.getTime() ? x + 1 : C.getTime() >= F.getTime() ? x : x - 1
    }
    e.exports = t.default
})($ke, Cm);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = l;
    var r = n(Cm),
    o = n(zr),
    i = n(Ef),
    s = n(ha),
    a = ed;
    function l(c, u) {
        var f,
        p,
        m,
        v,
        y,
        b,
        w,
        k;
        (0, o.default)(1, arguments);
        var C = (0, a.getDefaultOptions)(),
        x = (0, s.default)((f = (p = (m = (v = u?.firstWeekContainsDate) !== null && v !== void 0 ? v : u == null || (y = u.locale) === null || y === void 0 || (b = y.options) === null || b === void 0 ? void 0 : b.firstWeekContainsDate) !== null && m !== void 0 ? m : C.firstWeekContainsDate) !== null && p !== void 0 ? p : (w = C.locale) === null || w === void 0 || (k = w.options) === null || k === void 0 ? void 0 : k.firstWeekContainsDate) !== null && f !== void 0 ? f : 1),
        S = (0, r.default)(c, u),
        T = new Date(0);
        T.setUTCFullYear(S, 0, x),
        T.setUTCHours(0, 0, 0, 0);
        var E = (0, i.default)(T, u);
        return E
    }
    e.exports = t.default
})(Oke, wy);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = l;
    var r = n(Ti),
    o = n(Ef),
    i = n(wy),
    s = n(zr),
    a = 6048e5;
    function l(c, u) {
        (0, s.default)(1, arguments);
        var f = (0, r.default)(c),
        p = (0, o.default)(f, u).getTime() - (0, i.default)(f, u).getTime();
        return Math.round(p / a) + 1
    }
    e.exports = t.default
})(Tke, yy);
var Im = {}, Ake = {
    get exports() {
        return Im
    },
    set exports(e) {
        Im = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r, o) {
        for (var i = r < 0 ? "-" : "", s = Math.abs(r).toString(); s.length < o; )
            s = "0" + s;
        return i + s
    }
    e.exports = t.default
})(Ake, Im);
var by = {}, Dke = {
    get exports() {
        return by
    },
    set exports(e) {
        by = e
    }
};
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(Im),
    o = {
        y: function (a, l) {
            var c = a.getUTCFullYear(),
            u = c > 0 ? c : 1 - c;
            return (0, r.default)(l === "yy" ? u % 100 : u, l.length)
        },
        M: function (a, l) {
            var c = a.getUTCMonth();
            return l === "M" ? String(c + 1) : (0, r.default)(c + 1, 2)
        },
        d: function (a, l) {
            return (0, r.default)(a.getUTCDate(), l.length)
        },
        a: function (a, l) {
            var c = a.getUTCHours() / 12 >= 1 ? "pm" : "am";
            switch (l) {
            case "a":
            case "aa":
                return c.toUpperCase();
            case "aaa":
                return c;
            case "aaaaa":
                return c[0];
            case "aaaa":
            default:
                return c === "am" ? "a.m." : "p.m."
            }
        },
        h: function (a, l) {
            return (0, r.default)(a.getUTCHours() % 12 || 12, l.length)
        },
        H: function (a, l) {
            return (0, r.default)(a.getUTCHours(), l.length)
        },
        m: function (a, l) {
            return (0, r.default)(a.getUTCMinutes(), l.length)
        },
        s: function (a, l) {
            return (0, r.default)(a.getUTCSeconds(), l.length)
        },
        S: function (a, l) {
            var c = l.length,
            u = a.getUTCMilliseconds(),
            f = Math.floor(u * Math.pow(10, c - 3));
            return (0, r.default)(f, l.length)
        }
    },
    i = o;
    t.default = i,
    e.exports = t.default
})(Dke, by);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(my),
    o = n(gy),
    i = n(Sm),
    s = n(yy),
    a = n(Cm),
    l = n(Im),
    c = n(by),
    u = {
        am: "am",
        pm: "pm",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    f = {
        G: function (w, k, C) {
            var x = w.getUTCFullYear() > 0 ? 1 : 0;
            switch (k) {
            case "G":
            case "GG":
            case "GGG":
                return C.era(x, {
                    width: "abbreviated"
                });
            case "GGGGG":
                return C.era(x, {
                    width: "narrow"
                });
            case "GGGG":
            default:
                return C.era(x, {
                    width: "wide"
                })
            }
        },
        y: function (w, k, C) {
            if (k === "yo") {
                var x = w.getUTCFullYear(),
                S = x > 0 ? x : 1 - x;
                return C.ordinalNumber(S, {
                    unit: "year"
                })
            }
            return c.default.y(w, k)
        },
        Y: function (w, k, C, x) {
            var S = (0, a.default)(w, x),
            T = S > 0 ? S : 1 - S;
            if (k === "YY") {
                var E = T % 100;
                return (0, l.default)(E, 2)
            }
            return k === "Yo" ? C.ordinalNumber(T, {
                unit: "year"
            }) : (0, l.default)(T, k.length)
        },
        R: function (w, k) {
            var C = (0, i.default)(w);
            return (0, l.default)(C, k.length)
        },
        u: function (w, k) {
            var C = w.getUTCFullYear();
            return (0, l.default)(C, k.length)
        },
        Q: function (w, k, C) {
            var x = Math.ceil((w.getUTCMonth() + 1) / 3);
            switch (k) {
            case "Q":
                return String(x);
            case "QQ":
                return (0, l.default)(x, 2);
            case "Qo":
                return C.ordinalNumber(x, {
                    unit: "quarter"
                });
            case "QQQ":
                return C.quarter(x, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "QQQQQ":
                return C.quarter(x, {
                    width: "narrow",
                    context: "formatting"
                });
            case "QQQQ":
            default:
                return C.quarter(x, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        q: function (w, k, C) {
            var x = Math.ceil((w.getUTCMonth() + 1) / 3);
            switch (k) {
            case "q":
                return String(x);
            case "qq":
                return (0, l.default)(x, 2);
            case "qo":
                return C.ordinalNumber(x, {
                    unit: "quarter"
                });
            case "qqq":
                return C.quarter(x, {
                    width: "abbreviated",
                    context: "standalone"
                });
            case "qqqqq":
                return C.quarter(x, {
                    width: "narrow",
                    context: "standalone"
                });
            case "qqqq":
            default:
                return C.quarter(x, {
                    width: "wide",
                    context: "standalone"
                })
            }
        },
        M: function (w, k, C) {
            var x = w.getUTCMonth();
            switch (k) {
            case "M":
            case "MM":
                return c.default.M(w, k);
            case "Mo":
                return C.ordinalNumber(x + 1, {
                    unit: "month"
                });
            case "MMM":
                return C.month(x, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "MMMMM":
                return C.month(x, {
                    width: "narrow",
                    context: "formatting"
                });
            case "MMMM":
            default:
                return C.month(x, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        L: function (w, k, C) {
            var x = w.getUTCMonth();
            switch (k) {
            case "L":
                return String(x + 1);
            case "LL":
                return (0, l.default)(x + 1, 2);
            case "Lo":
                return C.ordinalNumber(x + 1, {
                    unit: "month"
                });
            case "LLL":
                return C.month(x, {
                    width: "abbreviated",
                    context: "standalone"
                });
            case "LLLLL":
                return C.month(x, {
                    width: "narrow",
                    context: "standalone"
                });
            case "LLLL":
            default:
                return C.month(x, {
                    width: "wide",
                    context: "standalone"
                })
            }
        },
        w: function (w, k, C, x) {
            var S = (0, s.default)(w, x);
            return k === "wo" ? C.ordinalNumber(S, {
                unit: "week"
            }) : (0, l.default)(S, k.length)
        },
        I: function (w, k, C) {
            var x = (0, o.default)(w);
            return k === "Io" ? C.ordinalNumber(x, {
                unit: "week"
            }) : (0, l.default)(x, k.length)
        },
        d: function (w, k, C) {
            return k === "do" ? C.ordinalNumber(w.getUTCDate(), {
                unit: "date"
            }) : c.default.d(w, k)
        },
        D: function (w, k, C) {
            var x = (0, r.default)(w);
            return k === "Do" ? C.ordinalNumber(x, {
                unit: "dayOfYear"
            }) : (0, l.default)(x, k.length)
        },
        E: function (w, k, C) {
            var x = w.getUTCDay();
            switch (k) {
            case "E":
            case "EE":
            case "EEE":
                return C.day(x, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "EEEEE":
                return C.day(x, {
                    width: "narrow",
                    context: "formatting"
                });
            case "EEEEEE":
                return C.day(x, {
                    width: "short",
                    context: "formatting"
                });
            case "EEEE":
            default:
                return C.day(x, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        e: function (w, k, C, x) {
            var S = w.getUTCDay(),
            T = (S - x.weekStartsOn + 8) % 7 || 7;
            switch (k) {
            case "e":
                return String(T);
            case "ee":
                return (0, l.default)(T, 2);
            case "eo":
                return C.ordinalNumber(T, {
                    unit: "day"
                });
            case "eee":
                return C.day(S, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "eeeee":
                return C.day(S, {
                    width: "narrow",
                    context: "formatting"
                });
            case "eeeeee":
                return C.day(S, {
                    width: "short",
                    context: "formatting"
                });
            case "eeee":
            default:
                return C.day(S, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        c: function (w, k, C, x) {
            var S = w.getUTCDay(),
            T = (S - x.weekStartsOn + 8) % 7 || 7;
            switch (k) {
            case "c":
                return String(T);
            case "cc":
                return (0, l.default)(T, k.length);
            case "co":
                return C.ordinalNumber(T, {
                    unit: "day"
                });
            case "ccc":
                return C.day(S, {
                    width: "abbreviated",
                    context: "standalone"
                });
            case "ccccc":
                return C.day(S, {
                    width: "narrow",
                    context: "standalone"
                });
            case "cccccc":
                return C.day(S, {
                    width: "short",
                    context: "standalone"
                });
            case "cccc":
            default:
                return C.day(S, {
                    width: "wide",
                    context: "standalone"
                })
            }
        },
        i: function (w, k, C) {
            var x = w.getUTCDay(),
            S = x === 0 ? 7 : x;
            switch (k) {
            case "i":
                return String(S);
            case "ii":
                return (0, l.default)(S, k.length);
            case "io":
                return C.ordinalNumber(S, {
                    unit: "day"
                });
            case "iii":
                return C.day(x, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "iiiii":
                return C.day(x, {
                    width: "narrow",
                    context: "formatting"
                });
            case "iiiiii":
                return C.day(x, {
                    width: "short",
                    context: "formatting"
                });
            case "iiii":
            default:
                return C.day(x, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        a: function (w, k, C) {
            var x = w.getUTCHours(),
            S = x / 12 >= 1 ? "pm" : "am";
            switch (k) {
            case "a":
            case "aa":
                return C.dayPeriod(S, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "aaa":
                return C.dayPeriod(S, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "aaaaa":
                return C.dayPeriod(S, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return C.dayPeriod(S, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        b: function (w, k, C) {
            var x = w.getUTCHours(),
            S;
            switch (x === 12 ? S = u.noon : x === 0 ? S = u.midnight : S = x / 12 >= 1 ? "pm" : "am", k) {
            case "b":
            case "bb":
                return C.dayPeriod(S, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "bbb":
                return C.dayPeriod(S, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "bbbbb":
                return C.dayPeriod(S, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return C.dayPeriod(S, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        B: function (w, k, C) {
            var x = w.getUTCHours(),
            S;
            switch (x >= 17 ? S = u.evening : x >= 12 ? S = u.afternoon : x >= 4 ? S = u.morning : S = u.night, k) {
            case "B":
            case "BB":
            case "BBB":
                return C.dayPeriod(S, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "BBBBB":
                return C.dayPeriod(S, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return C.dayPeriod(S, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        h: function (w, k, C) {
            if (k === "ho") {
                var x = w.getUTCHours() % 12;
                return x === 0 && (x = 12),
                C.ordinalNumber(x, {
                    unit: "hour"
                })
            }
            return c.default.h(w, k)
        },
        H: function (w, k, C) {
            return k === "Ho" ? C.ordinalNumber(w.getUTCHours(), {
                unit: "hour"
            }) : c.default.H(w, k)
        },
        K: function (w, k, C) {
            var x = w.getUTCHours() % 12;
            return k === "Ko" ? C.ordinalNumber(x, {
                unit: "hour"
            }) : (0, l.default)(x, k.length)
        },
        k: function (w, k, C) {
            var x = w.getUTCHours();
            return x === 0 && (x = 24),
            k === "ko" ? C.ordinalNumber(x, {
                unit: "hour"
            }) : (0, l.default)(x, k.length)
        },
        m: function (w, k, C) {
            return k === "mo" ? C.ordinalNumber(w.getUTCMinutes(), {
                unit: "minute"
            }) : c.default.m(w, k)
        },
        s: function (w, k, C) {
            return k === "so" ? C.ordinalNumber(w.getUTCSeconds(), {
                unit: "second"
            }) : c.default.s(w, k)
        },
        S: function (w, k) {
            return c.default.S(w, k)
        },
        X: function (w, k, C, x) {
            var S = x._originalDate || w,
            T = S.getTimezoneOffset();
            if (T === 0)
                return "Z";
            switch (k) {
            case "X":
                return m(T);
            case "XXXX":
            case "XX":
                return v(T);
            case "XXXXX":
            case "XXX":
            default:
                return v(T, ":")
            }
        },
        x: function (w, k, C, x) {
            var S = x._originalDate || w,
            T = S.getTimezoneOffset();
            switch (k) {
            case "x":
                return m(T);
            case "xxxx":
            case "xx":
                return v(T);
            case "xxxxx":
            case "xxx":
            default:
                return v(T, ":")
            }
        },
        O: function (w, k, C, x) {
            var S = x._originalDate || w,
            T = S.getTimezoneOffset();
            switch (k) {
            case "O":
            case "OO":
            case "OOO":
                return "GMT" + p(T, ":");
            case "OOOO":
            default:
                return "GMT" + v(T, ":")
            }
        },
        z: function (w, k, C, x) {
            var S = x._originalDate || w,
            T = S.getTimezoneOffset();
            switch (k) {
            case "z":
            case "zz":
            case "zzz":
                return "GMT" + p(T, ":");
            case "zzzz":
            default:
                return "GMT" + v(T, ":")
            }
        },
        t: function (w, k, C, x) {
            var S = x._originalDate || w,
            T = Math.floor(S.getTime() / 1e3);
            return (0, l.default)(T, k.length)
        },
        T: function (w, k, C, x) {
            var S = x._originalDate || w,
            T = S.getTime();
            return (0, l.default)(T, k.length)
        }
    };
    function p(b, w) {
        var k = b > 0 ? "-" : "+",
        C = Math.abs(b),
        x = Math.floor(C / 60),
        S = C % 60;
        if (S === 0)
            return k + String(x);
        var T = w || "";
        return k + String(x) + T + (0, l.default)(S, 2)
    }
    function m(b, w) {
        if (b % 60 === 0) {
            var k = b > 0 ? "-" : "+";
            return k + (0, l.default)(Math.abs(b) / 60, 2)
        }
        return v(b, w)
    }
    function v(b, w) {
        var k = w || "",
        C = b > 0 ? "-" : "+",
        x = Math.abs(b),
        S = (0, l.default)(Math.floor(x / 60), 2),
        T = (0, l.default)(x % 60, 2);
        return C + S + k + T
    }
    var y = f;
    t.default = y,
    e.exports = t.default
})(_ke, py);
var _y = {}, Nke = {
    get exports() {
        return _y
    },
    set exports(e) {
        _y = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var n = function (l, c) {
        switch (l) {
        case "P":
            return c.date({
                width: "short"
            });
        case "PP":
            return c.date({
                width: "medium"
            });
        case "PPP":
            return c.date({
                width: "long"
            });
        case "PPPP":
        default:
            return c.date({
                width: "full"
            })
        }
    },
    r = function (l, c) {
        switch (l) {
        case "p":
            return c.time({
                width: "short"
            });
        case "pp":
            return c.time({
                width: "medium"
            });
        case "ppp":
            return c.time({
                width: "long"
            });
        case "pppp":
        default:
            return c.time({
                width: "full"
            })
        }
    },
    o = function (l, c) {
        var u = l.match(/(P+)(p+)?/) || [],
        f = u[1],
        p = u[2];
        if (!p)
            return n(l, c);
        var m;
        switch (f) {
        case "P":
            m = c.dateTime({
                width: "short"
            });
            break;
        case "PP":
            m = c.dateTime({
                width: "medium"
            });
            break;
        case "PPP":
            m = c.dateTime({
                width: "long"
            });
            break;
        case "PPPP":
        default:
            m = c.dateTime({
                width: "full"
            });
            break
        }
        return m.replace("{{date}}", n(f, c)).replace("{{time}}", r(p, c))
    },
    i = {
        p: r,
        P: o
    },
    s = i;
    t.default = s,
    e.exports = t.default
})(Nke, _y);
var Tm = {}, Rke = {
    get exports() {
        return Tm
    },
    set exports(e) {
        Tm = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r) {
        var o = new Date(Date.UTC(r.getFullYear(), r.getMonth(), r.getDate(), r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds()));
        return o.setUTCFullYear(r.getFullYear()),
        r.getTime() - o.getTime()
    }
    e.exports = t.default
})(Rke, Tm);
const nA = og(Tm);
var mg = {};
Object.defineProperty(mg, "__esModule", {
    value: !0
});
mg.isProtectedDayOfYearToken = Vke;
mg.isProtectedWeekYearToken = Fke;
mg.throwProtectedError = jke;
var Lke = ["D", "DD"], Bke = ["YY", "YYYY"];
function Vke(e) {
    return Lke.indexOf(e) !== -1
}
function Fke(e) {
    return Bke.indexOf(e) !== -1
}
function jke(e, t, n) {
    if (e === "YYYY")
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "YY")
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "D")
        throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "DD")
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}
var ky = {}, Wke = {
    get exports() {
        return ky
    },
    set exports(e) {
        ky = e
    }
}, xy = {}, zke = {
    get exports() {
        return xy
    },
    set exports(e) {
        xy = e
    }
}, Sy = {}, Hke = {
    get exports() {
        return Sy
    },
    set exports(e) {
        Sy = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var n = {
        lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
        },
        xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
        },
        xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
        },
        aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
        },
        xHours: {
            one: "1 hour",
            other: "{{count}} hours"
        },
        xDays: {
            one: "1 day",
            other: "{{count}} days"
        },
        aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
        },
        xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
        },
        aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
        },
        xMonths: {
            one: "1 month",
            other: "{{count}} months"
        },
        aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
        },
        xYears: {
            one: "1 year",
            other: "{{count}} years"
        },
        overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
        },
        almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
        }
    },
    r = function (s, a, l) {
        var c,
        u = n[s];
        return typeof u == "string" ? c = u : a === 1 ? c = u.one : c = u.other.replace("{{count}}", a.toString()),
        l != null && l.addSuffix ? l.comparison && l.comparison > 0 ? "in " + c : c + " ago" : c
    },
    o = r;
    t.default = o,
    e.exports = t.default
})(Hke, Sy);
var Cy = {}, Uke = {
    get exports() {
        return Cy
    },
    set exports(e) {
        Cy = e
    }
}, Iy = {}, qke = {
    get exports() {
        return Iy
    },
    set exports(e) {
        Iy = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r) {
        return function () {
            var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            i = o.width ? String(o.width) : r.defaultWidth,
            s = r.formats[i] || r.formats[r.defaultWidth];
            return s
        }
    }
    e.exports = t.default
})(qke, Iy);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(Iy),
    o = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
    },
    i = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
    },
    s = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
    },
    a = {
        date: (0, r.default)({
            formats: o,
            defaultWidth: "full"
        }),
        time: (0, r.default)({
            formats: i,
            defaultWidth: "full"
        }),
        dateTime: (0, r.default)({
            formats: s,
            defaultWidth: "full"
        })
    },
    l = a;
    t.default = l,
    e.exports = t.default
})(Uke, Cy);
var Ty = {}, Yke = {
    get exports() {
        return Ty
    },
    set exports(e) {
        Ty = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var n = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
    },
    r = function (s, a, l, c) {
        return n[s]
    },
    o = r;
    t.default = o,
    e.exports = t.default
})(Yke, Ty);
var My = {}, Kke = {
    get exports() {
        return My
    },
    set exports(e) {
        My = e
    }
}, Py = {}, Gke = {
    get exports() {
        return Py
    },
    set exports(e) {
        Py = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r) {
        return function (o, i) {
            var s = i != null && i.context ? String(i.context) : "standalone",
            a;
            if (s === "formatting" && r.formattingValues) {
                var l = r.defaultFormattingWidth || r.defaultWidth,
                c = i != null && i.width ? String(i.width) : l;
                a = r.formattingValues[c] || r.formattingValues[l]
            } else {
                var u = r.defaultWidth,
                f = i != null && i.width ? String(i.width) : r.defaultWidth;
                a = r.values[f] || r.values[u]
            }
            var p = r.argumentCallback ? r.argumentCallback(o) : o;
            return a[p]
        }
    }
    e.exports = t.default
})(Gke, Py);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(Py),
    o = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
    },
    i = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    },
    s = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    a = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    l = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        }
    },
    c = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        }
    },
    u = function (v, y) {
        var b = Number(v),
        w = b % 100;
        if (w > 20 || w < 10)
            switch (w % 10) {
            case 1:
                return b + "st";
            case 2:
                return b + "nd";
            case 3:
                return b + "rd"
            }
        return b + "th"
    },
    f = {
        ordinalNumber: u,
        era: (0, r.default)({
            values: o,
            defaultWidth: "wide"
        }),
        quarter: (0, r.default)({
            values: i,
            defaultWidth: "wide",
            argumentCallback: function (v) {
                return v - 1
            }
        }),
        month: (0, r.default)({
            values: s,
            defaultWidth: "wide"
        }),
        day: (0, r.default)({
            values: a,
            defaultWidth: "wide"
        }),
        dayPeriod: (0, r.default)({
            values: l,
            defaultWidth: "wide",
            formattingValues: c,
            defaultFormattingWidth: "wide"
        })
    },
    p = f;
    t.default = p,
    e.exports = t.default
})(Kke, My);
var Ey = {}, Xke = {
    get exports() {
        return Ey
    },
    set exports(e) {
        Ey = e
    }
}, Oy = {}, Jke = {
    get exports() {
        return Oy
    },
    set exports(e) {
        Oy = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(i) {
        return function (s) {
            var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            l = a.width,
            c = l && i.matchPatterns[l] || i.matchPatterns[i.defaultMatchWidth],
            u = s.match(c);
            if (!u)
                return null;
            var f = u[0],
            p = l && i.parsePatterns[l] || i.parsePatterns[i.defaultParseWidth],
            m = Array.isArray(p) ? o(p, function (b) {
                return b.test(f)
            }) : r(p, function (b) {
                return b.test(f)
            }),
            v;
            v = i.valueCallback ? i.valueCallback(m) : m,
            v = a.valueCallback ? a.valueCallback(v) : v;
            var y = s.slice(f.length);
            return {
                value: v,
                rest: y
            }
        }
    }
    function r(i, s) {
        for (var a in i)
            if (i.hasOwnProperty(a) && s(i[a]))
                return a
    }
    function o(i, s) {
        for (var a = 0; a < i.length; a++)
            if (s(i[a]))
                return a
    }
    e.exports = t.default
})(Jke, Oy);
var $y = {}, Zke = {
    get exports() {
        return $y
    },
    set exports(e) {
        $y = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r) {
        return function (o) {
            var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            s = o.match(r.matchPattern);
            if (!s)
                return null;
            var a = s[0],
            l = o.match(r.parsePattern);
            if (!l)
                return null;
            var c = r.valueCallback ? r.valueCallback(l[0]) : l[0];
            c = i.valueCallback ? i.valueCallback(c) : c;
            var u = o.slice(a.length);
            return {
                value: c,
                rest: u
            }
        }
    }
    e.exports = t.default
})(Zke, $y);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(Oy),
    o = n($y),
    i = /^(\d+)(th|st|nd|rd)?/i,
    s = /\d+/i,
    a = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
    },
    l = {
        any: [/^b/i, /^(a|c)/i]
    },
    c = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
    },
    u = {
        any: [/1/i, /2/i, /3/i, /4/i]
    },
    f = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    },
    p = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    },
    m = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    },
    v = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    },
    y = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    },
    b = {
        any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
        }
    },
    w = {
        ordinalNumber: (0, o.default)({
            matchPattern: i,
            parsePattern: s,
            valueCallback: function (x) {
                return parseInt(x, 10)
            }
        }),
        era: (0, r.default)({
            matchPatterns: a,
            defaultMatchWidth: "wide",
            parsePatterns: l,
            defaultParseWidth: "any"
        }),
        quarter: (0, r.default)({
            matchPatterns: c,
            defaultMatchWidth: "wide",
            parsePatterns: u,
            defaultParseWidth: "any",
            valueCallback: function (x) {
                return x + 1
            }
        }),
        month: (0, r.default)({
            matchPatterns: f,
            defaultMatchWidth: "wide",
            parsePatterns: p,
            defaultParseWidth: "any"
        }),
        day: (0, r.default)({
            matchPatterns: m,
            defaultMatchWidth: "wide",
            parsePatterns: v,
            defaultParseWidth: "any"
        }),
        dayPeriod: (0, r.default)({
            matchPatterns: y,
            defaultMatchWidth: "any",
            parsePatterns: b,
            defaultParseWidth: "any"
        })
    },
    k = w;
    t.default = k,
    e.exports = t.default
})(Xke, Ey);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(Sy),
    o = n(Cy),
    i = n(Ty),
    s = n(My),
    a = n(Ey),
    l = {
        code: "en-US",
        formatDistance: r.default,
        formatLong: o.default,
        formatRelative: i.default,
        localize: s.default,
        match: a.default,
        options: {
            weekStartsOn: 0,
            firstWeekContainsDate: 1
        }
    },
    c = l;
    t.default = c,
    e.exports = t.default
})(zke, xy);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = void 0;
    var r = n(xy),
    o = r.default;
    t.default = o,
    e.exports = t.default
})(Wke, ky);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = C;
    var r = n(cy),
    o = n(fy),
    i = n(Ti),
    s = n(py),
    a = n(_y),
    l = n(Tm),
    c = mg,
    u = n(ha),
    f = n(zr),
    p = ed,
    m = n(ky),
    v = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
    y = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
    b = /^'([^]*?)'?$/,
    w = /''/g,
    k = /[a-zA-Z]/;
    function C(S, T, E) {
        var M,
        N,
        F,
        K,
        j,
        G,
        Y,
        ue,
        re,
        de,
        Se,
        Pe,
        je,
        Ke,
        Ue,
        yt,
        at,
        le;
        (0, f.default)(2, arguments);
        var ye = String(T),
        ge = (0, p.getDefaultOptions)(),
        pe = (M = (N = E?.locale) !== null && N !== void 0 ? N : ge.locale) !== null && M !== void 0 ? M : m.default,
        xe = (0, u.default)((F = (K = (j = (G = E?.firstWeekContainsDate) !== null && G !== void 0 ? G : E == null || (Y = E.locale) === null || Y === void 0 || (ue = Y.options) === null || ue === void 0 ? void 0 : ue.firstWeekContainsDate) !== null && j !== void 0 ? j : ge.firstWeekContainsDate) !== null && K !== void 0 ? K : (re = ge.locale) === null || re === void 0 || (de = re.options) === null || de === void 0 ? void 0 : de.firstWeekContainsDate) !== null && F !== void 0 ? F : 1);
        if (!(xe >= 1 && xe <= 7))
            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        var et = (0, u.default)((Se = (Pe = (je = (Ke = E?.weekStartsOn) !== null && Ke !== void 0 ? Ke : E == null || (Ue = E.locale) === null || Ue === void 0 || (yt = Ue.options) === null || yt === void 0 ? void 0 : yt.weekStartsOn) !== null && je !== void 0 ? je : ge.weekStartsOn) !== null && Pe !== void 0 ? Pe : (at = ge.locale) === null || at === void 0 || (le = at.options) === null || le === void 0 ? void 0 : le.weekStartsOn) !== null && Se !== void 0 ? Se : 0);
        if (!(et >= 0 && et <= 6))
            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        if (!pe.localize)
            throw new RangeError("locale must contain localize property");
        if (!pe.formatLong)
            throw new RangeError("locale must contain formatLong property");
        var Xe = (0, i.default)(S);
        if (!(0, r.default)(Xe))
            throw new RangeError("Invalid time value");
        var W = (0, l.default)(Xe),
        R = (0, o.default)(Xe, W),
        X = {
            firstWeekContainsDate: xe,
            weekStartsOn: et,
            locale: pe,
            _originalDate: Xe
        },
        Q = ye.match(y).map(function (Z) {
            var fe = Z[0];
            if (fe === "p" || fe === "P") {
                var be = a.default[fe];
                return be(Z, pe.formatLong)
            }
            return Z
        }).join("").match(v).map(function (Z) {
            if (Z === "''")
                return "'";
            var fe = Z[0];
            if (fe === "'")
                return x(Z);
            var be = s.default[fe];
            if (be)
                return !(E != null && E.useAdditionalWeekYearTokens) && (0, c.isProtectedWeekYearToken)(Z) && (0, c.throwProtectedError)(Z, T, String(S)), !(E != null && E.useAdditionalDayOfYearTokens) && (0, c.isProtectedDayOfYearToken)(Z) && (0, c.throwProtectedError)(Z, T, String(S)), be(R, Z, pe.localize, X);
            if (fe.match(k))
                throw new RangeError("Format string contains an unescaped latin alphabet character `" + fe + "`");
            return Z
        }).join("");
        return Q
    }
    function x(S) {
        var T = S.match(b);
        return T ? T[1].replace(w, "'") : S
    }
    e.exports = t.default
})(uke, ly);
const Qke = og(ly);
function rA(e, t, n) {
    var r = nxe(e, n.timeZone, n.locale);
    return r.formatToParts ? exe(r, t) : txe(r, t)
}
function exe(e, t) {
    for (var n = e.formatToParts(t), r = n.length - 1; r >= 0; --r)
        if (n[r].type === "timeZoneName")
            return n[r].value
}
function txe(e, t) {
    var n = e.format(t).replace(/\u200E/g, ""),
    r = / [\w-+ ]+$/.exec(n);
    return r ? r[0].substr(1) : ""
}
function nxe(e, t, n) {
    if (n && !n.code)
        throw new Error("date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`");
    return new Intl.DateTimeFormat(n ? [n.code, "en-US"] : void 0, {
        timeZone: t,
        timeZoneName: e
    })
}
function rxe(e, t) {
    var n = axe(t);
    return n.formatToParts ? ixe(n, e) : sxe(n, e)
}
var oxe = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
};
function ixe(e, t) {
    try {
        for (var n = e.formatToParts(t), r = [], o = 0; o < n.length; o++) {
            var i = oxe[n[o].type];
            i >= 0 && (r[i] = parseInt(n[o].value, 10))
        }
        return r
    } catch (s) {
        if (s instanceof RangeError)
            return [NaN];
        throw s
    }
}
function sxe(e, t) {
    var n = e.format(t).replace(/\u200E/g, ""),
    r = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(n);
    return [r[3], r[1], r[2], r[4], r[5], r[6]]
}
var r2 = {};
function axe(e) {
    if (!r2[e]) {
        var t = new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: "America/New_York",
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }).format(new Date("2014-06-25T04:00:00.123Z")),
        n = t === "06/25/2014, 00:00:00" || t === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
        r2[e] = n ? new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: e,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }) : new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone: e,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        })
    }
    return r2[e]
}
function SI(e, t, n, r, o, i, s) {
    var a = new Date(0);
    return a.setUTCFullYear(e, t, n),
    a.setUTCHours(r, o, i, s),
    a
}
var oA = 36e5, lxe = 6e4, o2 = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function Mw(e, t, n) {
    var r,
    o;
    if (!e || (r = o2.timezoneZ.exec(e), r))
        return 0;
    var i;
    if (r = o2.timezoneHH.exec(e), r)
        return i = parseInt(r[1], 10), iA(i) ?  - (i * oA) : NaN;
    if (r = o2.timezoneHHMM.exec(e), r) {
        i = parseInt(r[1], 10);
        var s = parseInt(r[2], 10);
        return iA(i, s) ? (o = Math.abs(i) * oA + s * lxe, i > 0 ? -o : o) : NaN
    }
    if (dxe(e)) {
        t = new Date(t || Date.now());
        var a = n ? t : cxe(t),
        l = Tx(a, e),
        c = n ? l : uxe(t, l, e);
        return -c
    }
    return NaN
}
function cxe(e) {
    return SI(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())
}
function Tx(e, t) {
    var n = rxe(e, t),
    r = SI(n[0], n[1] - 1, n[2], n[3] % 24, n[4], n[5], 0).getTime(),
    o = e.getTime(),
    i = o % 1e3;
    return o -= i >= 0 ? i : 1e3 + i,
    r - o
}
function uxe(e, t, n) {
    var r = e.getTime(),
    o = r - t,
    i = Tx(new Date(o), n);
    if (t === i)
        return t;
    o -= i - t;
    var s = Tx(new Date(o), n);
    return i === s ? i : Math.max(i, s)
}
function iA(e, t) {
    return -23 <= e && e <= 23 && (t == null || 0 <= t && t <= 59)
}
var sA = {};
function dxe(e) {
    if (sA[e])
        return !0;
    try {
        return new Intl.DateTimeFormat(void 0, {
            timeZone: e
        }),
        sA[e] = !0,
        !0
    } catch {
        return !1
    }
}
var fxe = 60 * 1e3, hxe = {
    X: function (e, t, n, r) {
        var o = i2(r.timeZone, r._originalDate || e);
        if (o === 0)
            return "Z";
        switch (t) {
        case "X":
            return aA(o);
        case "XXXX":
        case "XX":
            return Dd(o);
        case "XXXXX":
        case "XXX":
        default:
            return Dd(o, ":")
        }
    },
    x: function (e, t, n, r) {
        var o = i2(r.timeZone, r._originalDate || e);
        switch (t) {
        case "x":
            return aA(o);
        case "xxxx":
        case "xx":
            return Dd(o);
        case "xxxxx":
        case "xxx":
        default:
            return Dd(o, ":")
        }
    },
    O: function (e, t, n, r) {
        var o = i2(r.timeZone, r._originalDate || e);
        switch (t) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + pxe(o, ":");
        case "OOOO":
        default:
            return "GMT" + Dd(o, ":")
        }
    },
    z: function (e, t, n, r) {
        var o = r._originalDate || e;
        switch (t) {
        case "z":
        case "zz":
        case "zzz":
            return rA("short", o, r);
        case "zzzz":
        default:
            return rA("long", o, r)
        }
    }
};
function i2(e, t) {
    var n = e ? Mw(e, t, !0) / fxe : t.getTimezoneOffset();
    if (Number.isNaN(n))
        throw new RangeError("Invalid time zone specified: " + e);
    return n
}
function Ay(e, t) {
    for (var n = e < 0 ? "-" : "", r = Math.abs(e).toString(); r.length < t; )
        r = "0" + r;
    return n + r
}
function Dd(e, t) {
    var n = t || "",
    r = e > 0 ? "-" : "+",
    o = Math.abs(e),
    i = Ay(Math.floor(o / 60), 2),
    s = Ay(Math.floor(o % 60), 2);
    return r + i + n + s
}
function aA(e, t) {
    if (e % 60 === 0) {
        var n = e > 0 ? "-" : "+";
        return n + Ay(Math.abs(e) / 60, 2)
    }
    return Dd(e, t)
}
function pxe(e, t) {
    var n = e > 0 ? "-" : "+",
    r = Math.abs(e),
    o = Math.floor(r / 60),
    i = r % 60;
    if (i === 0)
        return n + String(o);
    var s = t || "";
    return n + String(o) + s + Ay(i, 2)
}
const mxe = hxe;
var gxe = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
const Z7 = gxe;
var s2 = 36e5, lA = 6e4, vxe = 2, Io = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    YY: /^(\d{2})$/,
    YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
    YYYY: /^(\d{4})/,
    YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    timeZone: Z7
};
function Dy(e, t) {
    if (arguments.length < 1)
        throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if (e === null)
        return new Date(NaN);
    var n = t || {},
    r = n.additionalDigits == null ? vxe : bke(n.additionalDigits);
    if (r !== 2 && r !== 1 && r !== 0)
        throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
        return new Date(e.getTime());
    if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
        return new Date(e);
    if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
        return new Date(NaN);
    var o = yxe(e),
    i = wxe(o.date, r),
    s = i.year,
    a = i.restDateString,
    l = bxe(a, s);
    if (isNaN(l))
        return new Date(NaN);
    if (l) {
        var c = l.getTime(),
        u = 0,
        f;
        if (o.time && (u = _xe(o.time), isNaN(u)))
            return new Date(NaN);
        if (o.timeZone || n.timeZone) {
            if (f = Mw(o.timeZone || n.timeZone, new Date(c + u)), isNaN(f))
                return new Date(NaN)
        } else
            f = nA(new Date(c + u)), f = nA(new Date(c + u + f));
        return new Date(c + u + f)
    } else
        return new Date(NaN)
}
function yxe(e) {
    var t = {},
    n = Io.dateTimePattern.exec(e),
    r;
    if (n ? (t.date = n[1], r = n[3]) : (n = Io.datePattern.exec(e), n ? (t.date = n[1], r = n[2]) : (t.date = null, r = e)), r) {
        var o = Io.timeZone.exec(r);
        o ? (t.time = r.replace(o[1], ""), t.timeZone = o[1].trim()) : t.time = r
    }
    return t
}
function wxe(e, t) {
    var n = Io.YYY[t],
    r = Io.YYYYY[t],
    o;
    if (o = Io.YYYY.exec(e) || r.exec(e), o) {
        var i = o[1];
        return {
            year: parseInt(i, 10),
            restDateString: e.slice(i.length)
        }
    }
    if (o = Io.YY.exec(e) || n.exec(e), o) {
        var s = o[1];
        return {
            year: parseInt(s, 10) * 100,
            restDateString: e.slice(s.length)
        }
    }
    return {
        year: null
    }
}
function bxe(e, t) {
    if (t === null)
        return null;
    var n,
    r,
    o,
    i;
    if (e.length === 0)
        return r = new Date(0), r.setUTCFullYear(t), r;
    if (n = Io.MM.exec(e), n)
        return r = new Date(0), o = parseInt(n[1], 10) - 1, uA(t, o) ? (r.setUTCFullYear(t, o), r) : new Date(NaN);
    if (n = Io.DDD.exec(e), n) {
        r = new Date(0);
        var s = parseInt(n[1], 10);
        return Sxe(t, s) ? (r.setUTCFullYear(t, 0, s), r) : new Date(NaN)
    }
    if (n = Io.MMDD.exec(e), n) {
        r = new Date(0),
        o = parseInt(n[1], 10) - 1;
        var a = parseInt(n[2], 10);
        return uA(t, o, a) ? (r.setUTCFullYear(t, o, a), r) : new Date(NaN)
    }
    if (n = Io.Www.exec(e), n)
        return i = parseInt(n[1], 10) - 1, dA(t, i) ? cA(t, i) : new Date(NaN);
    if (n = Io.WwwD.exec(e), n) {
        i = parseInt(n[1], 10) - 1;
        var l = parseInt(n[2], 10) - 1;
        return dA(t, i, l) ? cA(t, i, l) : new Date(NaN)
    }
    return null
}
function _xe(e) {
    var t,
    n,
    r;
    if (t = Io.HH.exec(e), t)
        return n = parseFloat(t[1].replace(",", ".")), a2(n) ? n % 24 * s2 : NaN;
    if (t = Io.HHMM.exec(e), t)
        return n = parseInt(t[1], 10), r = parseFloat(t[2].replace(",", ".")), a2(n, r) ? n % 24 * s2 + r * lA : NaN;
    if (t = Io.HHMMSS.exec(e), t) {
        n = parseInt(t[1], 10),
        r = parseInt(t[2], 10);
        var o = parseFloat(t[3].replace(",", "."));
        return a2(n, r, o) ? n % 24 * s2 + r * lA + o * 1e3 : NaN
    }
    return null
}
function cA(e, t, n) {
    t = t || 0,
    n = n || 0;
    var r = new Date(0);
    r.setUTCFullYear(e, 0, 4);
    var o = r.getUTCDay() || 7,
    i = t * 7 + n + 1 - o;
    return r.setUTCDate(r.getUTCDate() + i),
    r
}
var kxe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], xxe = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Q7(e) {
    return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
function uA(e, t, n) {
    if (t < 0 || t > 11)
        return !1;
    if (n != null) {
        if (n < 1)
            return !1;
        var r = Q7(e);
        if (r && n > xxe[t] || !r && n > kxe[t])
            return !1
    }
    return !0
}
function Sxe(e, t) {
    if (t < 1)
        return !1;
    var n = Q7(e);
    return !(n && t > 366 || !n && t > 365)
}
function dA(e, t, n) {
    return !(t < 0 || t > 52 || n != null && (n < 0 || n > 6))
}
function a2(e, t, n) {
    return !(e != null && (e < 0 || e >= 25) || t != null && (t < 0 || t >= 60) || n != null && (n < 0 || n >= 60))
}
var Cxe = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
function f0(e, t, n) {
    var r = String(t),
    o = n || {},
    i = r.match(Cxe);
    if (i) {
        var s = Dy(e, o);
        r = i.reduce(function (a, l) {
            if (l[0] === "'")
                return a;
            var c = a.indexOf(l),
            u = a[c - 1] === "'",
            f = a.replace(l, "'" + mxe[l[0]](s, l, null, o) + "'");
            return u ? f.substring(0, c - 1) + f.substring(c + 1) : f
        }, r)
    }
    return Qke(e, r, o)
}
var Ny = {}, Ixe = {
    get exports() {
        return Ny
    },
    set exports(e) {
        Ny = e
    }
}, Ry = {}, Txe = {
    get exports() {
        return Ry
    },
    set exports(e) {
        Ry = e
    }
};
(function (e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n;
    function n(r, o) {
        if (r == null)
            throw new TypeError("assign requires that input parameter not be null or undefined");
        for (var i in o)
            Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
        return r
    }
    e.exports = t.default
})(Txe, Ry);
(function (e, t) {
    var n = Un.default;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = o;
    var r = n(Ry);
    function o(i) {
        return (0, r.default)({}, i)
    }
    e.exports = t.default
})(Ixe, Ny);
const Mxe = og(Ny);
function eV(e, t, n) {
    var r = Dy(e, n),
    o = Mw(t, r, !0),
    i = new Date(r.getTime() - o),
    s = new Date(0);
    return s.setFullYear(i.getUTCFullYear(), i.getUTCMonth(), i.getUTCDate()),
    s.setHours(i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds()),
    s
}
function Nd(e, t, n) {
    if (typeof e == "string" && !e.match(Z7)) {
        var r = Mxe(n);
        return r.timeZone = t,
        Dy(e, r)
    }
    var o = Dy(e, n),
    i = SI(o.getFullYear(), o.getMonth(), o.getDate(), o.getHours(), o.getMinutes(), o.getSeconds(), o.getMilliseconds()).getTime(),
    s = Mw(t, new Date(i));
    return new Date(i + s)
}
function Mm(e) {
    var t = e.getBoundingClientRect();
    return {
        width: t.width,
        height: t.height,
        top: t.top,
        right: t.right,
        bottom: t.bottom,
        left: t.left,
        x: t.left,
        y: t.top
    }
}
function ds(e) {
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t ? t.defaultView : window
    }
    return e
}
function CI(e) {
    var t = ds(e),
    n = t.pageXOffset,
    r = t.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}
function Pm(e) {
    var t = ds(e).Element;
    return e instanceof t || e instanceof Element
}
function _a(e) {
    var t = ds(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}
function Pxe(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}
function Exe(e) {
    return e === ds(e) || !_a(e) ? CI(e) : Pxe(e)
}
function il(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function gc(e) {
    return (Pm(e) ? e.ownerDocument : e.document).documentElement
}
function tV(e) {
    return Mm(gc(e)).left + CI(e).scrollLeft
}
function gg(e) {
    return ds(e).getComputedStyle(e)
}
function II(e) {
    var t = gg(e),
    n = t.overflow,
    r = t.overflowX,
    o = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + o + r)
}
function nV(e, t, n) {
    n === void 0 && (n = !1);
    var r = gc(t),
    o = Mm(e),
    i = {
        scrollLeft: 0,
        scrollTop: 0
    },
    s = {
        x: 0,
        y: 0
    };
    return n || ((il(t) !== "body" || II(r)) && (i = Exe(t)), _a(t) ? (s = Mm(t), s.x += t.clientLeft, s.y += t.clientTop) : r && (s.x = tV(r))), {
        x: o.left + i.scrollLeft - s.x,
        y: o.top + i.scrollTop - s.y,
        width: o.width,
        height: o.height
    }
}
function TI(e) {
    return {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: e.offsetWidth,
        height: e.offsetHeight
    }
}
function rV(e) {
    return il(e) === "html" ? e : e.assignedSlot || e.parentNode || e.host || gc(e)
}
function oV(e) {
    return ["html", "body", "#document"].indexOf(il(e)) >= 0 ? e.ownerDocument.body : _a(e) && II(e) ? e : oV(rV(e))
}
function Np(e, t) {
    t === void 0 && (t = []);
    var n = oV(e),
    r = il(n) === "body",
    o = ds(n),
    i = r ? [o].concat(o.visualViewport || [], II(n) ? n : []) : n,
    s = t.concat(i);
    return r ? s : s.concat(Np(rV(i)))
}
function Oxe(e) {
    return ["table", "td", "th"].indexOf(il(e)) >= 0
}
function fA(e) {
    return !_a(e) || gg(e).position === "fixed" ? null : e.offsetParent
}
function vg(e) {
    for (var t = ds(e), n = fA(e); n && Oxe(n); )
        n = fA(n);
    return n && il(n) === "body" && gg(n).position === "static" ? t : n || t
}
var ns = "top", $s = "bottom", As = "right", rs = "left", MI = "auto", yg = [ns, $s, As, rs], Of = "start", PI = "end", $xe = "clippingParents", iV = "viewport", Jh = "popper", Axe = "reference", hA = yg.reduce(function (e, t) {
    return e.concat([t + "-" + Of, t + "-" + PI])
}, []), sV = [].concat(yg, [MI]).reduce(function (e, t) {
    return e.concat([t, t + "-" + Of, t + "-" + PI])
}, []), Dxe = "beforeRead", Nxe = "read", Rxe = "afterRead", Lxe = "beforeMain", Bxe = "main", Vxe = "afterMain", Fxe = "beforeWrite", jxe = "write", Wxe = "afterWrite", zxe = [Dxe, Nxe, Rxe, Lxe, Bxe, Vxe, Fxe, jxe, Wxe];
function Hxe(e) {
    var t = new Map,
    n = new Set,
    r = [];
    e.forEach(function (i) {
        t.set(i.name, i)
    });
    function o(i) {
        n.add(i.name);
        var s = [].concat(i.requires || [], i.requiresIfExists || []);
        s.forEach(function (a) {
            if (!n.has(a)) {
                var l = t.get(a);
                l && o(l)
            }
        }),
        r.push(i)
    }
    return e.forEach(function (i) {
        n.has(i.name) || o(i)
    }),
    r
}
function Uxe(e) {
    var t = Hxe(e);
    return zxe.reduce(function (n, r) {
        return n.concat(t.filter(function (o) {
                return o.phase === r
            }))
    }, [])
}
function qxe(e) {
    var t;
    return function () {
        return t || (t = new Promise(function (n) {
                Promise.resolve().then(function () {
                    t = void 0,
                    n(e())
                })
            })),
        t
    }
}
function sa(e) {
    return e.split("-")[0]
}
function Yxe(e) {
    var t = e.reduce(function (n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, {}, r, {
            options: Object.assign({}, o.options, {}, r.options),
            data: Object.assign({}, o.data, {}, r.data)
        }) : r,
        n
    }, {});
    return Object.keys(t).map(function (n) {
        return t[n]
    })
}
var pA = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function mA() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return !t.some(function (r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}
function Kxe(e) {
    e === void 0 && (e = {});
    var t = e,
    n = t.defaultModifiers,
    r = n === void 0 ? [] : n,
    o = t.defaultOptions,
    i = o === void 0 ? pA : o;
    return function (a, l, c) {
        c === void 0 && (c = i);
        var u = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, pA, {}, i),
            modifiersData: {},
            elements: {
                reference: a,
                popper: l
            },
            attributes: {},
            styles: {}
        },
        f = [],
        p = !1,
        m = {
            state: u,
            setOptions: function (w) {
                y(),
                u.options = Object.assign({}, i, {}, u.options, {}, w),
                u.scrollParents = {
                    reference: Pm(a) ? Np(a) : a.contextElement ? Np(a.contextElement) : [],
                    popper: Np(l)
                };
                var k = Uxe(Yxe([].concat(r, u.options.modifiers)));
                return u.orderedModifiers = k.filter(function (C) {
                    return C.enabled
                }),
                v(),
                m.update()
            },
            forceUpdate: function () {
                if (!p) {
                    var w = u.elements,
                    k = w.reference,
                    C = w.popper;
                    if (mA(k, C)) {
                        u.rects = {
                            reference: nV(k, vg(C), u.options.strategy === "fixed"),
                            popper: TI(C)
                        },
                        u.reset = !1,
                        u.placement = u.options.placement,
                        u.orderedModifiers.forEach(function (F) {
                            return u.modifiersData[F.name] = Object.assign({}, F.data)
                        });
                        for (var x = 0; x < u.orderedModifiers.length; x++) {
                            if (u.reset === !0) {
                                u.reset = !1,
                                x = -1;
                                continue
                            }
                            var S = u.orderedModifiers[x],
                            T = S.fn,
                            E = S.options,
                            M = E === void 0 ? {}
                             : E,
                            N = S.name;
                            typeof T == "function" && (u = T({
                                    state: u,
                                    options: M,
                                    name: N,
                                    instance: m
                                }) || u)
                        }
                    }
                }
            },
            update: qxe(function () {
                return new Promise(function (b) {
                    m.forceUpdate(),
                    b(u)
                })
            }),
            destroy: function () {
                y(),
                p = !0
            }
        };
        if (!mA(a, l))
            return m;
        m.setOptions(c).then(function (b) {
            !p && c.onFirstUpdate && c.onFirstUpdate(b)
        });
        function v() {
            u.orderedModifiers.forEach(function (b) {
                var w = b.name,
                k = b.options,
                C = k === void 0 ? {}
                 : k,
                x = b.effect;
                if (typeof x == "function") {
                    var S = x({
                        state: u,
                        name: w,
                        instance: m,
                        options: C
                    }),
                    T = function () {};
                    f.push(S || T)
                }
            })
        }
        function y() {
            f.forEach(function (b) {
                return b()
            }),
            f = []
        }
        return m
    }
}
var Ev = {
    passive: !0
};
function Gxe(e) {
    var t = e.state,
    n = e.instance,
    r = e.options,
    o = r.scroll,
    i = o === void 0 ? !0 : o,
    s = r.resize,
    a = s === void 0 ? !0 : s,
    l = ds(t.elements.popper),
    c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return i && c.forEach(function (u) {
        u.addEventListener("scroll", n.update, Ev)
    }),
    a && l.addEventListener("resize", n.update, Ev),
    function () {
        i && c.forEach(function (u) {
            u.removeEventListener("scroll", n.update, Ev)
        }),
        a && l.removeEventListener("resize", n.update, Ev)
    }
}
const Xxe = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: Gxe,
    data: {}
};
function Em(e) {
    return e.split("-")[1]
}
function EI(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function aV(e) {
    var t = e.reference,
    n = e.element,
    r = e.placement,
    o = r ? sa(r) : null,
    i = r ? Em(r) : null,
    s = t.x + t.width / 2 - n.width / 2,
    a = t.y + t.height / 2 - n.height / 2,
    l;
    switch (o) {
    case ns:
        l = {
            x: s,
            y: t.y - n.height
        };
        break;
    case $s:
        l = {
            x: s,
            y: t.y + t.height
        };
        break;
    case As:
        l = {
            x: t.x + t.width,
            y: a
        };
        break;
    case rs:
        l = {
            x: t.x - n.width,
            y: a
        };
        break;
    default:
        l = {
            x: t.x,
            y: t.y
        }
    }
    var c = o ? EI(o) : null;
    if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (i) {
        case Of:
            l[c] = Math.floor(l[c]) - Math.floor(t[u] / 2 - n[u] / 2);
            break;
        case PI:
            l[c] = Math.floor(l[c]) + Math.ceil(t[u] / 2 - n[u] / 2);
            break
        }
    }
    return l
}
function Jxe(e) {
    var t = e.state,
    n = e.name;
    t.modifiersData[n] = aV({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
    })
}
const Zxe = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: Jxe,
    data: {}
};
var Qxe = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function eSe(e) {
    var t = e.x,
    n = e.y,
    r = window,
    o = r.devicePixelRatio || 1;
    return {
        x: Math.round(t * o) / o || 0,
        y: Math.round(n * o) / o || 0
    }
}
function gA(e) {
    var t,
    n = e.popper,
    r = e.popperRect,
    o = e.placement,
    i = e.offsets,
    s = e.position,
    a = e.gpuAcceleration,
    l = e.adaptive,
    c = eSe(i),
    u = c.x,
    f = c.y,
    p = i.hasOwnProperty("x"),
    m = i.hasOwnProperty("y"),
    v = rs,
    y = ns,
    b = window;
    if (l) {
        var w = vg(n);
        w === ds(n) && (w = gc(n)),
        o === ns && (y = $s, f -= w.clientHeight - r.height, f *= a ? 1 : -1),
        o === rs && (v = As, u -= w.clientWidth - r.width, u *= a ? 1 : -1)
    }
    var k = Object.assign({
        position: s
    }, l && Qxe);
    if (a) {
        var C;
        return Object.assign({}, k, (C = {}, C[y] = m ? "0" : "", C[v] = p ? "0" : "", C.transform = (b.devicePixelRatio || 1) < 2 ? "translate(" + u + "px, " + f + "px)" : "translate3d(" + u + "px, " + f + "px, 0)", C))
    }
    return Object.assign({}, k, (t = {}, t[y] = m ? f + "px" : "", t[v] = p ? u + "px" : "", t.transform = "", t))
}
function tSe(e) {
    var t = e.state,
    n = e.options,
    r = n.gpuAcceleration,
    o = r === void 0 ? !0 : r,
    i = n.adaptive,
    s = i === void 0 ? !0 : i,
    a = {
        placement: sa(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: o
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, {}, gA(Object.assign({}, a, {
                        offsets: t.modifiersData.popperOffsets,
                        position: t.options.strategy,
                        adaptive: s
                    })))),
    t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, {}, gA(Object.assign({}, a, {
                        offsets: t.modifiersData.arrow,
                        position: "absolute",
                        adaptive: !1
                    })))),
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
const nSe = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: tSe,
    data: {}
};
function rSe(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function (n) {
        var r = t.styles[n] || {},
        o = t.attributes[n] || {},
        i = t.elements[n];
        !_a(i) || !il(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function (s) {
                var a = o[s];
                a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a)
            }))
    })
}
function oSe(e) {
    var t = e.state,
    n = {
        popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(t.elements.popper.style, n.popper),
    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
    function () {
        Object.keys(t.elements).forEach(function (r) {
            var o = t.elements[r],
            i = t.attributes[r] || {},
            s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]),
            a = s.reduce(function (l, c) {
                return l[c] = "",
                l
            }, {});
            !_a(o) || !il(o) || (Object.assign(o.style, a), Object.keys(i).forEach(function (l) {
                    o.removeAttribute(l)
                }))
        })
    }
}
const iSe = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: rSe,
    effect: oSe,
    requires: ["computeStyles"]
};
function sSe(e, t, n) {
    var r = sa(e),
    o = [rs, ns].indexOf(r) >= 0 ? -1 : 1,
    i = typeof n == "function" ? n(Object.assign({}, t, {
                placement: e
            })) : n,
    s = i[0],
    a = i[1];
    return s = s || 0,
    a = (a || 0) * o,
    [rs, As].indexOf(r) >= 0 ? {
        x: a,
        y: s
    }
     : {
        x: s,
        y: a
    }
}
function aSe(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.offset,
    i = o === void 0 ? [0, 0] : o,
    s = sV.reduce(function (u, f) {
        return u[f] = sSe(f, t.rects, i),
        u
    }, {}),
    a = s[t.placement],
    l = a.x,
    c = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c),
    t.modifiersData[r] = s
}
const lSe = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: aSe
};
var cSe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function h0(e) {
    return e.replace(/left|right|bottom|top/g, function (t) {
        return cSe[t]
    })
}
var uSe = {
    start: "end",
    end: "start"
};
function vA(e) {
    return e.replace(/start|end/g, function (t) {
        return uSe[t]
    })
}
function dSe(e) {
    var t = ds(e),
    n = t.visualViewport,
    r = t.innerWidth,
    o = t.innerHeight;
    return n && /iPhone|iPod|iPad/.test(navigator.platform) && (r = n.width, o = n.height), {
        width: r,
        height: o,
        x: 0,
        y: 0
    }
}
function fSe(e) {
    var t = ds(e),
    n = CI(e),
    r = nV(gc(e), t);
    return r.height = Math.max(r.height, t.innerHeight),
    r.width = Math.max(r.width, t.innerWidth),
    r.x = -n.scrollLeft,
    r.y = -n.scrollTop,
    r
}
function Ov(e) {
    return parseFloat(e) || 0
}
function hSe(e) {
    var t = _a(e) ? gg(e) : {};
    return {
        top: Ov(t.borderTopWidth),
        right: Ov(t.borderRightWidth),
        bottom: Ov(t.borderBottomWidth),
        left: Ov(t.borderLeftWidth)
    }
}
function pSe(e) {
    var t = ds(e),
    n = hSe(e),
    r = il(e) === "html",
    o = tV(e),
    i = e.clientWidth + n.right,
    s = e.clientHeight + n.bottom;
    return r && t.innerHeight - e.clientHeight > 50 && (s = t.innerHeight - n.bottom), {
        top: r ? 0 : e.clientTop,
        right: e.clientLeft > n.left ? n.right : r ? t.innerWidth - i - o : e.offsetWidth - i,
        bottom: r ? t.innerHeight - s : e.offsetHeight - s,
        left: r ? o : e.clientLeft
    }
}
function lV(e, t) {
    var n = Boolean(t.getRootNode && t.getRootNode().host);
    if (e.contains(t))
        return !0;
    if (n) {
        var r = t;
        do {
            if (r && e.isSameNode(r))
                return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}
function Mx(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}
function yA(e, t) {
    return t === iV ? Mx(dSe(e)) : _a(t) ? Mm(t) : Mx(fSe(gc(e)))
}
function mSe(e) {
    var t = Np(e),
    n = ["absolute", "fixed"].indexOf(gg(e).position) >= 0,
    r = n && _a(e) ? vg(e) : e;
    return Pm(r) ? t.filter(function (o) {
        return Pm(o) && lV(o, r)
    }) : []
}
function gSe(e, t, n) {
    var r = t === "clippingParents" ? mSe(e) : [].concat(t),
    o = [].concat(r, [n]),
    i = o[0],
    s = o.reduce(function (a, l) {
        var c = yA(e, l),
        u = pSe(_a(l) ? l : gc(e));
        return a.top = Math.max(c.top + u.top, a.top),
        a.right = Math.min(c.right - u.right, a.right),
        a.bottom = Math.min(c.bottom - u.bottom, a.bottom),
        a.left = Math.max(c.left + u.left, a.left),
        a
    }, yA(e, i));
    return s.width = s.right - s.left,
    s.height = s.bottom - s.top,
    s.x = s.left,
    s.y = s.top,
    s
}
function cV() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function uV(e) {
    return Object.assign({}, cV(), {}, e)
}
function dV(e, t) {
    return t.reduce(function (n, r) {
        return n[r] = e,
        n
    }, {})
}
function Om(e, t) {
    t === void 0 && (t = {});
    var n = t,
    r = n.placement,
    o = r === void 0 ? e.placement : r,
    i = n.boundary,
    s = i === void 0 ? $xe : i,
    a = n.rootBoundary,
    l = a === void 0 ? iV : a,
    c = n.elementContext,
    u = c === void 0 ? Jh : c,
    f = n.altBoundary,
    p = f === void 0 ? !1 : f,
    m = n.padding,
    v = m === void 0 ? 0 : m,
    y = uV(typeof v != "number" ? v : dV(v, yg)),
    b = u === Jh ? Axe : Jh,
    w = e.elements.reference,
    k = e.rects.popper,
    C = e.elements[p ? b : u],
    x = gSe(Pm(C) ? C : C.contextElement || gc(e.elements.popper), s, l),
    S = Mm(w),
    T = aV({
        reference: S,
        element: k,
        strategy: "absolute",
        placement: o
    }),
    E = Mx(Object.assign({}, k, {}, T)),
    M = u === Jh ? E : S,
    N = {
        top: x.top - M.top + y.top,
        bottom: M.bottom - x.bottom + y.bottom,
        left: x.left - M.left + y.left,
        right: M.right - x.right + y.right
    },
    F = e.modifiersData.offset;
    if (u === Jh && F) {
        var K = F[o];
        Object.keys(N).forEach(function (j) {
            var G = [As, $s].indexOf(j) >= 0 ? 1 : -1,
            Y = [ns, $s].indexOf(j) >= 0 ? "y" : "x";
            N[j] += K[Y] * G
        })
    }
    return N
}
function vSe(e, t) {
    t === void 0 && (t = {});
    var n = t,
    r = n.placement,
    o = n.boundary,
    i = n.rootBoundary,
    s = n.padding,
    a = n.flipVariations,
    l = n.allowedAutoPlacements,
    c = l === void 0 ? sV : l,
    u = Em(r),
    f = (u ? a ? hA : hA.filter(function (m) {
            return Em(m) === u
        }) : yg).filter(function (m) {
        return c.indexOf(m) >= 0
    }),
    p = f.reduce(function (m, v) {
        return m[v] = Om(e, {
            placement: v,
            boundary: o,
            rootBoundary: i,
            padding: s
        })[sa(v)],
        m
    }, {});
    return Object.keys(p).sort(function (m, v) {
        return p[m] - p[v]
    })
}
function ySe(e) {
    if (sa(e) === MI)
        return [];
    var t = h0(e);
    return [vA(e), t, vA(t)]
}
function wSe(e) {
    var t = e.state,
    n = e.options,
    r = e.name;
    if (!t.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, f = n.rootBoundary, p = n.altBoundary, m = n.flipVariations, v = m === void 0 ? !0 : m, y = n.allowedAutoPlacements, b = t.options.placement, w = sa(b), k = w === b, C = l || (k || !v ? [h0(b)] : ySe(b)), x = [b].concat(C).reduce(function (at, le) {
                return at.concat(sa(le) === MI ? vSe(t, {
                        placement: le,
                        boundary: u,
                        rootBoundary: f,
                        padding: c,
                        flipVariations: v,
                        allowedAutoPlacements: y
                    }) : le)
            }, []), S = t.rects.reference, T = t.rects.popper, E = new Map, M = !0, N = x[0], F = 0; F < x.length; F++) {
            var K = x[F],
            j = sa(K),
            G = Em(K) === Of,
            Y = [ns, $s].indexOf(j) >= 0,
            ue = Y ? "width" : "height",
            re = Om(t, {
                placement: K,
                boundary: u,
                rootBoundary: f,
                altBoundary: p,
                padding: c
            }),
            de = Y ? G ? As : rs : G ? $s : ns;
            S[ue] > T[ue] && (de = h0(de));
            var Se = h0(de),
            Pe = [];
            if (i && Pe.push(re[j] <= 0), a && Pe.push(re[de] <= 0, re[Se] <= 0), Pe.every(function (at) {
                    return at
                })) {
                N = K,
                M = !1;
                break
            }
            E.set(K, Pe)
        }
        if (M)
            for (var je = v ? 3 : 1, Ke = function (le) {
                var ye = x.find(function (ge) {
                    var pe = E.get(ge);
                    if (pe)
                        return pe.slice(0, le)
                            .every(function (xe) {
                                return xe
                            })
                    });
                if (ye)
                    return N = ye, "break"
            }, Ue = je; Ue > 0; Ue--) {
                var yt = Ke(Ue);
                if (yt === "break")
                    break
            }
    t.placement !== N && (t.modifiersData[r]._skip = !0, t.placement = N, t.reset = !0)
}
}
const bSe = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: wSe,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function _Se(e) {
    return e === "x" ? "y" : "x"
}
function p0(e, t, n) {
    return Math.max(e, Math.min(t, n))
}
function kSe(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.mainAxis,
    i = o === void 0 ? !0 : o,
    s = n.altAxis,
    a = s === void 0 ? !1 : s,
    l = n.boundary,
    c = n.rootBoundary,
    u = n.altBoundary,
    f = n.padding,
    p = n.tether,
    m = p === void 0 ? !0 : p,
    v = n.tetherOffset,
    y = v === void 0 ? 0 : v,
    b = Om(t, {
        boundary: l,
        rootBoundary: c,
        padding: f,
        altBoundary: u
    }),
    w = sa(t.placement),
    k = Em(t.placement),
    C = !k,
    x = EI(w),
    S = _Se(x),
    T = t.modifiersData.popperOffsets,
    E = t.rects.reference,
    M = t.rects.popper,
    N = typeof y == "function" ? y(Object.assign({}, t.rects, {
                placement: t.placement
            })) : y,
    F = {
        x: 0,
        y: 0
    };
    if (T) {
        if (i) {
            var K = x === "y" ? ns : rs,
            j = x === "y" ? $s : As,
            G = x === "y" ? "height" : "width",
            Y = T[x],
            ue = T[x] + b[K],
            re = T[x] - b[j],
            de = m ? -M[G] / 2 : 0,
            Se = k === Of ? E[G] : M[G],
            Pe = k === Of ? -M[G] : -E[G],
            je = t.elements.arrow,
            Ke = m && je ? TI(je) : {
                width: 0,
                height: 0
            },
            Ue = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : cV(),
            yt = Ue[K],
            at = Ue[j],
            le = p0(0, E[G], Ke[G]),
            ye = C ? E[G] / 2 - de - le - yt - N : Se - le - yt - N,
            ge = C ? -E[G] / 2 + de + le + at + N : Pe + le + at + N,
            pe = t.elements.arrow && vg(t.elements.arrow),
            xe = pe ? x === "y" ? pe.clientTop || 0 : pe.clientLeft || 0 : 0,
            et = t.modifiersData.offset ? t.modifiersData.offset[t.placement][x] : 0,
            Xe = T[x] + ye - et - xe,
            W = T[x] + ge - et,
            R = p0(m ? Math.min(ue, Xe) : ue, Y, m ? Math.max(re, W) : re);
            T[x] = R,
            F[x] = R - Y
        }
        if (a) {
            var X = x === "x" ? ns : rs,
            Q = x === "x" ? $s : As,
            Z = T[S],
            fe = Z + b[X],
            be = Z - b[Q],
            Ee = p0(fe, Z, be);
            T[S] = Ee,
            F[S] = Ee - Z
        }
        t.modifiersData[r] = F
    }
}
const xSe = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: kSe,
    requiresIfExists: ["offset"]
};
function SSe(e) {
    var t,
    n = e.state,
    r = e.name,
    o = n.elements.arrow,
    i = n.modifiersData.popperOffsets,
    s = sa(n.placement),
    a = EI(s),
    l = [rs, As].indexOf(s) >= 0,
    c = l ? "height" : "width";
    if (!(!o || !i)) {
        var u = n.modifiersData[r + "#persistent"].padding,
        f = TI(o),
        p = a === "y" ? ns : rs,
        m = a === "y" ? $s : As,
        v = n.rects.reference[c] + n.rects.reference[a] - i[a] - n.rects.popper[c],
        y = i[a] - n.rects.reference[a],
        b = vg(o),
        w = b ? a === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0,
        k = v / 2 - y / 2,
        C = u[p],
        x = w - f[c] - u[m],
        S = w / 2 - f[c] / 2 + k,
        T = p0(C, S, x),
        E = a;
        n.modifiersData[r] = (t = {}, t[E] = T, t.centerOffset = T - S, t)
    }
}
function CSe(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.element,
    i = o === void 0 ? "[data-popper-arrow]" : o,
    s = n.padding,
    a = s === void 0 ? 0 : s;
    i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || lV(t.elements.popper, i) && (t.elements.arrow = i, t.modifiersData[r + "#persistent"] = {
                padding: uV(typeof a != "number" ? a : dV(a, yg))
            }))
}
const ISe = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: SSe,
    effect: CSe,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function wA(e, t, n) {
    return n === void 0 && (n = {
            x: 0,
            y: 0
        }), {
        top: e.top - t.height - n.y,
        right: e.right - t.width + n.x,
        bottom: e.bottom - t.height + n.y,
        left: e.left - t.width - n.x
    }
}
function bA(e) {
    return [ns, As, $s, rs].some(function (t) {
        return e[t] >= 0
    })
}
function TSe(e) {
    var t = e.state,
    n = e.name,
    r = t.rects.reference,
    o = t.rects.popper,
    i = t.modifiersData.preventOverflow,
    s = Om(t, {
        elementContext: "reference"
    }),
    a = Om(t, {
        altBoundary: !0
    }),
    l = wA(s, r),
    c = wA(a, o, i),
    u = bA(l),
    f = bA(c);
    t.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: f
    },
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": f
    })
}
const MSe = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: TSe
};
var PSe = [Xxe, Zxe, nSe, iSe, lSe, bSe, xSe, ISe, MSe], ESe = Kxe({
    defaultModifiers: PSe
}), OSe = Object.defineProperty, $Se = Object.defineProperties, ASe = Object.getOwnPropertyDescriptors, Ly = Object.getOwnPropertySymbols, fV = Object.prototype.hasOwnProperty, hV = Object.prototype.propertyIsEnumerable, _A = (e, t, n) => t in e ? OSe(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n, ct = (e, t) => {
    for (var n in t || (t = {}))
        fV.call(t, n) && _A(e, n, t[n]);
    if (Ly)
        for (var n of Ly(t))
            hV.call(t, n) && _A(e, n, t[n]);
    return e
}, sn = (e, t) => $Se(e, ASe(t)), DSe = (e, t) => {
    var n = {};
    for (var r in e)
        fV.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && Ly)
        for (var r of Ly(e))
            t.indexOf(r) < 0 && hV.call(e, r) && (n[r] = e[r]);
    return n
};
function pa(e) {
    if (e === null || e === !0 || e === !1)
        return NaN;
    var t = Number(e);
    return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t)
}
function mo(e, t) {
    if (t.length < e)
        throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present")
}
function sl(e) {
    mo(1, arguments);
    var t = Object.prototype.toString.call(e);
    return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"), console.warn(new Error().stack)), new Date(NaN))
}
function qs(e, t) {
    mo(2, arguments);
    var n = sl(e),
    r = pa(t);
    return isNaN(r) ? new Date(NaN) : (r && n.setDate(n.getDate() + r), n)
}
function Px(e, t) {
    mo(2, arguments);
    var n = sl(e),
    r = pa(t);
    if (isNaN(r))
        return new Date(NaN);
    if (!r)
        return n;
    var o = n.getDate(),
    i = new Date(n.getTime());
    i.setMonth(n.getMonth() + r + 1, 0);
    var s = i.getDate();
    return o >= s ? i : (n.setFullYear(i.getFullYear(), i.getMonth(), o), n)
}
function kA(e, t) {
    mo(2, arguments);
    var n = pa(t);
    return Px(e, n * 12)
}
var $v = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, NSe = typeof $v == "object" && $v && $v.Object === Object && $v, pV = NSe, RSe = pV, LSe = typeof self == "object" && self && self.Object === Object && self, BSe = RSe || LSe || Function("return this")(), ka = BSe, VSe = ka, FSe = VSe.Symbol, oh = FSe, xA = oh, mV = Object.prototype, jSe = mV.hasOwnProperty, WSe = mV.toString, Zh = xA ? xA.toStringTag : void 0;
function zSe(e) {
    var t = jSe.call(e, Zh),
    n = e[Zh];
    try {
        e[Zh] = void 0;
        var r = !0
    } catch {}
    var o = WSe.call(e);
    return r && (t ? e[Zh] = n : delete e[Zh]),
    o
}
var HSe = zSe, USe = Object.prototype, qSe = USe.toString;
function YSe(e) {
    return qSe.call(e)
}
var KSe = YSe, SA = oh, GSe = HSe, XSe = KSe, JSe = "[object Null]", ZSe = "[object Undefined]", CA = SA ? SA.toStringTag : void 0;
function QSe(e) {
    return e == null ? e === void 0 ? ZSe : JSe : CA && CA in Object(e) ? GSe(e) : XSe(e)
}
var xa = QSe;
function eCe(e) {
    return e != null && typeof e == "object"
}
var Mi = eCe, tCe = xa, nCe = Mi, rCe = "[object Boolean]";
function oCe(e) {
    return e === !0 || e === !1 || nCe(e) && tCe(e) == rCe
}
var iCe = oCe, sCe = xa, aCe = Mi, lCe = "[object Number]";
function cCe(e) {
    return typeof e == "number" || aCe(e) && sCe(e) == lCe
}
var Rp = cCe, uCe = Array.isArray, Pi = uCe, dCe = xa, fCe = Pi, hCe = Mi, pCe = "[object String]";
function mCe(e) {
    return typeof e == "string" || !fCe(e) && hCe(e) && dCe(e) == pCe
}
var Vl = mCe;
function gCe(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
var fs = gCe, vCe = xa, yCe = fs, wCe = "[object AsyncFunction]", bCe = "[object Function]", _Ce = "[object GeneratorFunction]", kCe = "[object Proxy]";
function xCe(e) {
    if (!yCe(e))
        return !1;
    var t = vCe(e);
    return t == bCe || t == _Ce || t == wCe || t == kCe
}
var Ya = xCe, SCe = 9007199254740991;
function CCe(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= SCe
}
var OI = CCe, ICe = Ya, TCe = OI;
function MCe(e) {
    return e != null && TCe(e.length) && !ICe(e)
}
var wg = MCe, PCe = wg, ECe = Mi;
function OCe(e) {
    return ECe(e) && PCe(e)
}
var Fo = OCe;
function $Ce(e) {
    return e === void 0
}
var ACe = $Ce, DCe = xa, NCe = Mi, RCe = "[object Date]";
function LCe(e) {
    return NCe(e) && DCe(e) == RCe
}
var BCe = LCe;
function VCe(e) {
    return function (t) {
        return e(t)
    }
}
var Pw = VCe, $f = {
    exports: {}
};
(function (e, t) {
    var n = pV,
    r = t && !t.nodeType && t,
    o = r && !0 && e && !e.nodeType && e,
    i = o && o.exports === r,
    s = i && n.process,
    a = function () {
        try {
            var l = o && o.require && o.require("util").types;
            return l || s && s.binding && s.binding("util")
        } catch {}
    }
    ();
    e.exports = a
})($f, $f.exports);
var FCe = BCe, jCe = Pw, IA = $f.exports, TA = IA && IA.isDate, WCe = TA ? jCe(TA) : FCe, zCe = WCe;
function HCe(e, t, n) {
    return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)),
    e
}
var UCe = HCe, qCe = xa, YCe = Mi, KCe = "[object Symbol]";
function GCe(e) {
    return typeof e == "symbol" || YCe(e) && qCe(e) == KCe
}
var Ew = GCe, MA = fs, XCe = Ew, PA = 0 / 0, JCe = /^\s+|\s+$/g, ZCe = /^[-+]0x[0-9a-f]+$/i, QCe = /^0b[01]+$/i, eIe = /^0o[0-7]+$/i, tIe = parseInt;
function nIe(e) {
    if (typeof e == "number")
        return e;
    if (XCe(e))
        return PA;
    if (MA(e)) {
        var t = typeof e.valueOf == "function" ? e.valueOf() : e;
        e = MA(t) ? t + "" : t
    }
    if (typeof e != "string")
        return e === 0 ? e : +e;
    e = e.replace(JCe, "");
    var n = QCe.test(e);
    return n || eIe.test(e) ? tIe(e.slice(2), n ? 2 : 8) : ZCe.test(e) ? PA : +e
}
var rIe = nIe, oIe = UCe, l2 = rIe;
function iIe(e, t, n) {
    return n === void 0 && (n = t, t = void 0),
    n !== void 0 && (n = l2(n), n = n === n ? n : 0),
    t !== void 0 && (t = l2(t), t = t === t ? t : 0),
    oIe(l2(e), t, n)
}
var sIe = iIe, aIe = Pi, lIe = Ew, cIe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, uIe = /^\w*$/;
function dIe(e, t) {
    if (aIe(e))
        return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || lIe(e) ? !0 : uIe.test(e) || !cIe.test(e) || t != null && e in Object(t)
}
var $I = dIe, fIe = ka, hIe = fIe["__core-js_shared__"], pIe = hIe, c2 = pIe, EA = function () {
    var e = /[^.]+$/.exec(c2 && c2.keys && c2.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : ""
}
();
function mIe(e) {
    return !!EA && EA in e
}
var gIe = mIe, vIe = Function.prototype, yIe = vIe.toString;
function wIe(e) {
    if (e != null) {
        try {
            return yIe.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var gV = wIe, bIe = Ya, _Ie = gIe, kIe = fs, xIe = gV, SIe = /[\\^$.*+?()[\]{}|]/g, CIe = /^\[object .+?Constructor\]$/, IIe = Function.prototype, TIe = Object.prototype, MIe = IIe.toString, PIe = TIe.hasOwnProperty, EIe = RegExp("^" + MIe.call(PIe).replace(SIe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function OIe(e) {
    if (!kIe(e) || _Ie(e))
        return !1;
    var t = bIe(e) ? EIe : CIe;
    return t.test(xIe(e))
}
var $Ie = OIe;
function AIe(e, t) {
    return e?.[t]
}
var DIe = AIe, NIe = $Ie, RIe = DIe;
function LIe(e, t) {
    var n = RIe(e, t);
    return NIe(n) ? n : void 0
}
var td = LIe, BIe = td, VIe = BIe(Object, "create"), Ow = VIe, OA = Ow;
function FIe() {
    this.__data__ = OA ? OA(null) : {},
    this.size = 0
}
var jIe = FIe;
function WIe(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
    t
}
var zIe = WIe, HIe = Ow, UIe = "__lodash_hash_undefined__", qIe = Object.prototype, YIe = qIe.hasOwnProperty;
function KIe(e) {
    var t = this.__data__;
    if (HIe) {
        var n = t[e];
        return n === UIe ? void 0 : n
    }
    return YIe.call(t, e) ? t[e] : void 0
}
var GIe = KIe, XIe = Ow, JIe = Object.prototype, ZIe = JIe.hasOwnProperty;
function QIe(e) {
    var t = this.__data__;
    return XIe ? t[e] !== void 0 : ZIe.call(t, e)
}
var eTe = QIe, tTe = Ow, nTe = "__lodash_hash_undefined__";
function rTe(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
    n[e] = tTe && t === void 0 ? nTe : t,
    this
}
var oTe = rTe, iTe = jIe, sTe = zIe, aTe = GIe, lTe = eTe, cTe = oTe;
function ih(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
ih.prototype.clear = iTe;
ih.prototype.delete = sTe;
ih.prototype.get = aTe;
ih.prototype.has = lTe;
ih.prototype.set = cTe;
var uTe = ih;
function dTe() {
    this.__data__ = [],
    this.size = 0
}
var fTe = dTe;
function hTe(e, t) {
    return e === t || e !== e && t !== t
}
var sh = hTe, pTe = sh;
function mTe(e, t) {
    for (var n = e.length; n--; )
        if (pTe(e[n][0], t))
            return n;
    return -1
}
var $w = mTe, gTe = $w, vTe = Array.prototype, yTe = vTe.splice;
function wTe(e) {
    var t = this.__data__,
    n = gTe(t, e);
    if (n < 0)
        return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : yTe.call(t, n, 1),
    --this.size,
    !0
}
var bTe = wTe, _Te = $w;
function kTe(e) {
    var t = this.__data__,
    n = _Te(t, e);
    return n < 0 ? void 0 : t[n][1]
}
var xTe = kTe, STe = $w;
function CTe(e) {
    return STe(this.__data__, e) > -1
}
var ITe = CTe, TTe = $w;
function MTe(e, t) {
    var n = this.__data__,
    r = TTe(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t,
    this
}
var PTe = MTe, ETe = fTe, OTe = bTe, $Te = xTe, ATe = ITe, DTe = PTe;
function ah(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
ah.prototype.clear = ETe;
ah.prototype.delete = OTe;
ah.prototype.get = $Te;
ah.prototype.has = ATe;
ah.prototype.set = DTe;
var Aw = ah, NTe = td, RTe = ka, LTe = NTe(RTe, "Map"), AI = LTe, $A = uTe, BTe = Aw, VTe = AI;
function FTe() {
    this.size = 0,
    this.__data__ = {
        hash: new $A,
        map: new(VTe || BTe),
        string: new $A
    }
}
var jTe = FTe;
function WTe(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
var zTe = WTe, HTe = zTe;
function UTe(e, t) {
    var n = e.__data__;
    return HTe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
}
var Dw = UTe, qTe = Dw;
function YTe(e) {
    var t = qTe(this, e).delete(e);
    return this.size -= t ? 1 : 0,
    t
}
var KTe = YTe, GTe = Dw;
function XTe(e) {
    return GTe(this, e).get(e)
}
var JTe = XTe, ZTe = Dw;
function QTe(e) {
    return ZTe(this, e).has(e)
}
var eMe = QTe, tMe = Dw;
function nMe(e, t) {
    var n = tMe(this, e),
    r = n.size;
    return n.set(e, t),
    this.size += n.size == r ? 0 : 1,
    this
}
var rMe = nMe, oMe = jTe, iMe = KTe, sMe = JTe, aMe = eMe, lMe = rMe;
function lh(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
lh.prototype.clear = oMe;
lh.prototype.delete = iMe;
lh.prototype.get = sMe;
lh.prototype.has = aMe;
lh.prototype.set = lMe;
var DI = lh, vV = DI, cMe = "Expected a function";
function NI(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
        throw new TypeError(cMe);
    var n = function () {
        var r = arguments,
        o = t ? t.apply(this, r) : r[0],
        i = n.cache;
        if (i.has(o))
            return i.get(o);
        var s = e.apply(this, r);
        return n.cache = i.set(o, s) || i,
        s
    };
    return n.cache = new(NI.Cache || vV),
    n
}
NI.Cache = vV;
var uMe = NI, dMe = uMe, fMe = 500;
function hMe(e) {
    var t = dMe(e, function (r) {
        return n.size === fMe && n.clear(),
        r
    }),
    n = t.cache;
    return t
}
var pMe = hMe, mMe = pMe, gMe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, vMe = /\\(\\)?/g, yMe = mMe(function (e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""),
    e.replace(gMe, function (n, r, o, i) {
        t.push(o ? i.replace(vMe, "$1") : r || n)
    }),
    t
}), wMe = yMe;
function bMe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = Array(r); ++n < r; )
        o[n] = t(e[n], n, e);
    return o
}
var RI = bMe, AA = oh, _Me = RI, kMe = Pi, xMe = Ew, SMe = 1 / 0, DA = AA ? AA.prototype : void 0, NA = DA ? DA.toString : void 0;
function yV(e) {
    if (typeof e == "string")
        return e;
    if (kMe(e))
        return _Me(e, yV) + "";
    if (xMe(e))
        return NA ? NA.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -SMe ? "-0" : t
}
var CMe = yV, IMe = CMe;
function TMe(e) {
    return e == null ? "" : IMe(e)
}
var MMe = TMe, PMe = Pi, EMe = $I, OMe = wMe, $Me = MMe;
function AMe(e, t) {
    return PMe(e) ? e : EMe(e, t) ? [e] : OMe($Me(e))
}
var ch = AMe, DMe = Ew, NMe = 1 / 0;
function RMe(e) {
    if (typeof e == "string" || DMe(e))
        return e;
    var t = e + "";
    return t == "0" && 1 / e == -NMe ? "-0" : t
}
var uh = RMe, LMe = ch, BMe = uh;
function VMe(e, t) {
    t = LMe(t, e);
    for (var n = 0, r = t.length; e != null && n < r; )
        e = e[BMe(t[n++])];
    return n && n == r ? e : void 0
}
var Nw = VMe, FMe = Nw;
function jMe(e, t, n) {
    var r = e == null ? void 0 : FMe(e, t);
    return r === void 0 ? n : r
}
var $m = jMe, WMe = td, zMe = function () {
    try {
        var e = WMe(Object, "defineProperty");
        return e({}, "", {}),
        e
    } catch {}
}
(), wV = zMe, RA = wV;
function HMe(e, t, n) {
    t == "__proto__" && RA ? RA(e, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
    }) : e[t] = n
}
var Rw = HMe, UMe = Rw, qMe = sh, YMe = Object.prototype, KMe = YMe.hasOwnProperty;
function GMe(e, t, n) {
    var r = e[t];
    (!(KMe.call(e, t) && qMe(r, n)) || n === void 0 && !(t in e)) && UMe(e, t, n)
}
var LI = GMe, XMe = 9007199254740991, JMe = /^(?:0|[1-9]\d*)$/;
function ZMe(e, t) {
    var n = typeof e;
    return t = t ?? XMe,
    !!t && (n == "number" || n != "symbol" && JMe.test(e)) && e > -1 && e % 1 == 0 && e < t
}
var Lw = ZMe, QMe = LI, ePe = ch, tPe = Lw, LA = fs, nPe = uh;
function rPe(e, t, n, r) {
    if (!LA(e))
        return e;
    t = ePe(t, e);
    for (var o = -1, i = t.length, s = i - 1, a = e; a != null && ++o < i; ) {
        var l = nPe(t[o]),
        c = n;
        if (l === "__proto__" || l === "constructor" || l === "prototype")
            return e;
        if (o != s) {
            var u = a[l];
            c = r ? r(u, l, a) : void 0,
            c === void 0 && (c = LA(u) ? u : tPe(t[o + 1]) ? [] : {})
        }
        QMe(a, l, c),
        a = a[l]
    }
    return e
}
var bV = rPe, oPe = bV;
function iPe(e, t, n) {
    return e == null ? e : oPe(e, t, n)
}
var sPe = iPe;
function aPe(e) {
    return function (t, n, r) {
        for (var o = -1, i = Object(t), s = r(t), a = s.length; a--; ) {
            var l = s[e ? a : ++o];
            if (n(i[l], l, i) === !1)
                break
        }
        return t
    }
}
var lPe = aPe, cPe = lPe, uPe = cPe(), _V = uPe;
function dPe(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
        r[n] = t(n);
    return r
}
var fPe = dPe, hPe = xa, pPe = Mi, mPe = "[object Arguments]";
function gPe(e) {
    return pPe(e) && hPe(e) == mPe
}
var vPe = gPe, BA = vPe, yPe = Mi, kV = Object.prototype, wPe = kV.hasOwnProperty, bPe = kV.propertyIsEnumerable, _Pe = BA(function () {
    return arguments
}
    ()) ? BA : function (e) {
    return yPe(e) && wPe.call(e, "callee") && !bPe.call(e, "callee")
}, Bw = _Pe, Af = {
    exports: {}
};
function kPe() {
    return !1
}
var xPe = kPe;
(function (e, t) {
    var n = ka,
    r = xPe,
    o = t && !t.nodeType && t,
    i = o && !0 && e && !e.nodeType && e,
    s = i && i.exports === o,
    a = s ? n.Buffer : void 0,
    l = a ? a.isBuffer : void 0,
    c = l || r;
    e.exports = c
})(Af, Af.exports);
var SPe = xa, CPe = OI, IPe = Mi, TPe = "[object Arguments]", MPe = "[object Array]", PPe = "[object Boolean]", EPe = "[object Date]", OPe = "[object Error]", $Pe = "[object Function]", APe = "[object Map]", DPe = "[object Number]", NPe = "[object Object]", RPe = "[object RegExp]", LPe = "[object Set]", BPe = "[object String]", VPe = "[object WeakMap]", FPe = "[object ArrayBuffer]", jPe = "[object DataView]", WPe = "[object Float32Array]", zPe = "[object Float64Array]", HPe = "[object Int8Array]", UPe = "[object Int16Array]", qPe = "[object Int32Array]", YPe = "[object Uint8Array]", KPe = "[object Uint8ClampedArray]", GPe = "[object Uint16Array]", XPe = "[object Uint32Array]", Hn = {};
Hn[WPe] = Hn[zPe] = Hn[HPe] = Hn[UPe] = Hn[qPe] = Hn[YPe] = Hn[KPe] = Hn[GPe] = Hn[XPe] = !0;
Hn[TPe] = Hn[MPe] = Hn[FPe] = Hn[PPe] = Hn[jPe] = Hn[EPe] = Hn[OPe] = Hn[$Pe] = Hn[APe] = Hn[DPe] = Hn[NPe] = Hn[RPe] = Hn[LPe] = Hn[BPe] = Hn[VPe] = !1;
function JPe(e) {
    return IPe(e) && CPe(e.length) && !!Hn[SPe(e)]
}
var ZPe = JPe, QPe = ZPe, eEe = Pw, VA = $f.exports, FA = VA && VA.isTypedArray, tEe = FA ? eEe(FA) : QPe, BI = tEe, nEe = fPe, rEe = Bw, oEe = Pi, iEe = Af.exports, sEe = Lw, aEe = BI, lEe = Object.prototype, cEe = lEe.hasOwnProperty;
function uEe(e, t) {
    var n = oEe(e),
    r = !n && rEe(e),
    o = !n && !r && iEe(e),
    i = !n && !r && !o && aEe(e),
    s = n || r || o || i,
    a = s ? nEe(e.length, String) : [],
    l = a.length;
    for (var c in e)
        (t || cEe.call(e, c)) && !(s && (c == "length" || o && (c == "offset" || c == "parent") || i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || sEe(c, l))) && a.push(c);
    return a
}
var xV = uEe, dEe = Object.prototype;
function fEe(e) {
    var t = e && e.constructor,
    n = typeof t == "function" && t.prototype || dEe;
    return e === n
}
var VI = fEe;
function hEe(e, t) {
    return function (n) {
        return e(t(n))
    }
}
var SV = hEe, pEe = SV, mEe = pEe(Object.keys, Object), gEe = mEe, vEe = VI, yEe = gEe, wEe = Object.prototype, bEe = wEe.hasOwnProperty;
function _Ee(e) {
    if (!vEe(e))
        return yEe(e);
    var t = [];
    for (var n in Object(e))
        bEe.call(e, n) && n != "constructor" && t.push(n);
    return t
}
var kEe = _Ee, xEe = xV, SEe = kEe, CEe = wg;
function IEe(e) {
    return CEe(e) ? xEe(e) : SEe(e)
}
var dh = IEe, TEe = _V, MEe = dh;
function PEe(e, t) {
    return e && TEe(e, t, MEe)
}
var CV = PEe, EEe = Aw;
function OEe() {
    this.__data__ = new EEe,
    this.size = 0
}
var $Ee = OEe;
function AEe(e) {
    var t = this.__data__,
    n = t.delete(e);
    return this.size = t.size,
    n
}
var DEe = AEe;
function NEe(e) {
    return this.__data__.get(e)
}
var REe = NEe;
function LEe(e) {
    return this.__data__.has(e)
}
var BEe = LEe, VEe = Aw, FEe = AI, jEe = DI, WEe = 200;
function zEe(e, t) {
    var n = this.__data__;
    if (n instanceof VEe) {
        var r = n.__data__;
        if (!FEe || r.length < WEe - 1)
            return r.push([e, t]), this.size = ++n.size, this;
        n = this.__data__ = new jEe(r)
    }
    return n.set(e, t),
    this.size = n.size,
    this
}
var HEe = zEe, UEe = Aw, qEe = $Ee, YEe = DEe, KEe = REe, GEe = BEe, XEe = HEe;
function fh(e) {
    var t = this.__data__ = new UEe(e);
    this.size = t.size
}
fh.prototype.clear = qEe;
fh.prototype.delete = YEe;
fh.prototype.get = KEe;
fh.prototype.has = GEe;
fh.prototype.set = XEe;
var Vw = fh, JEe = "__lodash_hash_undefined__";
function ZEe(e) {
    return this.__data__.set(e, JEe),
    this
}
var QEe = ZEe;
function e3e(e) {
    return this.__data__.has(e)
}
var t3e = e3e, n3e = DI, r3e = QEe, o3e = t3e;
function By(e) {
    var t = -1,
    n = e == null ? 0 : e.length;
    for (this.__data__ = new n3e; ++t < n; )
        this.add(e[t])
}
By.prototype.add = By.prototype.push = r3e;
By.prototype.has = o3e;
var i3e = By;
function s3e(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
        if (t(e[n], n, e))
            return !0;
    return !1
}
var IV = s3e;
function a3e(e, t) {
    return e.has(t)
}
var l3e = a3e, c3e = i3e, u3e = IV, d3e = l3e, f3e = 1, h3e = 2;
function p3e(e, t, n, r, o, i) {
    var s = n & f3e,
    a = e.length,
    l = t.length;
    if (a != l && !(s && l > a))
        return !1;
    var c = i.get(e),
    u = i.get(t);
    if (c && u)
        return c == t && u == e;
    var f = -1,
    p = !0,
    m = n & h3e ? new c3e : void 0;
    for (i.set(e, t), i.set(t, e); ++f < a; ) {
        var v = e[f],
        y = t[f];
        if (r)
            var b = s ? r(y, v, f, t, e, i) : r(v, y, f, e, t, i);
        if (b !== void 0) {
            if (b)
                continue;
            p = !1;
            break
        }
        if (m) {
            if (!u3e(t, function (w, k) {
                    if (!d3e(m, k) && (v === w || o(v, w, n, r, i)))
                        return m.push(k)
                    })) {
                    p = !1;
                    break
                }
        } else if (!(v === y || o(v, y, n, r, i))) {
            p = !1;
            break
        }
    }
    return i.delete(e),
    i.delete(t),
    p
}
var TV = p3e, m3e = ka, g3e = m3e.Uint8Array, MV = g3e;
function v3e(e) {
    var t = -1,
    n = Array(e.size);
    return e.forEach(function (r, o) {
        n[++t] = [o, r]
    }),
    n
}
var PV = v3e;
function y3e(e) {
    var t = -1,
    n = Array(e.size);
    return e.forEach(function (r) {
        n[++t] = r
    }),
    n
}
var w3e = y3e, jA = oh, WA = MV, b3e = sh, _3e = TV, k3e = PV, x3e = w3e, S3e = 1, C3e = 2, I3e = "[object Boolean]", T3e = "[object Date]", M3e = "[object Error]", P3e = "[object Map]", E3e = "[object Number]", O3e = "[object RegExp]", $3e = "[object Set]", A3e = "[object String]", D3e = "[object Symbol]", N3e = "[object ArrayBuffer]", R3e = "[object DataView]", zA = jA ? jA.prototype : void 0, u2 = zA ? zA.valueOf : void 0;
function L3e(e, t, n, r, o, i, s) {
    switch (n) {
    case R3e:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
            return !1;
        e = e.buffer,
        t = t.buffer;
    case N3e:
        return !(e.byteLength != t.byteLength || !i(new WA(e), new WA(t)));
    case I3e:
    case T3e:
    case E3e:
        return b3e(+e, +t);
    case M3e:
        return e.name == t.name && e.message == t.message;
    case O3e:
    case A3e:
        return e == t + "";
    case P3e:
        var a = k3e;
    case $3e:
        var l = r & S3e;
        if (a || (a = x3e), e.size != t.size && !l)
            return !1;
        var c = s.get(e);
        if (c)
            return c == t;
        r |= C3e,
        s.set(e, t);
        var u = _3e(a(e), a(t), r, o, i, s);
        return s.delete(e),
        u;
    case D3e:
        if (u2)
            return u2.call(e) == u2.call(t)
    }
    return !1
}
var B3e = L3e;
function V3e(e, t) {
    for (var n = -1, r = t.length, o = e.length; ++n < r; )
        e[o + n] = t[n];
    return e
}
var FI = V3e, F3e = FI, j3e = Pi;
function W3e(e, t, n) {
    var r = t(e);
    return j3e(e) ? r : F3e(r, n(e))
}
var EV = W3e;
function z3e(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = 0, i = []; ++n < r; ) {
        var s = e[n];
        t(s, n, e) && (i[o++] = s)
    }
    return i
}
var H3e = z3e;
function U3e() {
    return []
}
var OV = U3e, q3e = H3e, Y3e = OV, K3e = Object.prototype, G3e = K3e.propertyIsEnumerable, HA = Object.getOwnPropertySymbols, X3e = HA ? function (e) {
    return e == null ? [] : (e = Object(e), q3e(HA(e), function (t) {
            return G3e.call(e, t)
        }))
}
 : Y3e, jI = X3e, J3e = EV, Z3e = jI, Q3e = dh;
function eOe(e) {
    return J3e(e, Q3e, Z3e)
}
var $V = eOe, UA = $V, tOe = 1, nOe = Object.prototype, rOe = nOe.hasOwnProperty;
function oOe(e, t, n, r, o, i) {
    var s = n & tOe,
    a = UA(e),
    l = a.length,
    c = UA(t),
    u = c.length;
    if (l != u && !s)
        return !1;
    for (var f = l; f--; ) {
        var p = a[f];
        if (!(s ? p in t : rOe.call(t, p)))
            return !1
    }
    var m = i.get(e),
    v = i.get(t);
    if (m && v)
        return m == t && v == e;
    var y = !0;
    i.set(e, t),
    i.set(t, e);
    for (var b = s; ++f < l; ) {
        p = a[f];
        var w = e[p],
        k = t[p];
        if (r)
            var C = s ? r(k, w, p, t, e, i) : r(w, k, p, e, t, i);
        if (!(C === void 0 ? w === k || o(w, k, n, r, i) : C)) {
            y = !1;
            break
        }
        b || (b = p == "constructor")
    }
    if (y && !b) {
        var x = e.constructor,
        S = t.constructor;
        x != S && "constructor" in e && "constructor" in t && !(typeof x == "function" && x instanceof x && typeof S == "function" && S instanceof S) && (y = !1)
    }
    return i.delete(e),
    i.delete(t),
    y
}
var iOe = oOe, sOe = td, aOe = ka, lOe = sOe(aOe, "DataView"), cOe = lOe, uOe = td, dOe = ka, fOe = uOe(dOe, "Promise"), hOe = fOe, pOe = td, mOe = ka, gOe = pOe(mOe, "Set"), vOe = gOe, yOe = td, wOe = ka, bOe = yOe(wOe, "WeakMap"), _Oe = bOe, Ex = cOe, Ox = AI, $x = hOe, Ax = vOe, Dx = _Oe, AV = xa, hh = gV, qA = "[object Map]", kOe = "[object Object]", YA = "[object Promise]", KA = "[object Set]", GA = "[object WeakMap]", XA = "[object DataView]", xOe = hh(Ex), SOe = hh(Ox), COe = hh($x), IOe = hh(Ax), TOe = hh(Dx), Fc = AV;
(Ex && Fc(new Ex(new ArrayBuffer(1))) != XA || Ox && Fc(new Ox) != qA || $x && Fc($x.resolve()) != YA || Ax && Fc(new Ax) != KA || Dx && Fc(new Dx) != GA) && (Fc = function (e) {
    var t = AV(e),
    n = t == kOe ? e.constructor : void 0,
    r = n ? hh(n) : "";
    if (r)
        switch (r) {
        case xOe:
            return XA;
        case SOe:
            return qA;
        case COe:
            return YA;
        case IOe:
            return KA;
        case TOe:
            return GA
        }
    return t
});
var bg = Fc, d2 = Vw, MOe = TV, POe = B3e, EOe = iOe, JA = bg, ZA = Pi, QA = Af.exports, OOe = BI, $Oe = 1, eD = "[object Arguments]", tD = "[object Array]", Av = "[object Object]", AOe = Object.prototype, nD = AOe.hasOwnProperty;
function DOe(e, t, n, r, o, i) {
    var s = ZA(e),
    a = ZA(t),
    l = s ? tD : JA(e),
    c = a ? tD : JA(t);
    l = l == eD ? Av : l,
    c = c == eD ? Av : c;
    var u = l == Av,
    f = c == Av,
    p = l == c;
    if (p && QA(e)) {
        if (!QA(t))
            return !1;
        s = !0,
        u = !1
    }
    if (p && !u)
        return i || (i = new d2), s || OOe(e) ? MOe(e, t, n, r, o, i) : POe(e, t, l, n, r, o, i);
    if (!(n & $Oe)) {
        var m = u && nD.call(e, "__wrapped__"),
        v = f && nD.call(t, "__wrapped__");
        if (m || v) {
            var y = m ? e.value() : e,
            b = v ? t.value() : t;
            return i || (i = new d2),
            o(y, b, n, r, i)
        }
    }
    return p ? (i || (i = new d2), EOe(e, t, n, r, o, i)) : !1
}
var NOe = DOe, ROe = NOe, rD = Mi;
function DV(e, t, n, r, o) {
    return e === t ? !0 : e == null || t == null || !rD(e) && !rD(t) ? e !== e && t !== t : ROe(e, t, n, r, DV, o)
}
var NV = DV, LOe = Vw, BOe = NV, VOe = 1, FOe = 2;
function jOe(e, t, n, r) {
    var o = n.length,
    i = o,
    s = !r;
    if (e == null)
        return !i;
    for (e = Object(e); o--; ) {
        var a = n[o];
        if (s && a[2] ? a[1] !== e[a[0]] : !(a[0]in e))
            return !1
    }
    for (; ++o < i; ) {
        a = n[o];
        var l = a[0],
        c = e[l],
        u = a[1];
        if (s && a[2]) {
            if (c === void 0 && !(l in e))
                return !1
        } else {
            var f = new LOe;
            if (r)
                var p = r(c, u, l, e, t, f);
            if (!(p === void 0 ? BOe(u, c, VOe | FOe, r, f) : p))
                return !1
        }
    }
    return !0
}
var WOe = jOe, zOe = fs;
function HOe(e) {
    return e === e && !zOe(e)
}
var RV = HOe, UOe = RV, qOe = dh;
function YOe(e) {
    for (var t = qOe(e), n = t.length; n--; ) {
        var r = t[n],
        o = e[r];
        t[n] = [r, o, UOe(o)]
    }
    return t
}
var KOe = YOe;
function GOe(e, t) {
    return function (n) {
        return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n))
    }
}
var LV = GOe, XOe = WOe, JOe = KOe, ZOe = LV;
function QOe(e) {
    var t = JOe(e);
    return t.length == 1 && t[0][2] ? ZOe(t[0][0], t[0][1]) : function (n) {
        return n === e || XOe(n, e, t)
    }
}
var e$e = QOe;
function t$e(e, t) {
    return e != null && t in Object(e)
}
var n$e = t$e, r$e = ch, o$e = Bw, i$e = Pi, s$e = Lw, a$e = OI, l$e = uh;
function c$e(e, t, n) {
    t = r$e(t, e);
    for (var r = -1, o = t.length, i = !1; ++r < o; ) {
        var s = l$e(t[r]);
        if (!(i = e != null && n(e, s)))
            break;
        e = e[s]
    }
    return i || ++r != o ? i : (o = e == null ? 0 : e.length, !!o && a$e(o) && s$e(s, o) && (i$e(e) || o$e(e)))
}
var BV = c$e, u$e = n$e, d$e = BV;
function f$e(e, t) {
    return e != null && d$e(e, t, u$e)
}
var VV = f$e, h$e = NV, p$e = $m, m$e = VV, g$e = $I, v$e = RV, y$e = LV, w$e = uh, b$e = 1, _$e = 2;
function k$e(e, t) {
    return g$e(e) && v$e(t) ? y$e(w$e(e), t) : function (n) {
        var r = p$e(n, e);
        return r === void 0 && r === t ? m$e(n, e) : h$e(t, r, b$e | _$e)
    }
}
var x$e = k$e;
function S$e(e) {
    return e
}
var WI = S$e;
function C$e(e) {
    return function (t) {
        return t?.[e]
    }
}
var I$e = C$e, T$e = Nw;
function M$e(e) {
    return function (t) {
        return T$e(t, e)
    }
}
var P$e = M$e, E$e = I$e, O$e = P$e, $$e = $I, A$e = uh;
function D$e(e) {
    return $$e(e) ? E$e(A$e(e)) : O$e(e)
}
var N$e = D$e, R$e = e$e, L$e = x$e, B$e = WI, V$e = Pi, F$e = N$e;
function j$e(e) {
    return typeof e == "function" ? e : e == null ? B$e : typeof e == "object" ? V$e(e) ? L$e(e[0], e[1]) : R$e(e) : F$e(e)
}
var FV = j$e, W$e = Rw, z$e = CV, H$e = FV;
function U$e(e, t) {
    var n = {};
    return t = H$e(t),
    z$e(e, function (r, o, i) {
        W$e(n, o, t(r, o, i))
    }),
    n
}
var q$e = U$e, Y$e = RI;
function K$e(e, t) {
    return Y$e(t, function (n) {
        return [n, e[n]]
    })
}
var G$e = K$e;
function X$e(e) {
    var t = -1,
    n = Array(e.size);
    return e.forEach(function (r) {
        n[++t] = [r, r]
    }),
    n
}
var J$e = X$e, Z$e = G$e, Q$e = bg, eAe = PV, tAe = J$e, nAe = "[object Map]", rAe = "[object Set]";
function oAe(e) {
    return function (t) {
        var n = Q$e(t);
        return n == nAe ? eAe(t) : n == rAe ? tAe(t) : Z$e(t, e(t))
    }
}
var iAe = oAe, sAe = iAe, aAe = dh, lAe = sAe(aAe), m0 = lAe;
function cAe(e, t, n) {
    switch (n.length) {
    case 0:
        return e.call(t);
    case 1:
        return e.call(t, n[0]);
    case 2:
        return e.call(t, n[0], n[1]);
    case 3:
        return e.call(t, n[0], n[1], n[2])
    }
    return e.apply(t, n)
}
var jV = cAe, uAe = jV, oD = Math.max;
function dAe(e, t, n) {
    return t = oD(t === void 0 ? e.length - 1 : t, 0),
    function () {
        for (var r = arguments, o = -1, i = oD(r.length - t, 0), s = Array(i); ++o < i; )
            s[o] = r[t + o];
        o = -1;
        for (var a = Array(t + 1); ++o < t; )
            a[o] = r[o];
        return a[t] = n(s),
        uAe(e, this, a)
    }
}
var WV = dAe;
function fAe(e) {
    return function () {
        return e
    }
}
var hAe = fAe, pAe = hAe, iD = wV, mAe = WI, gAe = iD ? function (e, t) {
    return iD(e, "toString", {
        configurable: !0,
        enumerable: !1,
        value: pAe(t),
        writable: !0
    })
}
 : mAe, vAe = gAe, yAe = 800, wAe = 16, bAe = Date.now;
function _Ae(e) {
    var t = 0,
    n = 0;
    return function () {
        var r = bAe(),
        o = wAe - (r - n);
        if (n = r, o > 0) {
            if (++t >= yAe)
                return arguments[0]
        } else
            t = 0;
        return e.apply(void 0, arguments)
    }
}
var kAe = _Ae, xAe = vAe, SAe = kAe, CAe = SAe(xAe), zV = CAe, IAe = WI, TAe = WV, MAe = zV;
function PAe(e, t) {
    return MAe(TAe(e, t, IAe), e + "")
}
var zI = PAe, EAe = sh, OAe = wg, $Ae = Lw, AAe = fs;
function DAe(e, t, n) {
    if (!AAe(n))
        return !1;
    var r = typeof t;
    return (r == "number" ? OAe(n) && $Ae(t, n.length) : r == "string" && t in n) ? EAe(n[t], e) : !1
}
var HI = DAe;
function NAe(e) {
    var t = [];
    if (e != null)
        for (var n in Object(e))
            t.push(n);
    return t
}
var RAe = NAe, LAe = fs, BAe = VI, VAe = RAe, FAe = Object.prototype, jAe = FAe.hasOwnProperty;
function WAe(e) {
    if (!LAe(e))
        return VAe(e);
    var t = BAe(e),
    n = [];
    for (var r in e)
        r == "constructor" && (t || !jAe.call(e, r)) || n.push(r);
    return n
}
var zAe = WAe, HAe = xV, UAe = zAe, qAe = wg;
function YAe(e) {
    return qAe(e) ? HAe(e, !0) : UAe(e)
}
var ph = YAe, KAe = zI, GAe = sh, XAe = HI, JAe = ph, HV = Object.prototype, ZAe = HV.hasOwnProperty, QAe = KAe(function (e, t) {
    e = Object(e);
    var n = -1,
    r = t.length,
    o = r > 2 ? t[2] : void 0;
    for (o && XAe(t[0], t[1], o) && (r = 1); ++n < r; )
        for (var i = t[n], s = JAe(i), a = -1, l = s.length; ++a < l; ) {
            var c = s[a],
            u = e[c];
            (u === void 0 || GAe(u, HV[c]) && !ZAe.call(e, c)) && (e[c] = i[c])
        }
    return e
}), Lp = QAe, eDe = Rw, tDe = sh;
function nDe(e, t, n) {
    (n !== void 0 && !tDe(e[t], n) || n === void 0 && !(t in e)) && eDe(e, t, n)
}
var UV = nDe, Vy = {
    exports: {}
};
(function (e, t) {
    var n = ka,
    r = t && !t.nodeType && t,
    o = r && !0 && e && !e.nodeType && e,
    i = o && o.exports === r,
    s = i ? n.Buffer : void 0,
    a = s ? s.allocUnsafe : void 0;
    function l(c, u) {
        if (u)
            return c.slice();
        var f = c.length,
        p = a ? a(f) : new c.constructor(f);
        return c.copy(p),
        p
    }
    e.exports = l
})(Vy, Vy.exports);
var sD = MV;
function rDe(e) {
    var t = new e.constructor(e.byteLength);
    return new sD(t).set(new sD(e)),
    t
}
var UI = rDe, oDe = UI;
function iDe(e, t) {
    var n = t ? oDe(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length)
}
var qV = iDe;
function sDe(e, t) {
    var n = -1,
    r = e.length;
    for (t || (t = Array(r)); ++n < r; )
        t[n] = e[n];
    return t
}
var YV = sDe, aDe = fs, aD = Object.create, lDe = function () {
    function e() {}
    return function (t) {
        if (!aDe(t))
            return {};
        if (aD)
            return aD(t);
        e.prototype = t;
        var n = new e;
        return e.prototype = void 0,
        n
    }
}
(), cDe = lDe, uDe = SV, dDe = uDe(Object.getPrototypeOf, Object), qI = dDe, fDe = cDe, hDe = qI, pDe = VI;
function mDe(e) {
    return typeof e.constructor == "function" && !pDe(e) ? fDe(hDe(e)) : {}
}
var KV = mDe, gDe = xa, vDe = qI, yDe = Mi, wDe = "[object Object]", bDe = Function.prototype, _De = Object.prototype, GV = bDe.toString, kDe = _De.hasOwnProperty, xDe = GV.call(Object);
function SDe(e) {
    if (!yDe(e) || gDe(e) != wDe)
        return !1;
    var t = vDe(e);
    if (t === null)
        return !0;
    var n = kDe.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && GV.call(n) == xDe
}
var XV = SDe;
function CDe(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
        return e[t]
}
var JV = CDe, IDe = LI, TDe = Rw;
function MDe(e, t, n, r) {
    var o = !n;
    n || (n = {});
    for (var i = -1, s = t.length; ++i < s; ) {
        var a = t[i],
        l = r ? r(n[a], e[a], a, n, e) : void 0;
        l === void 0 && (l = e[a]),
        o ? TDe(n, a, l) : IDe(n, a, l)
    }
    return n
}
var mh = MDe, PDe = mh, EDe = ph;
function ODe(e) {
    return PDe(e, EDe(e))
}
var $De = ODe, lD = UV, ADe = Vy.exports, DDe = qV, NDe = YV, RDe = KV, cD = Bw, uD = Pi, LDe = Fo, BDe = Af.exports, VDe = Ya, FDe = fs, jDe = XV, WDe = BI, dD = JV, zDe = $De;
function HDe(e, t, n, r, o, i, s) {
    var a = dD(e, n),
    l = dD(t, n),
    c = s.get(l);
    if (c) {
        lD(e, n, c);
        return
    }
    var u = i ? i(a, l, n + "", e, t, s) : void 0,
    f = u === void 0;
    if (f) {
        var p = uD(l),
        m = !p && BDe(l),
        v = !p && !m && WDe(l);
        u = l,
        p || m || v ? uD(a) ? u = a : LDe(a) ? u = NDe(a) : m ? (f = !1, u = ADe(l, !0)) : v ? (f = !1, u = DDe(l, !0)) : u = [] : jDe(l) || cD(l) ? (u = a, cD(a) ? u = zDe(a) : (!FDe(a) || VDe(a)) && (u = RDe(l))) : f = !1
    }
    f && (s.set(l, u), o(u, l, r, i, s), s.delete(l)),
    lD(e, n, u)
}
var UDe = HDe, qDe = Vw, YDe = UV, KDe = _V, GDe = UDe, XDe = fs, JDe = ph, ZDe = JV;
function ZV(e, t, n, r, o) {
    e !== t && KDe(t, function (i, s) {
        if (o || (o = new qDe), XDe(i))
            GDe(e, t, s, n, ZV, r, o);
        else {
            var a = r ? r(ZDe(e, s), i, s + "", e, t, o) : void 0;
            a === void 0 && (a = i),
            YDe(e, s, a)
        }
    }, JDe)
}
var QV = ZV, QDe = QV, fD = fs;
function e9(e, t, n, r, o, i) {
    return fD(e) && fD(t) && (i.set(t, e), QDe(e, t, void 0, e9, i), i.delete(t)),
    e
}
var eNe = e9, tNe = zI, nNe = HI;
function rNe(e) {
    return tNe(function (t, n) {
        var r = -1,
        o = n.length,
        i = o > 1 ? n[o - 1] : void 0,
        s = o > 2 ? n[2] : void 0;
        for (i = e.length > 3 && typeof i == "function" ? (o--, i) : void 0, s && nNe(n[0], n[1], s) && (i = o < 3 ? void 0 : i, o = 1), t = Object(t); ++r < o; ) {
            var a = n[r];
            a && e(t, a, r, i)
        }
        return t
    })
}
var oNe = rNe, iNe = QV, sNe = oNe, aNe = sNe(function (e, t, n, r) {
    iNe(e, t, n, r)
}), lNe = aNe, cNe = jV, uNe = zI, dNe = eNe, fNe = lNe, hNe = uNe(function (e) {
    return e.push(void 0, dNe),
    cNe(fNe, void 0, e)
}), YI = hNe, pNe = Nw, mNe = bV, gNe = ch;
function vNe(e, t, n) {
    for (var r = -1, o = t.length, i = {}; ++r < o; ) {
        var s = t[r],
        a = pNe(e, s);
        n(a, s) && mNe(i, gNe(s, e), a)
    }
    return i
}
var yNe = vNe, wNe = yNe, bNe = VV;
function _Ne(e, t) {
    return wNe(e, t, function (n, r) {
        return bNe(e, r)
    })
}
var kNe = _Ne, hD = oh, xNe = Bw, SNe = Pi, pD = hD ? hD.isConcatSpreadable : void 0;
function CNe(e) {
    return SNe(e) || xNe(e) || !!(pD && e && e[pD])
}
var INe = CNe, TNe = FI, MNe = INe;
function t9(e, t, n, r, o) {
    var i = -1,
    s = e.length;
    for (n || (n = MNe), o || (o = []); ++i < s; ) {
        var a = e[i];
        t > 0 && n(a) ? t > 1 ? t9(a, t - 1, n, r, o) : TNe(o, a) : r || (o[o.length] = a)
    }
    return o
}
var PNe = t9, ENe = PNe;
function ONe(e) {
    var t = e == null ? 0 : e.length;
    return t ? ENe(e, 1) : []
}
var $Ne = ONe, ANe = $Ne, DNe = WV, NNe = zV;
function RNe(e) {
    return NNe(DNe(e, void 0, ANe), e + "")
}
var n9 = RNe, LNe = kNe, BNe = n9, VNe = BNe(function (e, t) {
    return e == null ? {}
     : LNe(e, t)
}), FNe = VNe;
function jNe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; );
    return e
}
var WNe = jNe, zNe = mh, HNe = dh;
function UNe(e, t) {
    return e && zNe(t, HNe(t), e)
}
var qNe = UNe, YNe = mh, KNe = ph;
function GNe(e, t) {
    return e && YNe(t, KNe(t), e)
}
var XNe = GNe, JNe = mh, ZNe = jI;
function QNe(e, t) {
    return JNe(e, ZNe(e), t)
}
var e5e = QNe, t5e = FI, n5e = qI, r5e = jI, o5e = OV, i5e = Object.getOwnPropertySymbols, s5e = i5e ? function (e) {
    for (var t = []; e; )
        t5e(t, r5e(e)), e = n5e(e);
    return t
}
 : o5e, r9 = s5e, a5e = mh, l5e = r9;
function c5e(e, t) {
    return a5e(e, l5e(e), t)
}
var u5e = c5e, d5e = EV, f5e = r9, h5e = ph;
function p5e(e) {
    return d5e(e, h5e, f5e)
}
var o9 = p5e, m5e = Object.prototype, g5e = m5e.hasOwnProperty;
function v5e(e) {
    var t = e.length,
    n = new e.constructor(t);
    return t && typeof e[0] == "string" && g5e.call(e, "index") && (n.index = e.index, n.input = e.input),
    n
}
var y5e = v5e, w5e = UI;
function b5e(e, t) {
    var n = t ? w5e(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength)
}
var _5e = b5e, k5e = /\w*$/;
function x5e(e) {
    var t = new e.constructor(e.source, k5e.exec(e));
    return t.lastIndex = e.lastIndex,
    t
}
var S5e = x5e, mD = oh, gD = mD ? mD.prototype : void 0, vD = gD ? gD.valueOf : void 0;
function C5e(e) {
    return vD ? Object(vD.call(e)) : {}
}
var I5e = C5e, T5e = UI, M5e = _5e, P5e = S5e, E5e = I5e, O5e = qV, $5e = "[object Boolean]", A5e = "[object Date]", D5e = "[object Map]", N5e = "[object Number]", R5e = "[object RegExp]", L5e = "[object Set]", B5e = "[object String]", V5e = "[object Symbol]", F5e = "[object ArrayBuffer]", j5e = "[object DataView]", W5e = "[object Float32Array]", z5e = "[object Float64Array]", H5e = "[object Int8Array]", U5e = "[object Int16Array]", q5e = "[object Int32Array]", Y5e = "[object Uint8Array]", K5e = "[object Uint8ClampedArray]", G5e = "[object Uint16Array]", X5e = "[object Uint32Array]";
function J5e(e, t, n) {
    var r = e.constructor;
    switch (t) {
    case F5e:
        return T5e(e);
    case $5e:
    case A5e:
        return new r(+e);
    case j5e:
        return M5e(e, n);
    case W5e:
    case z5e:
    case H5e:
    case U5e:
    case q5e:
    case Y5e:
    case K5e:
    case G5e:
    case X5e:
        return O5e(e, n);
    case D5e:
        return new r;
    case N5e:
    case B5e:
        return new r(e);
    case R5e:
        return P5e(e);
    case L5e:
        return new r;
    case V5e:
        return E5e(e)
    }
}
var Z5e = J5e, Q5e = bg, eRe = Mi, tRe = "[object Map]";
function nRe(e) {
    return eRe(e) && Q5e(e) == tRe
}
var rRe = nRe, oRe = rRe, iRe = Pw, yD = $f.exports, wD = yD && yD.isMap, sRe = wD ? iRe(wD) : oRe, aRe = sRe, lRe = bg, cRe = Mi, uRe = "[object Set]";
function dRe(e) {
    return cRe(e) && lRe(e) == uRe
}
var fRe = dRe, hRe = fRe, pRe = Pw, bD = $f.exports, _D = bD && bD.isSet, mRe = _D ? pRe(_D) : hRe, gRe = mRe, vRe = Vw, yRe = WNe, wRe = LI, bRe = qNe, _Re = XNe, kRe = Vy.exports, xRe = YV, SRe = e5e, CRe = u5e, IRe = $V, TRe = o9, MRe = bg, PRe = y5e, ERe = Z5e, ORe = KV, $Re = Pi, ARe = Af.exports, DRe = aRe, NRe = fs, RRe = gRe, LRe = dh, BRe = ph, VRe = 1, FRe = 2, jRe = 4, i9 = "[object Arguments]", WRe = "[object Array]", zRe = "[object Boolean]", HRe = "[object Date]", URe = "[object Error]", s9 = "[object Function]", qRe = "[object GeneratorFunction]", YRe = "[object Map]", KRe = "[object Number]", a9 = "[object Object]", GRe = "[object RegExp]", XRe = "[object Set]", JRe = "[object String]", ZRe = "[object Symbol]", QRe = "[object WeakMap]", e4e = "[object ArrayBuffer]", t4e = "[object DataView]", n4e = "[object Float32Array]", r4e = "[object Float64Array]", o4e = "[object Int8Array]", i4e = "[object Int16Array]", s4e = "[object Int32Array]", a4e = "[object Uint8Array]", l4e = "[object Uint8ClampedArray]", c4e = "[object Uint16Array]", u4e = "[object Uint32Array]", Fn = {};
Fn[i9] = Fn[WRe] = Fn[e4e] = Fn[t4e] = Fn[zRe] = Fn[HRe] = Fn[n4e] = Fn[r4e] = Fn[o4e] = Fn[i4e] = Fn[s4e] = Fn[YRe] = Fn[KRe] = Fn[a9] = Fn[GRe] = Fn[XRe] = Fn[JRe] = Fn[ZRe] = Fn[a4e] = Fn[l4e] = Fn[c4e] = Fn[u4e] = !0;
Fn[URe] = Fn[s9] = Fn[QRe] = !1;
function g0(e, t, n, r, o, i) {
    var s,
    a = t & VRe,
    l = t & FRe,
    c = t & jRe;
    if (n && (s = o ? n(e, r, o, i) : n(e)), s !== void 0)
        return s;
    if (!NRe(e))
        return e;
    var u = $Re(e);
    if (u) {
        if (s = PRe(e), !a)
            return xRe(e, s)
    } else {
        var f = MRe(e),
        p = f == s9 || f == qRe;
        if (ARe(e))
            return kRe(e, a);
        if (f == a9 || f == i9 || p && !o) {
            if (s = l || p ? {}
                 : ORe(e), !a)
                return l ? CRe(e, _Re(s, e)) : SRe(e, bRe(s, e))
        } else {
            if (!Fn[f])
                return o ? e : {};
            s = ERe(e, f, a)
        }
    }
    i || (i = new vRe);
    var m = i.get(e);
    if (m)
        return m;
    i.set(e, s),
    RRe(e) ? e.forEach(function (b) {
        s.add(g0(b, t, n, b, e, i))
    }) : DRe(e) && e.forEach(function (b, w) {
        s.set(w, g0(b, t, n, w, e, i))
    });
    var v = c ? l ? TRe : IRe : l ? BRe : LRe,
    y = u ? void 0 : v(e);
    return yRe(y || e, function (b, w) {
        y && (w = b, b = e[w]),
        wRe(s, w, g0(b, t, n, w, e, i))
    }),
    s
}
var d4e = g0;
function f4e(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0
}
var Am = f4e;
function h4e(e, t, n) {
    var r = -1,
    o = e.length;
    t < 0 && (t = -t > o ? 0 : o + t),
    n = n > o ? o : n,
    n < 0 && (n += o),
    o = t > n ? 0 : n - t >>> 0,
    t >>>= 0;
    for (var i = Array(o); ++r < o; )
        i[r] = e[r + t];
    return i
}
var p4e = h4e, m4e = Nw, g4e = p4e;
function v4e(e, t) {
    return t.length < 2 ? e : m4e(e, g4e(t, 0, -1))
}
var y4e = v4e, w4e = ch, b4e = Am, _4e = y4e, k4e = uh;
function x4e(e, t) {
    return t = w4e(t, e),
    e = _4e(e, t),
    e == null || delete e[k4e(b4e(t))]
}
var S4e = x4e, C4e = XV;
function I4e(e) {
    return C4e(e) ? void 0 : e
}
var T4e = I4e, M4e = RI, P4e = d4e, E4e = S4e, O4e = ch, $4e = mh, A4e = T4e, D4e = n9, N4e = o9, R4e = 1, L4e = 2, B4e = 4, V4e = D4e(function (e, t) {
    var n = {};
    if (e == null)
        return n;
    var r = !1;
    t = M4e(t, function (i) {
        return i = O4e(i, e),
        r || (r = i.length > 1),
        i
    }),
    $4e(e, N4e(e), n),
    r && (n = P4e(n, R4e | L4e | B4e, A4e));
    for (var o = t.length; o--; )
        E4e(n, t[o]);
    return n
}), Nx = V4e, F4e = Object.prototype, j4e = F4e.hasOwnProperty;
function W4e(e, t) {
    return e != null && j4e.call(e, t)
}
var z4e = W4e, H4e = z4e, U4e = BV;
function q4e(e, t) {
    return e != null && U4e(e, t, H4e)
}
var l9 = q4e, Y4e = wg;
function K4e(e, t) {
    return function (n, r) {
        if (n == null)
            return n;
        if (!Y4e(n))
            return e(n, r);
        for (var o = n.length, i = t ? o : -1, s = Object(n); (t ? i-- : ++i < o) && r(s[i], i, s) !== !1; );
        return n
    }
}
var G4e = K4e, X4e = CV, J4e = G4e, Z4e = J4e(X4e), Q4e = Z4e;
function eLe(e) {
    return e && e.length ? e[0] : void 0
}
var c9 = eLe, tLe = Q4e;
function nLe(e, t) {
    var n;
    return tLe(e, function (r, o, i) {
        return n = t(r, o, i),
        !n
    }),
    !!n
}
var rLe = nLe, oLe = IV, iLe = FV, sLe = rLe, aLe = Pi, lLe = HI;
function cLe(e, t, n) {
    var r = aLe(e) ? oLe : sLe;
    return n && lLe(e, t, n) && (t = void 0),
    r(e, iLe(t))
}
var u9 = cLe;
const uLe = e => Object.prototype.toString.call(e).slice(8, -1), Yl = e => zCe(e) && !isNaN(e.getTime()), Ji = e => uLe(e) === "Object", KI = l9, Rx = (e, t) => u9(t, n => l9(e, n)), dLe = u9, cn = (e, t, n = "0") => {
    for (e = e != null ? String(e) : "", t = t || 2; e.length < t; )
        e = `${n}${e}`;
    return e
}, fLe = (...e) => {
    const t = {};
    return e.forEach(n => Object.entries(n).forEach(([r, o]) => {
            t[r] ? Fo(t[r]) ? t[r].push(o) : t[r] = [t[r], o] : t[r] = o
        })),
    t
}, vi = e => !!(e && e.month && e.year), hp = (e, t) => !vi(e) || !vi(t) ? !1 : e.year === t.year ? e.month < t.month : e.year < t.year, Bp = (e, t) => !vi(e) || !vi(t) ? !1 : e.year === t.year ? e.month > t.month : e.year > t.year, d9 = (e, t, n) => (e || !1) && !hp(e, t) && !Bp(e, n), f2 = (e, t) => !e && t || e && !t ? !1 : !e && !t ? !0 : e.month === t.month && e.year === t.year, Fa = ({
    month: e,
    year: t
}, n) => {
    const r = n > 0 ? 1 : -1;
    for (let o = 0; o < Math.abs(n); o++)
        e += r, e > 12 ? (e = 1, t++) : e < 1 && (e = 12, t--);
    return {
        month: e,
        year: t
    }
}, hLe = (e, t) => {
    if (!vi(e) || !vi(t))
        return [];
    const n = [];
    for (; !Bp(e, t); )
        n.push(e), e = Fa(e, 1);
    return n
};
function h2(e, t) {
    const n = Yl(e),
    r = Yl(t);
    return !n && !r ? !0 : n !== r ? !1 : e.getTime() === t.getTime()
}
const Ui = e => Fo(e) && e.length > 0, kD = (e, t, n) => {
    const r = [];
    return n.forEach(o => {
        const i = o.name || o.toString(),
        s = o.mixin,
        a = o.validate;
        if (Object.prototype.hasOwnProperty.call(e, i)) {
            const l = a ? a(e[i]) : e[i];
            t[i] = s && Ji(l) ? ct(ct({}, s), l) : l,
            r.push(i)
        }
    }), {
        target: t,
        assigned: r.length ? r : null
    }
}, xo = (e, t, n, r) => {
    e && t && n && e.addEventListener(t, n, r)
}, So = (e, t, n, r) => {
    e && t && e.removeEventListener(t, n, r)
}, Vp = (e, t) => !!e && !!t && (e === t || e.contains(t)), f9 = (e, t) => {
    (e.key === " " || e.key === "Enter") && (t(e), e.preventDefault())
}, Fy = () => {
    function e() {
        return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1)
    }
    return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`
};
function pLe(e) {
    let t = 0,
    n = 0,
    r;
    if (e.length === 0)
        return t;
    for (n = 0; n < e.length; n++)
        r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0;
    return t
}
var gh = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r, o] of t)
        n[r] = o;
    return n
};
const mLe = {
    name: "CustomTransition",
    emits: ["before-enter", "before-transition", "after-enter", "after-transition"],
    props: {
        name: String,
        appear: Boolean
    },
    computed: {
        name_() {
            return `vc-${this.name || "none"}`
        }
    },
    methods: {
        beforeEnter(e) {
            this.$emit("before-enter", e),
            this.$emit("before-transition", e)
        },
        afterEnter(e) {
            this.$emit("after-enter", e),
            this.$emit("after-transition", e)
        }
    }
};
function gLe(e, t, n, r, o, i) {
    return _(),
    H(ho, {
        name: i.name_,
        appear: n.appear,
        onBeforeEnter: i.beforeEnter,
        onAfterEnter: i.afterEnter
    }, {
    default:
        oe(() => [Ye(e.$slots, "default")]),
        _: 3
    }, 8, ["name", "appear", "onBeforeEnter", "onAfterEnter"])
}
var h9 = gh(mLe, [["render", gLe]]);
const Lx = {
    name: "Popover",
    emits: ["before-show", "after-show", "before-hide", "after-hide"],
    render() {
        return dt("div", {
            class: ["vc-popover-content-wrapper", {
                    "is-interactive": this.isInteractive
                }
            ],
            ref: "popover"
        }, [dt(h9, {
                    name: this.transition,
                    appear: !0,
                    "on-before-enter": this.beforeEnter,
                    "on-after-enter": this.afterEnter,
                    "on-before-leave": this.beforeLeave,
                    "on-after-leave": this.afterLeave
                }, {
                default:
                    () => this.isVisible ? dt("div", {
                        tabindex: -1,
                        class: ["vc-popover-content", `direction-${this.direction}`, this.contentClass],
                        style: this.contentStyle
                    }, [this.content, dt("span", {
                                class: ["vc-popover-caret", `direction-${this.direction}`, `align-${this.alignment}`]
                            })]) : null
                })])
    },
    props: {
        id: {
            type: String,
            required: !0
        },
        contentClass: String
    },
    data() {
        return {
            ref: null,
            opts: null,
            data: null,
            transition: "slide-fade",
            transitionTranslate: "15px",
            transitionDuration: "0.15s",
            placement: "bottom",
            positionFixed: !1,
            modifiers: [],
            isInteractive: !1,
            isHovered: !1,
            isFocused: !1,
            showDelay: 0,
            hideDelay: 110,
            autoHide: !1,
            popperEl: null
        }
    },
    computed: {
        content() {
            return Ya(this.$slots.default) && this.$slots.default({
                direction: this.direction,
                alignment: this.alignment,
                data: this.data,
                updateLayout: this.setupPopper,
                hide: e => this.hide(e)
            }) || this.$slots.default
        },
        contentStyle() {
            return {
                "--slide-translate": this.transitionTranslate,
                "--slide-duration": this.transitionDuration
            }
        },
        popperOptions() {
            return {
                placement: this.placement,
                strategy: this.positionFixed ? "fixed" : "absolute",
                modifiers: [{
                        name: "onUpdate",
                        enabled: !0,
                        phase: "afterWrite",
                        fn: this.onPopperUpdate
                    }, ...this.modifiers || []],
                onFirstUpdate: this.onPopperUpdate
            }
        },
        isVisible() {
            return !!(this.ref && this.content)
        },
        direction() {
            return this.placement && this.placement.split("-")[0] || "bottom"
        },
        alignment() {
            const e = this.direction === "left" || this.direction === "right";
            let t = this.placement.split("-");
            return t = t.length > 1 ? t[1] : "",
            ["start", "top", "left"].includes(t) ? e ? "top" : "left" : ["end", "bottom", "right"].includes(t) ? e ? "bottom" : "right" : e ? "middle" : "center"
        }
    },
    watch: {
        opts(e, t) {
            t && t.callback && t.callback(sn(ct({}, t), {
                    completed: !e,
                    reason: e ? "Overridden by action" : null
                }))
        }
    },
    mounted() {
        this.popoverEl = this.$refs.popover,
        this.addEvents()
    },
    beforeUnmount() {
        this.destroyPopper(),
        this.removeEvents(),
        this.popoverEl = null
    },
    methods: {
        addEvents() {
            xo(this.popoverEl, "click", this.onClick),
            xo(this.popoverEl, "mouseover", this.onMouseOver),
            xo(this.popoverEl, "mouseleave", this.onMouseLeave),
            xo(this.popoverEl, "focusin", this.onFocusIn),
            xo(this.popoverEl, "focusout", this.onFocusOut),
            xo(document, "keydown", this.onDocumentKeydown),
            xo(document, "click", this.onDocumentClick),
            xo(document, "show-popover", this.onDocumentShowPopover),
            xo(document, "hide-popover", this.onDocumentHidePopover),
            xo(document, "toggle-popover", this.onDocumentTogglePopover),
            xo(document, "update-popover", this.onDocumentUpdatePopover)
        },
        removeEvents() {
            So(this.popoverEl, "click", this.onClick),
            So(this.popoverEl, "mouseover", this.onMouseOver),
            So(this.popoverEl, "mouseleave", this.onMouseLeave),
            So(this.popoverEl, "focusin", this.onFocusIn),
            So(this.popoverEl, "focusout", this.onFocusOut),
            So(document, "keydown", this.onDocumentKeydown),
            So(document, "click", this.onDocumentClick),
            So(document, "show-popover", this.onDocumentShowPopover),
            So(document, "hide-popover", this.onDocumentHidePopover),
            So(document, "toggle-popover", this.onDocumentTogglePopover),
            So(document, "update-popover", this.onDocumentUpdatePopover)
        },
        onClick(e) {
            e.stopPropagation()
        },
        onMouseOver() {
            this.isHovered = !0,
            this.isInteractive && this.show()
        },
        onMouseLeave() {
            this.isHovered = !1,
            this.autoHide && !this.isFocused && (!this.ref || this.ref !== document.activeElement) && this.hide()
        },
        onFocusIn() {
            this.isFocused = !0,
            this.isInteractive && this.show()
        },
        onFocusOut(e) {
            (!e.relatedTarget || !Vp(this.popoverEl, e.relatedTarget)) && (this.isFocused = !1, !this.isHovered && this.autoHide && this.hide())
        },
        onDocumentClick(e) {
            !this.$refs.popover || !this.ref || Vp(this.popoverEl, e.target) || Vp(this.ref, e.target) || this.hide()
        },
        onDocumentKeydown(e) {
            (e.key === "Esc" || e.key === "Escape") && this.hide()
        },
        onDocumentShowPopover({
            detail: e
        }) {
            !e.id || e.id !== this.id || this.show(e)
        },
        onDocumentHidePopover({
            detail: e
        }) {
            !e.id || e.id !== this.id || this.hide(e)
        },
        onDocumentTogglePopover({
            detail: e
        }) {
            !e.id || e.id !== this.id || this.toggle(e)
        },
        onDocumentUpdatePopover({
            detail: e
        }) {
            !e.id || e.id !== this.id || this.update(e)
        },
        show(e = {}) {
            e.action = "show";
            const t = e.ref || this.ref,
            n = e.showDelay >= 0 ? e.showDelay : this.showDelay;
            if (!t) {
                e.callback && e.callback({
                    completed: !1,
                    reason: "Invalid reference element provided"
                });
                return
            }
            clearTimeout(this.timeout),
            this.opts = e;
            const r = () => {
                Object.assign(this, Nx(e, ["id"])),
                this.setupPopper(),
                this.opts = null
            };
            n > 0 ? this.timeout = setTimeout(() => r(), n) : r()
        },
        hide(e = {}) {
            e.action = "hide";
            const t = e.ref || this.ref,
            n = e.hideDelay >= 0 ? e.hideDelay : this.hideDelay;
            if (!this.ref || t !== this.ref) {
                e.callback && e.callback(sn(ct({}, e), {
                        completed: !1,
                        reason: this.ref ? "Invalid reference element provided" : "Popover already hidden"
                    }));
                return
            }
            const r = () => {
                this.ref = null,
                this.opts = null
            };
            clearTimeout(this.timeout),
            this.opts = e,
            n > 0 ? this.timeout = setTimeout(r, n) : r()
        },
        toggle(e = {}) {
            this.isVisible && e.ref === this.ref ? this.hide(e) : this.show(e)
        },
        update(e = {}) {
            Object.assign(this, Nx(e, ["id"])),
            this.setupPopper()
        },
        setupPopper() {
            this.$nextTick(() => {
                !this.ref || !this.$refs.popover || (this.popper && this.popper.reference !== this.ref && this.destroyPopper(), this.popper ? this.popper.update() : this.popper = ESe(this.ref, this.popoverEl, this.popperOptions))
            })
        },
        onPopperUpdate(e) {
            e.placement ? this.placement = e.placement : e.state && (this.placement = e.state.placement)
        },
        beforeEnter(e) {
            this.$emit("before-show", e)
        },
        afterEnter(e) {
            this.$emit("after-show", e)
        },
        beforeLeave(e) {
            this.$emit("before-hide", e)
        },
        afterLeave(e) {
            this.destroyPopper(),
            this.$emit("after-hide", e)
        },
        destroyPopper() {
            this.popper && (this.popper.destroy(), this.popper = null)
        }
    }
}, vLe = {
    inject: ["sharedState"],
    computed: {
        masks() {
            return this.sharedState.masks
        },
        theme() {
            return this.sharedState.theme
        },
        locale() {
            return this.sharedState.locale
        },
        dayPopoverId() {
            return this.sharedState.dayPopoverId
        }
    },
    methods: {
        format(e, t) {
            return this.locale.format(e, t)
        },
        pageForDate(e) {
            return this.locale.getDateParts(this.locale.normalizeDate(e))
        }
    }
}, yLe = ["base", "start", "end", "startEnd"], wLe = ["class", "contentClass", "style", "contentStyle", "color", "fillMode"], bLe = {
    color: "blue",
    isDark: !1,
    highlight: {
        base: {
            fillMode: "light"
        },
        start: {
            fillMode: "solid"
        },
        end: {
            fillMode: "solid"
        }
    },
    dot: {
        base: {
            fillMode: "solid"
        },
        start: {
            fillMode: "solid"
        },
        end: {
            fillMode: "solid"
        }
    },
    bar: {
        base: {
            fillMode: "solid"
        },
        start: {
            fillMode: "solid"
        },
        end: {
            fillMode: "solid"
        }
    },
    content: {
        base: {},
        start: {},
        end: {}
    }
};
class xD {
    constructor(t) {
        Object.assign(this, bLe, t)
    }
    normalizeAttr({
        config: t,
        type: n
    }) {
        let r = this.color,
        o = {};
        const i = this[n];
        if (t === !0 || Vl(t))
            r = Vl(t) ? t : r, o = ct({}, i);
        else if (Ji(t))
            Rx(t, yLe) ? o = ct({}, t) : o = {
                base: ct({}, t),
                start: ct({}, t),
                end: ct({}, t)
            };
        else
            return null;
        return Lp(o, {
            start: o.startEnd,
            end: o.startEnd
        }, i),
        m0(o).forEach(([s, a]) => {
            let l = r;
            a === !0 || Vl(a) ? (l = Vl(a) ? a : l, o[s] = {
                    color: l
                }) : Ji(a) && (Rx(a, wLe) ? o[s] = ct({}, a) : o[s] = {}),
            KI(o, `${s}.color`) || sPe(o, `${s}.color`, l)
        }),
        o
    }
    normalizeHighlight(t) {
        const n = this.normalizeAttr({
            config: t,
            type: "highlight"
        });
        return m0(n).forEach(([r, o]) => {
            const i = Lp(o, {
                isDark: this.isDark,
                color: this.color
            });
            o.style = ct(ct({}, this.getHighlightBgStyle(i)), o.style),
            o.contentStyle = ct(ct({}, this.getHighlightContentStyle(i)), o.contentStyle)
        }),
        n
    }
    getHighlightBgStyle({
        fillMode: t,
        color: n,
        isDark: r
    }) {
        switch (t) {
        case "outline":
        case "none":
            return {
                backgroundColor: r ? "var(--gray-900)" : "var(--white)",
                border: "2px solid",
                borderColor: r ? `var(--${n}-200)` : `var(--${n}-700)`,
                borderRadius: "var(--rounded-full)"
            };
        case "light":
            return {
                backgroundColor: r ? `var(--${n}-800)` : `var(--${n}-200)`,
                opacity: r ? .75 : 1,
                borderRadius: "var(--rounded-full)"
            };
        case "solid":
            return {
                backgroundColor: r ? `var(--${n}-500)` : `var(--${n}-600)`,
                borderRadius: "var(--rounded-full)"
            };
        default:
            return {
                borderRadius: "var(--rounded-full)"
            }
        }
    }
    getHighlightContentStyle({
        fillMode: t,
        color: n,
        isDark: r
    }) {
        switch (t) {
        case "outline":
        case "none":
            return {
                fontWeight: "var(--font-bold)",
                color: r ? `var(--${n}-100)` : `var(--${n}-900)`
            };
        case "light":
            return {
                fontWeight: "var(--font-bold)",
                color: r ? `var(--${n}-100)` : `var(--${n}-900)`
            };
        case "solid":
            return {
                fontWeight: "var(--font-bold)",
                color: "var(--white)"
            };
        default:
            return ""
        }
    }
    bgAccentHigh({
        color: t,
        isDark: n
    }) {
        return {
            backgroundColor: n ? `var(--${t}-500)` : `var(--${t}-600)`
        }
    }
    contentAccent({
        color: t,
        isDark: n
    }) {
        return t ? {
            fontWeight: "var(--font-bold)",
            color: n ? `var(--${t}-100)` : `var(--${t}-900)`
        }
         : null
    }
    normalizeDot(t) {
        return this.normalizeNonHighlight("dot", t, this.bgAccentHigh)
    }
    normalizeBar(t) {
        return this.normalizeNonHighlight("bar", t, this.bgAccentHigh)
    }
    normalizeContent(t) {
        return this.normalizeNonHighlight("content", t, this.contentAccent)
    }
    normalizeNonHighlight(t, n, r) {
        const o = this.normalizeAttr({
            type: t,
            config: n
        });
        return m0(o).forEach(([i, s]) => {
            Lp(s, {
                isDark: this.isDark,
                color: this.color
            }),
            s.style = ct(ct({}, r(s)), s.style)
        }),
        o
    }
}
var v0 = 6e4;
function SD(e) {
    return e.getTime() % v0
}
function jy(e) {
    var t = new Date(e.getTime()),
    n = Math.ceil(t.getTimezoneOffset());
    t.setSeconds(0, 0);
    var r = n > 0,
    o = r ? (v0 + SD(t)) % v0 : SD(t);
    return n * v0 + o
}
function _Le(e, t) {
    var n = CLe(t);
    return n.formatToParts ? xLe(n, e) : SLe(n, e)
}
var kLe = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
};
function xLe(e, t) {
    for (var n = e.formatToParts(t), r = [], o = 0; o < n.length; o++) {
        var i = kLe[n[o].type];
        i >= 0 && (r[i] = parseInt(n[o].value, 10))
    }
    return r
}
function SLe(e, t) {
    var n = e.format(t).replace(/\u200E/g, ""),
    r = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(n);
    return [r[3], r[1], r[2], r[4], r[5], r[6]]
}
var p2 = {};
function CLe(e) {
    if (!p2[e]) {
        var t = new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: "America/New_York",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }).format(new Date("2014-06-25T04:00:00.123Z")),
        n = t === "06/25/2014, 00:00:00" || t === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
        p2[e] = n ? new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: e,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }) : new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone: e,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        })
    }
    return p2[e]
}
var CD = 36e5, ILe = 6e4, Dv = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-])(\d{2})$/,
    timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
    timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
};
function ID(e, t) {
    var n,
    r;
    if (n = Dv.timezoneZ.exec(e), n)
        return 0;
    var o;
    if (n = Dv.timezoneHH.exec(e), n)
        return o = parseInt(n[2], 10), TD() ? (r = o * CD, n[1] === "+" ? -r : r) : NaN;
    if (n = Dv.timezoneHHMM.exec(e), n) {
        o = parseInt(n[2], 10);
        var i = parseInt(n[3], 10);
        return TD(o, i) ? (r = o * CD + i * ILe, n[1] === "+" ? -r : r) : NaN
    }
    if (n = Dv.timezoneIANA.exec(e), n) {
        var s = _Le(t, e),
        a = Date.UTC(s[0], s[1] - 1, s[2], s[3], s[4], s[5]),
        l = t.getTime() - t.getTime() % 1e3;
        return  - (a - l)
    }
    return 0
}
function TD(e, t) {
    return !(t != null && (t < 0 || t > 59))
}
var m2 = 36e5, MD = 6e4, TLe = 2, Zr = {
    dateTimeDelimeter: /[T ]/,
    plainTime: /:/,
    timeZoneDelimeter: /[Z ]/i,
    YY: /^(\d{2})$/,
    YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
    YYYY: /^(\d{4})/,
    YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
};
function PD(e, t) {
    if (arguments.length < 1)
        throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if (e === null)
        return new Date(NaN);
    var n = t || {},
    r = n.additionalDigits == null ? TLe : pa(n.additionalDigits);
    if (r !== 2 && r !== 1 && r !== 0)
        throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
        return new Date(e.getTime());
    if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
        return new Date(e);
    if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
        return new Date(NaN);
    var o = MLe(e),
    i = PLe(o.date, r),
    s = i.year,
    a = i.restDateString,
    l = ELe(a, s);
    if (isNaN(l))
        return new Date(NaN);
    if (l) {
        var c = l.getTime(),
        u = 0,
        f;
        if (o.time && (u = OLe(o.time), isNaN(u)))
            return new Date(NaN);
        if (o.timezone || n.timeZone) {
            if (f = ID(o.timezone || n.timeZone, new Date(c + u)), isNaN(f))
                return new Date(NaN);
            if (f = ID(o.timezone || n.timeZone, new Date(c + u + f)), isNaN(f))
                return new Date(NaN)
        } else
            f = jy(new Date(c + u)), f = jy(new Date(c + u + f));
        return new Date(c + u + f)
    } else
        return new Date(NaN)
}
function MLe(e) {
    var t = {},
    n = e.split(Zr.dateTimeDelimeter),
    r;
    if (Zr.plainTime.test(n[0]) ? (t.date = null, r = n[0]) : (t.date = n[0], r = n[1], t.timezone = n[2], Zr.timeZoneDelimeter.test(t.date) && (t.date = e.split(Zr.timeZoneDelimeter)[0], r = e.substr(t.date.length, e.length))), r) {
        var o = Zr.timezone.exec(r);
        o ? (t.time = r.replace(o[1], ""), t.timezone = o[1]) : t.time = r
    }
    return t
}
function PLe(e, t) {
    var n = Zr.YYY[t],
    r = Zr.YYYYY[t],
    o;
    if (o = Zr.YYYY.exec(e) || r.exec(e), o) {
        var i = o[1];
        return {
            year: parseInt(i, 10),
            restDateString: e.slice(i.length)
        }
    }
    if (o = Zr.YY.exec(e) || n.exec(e), o) {
        var s = o[1];
        return {
            year: parseInt(s, 10) * 100,
            restDateString: e.slice(s.length)
        }
    }
    return {
        year: null
    }
}
function ELe(e, t) {
    if (t === null)
        return null;
    var n,
    r,
    o,
    i;
    if (e.length === 0)
        return r = new Date(0), r.setUTCFullYear(t), r;
    if (n = Zr.MM.exec(e), n)
        return r = new Date(0), o = parseInt(n[1], 10) - 1, OD(t, o) ? (r.setUTCFullYear(t, o), r) : new Date(NaN);
    if (n = Zr.DDD.exec(e), n) {
        r = new Date(0);
        var s = parseInt(n[1], 10);
        return DLe(t, s) ? (r.setUTCFullYear(t, 0, s), r) : new Date(NaN)
    }
    if (n = Zr.MMDD.exec(e), n) {
        r = new Date(0),
        o = parseInt(n[1], 10) - 1;
        var a = parseInt(n[2], 10);
        return OD(t, o, a) ? (r.setUTCFullYear(t, o, a), r) : new Date(NaN)
    }
    if (n = Zr.Www.exec(e), n)
        return i = parseInt(n[1], 10) - 1, $D(t, i) ? ED(t, i) : new Date(NaN);
    if (n = Zr.WwwD.exec(e), n) {
        i = parseInt(n[1], 10) - 1;
        var l = parseInt(n[2], 10) - 1;
        return $D(t, i, l) ? ED(t, i, l) : new Date(NaN)
    }
    return null
}
function OLe(e) {
    var t,
    n,
    r;
    if (t = Zr.HH.exec(e), t)
        return n = parseFloat(t[1].replace(",", ".")), g2(n) ? n % 24 * m2 : NaN;
    if (t = Zr.HHMM.exec(e), t)
        return n = parseInt(t[1], 10), r = parseFloat(t[2].replace(",", ".")), g2(n, r) ? n % 24 * m2 + r * MD : NaN;
    if (t = Zr.HHMMSS.exec(e), t) {
        n = parseInt(t[1], 10),
        r = parseInt(t[2], 10);
        var o = parseFloat(t[3].replace(",", "."));
        return g2(n, r, o) ? n % 24 * m2 + r * MD + o * 1e3 : NaN
    }
    return null
}
function ED(e, t, n) {
    t = t || 0,
    n = n || 0;
    var r = new Date(0);
    r.setUTCFullYear(e, 0, 4);
    var o = r.getUTCDay() || 7,
    i = t * 7 + n + 1 - o;
    return r.setUTCDate(r.getUTCDate() + i),
    r
}
var $Le = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ALe = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function p9(e) {
    return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
function OD(e, t, n) {
    if (t < 0 || t > 11)
        return !1;
    if (n != null) {
        if (n < 1)
            return !1;
        var r = p9(e);
        if (r && n > ALe[t] || !r && n > $Le[t])
            return !1
    }
    return !0
}
function DLe(e, t) {
    if (t < 1)
        return !1;
    var n = p9(e);
    return !(n && t > 366 || !n && t > 365)
}
function $D(e, t, n) {
    return !(t < 0 || t > 52 || n != null && (n < 0 || n > 6))
}
function g2(e, t, n) {
    return !(e != null && (e < 0 || e >= 25) || t != null && (t < 0 || t >= 60) || n != null && (n < 0 || n >= 60))
}
function Au(e, t) {
    mo(1, arguments);
    var n = t || {},
    r = n.locale,
    o = r && r.options && r.options.weekStartsOn,
    i = o == null ? 0 : pa(o),
    s = n.weekStartsOn == null ? i : pa(n.weekStartsOn);
    if (!(s >= 0 && s <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var a = sl(e),
    l = a.getDay(),
    c = (l < s ? 7 : 0) + l - s;
    return a.setDate(a.getDate() - c),
    a.setHours(0, 0, 0, 0),
    a
}
function Wy(e) {
    return mo(1, arguments),
    Au(e, {
        weekStartsOn: 1
    })
}
function NLe(e) {
    mo(1, arguments);
    var t = sl(e),
    n = t.getFullYear(),
    r = new Date(0);
    r.setFullYear(n + 1, 0, 4),
    r.setHours(0, 0, 0, 0);
    var o = Wy(r),
    i = new Date(0);
    i.setFullYear(n, 0, 4),
    i.setHours(0, 0, 0, 0);
    var s = Wy(i);
    return t.getTime() >= o.getTime() ? n + 1 : t.getTime() >= s.getTime() ? n : n - 1
}
function RLe(e) {
    mo(1, arguments);
    var t = NLe(e),
    n = new Date(0);
    n.setFullYear(t, 0, 4),
    n.setHours(0, 0, 0, 0);
    var r = Wy(n);
    return r
}
var LLe = 6048e5;
function BLe(e) {
    mo(1, arguments);
    var t = sl(e),
    n = Wy(t).getTime() - RLe(t).getTime();
    return Math.round(n / LLe) + 1
}
function VLe(e, t) {
    mo(1, arguments);
    var n = sl(e),
    r = n.getFullYear(),
    o = t || {},
    i = o.locale,
    s = i && i.options && i.options.firstWeekContainsDate,
    a = s == null ? 1 : pa(s),
    l = o.firstWeekContainsDate == null ? a : pa(o.firstWeekContainsDate);
    if (!(l >= 1 && l <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var c = new Date(0);
    c.setFullYear(r + 1, 0, l),
    c.setHours(0, 0, 0, 0);
    var u = Au(c, t),
    f = new Date(0);
    f.setFullYear(r, 0, l),
    f.setHours(0, 0, 0, 0);
    var p = Au(f, t);
    return n.getTime() >= u.getTime() ? r + 1 : n.getTime() >= p.getTime() ? r : r - 1
}
function FLe(e, t) {
    mo(1, arguments);
    var n = t || {},
    r = n.locale,
    o = r && r.options && r.options.firstWeekContainsDate,
    i = o == null ? 1 : pa(o),
    s = n.firstWeekContainsDate == null ? i : pa(n.firstWeekContainsDate),
    a = VLe(e, t),
    l = new Date(0);
    l.setFullYear(a, 0, s),
    l.setHours(0, 0, 0, 0);
    var c = Au(l, t);
    return c
}
var jLe = 6048e5;
function WLe(e, t) {
    mo(1, arguments);
    var n = sl(e),
    r = Au(n, t).getTime() - FLe(n, t).getTime();
    return Math.round(r / jLe) + 1
}
var zLe = 6048e5;
function HLe(e, t, n) {
    mo(2, arguments);
    var r = Au(e, n),
    o = Au(t, n),
    i = r.getTime() - jy(r),
    s = o.getTime() - jy(o);
    return Math.round((i - s) / zLe)
}
function ULe(e) {
    mo(1, arguments);
    var t = sl(e),
    n = t.getMonth();
    return t.setFullYear(t.getFullYear(), n + 1, 0),
    t.setHours(0, 0, 0, 0),
    t
}
function qLe(e) {
    mo(1, arguments);
    var t = sl(e);
    return t.setDate(1),
    t.setHours(0, 0, 0, 0),
    t
}
function YLe(e, t) {
    return mo(1, arguments),
    HLe(ULe(e), qLe(e), t) + 1
}
const KLe = 24 * 60 * 60 * 1e3;
class Cr {
    constructor(t, {
        order: n = 0,
        locale: r,
        isFullDay: o
    } = {}) {
        if (this.isDateInfo = !0, this.order = n, this.locale = r instanceof zy ? r : new zy(r), this.firstDayOfWeek = this.locale.firstDayOfWeek, !Ji(t)) {
            const l = this.locale.normalizeDate(t);
            o ? t = {
                start: l,
                end: l
            }
             : t = {
                startOn: l,
                endOn: l
            }
        }
        let i = null,
        s = null;
        if (t.start ? i = this.locale.normalizeDate(t.start, sn(ct({}, this.opts), {
                        time: "00:00:00"
                    })) : t.startOn && (i = this.locale.normalizeDate(t.startOn, this.opts)), t.end ? s = this.locale.normalizeDate(t.end, sn(ct({}, this.opts), {
                        time: "23:59:59"
                    })) : t.endOn && (s = this.locale.normalizeDate(t.endOn, this.opts)), i && s && i > s) {
            const l = i;
            i = s,
            s = l
        } else
            i && t.span >= 1 && (s = qs(i, t.span - 1));
        this.start = i,
        this.startTime = i ? i.getTime() : NaN,
        this.end = s,
        this.endTime = s ? s.getTime() : NaN,
        this.isDate = this.startTime && this.startTime === this.endTime,
        this.isRange = !this.isDate;
        const a = kD(t, {}, Cr.patternProps);
        if (a.assigned && (this.on = {
                    and: a.target
                }), t.on) {
            const l = (Fo(t.on) ? t.on : [t.on]).map(c => {
                if (Ya(c))
                    return c;
                const u = kD(c, {}, Cr.patternProps);
                return u.assigned ? u.target : null
            }).filter(c => c);
            l.length && (this.on = sn(ct({}, this.on), {
                    or: l
                }))
        }
        this.isComplex = !!this.on
    }
    get opts() {
        return {
            order: this.order,
            locale: this.locale
        }
    }
    toDateInfo(t) {
        return t.isDateInfo ? t : new Cr(t, this.opts)
    }
    startOfWeek(t) {
        const n = t.getDay() + 1,
        r = n >= this.firstDayOfWeek ? this.firstDayOfWeek - n :  - (7 - (this.firstDayOfWeek - n));
        return qs(t, r)
    }
    diffInDays(t, n) {
        return Math.round((n - t) / KLe)
    }
    diffInWeeks(t, n) {
        return this.diffInDays(this.startOfWeek(t), this.startOfWeek(n))
    }
    diffInYears(t, n) {
        return n.getUTCFullYear() - t.getUTCFullYear()
    }
    diffInMonths(t, n) {
        return this.diffInYears(t, n) * 12 + (n.getMonth() - t.getMonth())
    }
    static get patterns() {
        return {
            dailyInterval: {
                test: (t, n, r) => r.diffInDays(r.start || new Date, t.date) % n === 0
            },
            weeklyInterval: {
                test: (t, n, r) => r.diffInWeeks(r.start || new Date, t.date) % n === 0
            },
            monthlyInterval: {
                test: (t, n, r) => r.diffInMonths(r.start || new Date, t.date) % n === 0
            },
            yearlyInterval: {
                test: () => (t, n, r) => r.diffInYears(r.start || new Date, t.date) % n === 0
            },
            days: {
                validate: t => Fo(t) ? t : [parseInt(t, 10)],
                test: (t, n) => n.includes(t.day) || n.includes(-t.dayFromEnd)
            },
            weekdays: {
                validate: t => Fo(t) ? t : [parseInt(t, 10)],
                test: (t, n) => n.includes(t.weekday)
            },
            ordinalWeekdays: {
                validate: t => Object.keys(t).reduce((n, r) => {
                    const o = t[r];
                    return o && (n[r] = Fo(o) ? o : [parseInt(o, 10)]),
                    n
                }, {}),
                test: (t, n) => Object.keys(n).map(r => parseInt(r, 10)).find(r => n[r].includes(t.weekday) && (r === t.weekdayOrdinal || r === -t.weekdayOrdinalFromEnd))
            },
            weekends: {
                validate: t => t,
                test: t => t.weekday === 1 || t.weekday === 7
            },
            workweek: {
                validate: t => t,
                test: t => t.weekday >= 2 && t.weekday <= 6
            },
            weeks: {
                validate: t => Fo(t) ? t : [parseInt(t, 10)],
                test: (t, n) => n.includes(t.week) || n.includes(-t.weekFromEnd)
            },
            months: {
                validate: t => Fo(t) ? t : [parseInt(t, 10)],
                test: (t, n) => n.includes(t.month)
            },
            years: {
                validate: t => Fo(t) ? t : [parseInt(t, 10)],
                test: (t, n) => n.includes(t.year)
            }
        }
    }
    static get patternProps() {
        return Object.keys(Cr.patterns).map(t => ({
                name: t,
                validate: Cr.patterns[t].validate
            }))
    }
    static testConfig(t, n, r) {
        return Ya(t) ? t(n) : Ji(t) ? Object.keys(t).every(o => Cr.patterns[o].test(n, t[o], r)) : null
    }
    iterateDatesInRange({
        start: t,
        end: n
    }, r) {
        if (!t || !n || !Ya(r))
            return null;
        t = this.locale.normalizeDate(t, sn(ct({}, this.opts), {
                    time: "00:00:00"
                }));
        const o = {
            i: 0,
            date: t,
            day: this.locale.getDateParts(t),
            finished: !1
        };
        let i = null;
        for (; !o.finished && o.date <= n; o.i++)
            i = r(o), o.date = qs(o.date, 1), o.day = this.locale.getDateParts(o.date);
        return i
    }
    shallowIntersectingRange(t) {
        return this.rangeShallowIntersectingRange(this, this.toDateInfo(t))
    }
    rangeShallowIntersectingRange(t, n) {
        if (!this.dateShallowIntersectsDate(t, n))
            return null;
        const r = t.toRange(),
        o = n.toRange();
        let i = null,
        s = null;
        return r.start ? o.start ? i = r.start > o.start ? r.start : o.start : i = r.start : o.start && (i = o.start),
        r.end ? o.end ? s = r.end < o.end ? r.end : o.end : s = r.end : o.end && (s = o.end), {
            start: i,
            end: s
        }
    }
    intersectsDate(t) {
        const n = this.toDateInfo(t);
        if (!this.shallowIntersectsDate(n))
            return null;
        if (!this.on)
            return this;
        const r = this.rangeShallowIntersectingRange(this, n);
        let o = !1;
        return this.iterateDatesInRange(r, i => {
            this.matchesDay(i.day) && (o = o || n.matchesDay(i.day), i.finished = o)
        }),
        o
    }
    shallowIntersectsDate(t) {
        return this.dateShallowIntersectsDate(this, this.toDateInfo(t))
    }
    dateShallowIntersectsDate(t, n) {
        return t.isDate ? n.isDate ? t.startTime === n.startTime : this.dateShallowIncludesDate(n, t) : n.isDate ? this.dateShallowIncludesDate(t, n) : !(t.start && n.end && t.start > n.end || t.end && n.start && t.end < n.start)
    }
    includesDate(t) {
        const n = this.toDateInfo(t);
        if (!this.shallowIncludesDate(n))
            return !1;
        if (!this.on)
            return !0;
        const r = this.rangeShallowIntersectingRange(this, n);
        let o = !0;
        return this.iterateDatesInRange(r, i => {
            this.matchesDay(i.day) && (o = o && n.matchesDay(i.day), i.finished = !o)
        }),
        o
    }
    shallowIncludesDate(t) {
        return this.dateShallowIncludesDate(this, t.isDate ? t : new Cr(t, this.opts))
    }
    dateShallowIncludesDate(t, n) {
        return t.isDate ? n.isDate ? t.startTime === n.startTime : !n.startTime || !n.endTime ? !1 : t.startTime === n.startTime && t.startTime === n.endTime : n.isDate ? !(t.start && n.start < t.start || t.end && n.start > t.end) : !(t.start && (!n.start || n.start < t.start) || t.end && (!n.end || n.end > t.end))
    }
    intersectsDay(t) {
        return this.shallowIntersectsDate(t.range) && this.matchesDay(t) ? this : null
    }
    matchesDay(t) {
        return this.on ? !(this.on.and && !Cr.testConfig(this.on.and, t, this) || this.on.or && !this.on.or.some(n => Cr.testConfig(n, t, this))) : !0
    }
    toRange() {
        return new Cr({
            start: this.start,
            end: this.end
        }, this.opts)
    }
    compare(t) {
        if (this.order !== t.order)
            return this.order - t.order;
        if (this.isDate !== t.isDate)
            return this.isDate ? 1 : -1;
        if (this.isDate)
            return 0;
        const n = this.start - t.start;
        return n !== 0 ? n : this.end - t.end
    }
}
const is = {
    ar: {
        dow: 7,
        L: "D/‏M/‏YYYY"
    },
    bg: {
        dow: 2,
        L: "D.MM.YYYY"
    },
    ca: {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    "zh-CN": {
        dow: 2,
        L: "YYYY/MM/DD"
    },
    "zh-TW": {
        dow: 1,
        L: "YYYY/MM/DD"
    },
    hr: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    cs: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    da: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    nl: {
        dow: 2,
        L: "DD-MM-YYYY"
    },
    "en-US": {
        dow: 1,
        L: "MM/DD/YYYY"
    },
    "en-AU": {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    "en-CA": {
        dow: 1,
        L: "YYYY-MM-DD"
    },
    "en-GB": {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    "en-IE": {
        dow: 2,
        L: "DD-MM-YYYY"
    },
    "en-NZ": {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    "en-ZA": {
        dow: 1,
        L: "YYYY/MM/DD"
    },
    eo: {
        dow: 2,
        L: "YYYY-MM-DD"
    },
    et: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    fi: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    fr: {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    "fr-CA": {
        dow: 1,
        L: "YYYY-MM-DD"
    },
    "fr-CH": {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    de: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    he: {
        dow: 1,
        L: "DD.MM.YYYY"
    },
    id: {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    it: {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    ja: {
        dow: 1,
        L: "YYYY年M月D日"
    },
    ko: {
        dow: 1,
        L: "YYYY.MM.DD"
    },
    lv: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    lt: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    mk: {
        dow: 2,
        L: "D.MM.YYYY"
    },
    nb: {
        dow: 2,
        L: "D. MMMM YYYY"
    },
    nn: {
        dow: 2,
        L: "D. MMMM YYYY"
    },
    pl: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    pt: {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    ro: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    ru: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    sk: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    "es-ES": {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    "es-MX": {
        dow: 2,
        L: "DD/MM/YYYY"
    },
    sv: {
        dow: 2,
        L: "YYYY-MM-DD"
    },
    th: {
        dow: 1,
        L: "DD/MM/YYYY"
    },
    tr: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    uk: {
        dow: 2,
        L: "DD.MM.YYYY"
    },
    vi: {
        dow: 2,
        L: "DD/MM/YYYY"
    }
};
is.en = is["en-US"];
is.es = is["es-ES"];
is.no = is.nb;
is.zh = is["zh-CN"];
m0(is).forEach(([e, {
                dow: t,
                L: n
            }
        ]) => {
    is[e] = {
        id: e,
        firstDayOfWeek: t,
        masks: {
            L: n
        }
    }
});
const xl = {
    DATE_TIME: 1,
    DATE: 2,
    TIME: 3
}, GLe = {
    1: ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds"],
    2: ["year", "month", "day"],
    3: ["hours", "minutes", "seconds", "milliseconds"]
}, AD = /d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|Z{1,4}|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g, Sl = /\d\d?/, XLe = /\d{3}/, JLe = /\d{4}/, Qh = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF/]+(\s*?[\u0600-\u06FF]+){1,2}/i, ZLe = /\[([^]*?)\]/gm, DD = () => {}, ND = e => (t, n, r) => {
    const o = r[e].indexOf(n.charAt(0).toUpperCase() + n.substring(1).toLowerCase());
    ~o && (t.month = o)
}, QLe = ["L", "iso"], _o = 7, e6e = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], t6e = [{
        value: 0,
        label: "00"
    }, {
        value: 1,
        label: "01"
    }, {
        value: 2,
        label: "02"
    }, {
        value: 3,
        label: "03"
    }, {
        value: 4,
        label: "04"
    }, {
        value: 5,
        label: "05"
    }, {
        value: 6,
        label: "06"
    }, {
        value: 7,
        label: "07"
    }, {
        value: 8,
        label: "08"
    }, {
        value: 9,
        label: "09"
    }, {
        value: 10,
        label: "10"
    }, {
        value: 11,
        label: "11"
    }, {
        value: 12,
        label: "12"
    }, {
        value: 13,
        label: "13"
    }, {
        value: 14,
        label: "14"
    }, {
        value: 15,
        label: "15"
    }, {
        value: 16,
        label: "16"
    }, {
        value: 17,
        label: "17"
    }, {
        value: 18,
        label: "18"
    }, {
        value: 19,
        label: "19"
    }, {
        value: 20,
        label: "20"
    }, {
        value: 21,
        label: "21"
    }, {
        value: 22,
        label: "22"
    }, {
        value: 23,
        label: "23"
    }
], RD = {
    D(e) {
        return e.day
    },
    DD(e) {
        return cn(e.day)
    },
    Do(e, t) {
        return t.DoFn(e.day)
    },
    d(e) {
        return e.weekday - 1
    },
    dd(e) {
        return cn(e.weekday - 1)
    },
    W(e, t) {
        return t.dayNamesNarrow[e.weekday - 1]
    },
    WW(e, t) {
        return t.dayNamesShorter[e.weekday - 1]
    },
    WWW(e, t) {
        return t.dayNamesShort[e.weekday - 1]
    },
    WWWW(e, t) {
        return t.dayNames[e.weekday - 1]
    },
    M(e) {
        return e.month
    },
    MM(e) {
        return cn(e.month)
    },
    MMM(e, t) {
        return t.monthNamesShort[e.month - 1]
    },
    MMMM(e, t) {
        return t.monthNames[e.month - 1]
    },
    YY(e) {
        return String(e.year).substring(2)
    },
    YYYY(e) {
        return cn(e.year, 4)
    },
    h(e) {
        return e.hours % 12 || 12
    },
    hh(e) {
        return cn(e.hours % 12 || 12)
    },
    H(e) {
        return e.hours
    },
    HH(e) {
        return cn(e.hours)
    },
    m(e) {
        return e.minutes
    },
    mm(e) {
        return cn(e.minutes)
    },
    s(e) {
        return e.seconds
    },
    ss(e) {
        return cn(e.seconds)
    },
    S(e) {
        return Math.round(e.milliseconds / 100)
    },
    SS(e) {
        return cn(Math.round(e.milliseconds / 10), 2)
    },
    SSS(e) {
        return cn(e.milliseconds, 3)
    },
    a(e, t) {
        return e.hours < 12 ? t.amPm[0] : t.amPm[1]
    },
    A(e, t) {
        return e.hours < 12 ? t.amPm[0].toUpperCase() : t.amPm[1].toUpperCase()
    },
    Z() {
        return "Z"
    },
    ZZ(e) {
        const t = e.timezoneOffset;
        return `${t > 0 ? "-" : "+"}${cn(Math.floor(Math.abs(t) / 60), 2)}`
    },
    ZZZ(e) {
        const t = e.timezoneOffset;
        return `${t > 0 ? "-" : "+"}${cn(Math.floor(Math.abs(t) / 60) * 100 + Math.abs(t) % 60, 4)}`
    },
    ZZZZ(e) {
        const t = e.timezoneOffset;
        return `${t > 0 ? "-" : "+"}${cn(Math.floor(Math.abs(t) / 60), 2)}:${cn(Math.abs(t) % 60, 2)}`
    }
}, Dn = {
    D: [Sl, (e, t) => {
            e.day = t
        }
    ],
    Do: [new RegExp(Sl.source + Qh.source), (e, t) => {
            e.day = parseInt(t, 10)
        }
    ],
    d: [Sl, DD],
    W: [Qh, DD],
    M: [Sl, (e, t) => {
            e.month = t - 1
        }
    ],
    MMM: [Qh, ND("monthNamesShort")],
    MMMM: [Qh, ND("monthNames")],
    YY: [Sl, (e, t) => {
            const r = +new Date().getFullYear().toString().substring(0, 2);
            e.year = `${t > 68 ? r - 1 : r}${t}`
        }
    ],
    YYYY: [JLe, (e, t) => {
            e.year = t
        }
    ],
    S: [/\d/, (e, t) => {
            e.millisecond = t * 100
        }
    ],
    SS: [/\d{2}/, (e, t) => {
            e.millisecond = t * 10
        }
    ],
    SSS: [XLe, (e, t) => {
            e.millisecond = t
        }
    ],
    h: [Sl, (e, t) => {
            e.hour = t
        }
    ],
    m: [Sl, (e, t) => {
            e.minute = t
        }
    ],
    s: [Sl, (e, t) => {
            e.second = t
        }
    ],
    a: [Qh, (e, t, n) => {
            const r = t.toLowerCase();
            r === n.amPm[0] ? e.isPm = !1 : r === n.amPm[1] && (e.isPm = !0)
        }
    ],
    Z: [/[^\s]*?[+-]\d\d:?\d\d|[^\s]*?Z?/, (e, t) => {
            t === "Z" && (t = "+00:00");
            const n = `${t}`.match(/([+-]|\d\d)/gi);
            if (n) {
                const r =  + (n[1] * 60) + parseInt(n[2], 10);
                e.timezoneOffset = n[0] === "+" ? r : -r
            }
        }
    ]
};
Dn.DD = Dn.D;
Dn.dd = Dn.d;
Dn.WWWW = Dn.WWW = Dn.WW = Dn.W;
Dn.MM = Dn.M;
Dn.mm = Dn.m;
Dn.hh = Dn.H = Dn.HH = Dn.h;
Dn.ss = Dn.s;
Dn.A = Dn.a;
Dn.ZZZZ = Dn.ZZZ = Dn.ZZ = Dn.Z;
function n6e(e, t) {
    const n = new Intl.DateTimeFormat().resolvedOptions().locale;
    let r;
    Vl(e) ? r = e : KI(e, "id") && (r = e.id),
    r = (r || n).toLowerCase();
    const o = Object.keys(t),
    i = a => o.find(l => l.toLowerCase() === a);
    r = i(r) || i(r.substring(0, 2)) || n;
    const s = sn(ct(ct({}, t["en-IE"]), t[r]), {
        id: r
    });
    return e = Ji(e) ? YI(e, s) : s,
    e
}
class zy {
    constructor(t, {
        locales: n = is,
        timezone: r
    } = {}) {
        const {
            id: o,
            firstDayOfWeek: i,
            masks: s
        } = n6e(t, n);
        this.id = o,
        this.daysInWeek = _o,
        this.firstDayOfWeek = sIe(i, 1, _o),
        this.masks = s,
        this.timezone = r || void 0,
        this.dayNames = this.getDayNames("long"),
        this.dayNamesShort = this.getDayNames("short"),
        this.dayNamesShorter = this.dayNamesShort.map(a => a.substring(0, 2)),
        this.dayNamesNarrow = this.getDayNames("narrow"),
        this.monthNames = this.getMonthNames("long"),
        this.monthNamesShort = this.getMonthNames("short"),
        this.amPm = ["am", "pm"],
        this.monthData = {},
        this.getMonthComps = this.getMonthComps.bind(this),
        this.parse = this.parse.bind(this),
        this.format = this.format.bind(this),
        this.toPage = this.toPage.bind(this)
    }
    format(t, n) {
        if (t = this.normalizeDate(t), !t)
            return "";
        n = this.normalizeMasks(n)[0];
        const r = [];
        n = n.replace(ZLe, (s, a) => (r.push(a), "??"));
        const o = /Z$/.test(n) ? "utc" : this.timezone,
        i = this.getDateParts(t, o);
        return n = n.replace(AD, s => s in RD ? RD[s](i, this) : s.slice(1, s.length - 1)),
        n.replace(/\?\?/g, () => r.shift())
    }
    parse(t, n) {
        return this.normalizeMasks(n).map(o => {
            if (typeof o != "string")
                throw new Error("Invalid mask in fecha.parse");
            let i = t;
            if (i.length > 1e3)
                return !1;
            let s = !0;
            const a = {};
            if (o.replace(AD, u => {
                    if (Dn[u]) {
                        const f = Dn[u],
                        p = i.search(f[0]);
                        ~p ? i.replace(f[0], m => (f[1](a, m, this), i = i.substring(p + m.length), m)) : s = !1
                    }
                    return Dn[u] ? "" : u.slice(1, u.length - 1)
                }), !s)
                return !1;
            const l = new Date;
            a.isPm === !0 && a.hour != null && +a.hour != 12 ? a.hour = +a.hour + 12 : a.isPm === !1 && +a.hour == 12 && (a.hour = 0);
            let c;
            return a.timezoneOffset != null ? (a.minute =  + (a.minute || 0) - +a.timezoneOffset, c = new Date(Date.UTC(a.year || l.getFullYear(), a.month || 0, a.day || 1, a.hour || 0, a.minute || 0, a.second || 0, a.millisecond || 0))) : c = this.getDateFromParts({
                year: a.year || l.getFullYear(),
                month: (a.month || 0) + 1,
                day: a.day || 1,
                hours: a.hour || 0,
                minutes: a.minute || 0,
                seconds: a.second || 0,
                milliseconds: a.millisecond || 0
            }),
            c
        }).find(o => o) || new Date(t)
    }
    normalizeMasks(t) {
        return (Ui(t) && t || [Vl(t) && t || "YYYY-MM-DD"]).map(n => QLe.reduce((r, o) => r.replace(o, this.masks[o] || ""), n))
    }
    normalizeDate(t, n = {}) {
        let r = null, {
            type: o,
            fillDate: i
        } = n;
        const {
            mask: s,
            patch: a,
            time: l
        } = n,
        c = o === "auto" || !o;
        if (Rp(t) ? (o = "number", r = new Date(+t)) : Vl(t) ? (o = "string", r = t ? this.parse(t, s || "iso") : null) : Ji(t) ? (o = "object", r = this.getDateFromParts(t)) : (o = "date", r = Yl(t) ? new Date(t.getTime()) : null), r && a) {
            i = i == null ? new Date : this.normalizeDate(i);
            const u = ct(ct({}, this.getDateParts(i)), FNe(this.getDateParts(r), GLe[a]));
            r = this.getDateFromParts(u)
        }
        return c && (n.type = o),
        r && !isNaN(r.getTime()) ? (l && (r = this.adjustTimeForDate(r, {
                    timeAdjust: l
                })), r) : null
    }
    denormalizeDate(t, {
        type: n,
        mask: r
    } = {}) {
        switch (n) {
        case "number":
            return t ? t.getTime() : NaN;
        case "string":
            return t ? this.format(t, r || "iso") : "";
        default:
            return t ? new Date(t) : null
        }
    }
    hourIsValid(t, n, r) {
        if (!n)
            return !0;
        if (Fo(n))
            return n.includes(t);
        if (Ji(n)) {
            const o = n.min || 0,
            i = n.max || 24;
            return o <= t && i >= t
        }
        return n(t, r)
    }
    getHourOptions(t, n) {
        return t6e.filter(r => this.hourIsValid(r.value, t, n))
    }
    getMinuteOptions(t) {
        const n = [];
        t = t > 0 ? t : 1;
        for (let r = 0; r <= 59; r += t)
            n.push({
                value: r,
                label: cn(r, 2)
            });
        return n
    }
    nearestOptionValue(t, n) {
        if (t == null)
            return t;
        const r = n.reduce((o, i) => {
            if (i.disabled)
                return o;
            if (isNaN(o))
                return i.value;
            const s = Math.abs(o - t);
            return Math.abs(i.value - t) < s ? i.value : o
        }, NaN);
        return isNaN(r) ? t : r
    }
    adjustTimeForDate(t, {
        timeAdjust: n,
        validHours: r,
        minuteIncrement: o
    }) {
        if (!n && !r && !o)
            return t;
        const i = this.getDateParts(t);
        if (n)
            if (n === "now") {
                const s = this.getDateParts(new Date);
                i.hours = s.hours,
                i.minutes = s.minutes,
                i.seconds = s.seconds,
                i.milliseconds = s.milliseconds
            } else {
                const s = new Date(`2000-01-01T${n}Z`);
                i.hours = s.getUTCHours(),
                i.minutes = s.getUTCMinutes(),
                i.seconds = s.getUTCSeconds(),
                i.milliseconds = s.getUTCMilliseconds()
            }
        if (r) {
            const s = this.getHourOptions(r, i);
            i.hours = this.nearestOptionValue(i.hours, s)
        }
        if (o) {
            const s = this.getMinuteOptions(o);
            i.minutes = this.nearestOptionValue(i.minutes, s)
        }
        return t = this.getDateFromParts(i),
        t
    }
    normalizeDates(t, n) {
        return n = n || {},
        n.locale = this,
        (Fo(t) ? t : [t]).map(r => r && (r instanceof Cr ? r : new Cr(r, n))).filter(r => r)
    }
    getDateParts(t, n = this.timezone) {
        if (!t)
            return null;
        let r = t;
        if (n) {
            const C = new Date(t.toLocaleString("en-US", {
                        timeZone: n
                    }));
            C.setMilliseconds(t.getMilliseconds());
            const x = C.getTime() - t.getTime();
            r = new Date(t.getTime() + x)
        }
        const o = r.getMilliseconds(),
        i = r.getSeconds(),
        s = r.getMinutes(),
        a = r.getHours(),
        l = r.getMonth() + 1,
        c = r.getFullYear(),
        u = this.getMonthComps(l, c),
        f = r.getDate(),
        p = u.days - f + 1,
        m = r.getDay() + 1,
        v = Math.floor((f - 1) / 7 + 1),
        y = Math.floor((u.days - f) / 7 + 1),
        b = Math.ceil((f + Math.abs(u.firstWeekday - u.firstDayOfWeek)) / 7),
        w = u.weeks - b + 1,
        k = {
            milliseconds: o,
            seconds: i,
            minutes: s,
            hours: a,
            day: f,
            dayFromEnd: p,
            weekday: m,
            weekdayOrdinal: v,
            weekdayOrdinalFromEnd: y,
            week: b,
            weekFromEnd: w,
            month: l,
            year: c,
            date: t,
            isValid: !0
        };
        return k.timezoneOffset = this.getTimezoneOffset(k),
        k
    }
    getDateFromParts(t) {
        if (!t)
            return null;
        const n = new Date, {
            year: r = n.getFullYear(),
            month: o = n.getMonth() + 1,
            day: i = n.getDate(),
            hours: s = 0,
            minutes: a = 0,
            seconds: l = 0,
            milliseconds: c = 0
        } = t;
        if (this.timezone) {
            const u = `${cn(r, 4)}-${cn(o, 2)}-${cn(i, 2)}T${cn(s, 2)}:${cn(a, 2)}:${cn(l, 2)}.${cn(c, 3)}`;
            return PD(u, {
                timeZone: this.timezone
            })
        }
        return new Date(r, o - 1, i, s, a, l, c)
    }
    getTimezoneOffset(t) {
        const {
            year: n,
            month: r,
            day: o,
            hours: i = 0,
            minutes: s = 0,
            seconds: a = 0,
            milliseconds: l = 0
        } = t;
        let c;
        const u = new Date(Date.UTC(n, r - 1, o, i, s, a, l));
        if (this.timezone) {
            const f = `${cn(n, 4)}-${cn(r, 2)}-${cn(o, 2)}T${cn(i, 2)}:${cn(s, 2)}:${cn(a, 2)}.${cn(l, 3)}`;
            c = PD(f, {
                timeZone: this.timezone
            })
        } else
            c = new Date(n, r - 1, o, i, s, a, l);
        return (c - u) / 6e4
    }
    toPage(t, n) {
        return Rp(t) ? Fa(n, t) : Vl(t) ? this.getDateParts(this.normalizeDate(t)) : Yl(t) ? this.getDateParts(t) : Ji(t) ? t : null
    }
    getMonthDates(t = 2e3) {
        const n = [];
        for (let r = 0; r < 12; r++)
            n.push(new Date(t, r, 15));
        return n
    }
    getMonthNames(t) {
        const n = new Intl.DateTimeFormat(this.id, {
            month: t,
            timezome: "UTC"
        });
        return this.getMonthDates().map(r => n.format(r))
    }
    getWeekdayDates(t = this.firstDayOfWeek) {
        const n = [],
        i = 5 + t - 1;
        for (let s = 0; s < _o; s++)
            n.push(this.getDateFromParts({
                    year: 2020,
                    month: 1,
                    day: i + s,
                    hours: 12
                }));
        return n
    }
    getDayNames(t) {
        const n = new Intl.DateTimeFormat(this.id, {
            weekday: t,
            timeZone: this.timezone
        });
        return this.getWeekdayDates(1).map(r => n.format(r))
    }
    getMonthComps(t, n) {
        const r = `${t}-${n}`;
        let o = this.monthData[r];
        if (!o) {
            const i = n % 4 === 0 && n % 100 !== 0 || n % 400 === 0,
            s = new Date(n, t - 1, 1),
            a = s.getDay() + 1,
            l = t === 2 && i ? 29 : e6e[t - 1],
            c = this.firstDayOfWeek - 1,
            u = YLe(s, {
                weekStartsOn: c
            }),
            f = [],
            p = [];
            for (let m = 0; m < u; m++) {
                const v = qs(s, m * 7);
                f.push(WLe(v, {
                        weekStartsOn: c
                    })),
                p.push(BLe(v))
            }
            o = {
                firstDayOfWeek: this.firstDayOfWeek,
                inLeapYear: i,
                firstWeekday: a,
                days: l,
                weeks: u,
                month: t,
                year: n,
                weeknumbers: f,
                isoWeeknumbers: p
            },
            this.monthData[r] = o
        }
        return o
    }
    getThisMonthComps() {
        const {
            month: t,
            year: n
        } = this.getDateParts(new Date);
        return this.getMonthComps(t, n)
    }
    getPrevMonthComps(t, n) {
        return t === 1 ? this.getMonthComps(12, n - 1) : this.getMonthComps(t - 1, n)
    }
    getNextMonthComps(t, n) {
        return t === 12 ? this.getMonthComps(1, n + 1) : this.getMonthComps(t + 1, n)
    }
    getDayId(t) {
        return this.format(t, "YYYY-MM-DD")
    }
    getCalendarDays({
        weeks: t,
        monthComps: n,
        prevMonthComps: r,
        nextMonthComps: o
    }) {
        const i = [], {
            firstDayOfWeek: s,
            firstWeekday: a,
            isoWeeknumbers: l,
            weeknumbers: c
        } = n,
        u = a + (a < s ? _o : 0) - s;
        let f = !0,
        p = !1,
        m = !1;
        const v = new Intl.DateTimeFormat(this.id, {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric"
        });
        let y = r.days - u + 1,
        b = r.days - y + 1,
        w = Math.floor((y - 1) / _o + 1),
        k = 1,
        C = r.weeks,
        x = 1,
        S = r.month,
        T = r.year;
        const E = new Date,
        M = E.getDate(),
        N = E.getMonth() + 1,
        F = E.getFullYear(),
        K = (j, G, Y) => (ue, re, de, Se) => this.normalizeDate({
            year: j,
            month: G,
            day: Y,
            hours: ue,
            minutes: re,
            seconds: de,
            milliseconds: Se
        });
        for (let j = 1; j <= t; j++) {
            for (let G = 1, Y = s; G <= _o; G++, Y += Y === _o ? 1 - _o : 1) {
                f && Y === a && (y = 1, b = n.days, w = Math.floor((y - 1) / _o + 1), k = Math.floor((n.days - y) / _o + 1), C = 1, x = n.weeks, S = n.month, T = n.year, f = !1, p = !0);
                const ue = K(T, S, y),
                re = {
                    start: ue(0, 0, 0),
                    end: ue(23, 59, 59, 999)
                },
                de = re.start,
                Se = `${cn(T, 4)}-${cn(S, 2)}-${cn(y, 2)}`,
                Pe = G,
                je = _o - G,
                Ke = c[j - 1],
                Ue = l[j - 1],
                yt = y === M && S === N && T === F,
                at = p && y === 1,
                le = p && y === n.days,
                ye = j === 1,
                ge = j === t,
                pe = G === 1,
                xe = G === _o;
                i.push({
                    id: Se,
                    label: y.toString(),
                    ariaLabel: v.format(new Date(T, S - 1, y)),
                    day: y,
                    dayFromEnd: b,
                    weekday: Y,
                    weekdayPosition: Pe,
                    weekdayPositionFromEnd: je,
                    weekdayOrdinal: w,
                    weekdayOrdinalFromEnd: k,
                    week: C,
                    weekFromEnd: x,
                    weeknumber: Ke,
                    isoWeeknumber: Ue,
                    month: S,
                    year: T,
                    dateFromTime: ue,
                    date: de,
                    range: re,
                    isToday: yt,
                    isFirstDay: at,
                    isLastDay: le,
                    inMonth: p,
                    inPrevMonth: f,
                    inNextMonth: m,
                    onTop: ye,
                    onBottom: ge,
                    onLeft: pe,
                    onRight: xe,
                    classes: [`id-${Se}`, `day-${y}`, `day-from-end-${b}`, `weekday-${Y}`, `weekday-position-${Pe}`, `weekday-ordinal-${w}`, `weekday-ordinal-from-end-${k}`, `week-${C}`, `week-from-end-${x}`, {
                            "is-today": yt,
                            "is-first-day": at,
                            "is-last-day": le,
                            "in-month": p,
                            "in-prev-month": f,
                            "in-next-month": m,
                            "on-top": ye,
                            "on-bottom": ge,
                            "on-left": pe,
                            "on-right": xe
                        }
                    ]
                }),
                p && le ? (p = !1, m = !0, y = 1, b = o.days, w = 1, k = Math.floor((o.days - y) / _o + 1), C = 1, x = o.weeks, S = o.month, T = o.year) : (y++, b--, w = Math.floor((y - 1) / _o + 1), k = Math.floor((n.days - y) / _o + 1))
            }
            C++,
            x--
        }
        return i
    }
}
let m9 = class {
    constructor({
        key: t,
        hashcode: n,
        highlight: r,
        content: o,
        dot: i,
        bar: s,
        popover: a,
        dates: l,
        excludeDates: c,
        excludeMode: u,
        customData: f,
        order: p,
        pinPage: m
    }, v, y) {
        this.key = ACe(t) ? Fy() : t,
        this.hashcode = n,
        this.customData = f,
        this.order = p || 0,
        this.dateOpts = {
            order: p,
            locale: y
        },
        this.pinPage = m,
        r && (this.highlight = v.normalizeHighlight(r)),
        o && (this.content = v.normalizeContent(o)),
        i && (this.dot = v.normalizeDot(i)),
        s && (this.bar = v.normalizeBar(s)),
        a && (this.popover = a),
        this.dates = y.normalizeDates(l, this.dateOpts),
        this.hasDates = !!Ui(this.dates),
        this.excludeDates = y.normalizeDates(c, this.dateOpts),
        this.hasExcludeDates = !!Ui(this.excludeDates),
        this.excludeMode = u || "intersects",
        this.hasExcludeDates && !this.hasDates && (this.dates.push(new Cr({}, this.dateOpts)), this.hasDates = !0),
        this.isComplex = dLe(this.dates, b => b.isComplex)
    }
    intersectsDate(t) {
        return t = t instanceof Cr ? t : new Cr(t, this.dateOpts),
        !this.excludesDate(t) && (this.dates.find(n => n.intersectsDate(t)) || !1)
    }
    includesDate(t) {
        return t = t instanceof Cr ? t : new Cr(t, this.dateOpts),
        !this.excludesDate(t) && (this.dates.find(n => n.includesDate(t)) || !1)
    }
    excludesDate(t) {
        return t = t instanceof Cr ? t : new Cr(t, this.dateOpts),
        this.hasExcludeDates && this.excludeDates.find(n => this.excludeMode === "intersects" && n.intersectsDate(t) || this.excludeMode === "includes" && n.includesDate(t))
    }
    intersectsDay(t) {
        return !this.excludesDay(t) && (this.dates.find(n => n.intersectsDay(t)) || !1)
    }
    excludesDay(t) {
        return this.hasExcludeDates && this.excludeDates.find(n => n.intersectsDay(t))
    }
};
const r6e = 300, o6e = 60, i6e = 80;
var s6e = {
    maxSwipeTime: r6e,
    minHorizontalSwipeDistance: o6e,
    maxVerticalSwipeDistance: i6e
};
const a6e = "MMMM YYYY", l6e = "W", c6e = "MMM", u6e = ["L", "YYYY-MM-DD", "YYYY/MM/DD"], d6e = ["L h:mm A", "YYYY-MM-DD h:mm A", "YYYY/MM/DD h:mm A"], f6e = ["L HH:mm", "YYYY-MM-DD HH:mm", "YYYY/MM/DD HH:mm"], h6e = ["h:mm A"], p6e = ["HH:mm"], m6e = "WWW, MMM D, YYYY", g6e = ["L", "YYYY-MM-DD", "YYYY/MM/DD"], v6e = "iso", y6e = "YYYY-MM-DDTHH:mm:ss.SSSZ";
var w6e = {
    title: a6e,
    weekdays: l6e,
    navMonths: c6e,
    input: u6e,
    inputDateTime: d6e,
    inputDateTime24hr: f6e,
    inputTime: h6e,
    inputTime24hr: p6e,
    dayPopover: m6e,
    data: g6e,
    model: v6e,
    iso: y6e
};
const b6e = "640px", _6e = "768px", k6e = "1024px", x6e = "1280px";
var S6e = {
    sm: b6e,
    md: _6e,
    lg: k6e,
    xl: x6e
};
const C6e = {
    componentPrefix: "v",
    color: "blue",
    isDark: !1,
    navVisibility: "click",
    titlePosition: "center",
    transition: "slide-h",
    touch: s6e,
    masks: w6e,
    screens: S6e,
    locales: is,
    datePicker: {
        updateOnInput: !0,
        inputDebounce: 1e3,
        popover: {
            visibility: "hover-focus",
            placement: "bottom-start",
            keepVisibleOnInput: !1,
            isInteractive: !0
        }
    }
}, Bx = es(C6e), I6e = ne(() => q$e(Bx.locales, e => (e.masks = YI(e.masks, Bx.masks), e))), Kl = e => window && KI(window.__vcalendar__, e) ? $m(window.__vcalendar__, e) : $m(Bx, e), T6e = {
    props: {
        color: {
            type: String,
        default:
            () => Kl("color")
        },
        isDark: {
            type: Boolean,
        default:
            () => Kl("isDark")
        },
        firstDayOfWeek: Number,
        masks: Object,
        locale: [String, Object],
        timezone: String,
        minDate: null,
        maxDate: null,
        minDateExact: null,
        maxDateExact: null,
        disabledDates: null,
        availableDates: null,
        theme: null
    },
    computed: {
        $theme() {
            return this.theme instanceof xD ? this.theme : new xD({
                color: this.color,
                isDark: this.isDark
            })
        },
        $locale() {
            if (this.locale instanceof zy)
                return this.locale;
            const e = Ji(this.locale) ? this.locale : {
                id: this.locale,
                firstDayOfWeek: this.firstDayOfWeek,
                masks: this.masks
            };
            return new zy(e, {
                locales: I6e.value,
                timezone: this.timezone
            })
        },
        disabledDates_() {
            const e = this.normalizeDates(this.disabledDates), {
                minDate: t,
                minDateExact: n,
                maxDate: r,
                maxDateExact: o
            } = this;
            if (n || t) {
                const i = n ? this.normalizeDate(n) : this.normalizeDate(t, {
                    time: "00:00:00"
                });
                e.push({
                    start: null,
                    end: new Date(i.getTime() - 1e3)
                })
            }
            if (o || r) {
                const i = o ? this.normalizeDate(o) : this.normalizeDate(r, {
                    time: "23:59:59"
                });
                e.push({
                    start: new Date(i.getTime() + 1e3),
                    end: null
                })
            }
            return e
        },
        availableDates_() {
            return this.normalizeDates(this.availableDates)
        },
        disabledAttribute() {
            return new m9({
                key: "disabled",
                dates: this.disabledDates_,
                excludeDates: this.availableDates_,
                excludeMode: "includes",
                order: 100
            }, this.$theme, this.$locale)
        }
    },
    methods: {
        formatDate(e, t) {
            return this.$locale ? this.$locale.format(e, t) : ""
        },
        parseDate(e, t) {
            if (!this.$locale)
                return null;
            const n = this.$locale.parse(e, t);
            return Yl(n) ? n : null
        },
        normalizeDate(e, t) {
            return this.$locale ? this.$locale.normalizeDate(e, t) : e
        },
        normalizeDates(e) {
            return this.$locale.normalizeDates(e, {
                isFullDay: !0
            })
        },
        pageForDate(e) {
            return this.$locale.getDateParts(this.normalizeDate(e))
        },
        pageForThisMonth() {
            return this.pageForDate(new Date)
        }
    }
}, M6e = {
    methods: {
        safeSlot(e, t, n = null) {
            return Ya(this.$slots[e]) ? this.$slots[e](t) : n
        }
    }
}, Fw = vLe, g9 = T6e, GI = M6e, P6e = {
    name: "PopoverRow",
    mixins: [Fw],
    props: {
        attribute: Object
    },
    computed: {
        indicator() {
            const {
                highlight: e,
                dot: t,
                bar: n,
                popover: r
            } = this.attribute;
            if (r && r.hideIndicator)
                return null;
            if (e) {
                const {
                    color: o,
                    isDark: i
                } = e.start;
                return {
                    style: sn(ct({}, this.theme.bgAccentHigh({
                                color: o,
                                isDark: !i
                            })), {
                        width: "10px",
                        height: "5px",
                        borderRadius: "3px"
                    })
                }
            }
            if (t) {
                const {
                    color: o,
                    isDark: i
                } = t.start;
                return {
                    style: sn(ct({}, this.theme.bgAccentHigh({
                                color: o,
                                isDark: !i
                            })), {
                        width: "5px",
                        height: "5px",
                        borderRadius: "50%"
                    })
                }
            }
            if (n) {
                const {
                    color: o,
                    isDark: i
                } = n.start;
                return {
                    style: sn(ct({}, this.theme.bgAccentHigh({
                                color: o,
                                isDark: !i
                            })), {
                        width: "10px",
                        height: "3px"
                    })
                }
            }
            return null
        }
    }
}, E6e = {
    class: "vc-day-popover-row"
}, O6e = {
    key: 0,
    class: "vc-day-popover-row-indicator"
}, $6e = {
    class: "vc-day-popover-row-content"
};
function A6e(e, t, n, r, o, i) {
    return _(),
    O("div", E6e, [i.indicator ? (_(), O("div", O6e, [P("span", {
                            style: Yt(i.indicator.style),
                            class: he(i.indicator.class)
                        }, null, 6)])) : J("", !0), P("div", $6e, [Ye(e.$slots, "default", {}, () => [mt(Re(n.attribute.popover ? n.attribute.popover.label : "No content provided"), 1)])])])
}
var D6e = gh(P6e, [["render", A6e]]);
const Nv = "26px", N6e = "0 0 32 32", R6e = {
    "left-arrow": {
        viewBox: "0 -1 16 34",
        path: "M11.196 10c0 0.143-0.071 0.304-0.179 0.411l-7.018 7.018 7.018 7.018c0.107 0.107 0.179 0.268 0.179 0.411s-0.071 0.304-0.179 0.411l-0.893 0.893c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-8.321-8.321c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l8.321-8.321c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l0.893 0.893c0.107 0.107 0.179 0.25 0.179 0.411z"
    },
    "right-arrow": {
        viewBox: "-5 -1 16 34",
        path: "M10.625 17.429c0 0.143-0.071 0.304-0.179 0.411l-8.321 8.321c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-0.893-0.893c-0.107-0.107-0.179-0.25-0.179-0.411 0-0.143 0.071-0.304 0.179-0.411l7.018-7.018-7.018-7.018c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l0.893-0.893c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l8.321 8.321c0.107 0.107 0.179 0.268 0.179 0.411z"
    }
}, L6e = {
    props: ["name"],
    data() {
        return {
            width: Nv,
            height: Nv,
            viewBox: N6e,
            path: "",
            isBaseline: !1
        }
    },
    mounted() {
        this.updateIcon()
    },
    watch: {
        name() {
            this.updateIcon()
        }
    },
    methods: {
        updateIcon() {
            const e = R6e[this.name];
            e && (this.width = e.width || Nv, this.height = e.height || Nv, this.viewBox = e.viewBox, this.path = e.path)
        }
    }
}, B6e = ["width", "height", "viewBox"], V6e = ["d"];
function F6e(e, t, n, r, o, i) {
    return _(),
    O("svg", {
        class: "vc-svg-icon",
        width: o.width,
        height: o.height,
        viewBox: o.viewBox
    }, [P("path", {
                d: o.path
            }, null, 8, V6e)], 8, B6e)
}
var v9 = gh(L6e, [["render", F6e]]);
const v2 = 12, j6e = {
    name: "CalendarNav",
    emits: ["input"],
    components: {
        SvgIcon: v9
    },
    mixins: [Fw],
    props: {
        value: {
            type: Object,
        default:
            () => ({
                month: 0,
                year: 0
            })
        },
        validator: {
            type: Function,
        default:
            () => () => !0
        }
    },
    data() {
        return {
            monthMode: !0,
            yearIndex: 0,
            yearGroupIndex: 0,
            onSpaceOrEnter: f9
        }
    },
    computed: {
        month() {
            return this.value && this.value.month || 0
        },
        year() {
            return this.value && this.value.year || 0
        },
        title() {
            return this.monthMode ? this.yearIndex : `${this.firstYear} - ${this.lastYear}`
        },
        monthItems() {
            return this.getMonthItems(this.yearIndex)
        },
        yearItems() {
            return this.getYearItems(this.yearGroupIndex)
        },
        prevItemsEnabled() {
            return this.monthMode ? this.prevMonthItemsEnabled : this.prevYearItemsEnabled
        },
        nextItemsEnabled() {
            return this.monthMode ? this.nextMonthItemsEnabled : this.nextYearItemsEnabled
        },
        prevMonthItemsEnabled() {
            return this.getMonthItems(this.yearIndex - 1).some(e => !e.isDisabled)
        },
        nextMonthItemsEnabled() {
            return this.getMonthItems(this.yearIndex + 1).some(e => !e.isDisabled)
        },
        prevYearItemsEnabled() {
            return this.getYearItems(this.yearGroupIndex - 1).some(e => !e.isDisabled)
        },
        nextYearItemsEnabled() {
            return this.getYearItems(this.yearGroupIndex + 1).some(e => !e.isDisabled)
        },
        activeItems() {
            return this.monthMode ? this.monthItems : this.yearItems
        },
        firstYear() {
            return c9(this.yearItems.map(e => e.year))
        },
        lastYear() {
            return Am(this.yearItems.map(e => e.year))
        }
    },
    watch: {
        year() {
            this.yearIndex = this.year
        },
        yearIndex(e) {
            this.yearGroupIndex = this.getYearGroupIndex(e)
        },
        value() {
            this.focusFirstItem()
        }
    },
    created() {
        this.yearIndex = this.year
    },
    mounted() {
        this.focusFirstItem()
    },
    methods: {
        focusFirstItem() {
            this.$nextTick(() => {
                const e = this.$refs.navContainer.querySelector(".vc-nav-item:not(.is-disabled)");
                e && e.focus()
            })
        },
        getItemClasses({
            isActive: e,
            isCurrent: t,
            isDisabled: n
        }) {
            const r = ["vc-nav-item"];
            return e ? r.push("is-active") : t && r.push("is-current"),
            n && r.push("is-disabled"),
            r
        },
        getYearGroupIndex(e) {
            return Math.floor(e / v2)
        },
        getMonthItems(e) {
            const {
                month: t,
                year: n
            } = this.pageForDate(new Date);
            return this.locale.getMonthDates().map((r, o) => {
                const i = o + 1;
                return {
                    month: i,
                    year: e,
                    id: `${e}.${cn(i, 2)}`,
                    label: this.locale.format(r, this.masks.navMonths),
                    ariaLabel: this.locale.format(r, "MMMM YYYY"),
                    isActive: i === this.month && e === this.year,
                    isCurrent: i === t && e === n,
                    isDisabled: !this.validator({
                        month: i,
                        year: e
                    }),
                    click: () => this.monthClick(i, e)
                }
            })
        },
        getYearItems(e) {
            const {
                _: t,
                year: n
            } = this.pageForDate(new Date),
            r = e * v2,
            o = r + v2,
            i = [];
            for (let s = r; s < o; s += 1) {
                let a = !1;
                for (let l = 1; l < 12 && (a = this.validator({
                            month: l,
                            year: s
                        }), !a); l++);
                i.push({
                    year: s,
                    id: s,
                    label: s,
                    ariaLabel: s,
                    isActive: s === this.year,
                    isCurrent: s === n,
                    isDisabled: !a,
                    click: () => this.yearClick(s)
                })
            }
            return i
        },
        monthClick(e, t) {
            this.validator({
                month: e,
                year: t
            }) && this.$emit("input", {
                month: e,
                year: t
            })
        },
        yearClick(e) {
            this.yearIndex = e,
            this.monthMode = !0,
            this.focusFirstItem()
        },
        toggleMode() {
            this.monthMode = !this.monthMode
        },
        movePrev() {
            this.prevItemsEnabled && (this.monthMode && this.movePrevYear(), this.movePrevYearGroup())
        },
        moveNext() {
            this.nextItemsEnabled && (this.monthMode && this.moveNextYear(), this.moveNextYearGroup())
        },
        movePrevYear() {
            this.yearIndex--
        },
        moveNextYear() {
            this.yearIndex++
        },
        movePrevYearGroup() {
            this.yearGroupIndex--
        },
        moveNextYearGroup() {
            this.yearGroupIndex++
        }
    }
}, W6e = {
    class: "vc-nav-container",
    ref: "navContainer"
}, z6e = {
    class: "vc-nav-header"
}, H6e = ["tabindex"], U6e = ["tabindex"], q6e = {
    class: "vc-nav-items"
}, Y6e = ["data-id", "aria-label", "tabindex", "onClick", "onKeydown"];
function K6e(e, t, n, r, o, i) {
    const s = B("svg-icon");
    return _(),
    O("div", W6e, [P("div", z6e, [P("span", {
                        role: "button",
                        class: he(["vc-nav-arrow is-left", {
                                    "is-disabled": !i.prevItemsEnabled
                                }
                            ]),
                        tabindex: i.prevItemsEnabled ? 0 : void 0,
                        onClick: t[0] || (t[0] = (...a) => i.movePrev && i.movePrev(...a)),
                        onKeydown: t[1] || (t[1] = a => o.onSpaceOrEnter(a, i.movePrev))
                    }, [Ye(e.$slots, "nav-left-button", {}, () => [z(s, {
                                        name: "left-arrow",
                                        width: "20px",
                                        height: "24px"
                                    })])], 42, H6e), P("span", {
                        role: "button",
                        class: "vc-nav-title vc-grid-focus",
                        style: {
                            whiteSpace: "nowrap"
                        },
                        tabindex: "0",
                        onClick: t[2] || (t[2] = (...a) => i.toggleMode && i.toggleMode(...a)),
                        onKeydown: t[3] || (t[3] = a => o.onSpaceOrEnter(a, i.toggleMode))
                    }, Re(i.title), 33), P("span", {
                        role: "button",
                        class: he(["vc-nav-arrow is-right", {
                                    "is-disabled": !i.nextItemsEnabled
                                }
                            ]),
                        tabindex: i.nextItemsEnabled ? 0 : void 0,
                        onClick: t[4] || (t[4] = (...a) => i.moveNext && i.moveNext(...a)),
                        onKeydown: t[5] || (t[5] = a => o.onSpaceOrEnter(a, i.moveNext))
                    }, [Ye(e.$slots, "nav-right-button", {}, () => [z(s, {
                                        name: "right-arrow",
                                        width: "20px",
                                        height: "24px"
                                    })])], 42, U6e)]), P("div", q6e, [(_(!0), O(Le, null, $t(i.activeItems, a => (_(), O("span", {
                                        key: a.label,
                                        role: "button",
                                        "data-id": a.id,
                                        "aria-label": a.ariaLabel,
                                        class: he(i.getItemClasses(a)),
                                        tabindex: a.isDisabled ? void 0 : 0,
                                        onClick: a.click,
                                        onKeydown: l => o.onSpaceOrEnter(l, a.click)
                                    }, Re(a.label), 43, Y6e))), 128))])], 512)
}
var G6e = gh(j6e, [["render", K6e]]);
function Vx(e) {
    document && document.dispatchEvent(new CustomEvent("show-popover", {
            detail: e
        }))
}
function Fx(e) {
    document && document.dispatchEvent(new CustomEvent("hide-popover", {
            detail: e
        }))
}
function y9(e) {
    document && document.dispatchEvent(new CustomEvent("toggle-popover", {
            detail: e
        }))
}
function X6e(e) {
    document && document.dispatchEvent(new CustomEvent("update-popover", {
            detail: e
        }))
}
function Hy(e) {
    const {
        visibility: t
    } = e,
    n = t === "click",
    r = t === "hover",
    o = t === "hover-focus",
    i = t === "focus";
    e.autoHide = !n;
    let s = !1,
    a = !1;
    const {
        isRenderFn: l
    } = e,
    c = {
        click: l ? "onClick" : "click",
        mousemove: l ? "onMousemove" : "mousemove",
        mouseleave: l ? "onMouseleave" : "mouseleave",
        focusin: l ? "onFocusin" : "focusin",
        focusout: l ? "onFocusout" : "focusout"
    };
    return {
        [c.click](u) {
            n && (e.ref = u.target, y9(e), u.stopPropagation())
        },
        [c.mousemove](u) {
            e.ref = u.currentTarget,
            s || (s = !0, (r || o) && Vx(e))
        },
        [c.mouseleave](u) {
            e.ref = u.target,
            s && (s = !1, (r || o && !a) && Fx(e))
        },
        [c.focusin](u) {
            e.ref = u.currentTarget,
            a || (a = !0, (i || o) && Vx(e))
        },
        [c.focusout](u) {
            e.ref = u.currentTarget,
            a && !Vp(e.ref, u.relatedTarget) && (a = !1, (i || o && !s) && Fx(e))
        }
    }
}
const J6e = {
    name: "CalendarDay",
    emits: ["dayclick", "daymouseenter", "daymouseleave", "dayfocusin", "dayfocusout", "daykeydown"],
    mixins: [Fw, GI],
    inheritAttrs: !1,
    render() {
        const e = () => this.hasBackgrounds && dt("div", {
            class: "vc-highlights vc-day-layer"
        }, this.backgrounds.map(({
                    key: o,
                    wrapperClass: i,
                    class: s,
                    style: a
                }) => dt("div", {
                    key: o,
                    class: i
                }, [dt("div", {
                            class: s,
                            style: a
                        })]))),
        t = () => this.safeSlot("day-content", {
            day: this.day,
            attributes: this.day.attributes,
            attributesMap: this.day.attributesMap,
            dayProps: this.dayContentProps,
            dayEvents: this.dayContentEvents
        }) || dt("span", sn(ct(sn(ct({}, this.dayContentProps), {
                        class: this.dayContentClass,
                        style: this.dayContentStyle
                    }), this.dayContentEvents), {
                ref: "content"
            }), [this.day.label]),
        n = () => this.hasDots && dt("div", {
            class: "vc-day-layer vc-day-box-center-bottom"
        }, [dt("div", {
                    class: "vc-dots"
                }, this.dots.map(({
                            key: o,
                            class: i,
                            style: s
                        }) => dt("span", {
                            key: o,
                            class: i,
                            style: s
                        })))]),
        r = () => this.hasBars && dt("div", {
            class: "vc-day-layer vc-day-box-center-bottom"
        }, [dt("div", {
                    class: "vc-bars"
                }, this.bars.map(({
                            key: o,
                            class: i,
                            style: s
                        }) => dt("span", {
                            key: o,
                            class: i,
                            style: s
                        })))]);
        return dt("div", {
            class: ["vc-day", ...this.day.classes, {
                    "vc-day-box-center-center": !this.$slots["day-content"]
                }, {
                    "is-not-in-month": !this.inMonth
                }
            ]
        }, [e(), t(), n(), r()])
    },
    inject: ["sharedState"],
    props: {
        day: {
            type: Object,
            required: !0
        }
    },
    data() {
        return {
            glyphs: {},
            dayContentEvents: {}
        }
    },
    computed: {
        label() {
            return this.day.label
        },
        startTime() {
            return this.day.range.start.getTime()
        },
        endTime() {
            return this.day.range.end.getTime()
        },
        inMonth() {
            return this.day.inMonth
        },
        isDisabled() {
            return this.day.isDisabled
        },
        backgrounds() {
            return this.glyphs.backgrounds
        },
        hasBackgrounds() {
            return !!Ui(this.backgrounds)
        },
        content() {
            return this.glyphs.content
        },
        dots() {
            return this.glyphs.dots
        },
        hasDots() {
            return !!Ui(this.dots)
        },
        bars() {
            return this.glyphs.bars
        },
        hasBars() {
            return !!Ui(this.bars)
        },
        popovers() {
            return this.glyphs.popovers
        },
        hasPopovers() {
            return !!Ui(this.popovers)
        },
        dayContentClass() {
            return ["vc-day-content vc-focusable", {
                    "is-disabled": this.isDisabled
                }, $m(Am(this.content), "class") || ""]
        },
        dayContentStyle() {
            return $m(Am(this.content), "style")
        },
        dayContentProps() {
            let e;
            return this.day.isFocusable ? e = "0" : this.day.inMonth && (e = "-1"), {
                tabindex: e,
                "aria-label": this.day.ariaLabel,
                "aria-disabled": this.day.isDisabled ? "true" : "false",
                role: "button"
            }
        },
        dayEvent() {
            return sn(ct({}, this.day), {
                el: this.$refs.content,
                popovers: this.popovers
            })
        }
    },
    watch: {
        theme() {
            this.refresh()
        },
        popovers() {
            this.refreshPopovers()
        },
        "day.shouldRefresh"() {
            this.refresh()
        }
    },
    mounted() {
        this.refreshPopovers(),
        this.refresh()
    },
    methods: {
        getDayEvent(e) {
            return sn(ct({}, this.dayEvent), {
                event: e
            })
        },
        click(e) {
            this.$emit("dayclick", this.getDayEvent(e))
        },
        mouseenter(e) {
            this.$emit("daymouseenter", this.getDayEvent(e))
        },
        mouseleave(e) {
            this.$emit("daymouseleave", this.getDayEvent(e))
        },
        focusin(e) {
            this.$emit("dayfocusin", this.getDayEvent(e))
        },
        focusout(e) {
            this.$emit("dayfocusout", this.getDayEvent(e))
        },
        keydown(e) {
            this.$emit("daykeydown", this.getDayEvent(e))
        },
        refresh() {
            if (!this.day.shouldRefresh)
                return;
            this.day.shouldRefresh = !1;
            const e = {
                backgrounds: [],
                dots: [],
                bars: [],
                popovers: [],
                content: []
            };
            this.day.attributes = Object.values(this.day.attributesMap || {}).sort((t, n) => t.order - n.order),
            this.day.attributes.forEach(t => {
                const {
                    targetDate: n
                } = t, {
                    isDate: r,
                    isComplex: o,
                    startTime: i,
                    endTime: s
                } = n,
                a = this.startTime <= i,
                l = this.endTime >= s,
                f = {
                    isDate: r,
                    isComplex: o,
                    onStart: a,
                    onEnd: l,
                    onStartAndEnd: a && l,
                    onStartOrEnd: a || l
                };
                this.processHighlight(t, f, e),
                this.processNonHighlight(t, "content", f, e.content),
                this.processNonHighlight(t, "dot", f, e.dots),
                this.processNonHighlight(t, "bar", f, e.bars),
                this.processPopover(t, e)
            }),
            this.glyphs = e
        },
        processHighlight({
            key: e,
            highlight: t
        }, {
            isDate: n,
            isComplex: r,
            onStart: o,
            onEnd: i,
            onStartAndEnd: s
        }, {
            backgrounds: a,
            content: l
        }) {
            if (!t)
                return;
            const {
                base: c,
                start: u,
                end: f
            } = t;
            n || r ? (a.push({
                    key: e,
                    wrapperClass: "vc-day-layer vc-day-box-center-center",
                    class: ["vc-highlight", u.class],
                    style: u.style
                }), l.push({
                    key: `${e}-content`,
                    class: u.contentClass,
                    style: u.contentStyle
                })) : s ? (a.push({
                    key: e,
                    wrapperClass: "vc-day-layer vc-day-box-center-center",
                    class: ["vc-highlight", u.class],
                    style: u.style
                }), l.push({
                    key: `${e}-content`,
                    class: u.contentClass,
                    style: u.contentStyle
                })) : o ? (a.push({
                    key: `${e}-base`,
                    wrapperClass: "vc-day-layer vc-day-box-right-center",
                    class: ["vc-highlight vc-highlight-base-start", c.class],
                    style: c.style
                }), a.push({
                    key: e,
                    wrapperClass: "vc-day-layer vc-day-box-center-center",
                    class: ["vc-highlight", u.class],
                    style: u.style
                }), l.push({
                    key: `${e}-content`,
                    class: u.contentClass,
                    style: u.contentStyle
                })) : i ? (a.push({
                    key: `${e}-base`,
                    wrapperClass: "vc-day-layer vc-day-box-left-center",
                    class: ["vc-highlight vc-highlight-base-end", c.class],
                    style: c.style
                }), a.push({
                    key: e,
                    wrapperClass: "vc-day-layer vc-day-box-center-center",
                    class: ["vc-highlight", f.class],
                    style: f.style
                }), l.push({
                    key: `${e}-content`,
                    class: f.contentClass,
                    style: f.contentStyle
                })) : (a.push({
                    key: `${e}-middle`,
                    wrapperClass: "vc-day-layer vc-day-box-center-center",
                    class: ["vc-highlight vc-highlight-base-middle", c.class],
                    style: c.style
                }), l.push({
                    key: `${e}-content`,
                    class: c.contentClass,
                    style: c.contentStyle
                }))
        },
        processNonHighlight(e, t, {
            isDate: n,
            onStart: r,
            onEnd: o
        }, i) {
            if (!e[t])
                return;
            const {
                key: s
            } = e,
            a = `vc-${t}`, {
                base: l,
                start: c,
                end: u
            } = e[t];
            n || r ? i.push({
                key: s,
                class: [a, c.class],
                style: c.style
            }) : o ? i.push({
                key: s,
                class: [a, u.class],
                style: u.style
            }) : i.push({
                key: s,
                class: [a, l.class],
                style: l.style
            })
        },
        processPopover(e, {
            popovers: t
        }) {
            const {
                key: n,
                customData: r,
                popover: o
            } = e;
            if (!o)
                return;
            const i = Lp({
                key: n,
                customData: r,
                attribute: e
            }, ct({}, o), {
                visibility: o.label ? "hover" : "click",
                placement: "bottom",
                isInteractive: !o.label
            });
            t.splice(0, 0, i)
        },
        refreshPopovers() {
            let e = {};
            Ui(this.popovers) && (e = Hy(Lp({
                            id: this.dayPopoverId,
                            data: this.day,
                            isRenderFn: !0
                        }, ...this.popovers))),
            this.dayContentEvents = fLe({
                onClick: this.click,
                onMouseenter: this.mouseenter,
                onMouseleave: this.mouseleave,
                onFocusin: this.focusin,
                onFocusout: this.focusout,
                onKeydown: this.keydown
            }, e),
            X6e({
                id: this.dayPopoverId,
                data: this.day
            })
        }
    }
}, Z6e = {
    name: "CalendarPane",
    emits: ["update:page", "weeknumberclick"],
    mixins: [Fw, GI],
    inheritAttrs: !1,
    render() {
        const e = this.safeSlot("header", this.page) || dt("div", {
            class: `vc-header align-${this.titlePosition}`
        }, [dt("div", ct({
                            class: "vc-title"
                        }, this.navPopoverEvents), [this.safeSlot("header-title", this.page, this.page.title)])]),
        t = this.weekdayLabels.map((l, c) => dt("div", {
                    key: c + 1,
                    class: "vc-weekday"
                }, [l])),
        n = this.showWeeknumbers_.startsWith("left"),
        r = this.showWeeknumbers_.startsWith("right");
        n ? t.unshift(dt("div", {
                class: "vc-weekday"
            })) : r && t.push(dt("div", {
                class: "vc-weekday"
            }));
        const o = l => dt("div", {
            class: ["vc-weeknumber"]
        }, [dt("span", {
                        class: ["vc-weeknumber-content", `is-${this.showWeeknumbers_}`],
                        onClick: c => {
                            this.$emit("weeknumberclick", {
                                weeknumber: l,
                                days: this.page.days.filter(u => u[this.weeknumberKey] === l),
                                event: c
                            })
                        }
                    }, [l])]),
        i = [], {
            daysInWeek: s
        } = this.locale;
        this.page.days.forEach((l, c) => {
            const u = c % s;
            (n && u === 0 || r && u === s) && i.push(o(l[this.weeknumberKey])),
            i.push(dt(J6e, sn(ct({}, this.$attrs), {
                        day: l
                    }), this.$slots)),
            r && u === s - 1 && i.push(o(l[this.weeknumberKey]))
        });
        const a = dt("div", {
            class: {
                "vc-weeks": !0,
                "vc-show-weeknumbers": this.showWeeknumbers_,
                "is-left": n,
                "is-right": r
            }
        }, [t, i]);
        return dt("div", {
            class: ["vc-pane", `row-from-end-${this.rowFromEnd}`, `column-from-end-${this.columnFromEnd}`],
            ref: "pane"
        }, [e, a])
    },
    props: {
        page: Object,
        position: Number,
        row: Number,
        rowFromEnd: Number,
        column: Number,
        columnFromEnd: Number,
        titlePosition: String,
        navVisibility: {
            type: String,
        default:
            () => Kl("navVisibility")
        },
        showWeeknumbers: [Boolean, String],
        showIsoWeeknumbers: [Boolean, String]
    },
    computed: {
        weeknumberKey() {
            return this.showWeeknumbers ? "weeknumber" : "isoWeeknumber"
        },
        showWeeknumbers_() {
            const e = this.showWeeknumbers || this.showIsoWeeknumbers;
            return e == null ? "" : iCe(e) ? e ? "left" : "" : e.startsWith("right") ? this.columnFromEnd > 1 ? "right" : e : this.column > 1 ? "left" : e
        },
        navPlacement() {
            switch (this.titlePosition) {
            case "left":
                return "bottom-start";
            case "right":
                return "bottom-end";
            default:
                return "bottom"
            }
        },
        navPopoverEvents() {
            const {
                sharedState: e,
                navVisibility: t,
                navPlacement: n,
                page: r,
                position: o
            } = this;
            return Hy({
                id: e.navPopoverId,
                visibility: t,
                placement: n,
                modifiers: [{
                        name: "flip",
                        options: {
                            fallbackPlacements: ["bottom"]
                        }
                    }
                ],
                data: {
                    page: r,
                    position: o
                },
                isInteractive: !0,
                isRenderFn: !0
            })
        },
        weekdayLabels() {
            return this.locale.getWeekdayDates().map(e => this.format(e, this.masks.weekdays))
        }
    }
};
class Q6e {
    constructor(t, n, r) {
        this.theme = t,
        this.locale = n,
        this.map = {},
        this.refresh(r, !0)
    }
    destroy() {
        this.theme = null,
        this.locale = null,
        this.map = {},
        this.list = [],
        this.pinAttr = null
    }
    refresh(t, n) {
        const r = {},
        o = [];
        let i = null;
        const s = [],
        a = n ? new Set : new Set(Object.keys(this.map));
        return Ui(t) && t.forEach((l, c) => {
            if (!l || !l.dates)
                return;
            const u = l.key ? l.key.toString() : c.toString(),
            f = l.order || 0,
            p = pLe(JSON.stringify(l));
            let m = this.map[u];
            !n && m && m.hashcode === p ? a.delete(u) : (m = new m9(ct({
                            key: u,
                            order: f,
                            hashcode: p
                        }, l), this.theme, this.locale), s.push(m)),
            m && m.pinPage && (i = m),
            r[u] = m,
            o.push(m)
        }),
        this.map = r,
        this.list = o,
        this.pinAttr = i, {
            adds: s,
            deletes: Array.from(a)
        }
    }
}
const e8e = (e, t, {
    maxSwipeTime: n,
    minHorizontalSwipeDistance: r,
    maxVerticalSwipeDistance: o
}) => {
    if (!e || !e.addEventListener || !Ya(t))
        return null;
    let i = 0,
    s = 0,
    a = null,
    l = !1;
    function c(f) {
        const p = f.changedTouches[0];
        i = p.screenX,
        s = p.screenY,
        a = new Date().getTime(),
        l = !0
    }
    function u(f) {
        if (!l)
            return;
        l = !1;
        const p = f.changedTouches[0],
        m = p.screenX - i,
        v = p.screenY - s;
        if (new Date().getTime() - a < n && Math.abs(m) >= r && Math.abs(v) <= o) {
            const b = {
                toLeft: !1,
                toRight: !1
            };
            m < 0 ? b.toLeft = !0 : b.toRight = !0,
            t(b)
        }
    }
    return xo(e, "touchstart", c, {
        passive: !0
    }),
    xo(e, "touchend", u, {
        passive: !0
    }),
    () => {
        So(e, "touchstart", c),
        So(e, "touchend", u)
    }
}, t8e = {
    name: "Calendar",
    emits: ["dayfocusin", "dayfocusout", "transition-start", "transition-end", "update:from-page", "update:to-page"],
    render() {
        const e = this.pages.map((o, i) => {
            const s = i + 1,
            a = Math.ceil((i + 1) / this.columns),
            l = this.rows - a + 1,
            c = s % this.columns || this.columns,
            u = this.columns - c + 1;
            return dt(Z6e, sn(ct({}, this.$attrs), {
                    key: o.key,
                    attributes: this.store,
                    page: o,
                    position: s,
                    row: a,
                    rowFromEnd: l,
                    column: c,
                    columnFromEnd: u,
                    titlePosition: this.titlePosition,
                    canMove: this.canMove,
                    "onUpdate:page": f => this.move(f, {
                        position: i + 1
                    }),
                    onDayfocusin: f => {
                        this.lastFocusedDay = f,
                        this.$emit("dayfocusin", f)
                    },
                    onDayfocusout: f => {
                        this.lastFocusedDay = null,
                        this.$emit("dayfocusout", f)
                    }
                }), this.$slots)
        }),
        t = o => {
            const i = () => this.move(o ? -this.step_ : this.step_),
            s = l => f9(l, i),
            a = o ? !this.canMovePrev : !this.canMoveNext;
            return dt("div", {
                class: ["vc-arrow", `is-${o ? "left" : "right"}`, {
                        "is-disabled": a
                    }
                ],
                role: "button",
                onClick: i,
                onKeydown: s
            }, [(o ? this.safeSlot("header-left-button", {
                            click: i
                        }) : this.safeSlot("header-right-button", {
                            click: i
                        })) || dt(v9, {
                        name: o ? "left-arrow" : "right-arrow"
                    })])
        },
        n = () => dt(Lx, {
            id: this.sharedState.navPopoverId,
            contentClass: "vc-nav-popover-container",
            ref: "navPopover"
        }, {
        default:
            ({
                data: o
            }) => {
                const {
                    position: i,
                    page: s
                } = o;
                return dt(G6e, {
                    value: s,
                    position: i,
                    validator: a => this.canMove(a, {
                        position: i
                    }),
                    onInput: a => this.move(a)
                }, ct({}, this.$slots))
            }
        }),
        r = () => dt(Lx, {
            id: this.sharedState.dayPopoverId,
            contentClass: "vc-day-popover-container"
        }, {
        default:
            ({
                data: o,
                updateLayout: i,
                hide: s
            }) => {
                const a = Object.values(o.attributes).filter(f => f.popover),
                l = this.$locale.masks,
                c = this.formatDate,
                u = c(o.date, l.dayPopover);
                return this.safeSlot("day-popover", {
                    day: o,
                    attributes: a,
                    masks: l,
                    format: c,
                    dayTitle: u,
                    updateLayout: i,
                    hide: s
                }, dt("div", [l.dayPopover && dt("div", {
                                class: ["vc-day-popover-header"]
                            }, [u]), a.map(f => dt(D6e, {
                                    key: f.key,
                                    attribute: f
                                }))]))
            }
        });
        return dt("div", {
            "data-helptext": "Press the arrow keys to navigate by day, Home and End to navigate to week ends, PageUp and PageDown to navigate by month, Alt+PageUp and Alt+PageDown to navigate by year",
            class: ["vc-container", `vc-${this.$theme.color}`, {
                    "vc-is-expanded": this.isExpanded,
                    "vc-is-dark": this.$theme.isDark
                }
            ],
            onKeydown: this.handleKeydown,
            onMouseup: o => o.preventDefault(),
            ref: "container"
        }, [n(), dt("div", {
                    class: ["vc-pane-container", {
                            "in-transition": this.inTransition
                        }
                    ]
                }, [dt(h9, {
                            name: this.transitionName,
                            "on-before-enter": () => {
                                this.inTransition = !0
                            },
                            "on-after-enter": () => {
                                this.inTransition = !1
                            }
                        }, {
                        default:
                            () => dt("div", sn(ct({}, this.$attrs), {
                                    class: "vc-pane-layout",
                                    style: {
                                        gridTemplateColumns: `repeat(${this.columns}, 1fr)`
                                    },
                                    key: this.firstPage ? this.firstPage.key : ""
                                }), e)
                        }), dt("div", {
                            class: [`vc-arrows-container title-${this.titlePosition}`]
                        }, [t(!0), t(!1)]), this.$slots.footer && this.$slots.footer()]), r()])
    },
    mixins: [g9, GI],
    provide() {
        return {
            sharedState: this.sharedState
        }
    },
    props: {
        rows: {
            type: Number,
        default:
            1
        },
        columns: {
            type: Number,
        default:
            1
        },
        step: Number,
        titlePosition: {
            type: String,
        default:
            () => Kl("titlePosition")
        },
        isExpanded: Boolean,
        fromDate: Date,
        toDate: Date,
        fromPage: Object,
        toPage: Object,
        minPage: Object,
        maxPage: Object,
        transition: String,
        attributes: [Object, Array],
        trimWeeks: Boolean,
        disablePageSwipe: Boolean
    },
    data() {
        return {
            pages: [],
            store: null,
            lastFocusedDay: null,
            focusableDay: new Date().getDate(),
            transitionName: "",
            inTransition: !1,
            sharedState: {
                navPopoverId: Fy(),
                dayPopoverId: Fy(),
                theme: {},
                masks: {},
                locale: {}
            }
        }
    },
    computed: {
        firstPage() {
            return c9(this.pages)
        },
        lastPage() {
            return Am(this.pages)
        },
        minPage_() {
            return this.minPage || this.pageForDate(this.minDate)
        },
        maxPage_() {
            return this.maxPage || this.pageForDate(this.maxDate)
        },
        count() {
            return this.rows * this.columns
        },
        step_() {
            return this.step || this.count
        },
        canMovePrev() {
            return this.canMove(-this.step_)
        },
        canMoveNext() {
            return this.canMove(this.step_)
        }
    },
    watch: {
        $locale() {
            this.refreshLocale(),
            this.refreshPages({
                page: this.firstPage,
                ignoreCache: !0
            }),
            this.initStore()
        },
        $theme() {
            this.refreshTheme(),
            this.initStore()
        },
        fromDate() {
            this.refreshPages()
        },
        fromPage(e) {
            const t = this.pages && this.pages[0];
            f2(e, t) || this.refreshPages()
        },
        toPage(e) {
            const t = this.pages && this.pages[this.pages.length - 1];
            f2(e, t) || this.refreshPages()
        },
        count() {
            this.refreshPages()
        },
        attributes: {
            handler(e) {
                const {
                    adds: t,
                    deletes: n
                } = this.store.refresh(e);
                this.refreshAttrs(this.pages, t, n)
            },
            deep: !0
        },
        pages(e) {
            this.refreshAttrs(e, this.store.list, null, !0)
        },
        disabledAttribute() {
            this.refreshDisabledDays()
        },
        lastFocusedDay(e) {
            e && (this.focusableDay = e.day, this.refreshFocusableDays())
        },
        inTransition(e) {
            e ? this.$emit("transition-start") : (this.$emit("transition-end"), this.transitionPromise && (this.transitionPromise.resolve(!0), this.transitionPromise = null))
        }
    },
    created() {
        this.refreshLocale(),
        this.refreshTheme(),
        this.initStore(),
        this.refreshPages()
    },
    mounted() {
        this.disablePageSwipe || (this.removeHandlers = e8e(this.$refs.container, ({
                        toLeft: e,
                        toRight: t
                    }) => {
                    e ? this.moveNext() : t && this.movePrev()
                }, Kl("touch")))
    },
    beforeUnmount() {
        this.pages = [],
        this.store.destroy(),
        this.store = null,
        this.sharedState = null,
        this.removeHandlers && this.removeHandlers()
    },
    methods: {
        refreshLocale() {
            this.sharedState.locale = this.$locale,
            this.sharedState.masks = this.$locale.masks
        },
        refreshTheme() {
            this.sharedState.theme = this.$theme
        },
        canMove(e, t = {}) {
            const n = this.firstPage && this.$locale.toPage(e, this.firstPage);
            if (!n)
                return !1;
            let {
                position: r
            } = t;
            if (Rp(e) && (r = 1), !r)
                if (hp(n, this.firstPage))
                    r = -1;
                else if (Bp(n, this.lastPage))
                    r = 1;
                else
                    return !0;
            return Object.assign(t, this.getTargetPageRange(n, {
                    position: r,
                    force: !0
                })),
            hLe(t.fromPage, t.toPage).some(o => d9(o, this.minPage_, this.maxPage_))
        },
        movePrev(e) {
            return this.move(-this.step_, e)
        },
        moveNext(e) {
            return this.move(this.step_, e)
        },
        move(e, t = {}) {
            const n = this.canMove(e, t);
            return !t.force && !n ? Promise.reject(new Error(`Move target is disabled: ${JSON.stringify(t)}`)) : (this.$refs.navPopover.hide({
                    hideDelay: 0
                }), t.fromPage && !f2(t.fromPage, this.firstPage) ? this.refreshPages(sn(ct({}, t), {
                        page: t.fromPage,
                        position: 1,
                        force: !0
                    })) : Promise.resolve(!0))
        },
        focusDate(e, t = {}) {
            return this.move(e, t).then(() => {
                const n = this.$el.querySelector(`.id-${this.$locale.getDayId(e)}.in-month .vc-focusable`);
                return n ? (n.focus(), Promise.resolve(!0)) : Promise.resolve(!1)
            })
        },
        showPageRange(e, t) {
            let n,
            r;
            if (Yl(e))
                n = this.pageForDate(e);
            else if (Ji(e)) {
                const {
                    month: s,
                    year: a
                } = e, {
                    from: l,
                    to: c
                } = e;
                Rp(s) && Rp(a) ? n = e : (l || c) && (n = Yl(l) ? this.pageForDate(l) : l, r = Yl(c) ? this.pageForDate(c) : c)
            } else
                return Promise.reject(new Error("Invalid page range provided."));
            const o = this.lastPage;
            let i = n;
            return Bp(r, o) && (i = Fa(r,  - (this.pages.length - 1))),
            hp(i, n) && (i = n),
            this.refreshPages(sn(ct({}, t), {
                    page: i
                }))
        },
        getTargetPageRange(e, {
            position: t,
            force: n
        } = {}) {
            let r = null,
            o = null;
            if (vi(e)) {
                let i = 0;
                t = +t,
                isNaN(t) || (i = t > 0 ? 1 - t :  - (this.count + t)),
                r = Fa(e, i)
            } else
                r = this.getDefaultInitialPage();
            return o = Fa(r, this.count - 1),
            n || (hp(r, this.minPage_) ? r = this.minPage_ : Bp(o, this.maxPage_) && (r = Fa(this.maxPage_, 1 - this.count)), o = Fa(r, this.count - 1)), {
                fromPage: r,
                toPage: o
            }
        },
        getDefaultInitialPage() {
            let e = this.fromPage || this.pageForDate(this.fromDate);
            if (!vi(e)) {
                const t = this.toPage || this.pageForDate(this.toPage);
                vi(t) && (e = Fa(t, 1 - this.count))
            }
            return vi(e) || (e = this.getPageForAttributes()),
            vi(e) || (e = this.pageForThisMonth()),
            e
        },
        refreshPages({
            page: e,
            position: t = 1,
            force: n,
            transition: r,
            ignoreCache: o
        } = {}) {
            return new Promise((i, s) => {
                const {
                    fromPage: a,
                    toPage: l
                } = this.getTargetPageRange(e, {
                    position: t,
                    force: n
                }),
                c = [];
                for (let u = 0; u < this.count; u++)
                    c.push(this.buildPage(Fa(a, u), o));
                this.refreshDisabledDays(c),
                this.refreshFocusableDays(c),
                this.transitionName = this.getPageTransition(this.pages[0], c[0], r),
                this.pages = c,
                this.$emit("update:from-page", a),
                this.$emit("update:to-page", l),
                this.transitionName && this.transitionName !== "none" ? this.transitionPromise = {
                    resolve: i,
                    reject: s
                }
                 : i(!0)
            })
        },
        refreshDisabledDays(e) {
            this.getPageDays(e).forEach(t => {
                t.isDisabled = !!this.disabledAttribute && this.disabledAttribute.intersectsDay(t)
            })
        },
        refreshFocusableDays(e) {
            this.getPageDays(e).forEach(t => {
                t.isFocusable = t.inMonth && t.day === this.focusableDay
            })
        },
        getPageDays(e = this.pages) {
            return e.reduce((t, n) => t.concat(n.days), [])
        },
        getPageTransition(e, t, n = this.transition) {
            if (n === "none")
                return n;
            if (n === "fade" || !n && this.count > 1 || !vi(e) || !vi(t))
                return "fade";
            const r = hp(t, e);
            return n === "slide-v" ? r ? "slide-down" : "slide-up" : r ? "slide-right" : "slide-left"
        },
        getPageForAttributes() {
            let e = null;
            const t = this.store.pinAttr;
            if (t && t.hasDates) {
                let [n] = t.dates;
                n = n.start || n.date,
                e = this.pageForDate(n)
            }
            return e
        },
        buildPage({
            month: e,
            year: t
        }, n) {
            const r = `${t.toString()}-${e.toString()}`;
            let o = this.pages.find(i => i.key === r);
            if (!o || n) {
                const i = new Date(t, e - 1, 15),
                s = this.$locale.getMonthComps(e, t),
                a = this.$locale.getPrevMonthComps(e, t),
                l = this.$locale.getNextMonthComps(e, t);
                o = {
                    key: r,
                    month: e,
                    year: t,
                    weeks: this.trimWeeks ? s.weeks : 6,
                    title: this.$locale.format(i, this.$locale.masks.title),
                    shortMonthLabel: this.$locale.format(i, "MMM"),
                    monthLabel: this.$locale.format(i, "MMMM"),
                    shortYearLabel: t.toString().substring(2),
                    yearLabel: t.toString(),
                    monthComps: s,
                    prevMonthComps: a,
                    nextMonthComps: l,
                    canMove: c => this.canMove(c),
                    move: c => this.move(c),
                    moveThisMonth: () => this.moveThisMonth(),
                    movePrevMonth: () => this.move(a),
                    moveNextMonth: () => this.move(l),
                    refresh: !0
                },
                o.days = this.$locale.getCalendarDays(o)
            }
            return o
        },
        initStore() {
            this.store = new Q6e(this.$theme, this.$locale, this.attributes),
            this.refreshAttrs(this.pages, this.store.list, [], !0)
        },
        refreshAttrs(e = [], t = [], n = [], r) {
            Ui(e) && e.forEach(o => {
                o.days.forEach(i => {
                    let s = !1,
                    a = {};
                    r ? s = !0 : Rx(i.attributesMap, n) ? (a = Nx(i.attributesMap, n), s = !0) : a = i.attributesMap || {},
                    t.forEach(l => {
                        const c = l.intersectsDay(i);
                        if (c) {
                            const u = sn(ct({}, l), {
                                targetDate: c
                            });
                            a[l.key] = u,
                            s = !0
                        }
                    }),
                    s && (i.attributesMap = a, i.shouldRefresh = !0)
                })
            })
        },
        handleKeydown(e) {
            const t = this.lastFocusedDay;
            t != null && (t.event = e, this.handleDayKeydown(t))
        },
        handleDayKeydown(e) {
            const {
                dateFromTime: t,
                event: n
            } = e,
            r = t(12);
            let o = null;
            switch (n.key) {
            case "ArrowLeft": {
                    o = qs(r, -1);
                    break
                }
            case "ArrowRight": {
                    o = qs(r, 1);
                    break
                }
            case "ArrowUp": {
                    o = qs(r, -7);
                    break
                }
            case "ArrowDown": {
                    o = qs(r, 7);
                    break
                }
            case "Home": {
                    o = qs(r, -e.weekdayPosition + 1);
                    break
                }
            case "End": {
                    o = qs(r, e.weekdayPositionFromEnd);
                    break
                }
            case "PageUp": {
                    n.altKey ? o = kA(r, -1) : o = Px(r, -1);
                    break
                }
            case "PageDown": {
                    n.altKey ? o = kA(r, 1) : o = Px(r, 1);
                    break
                }
            }
            o && (n.preventDefault(), this.focusDate(o).catch())
        }
    }
}, n8e = {
    inheritAttrs: !1,
    emits: ["update:modelValue"],
    props: {
        options: Array,
        modelValue: null
    }
}, r8e = {
    class: "vc-select"
}, o8e = ["value"], i8e = ["value", "disabled"], s8e = P("div", {
    class: "vc-select-arrow"
}, [P("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20"
        }, [P("path", {
                    d: "M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"
                })])], -1);
function a8e(e, t, n, r, o, i) {
    return _(),
    O("div", r8e, [P("select", Bt(e.$attrs, {
                    value: n.modelValue,
                    onChange: t[0] || (t[0] = s => e.$emit("update:modelValue", s.target.value))
                }), [(_(!0), O(Le, null, $t(n.options, s => (_(), O("option", {
                                        key: s.value,
                                        value: s.value,
                                        disabled: s.disabled
                                    }, Re(s.label), 9, i8e))), 128))], 16, o8e), s8e])
}
var l8e = gh(n8e, [["render", a8e]]);
const c8e = [{
        value: 0,
        label: "12"
    }, {
        value: 1,
        label: "1"
    }, {
        value: 2,
        label: "2"
    }, {
        value: 3,
        label: "3"
    }, {
        value: 4,
        label: "4"
    }, {
        value: 5,
        label: "5"
    }, {
        value: 6,
        label: "6"
    }, {
        value: 7,
        label: "7"
    }, {
        value: 8,
        label: "8"
    }, {
        value: 9,
        label: "9"
    }, {
        value: 10,
        label: "10"
    }, {
        value: 11,
        label: "11"
    }
], u8e = [{
        value: 12,
        label: "12"
    }, {
        value: 13,
        label: "1"
    }, {
        value: 14,
        label: "2"
    }, {
        value: 15,
        label: "3"
    }, {
        value: 16,
        label: "4"
    }, {
        value: 17,
        label: "5"
    }, {
        value: 18,
        label: "6"
    }, {
        value: 19,
        label: "7"
    }, {
        value: 20,
        label: "8"
    }, {
        value: 21,
        label: "9"
    }, {
        value: 22,
        label: "10"
    }, {
        value: 23,
        label: "11"
    }
], d8e = {
    name: "TimePicker",
    components: {
        TimeSelect: l8e
    },
    emits: ["update:modelValue"],
    props: {
        modelValue: {
            type: Object,
            required: !0
        },
        locale: {
            type: Object,
            required: !0
        },
        theme: {
            type: Object,
            required: !0
        },
        is24hr: {
            type: Boolean,
        default:
            !0
        },
        showBorder: Boolean,
        hourOptions: Array,
        minuteOptions: Array
    },
    computed: {
        date() {
            let e = this.locale.normalizeDate(this.modelValue);
            return this.modelValue.hours === 24 && (e = new Date(e.getTime() - 1)),
            e
        },
        hours: {
            get() {
                return this.modelValue.hours
            },
            set(e) {
                this.updateValue(e, this.minutes)
            }
        },
        minutes: {
            get() {
                return this.modelValue.minutes
            },
            set(e) {
                this.updateValue(this.hours, e)
            }
        },
        isAM: {
            get() {
                return this.modelValue.hours < 12
            },
            set(e) {
                let t = this.hours;
                e && t >= 12 ? t -= 12 : !e && t < 12 && (t += 12),
                this.updateValue(t, this.minutes)
            }
        },
        amHourOptions() {
            return c8e.filter(e => this.hourOptions.some(t => t.value === e.value))
        },
        pmHourOptions() {
            return u8e.filter(e => this.hourOptions.some(t => t.value === e.value))
        },
        hourOptions_() {
            return this.is24hr ? this.hourOptions : this.isAM ? this.amHourOptions : this.pmHourOptions
        },
        amDisabled() {
            return !Ui(this.amHourOptions)
        },
        pmDisabled() {
            return !Ui(this.pmHourOptions)
        }
    },
    methods: {
        updateValue(e, t = this.minutes) {
            (e !== this.hours || t !== this.minutes) && this.$emit("update:modelValue", sn(ct({}, this.modelValue), {
                    hours: e,
                    minutes: t,
                    seconds: 0,
                    milliseconds: 0
                }))
        }
    }
}, f8e = P("div", null, [P("svg", {
                fill: "none",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                viewBox: "0 0 24 24",
                class: "vc-time-icon",
                stroke: "currentColor"
            }, [P("path", {
                        d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                    })])], -1), h8e = {
    class: "vc-time-content"
}, p8e = {
    key: 0,
    class: "vc-time-date"
}, m8e = {
    class: "vc-time-weekday"
}, g8e = {
    class: "vc-time-month"
}, v8e = {
    class: "vc-time-day"
}, y8e = {
    class: "vc-time-year"
}, w8e = {
    class: "vc-time-select"
}, b8e = P("span", {
    style: {
        margin: "0 4px"
    }
}, ":", -1), _8e = {
    key: 0,
    class: "vc-am-pm"
};
function k8e(e, t, n, r, o, i) {
    const s = B("time-select");
    return _(),
    O("div", {
        class: he(["vc-time-picker", [{
                        "vc-invalid": !n.modelValue.isValid,
                        "vc-bordered": n.showBorder
                    }
                ]])
    }, [f8e, P("div", h8e, [i.date ? (_(), O("div", p8e, [P("span", m8e, Re(n.locale.format(i.date, "WWW")), 1), P("span", g8e, Re(n.locale.format(i.date, "MMM")), 1), P("span", v8e, Re(n.locale.format(i.date, "D")), 1), P("span", y8e, Re(n.locale.format(i.date, "YYYY")), 1)])) : J("", !0), P("div", w8e, [z(s, {
                                modelValue: i.hours,
                                "onUpdate:modelValue": t[0] || (t[0] = a => i.hours = a),
                                modelModifiers: {
                                    number: !0
                                },
                                options: i.hourOptions_
                            }, null, 8, ["modelValue", "options"]), b8e, z(s, {
                                modelValue: i.minutes,
                                "onUpdate:modelValue": t[1] || (t[1] = a => i.minutes = a),
                                modelModifiers: {
                                    number: !0
                                },
                                options: n.minuteOptions
                            }, null, 8, ["modelValue", "options"]), n.is24hr ? J("", !0) : (_(), O("div", _8e, [P("button", {
                                            class: he({
                                                active: i.isAM,
                                                "vc-disabled": i.amDisabled
                                            }),
                                            onClick: t[2] || (t[2] = ve(a => i.isAM = !0, ["prevent"])),
                                            type: "button"
                                        }, " AM ", 2), P("button", {
                                            class: he({
                                                active: !i.isAM,
                                                "vc-disabled": i.pmDisabled
                                            }),
                                            onClick: t[3] || (t[3] = ve(a => i.isAM = !1, ["prevent"])),
                                            type: "button"
                                        }, " PM ", 2)]))])])], 2)
}
var x8e = gh(d8e, [["render", k8e]]);
const LD = {
    type: "auto",
    mask: "iso",
    timeAdjust: ""
}, S8e = [LD, LD], Rv = {
    DATE: "date",
    DATE_TIME: "datetime",
    TIME: "time"
}, pi = {
    NONE: 0,
    START: 1,
    END: 2,
    BOTH: 3
}, C8e = {
    name: "DatePicker",
    emits: ["update:modelValue", "drag", "dayclick", "daykeydown", "popover-will-show", "popover-did-show", "popover-will-hide", "popover-did-hide"],
    render() {
        const e = (o, i) => {
            if (!this.$slots.footer)
                return o;
            const s = [o, this.$slots.footer()];
            return i ? dt(i, s) : s
        },
        t = () => {
            if (!this.dateParts)
                return null;
            const o = this.isRange ? this.dateParts : [this.dateParts[0]];
            return dt("div", {}, sn(ct({}, this.$slots), {
                default:
                    () => o.map((i, s) => {
                        const a = this.$locale.getHourOptions(this.modelConfig_[s].validHours, i),
                        l = this.$locale.getMinuteOptions(this.modelConfig_[s].minuteIncrement, i);
                        return dt(x8e, {
                            modelValue: i,
                            locale: this.$locale,
                            theme: this.$theme,
                            is24hr: this.is24hr,
                            showBorder: !this.isTime,
                            isDisabled: this.isDateTime && !i.isValid || this.isDragging,
                            hourOptions: a,
                            minuteOptions: l,
                            "onUpdate:modelValue": c => this.onTimeInput(c, s === 0)
                        })
                    })
                }))
        },
        n = () => dt(t8e, sn(ct({}, this.$attrs), {
                attributes: this.attributes_,
                theme: this.$theme,
                locale: this.$locale,
                minDate: this.minDateExact || this.minDate,
                maxDate: this.maxDateExact || this.maxDate,
                disabledDates: this.disabledDates,
                availableDates: this.availableDates,
                onDayclick: this.onDayClick,
                onDaykeydown: this.onDayKeydown,
                onDaymouseenter: this.onDayMouseEnter,
                ref: "calendar"
            }), sn(ct({}, this.$slots), {
                footer: () => this.isDateTime ? e(t()) : e()
            })),
        r = () => this.isTime ? dt("div", {
            class: ["vc-container", `vc-${this.$theme.color}`, {
                    "vc-is-dark": this.$theme.isDark
                }
            ]
        }, e(t(), "div")) : n();
        return this.$slots.default ? dt("div", [this.$slots.default(this.slotArgs), dt(Lx, {
                    id: this.datePickerPopoverId,
                    placement: "bottom-start",
                    contentClass: `vc-container${this.isDark ? " vc-is-dark" : ""}`,
                    "on-before-show": o => this.$emit("popover-will-show", o),
                    "on-after-show": o => this.$emit("popover-did-show", o),
                    "on-before-hide": o => this.$emit("popover-will-hide", o),
                    "on-after-hide": o => this.$emit("popover-did-hide", o),
                    ref: "popover"
                }, {
                default:
                    r
                })]) : r()
    },
    mixins: [g9],
    props: {
        mode: {
            type: String,
        default:
            Rv.DATE
        },
        modelValue: {
            type: null,
            required: !0
        },
        modelConfig: {
            type: Object,
        default:
            () => ({})
        },
        is24hr: Boolean,
        minuteIncrement: Number,
        isRequired: Boolean,
        isRange: Boolean,
        updateOnInput: {
            type: Boolean,
        default:
            () => Kl("datePicker.updateOnInput")
        },
        inputDebounce: {
            type: Number,
        default:
            () => Kl("datePicker.inputDebounce")
        },
        popover: {
            type: Object,
        default:
            () => ({})
        },
        dragAttribute: Object,
        selectAttribute: Object,
        attributes: Array,
        validHours: [Object, Array, Function]
    },
    data() {
        return {
            value_: null,
            dateParts: null,
            activeDate: "",
            dragValue: null,
            inputValues: ["", ""],
            updateTimeout: null,
            watchValue: !0,
            datePickerPopoverId: Fy()
        }
    },
    computed: {
        isDate() {
            return this.mode.toLowerCase() === Rv.DATE
        },
        isDateTime() {
            return this.mode.toLowerCase() === Rv.DATE_TIME
        },
        isTime() {
            return this.mode.toLowerCase() === Rv.TIME
        },
        isDragging() {
            return !!this.dragValue
        },
        modelConfig_() {
            return this.normalizeConfig(this.modelConfig, S8e)
        },
        inputMask() {
            const e = this.$locale.masks;
            return this.isTime ? this.is24hr ? e.inputTime24hr : e.inputTime : this.isDateTime ? this.is24hr ? e.inputDateTime24hr : e.inputDateTime : this.$locale.masks.input
        },
        inputMaskHasTime() {
            return /[Hh]/g.test(this.inputMask)
        },
        inputMaskHasDate() {
            return /[dD]{1,2}|Do|W{1,4}|M{1,4}|YY(?:YY)?/g.test(this.inputMask)
        },
        inputMaskPatch() {
            if (this.inputMaskHasTime && this.inputMaskHasDate)
                return xl.DATE_TIME;
            if (this.inputMaskHasDate)
                return xl.DATE;
            if (this.inputMaskHasTime)
                return xl.TIME
        },
        slotArgs() {
            const {
                isRange: e,
                isDragging: t,
                updateValue: n,
                showPopover: r,
                hidePopover: o,
                togglePopover: i
            } = this,
            s = e ? {
                start: this.inputValues[0],
                end: this.inputValues[1]
            }
             : this.inputValues[0],
            a = [!0, !1].map(c => ct({
                    input: this.onInputInput(c),
                    change: this.onInputChange(c),
                    keyup: this.onInputKeyup
                }, Hy(sn(ct({}, this.popover_), {
                            id: this.datePickerPopoverId,
                            callback: u => {
                                u.action === "show" && u.completed && this.onInputShow(c)
                            }
                        })))),
            l = e ? {
                start: a[0],
                end: a[1]
            }
             : a[0];
            return {
                inputValue: s,
                inputEvents: l,
                isDragging: t,
                updateValue: n,
                showPopover: r,
                hidePopover: o,
                togglePopover: i,
                getPopoverTriggerEvents: Hy
            }
        },
        popover_() {
            return YI(this.popover, Kl("datePicker.popover"))
        },
        selectAttribute_() {
            if (!this.hasValue(this.value_))
                return null;
            const e = sn(ct({
                        key: "select-drag"
                    }, this.selectAttribute), {
                    dates: this.value_,
                    pinPage: !0
                }), {
                dot: t,
                bar: n,
                highlight: r,
                content: o
            } = e;
            return !t && !n && !r && !o && (e.highlight = !0),
            e
        },
        dragAttribute_() {
            if (!this.isRange || !this.hasValue(this.dragValue))
                return null;
            const e = sn(ct({
                        key: "select-drag"
                    }, this.dragAttribute), {
                    dates: this.dragValue
                }), {
                dot: t,
                bar: n,
                highlight: r,
                content: o
            } = e;
            return !t && !n && !r && !o && (e.highlight = {
                    startEnd: {
                        fillMode: "outline"
                    }
                }),
            e
        },
        attributes_() {
            const e = Fo(this.attributes) ? [...this.attributes] : [];
            return this.dragAttribute_ ? e.push(this.dragAttribute_) : this.selectAttribute_ && e.push(this.selectAttribute_),
            e
        }
    },
    watch: {
        inputMask() {
            this.formatInput()
        },
        modelValue(e) {
            this.watchValue && this.forceUpdateValue(e, {
                config: this.modelConfig_,
                formatInput: !0,
                hidePopover: !1
            })
        },
        value_() {
            this.refreshDateParts()
        },
        dragValue() {
            this.refreshDateParts()
        },
        timezone() {
            this.refreshDateParts(),
            this.forceUpdateValue(this.value_, {
                formatInput: !0
            })
        }
    },
    created() {
        this.value_ = this.normalizeValue(this.modelValue, this.modelConfig_, xl.DATE_TIME, pi.BOTH),
        this.forceUpdateValue(this.modelValue, {
            config: this.modelConfig_,
            formatInput: !0,
            hidePopover: !1
        }),
        this.refreshDateParts()
    },
    mounted() {
        xo(document, "keydown", this.onDocumentKeyDown),
        xo(document, "click", this.onDocumentClick)
    },
    beforeUnmount() {
        So(document, "keydown", this.onDocumentKeyDown),
        So(document, "click", this.onDocumentClick)
    },
    methods: {
        getDateParts(e) {
            return this.$locale.getDateParts(e)
        },
        getDateFromParts(e) {
            return this.$locale.getDateFromParts(e)
        },
        refreshDateParts() {
            const e = this.dragValue || this.value_,
            t = [];
            this.isRange ? (e && e.start ? t.push(this.getDateParts(e.start)) : t.push({}), e && e.end ? t.push(this.getDateParts(e.end)) : t.push({})) : e ? t.push(this.getDateParts(e)) : t.push({}),
            this.$nextTick(() => this.dateParts = t)
        },
        onDocumentKeyDown(e) {
            this.dragValue && e.key === "Escape" && (this.dragValue = null)
        },
        onDocumentClick(e) {
            document.body.contains(e.target) && !Vp(this.$el, e.target) && (this.dragValue = null, this.formatInput())
        },
        onDayClick(e) {
            this.handleDayClick(e),
            this.$emit("dayclick", e)
        },
        onDayKeydown(e) {
            switch (e.event.key) {
            case " ":
            case "Enter": {
                    this.handleDayClick(e),
                    e.event.preventDefault();
                    break
                }
            case "Escape":
                this.hidePopover()
            }
            this.$emit("daykeydown", e)
        },
        handleDayClick(e) {
            const {
                keepVisibleOnInput: t,
                visibility: n
            } = this.popover_,
            r = {
                patch: xl.DATE,
                adjustTime: !0,
                formatInput: !0,
                hidePopover: this.isDate && !t && n !== "visible"
            };
            this.isRange ? (this.isDragging ? this.dragTrackingValue.end = e.date : this.dragTrackingValue = ct({}, e.range), r.isDragging = !this.isDragging, r.rangePriority = r.isDragging ? pi.NONE : pi.BOTH, r.hidePopover = r.hidePopover && !r.isDragging, this.updateValue(this.dragTrackingValue, r)) : (r.clearIfEqual = !this.isRequired, this.updateValue(e.date, r))
        },
        onDayMouseEnter(e) {
            this.isDragging && (this.dragTrackingValue.end = e.date, this.updateValue(this.dragTrackingValue, {
                    patch: xl.DATE,
                    adjustTime: !0,
                    formatInput: !0,
                    hidePriority: !1,
                    rangePriority: pi.NONE
                }))
        },
        onTimeInput(e, t) {
            let n = null;
            if (this.isRange) {
                const r = t ? e : this.dateParts[0],
                o = t ? this.dateParts[1] : e;
                n = {
                    start: r,
                    end: o
                }
            } else
                n = e;
            this.updateValue(n, {
                patch: xl.TIME,
                rangePriority: t ? pi.START : pi.END
            }).then(() => this.adjustPageRange(t))
        },
        onInputInput(e) {
            return t => {
                this.updateOnInput && this.onInputUpdate(t.target.value, e, {
                    formatInput: !1,
                    hidePopover: !1,
                    debounce: this.inputDebounce
                })
            }
        },
        onInputChange(e) {
            return t => {
                this.onInputUpdate(t.target.value, e, {
                    formatInput: !0,
                    hidePopover: !1
                })
            }
        },
        onInputUpdate(e, t, n) {
            this.inputValues.splice(t ? 0 : 1, 1, e);
            const r = this.isRange ? {
                start: this.inputValues[0],
                end: this.inputValues[1] || this.inputValues[0]
            }
             : e,
            o = {
                type: "string",
                mask: this.inputMask
            };
            this.updateValue(r, sn(ct({}, n), {
                    config: o,
                    patch: this.inputMaskPatch,
                    rangePriority: t ? pi.START : pi.END
                })).then(() => this.adjustPageRange(t))
        },
        onInputShow(e) {
            this.adjustPageRange(e)
        },
        onInputKeyup(e) {
            e.key === "Escape" && this.updateValue(this.value_, {
                formatInput: !0,
                hidePopover: !0
            })
        },
        updateValue(e, t = {}) {
            return clearTimeout(this.updateTimeout),
            new Promise(n => {
                const r = t, {
                    debounce: o
                } = r,
                i = DSe(r, ["debounce"]);
                o > 0 ? this.updateTimeout = setTimeout(() => {
                    this.forceUpdateValue(e, i),
                    n(this.value_)
                }, o) : (this.forceUpdateValue(e, i), n(this.value_))
            })
        },
        normalizeConfig(e, t = this.modelConfig_) {
            return e = Fo(e) ? e : [e.start || e, e.end || e],
            t.map((n, r) => ct(ct({
                        validHours: this.validHours,
                        minuteIncrement: this.minuteIncrement
                    }, n), e[r]))
        },
        forceUpdateValue(e, {
            config: t = this.modelConfig_,
            patch: n = xl.DATE_TIME,
            clearIfEqual: r = !1,
            formatInput: o = !0,
            hidePopover: i = !1,
            isDragging: s = this.isDragging,
            rangePriority: a = pi.BOTH
        } = {}) {
            t = this.normalizeConfig(t);
            let l = this.normalizeValue(e, t, n, a);
            !l && this.isRequired && (l = this.value_),
            l = this.adjustTimeForValue(l, t);
            const c = this.valueIsDisabled(l);
            if (c) {
                if (s)
                    return;
                l = this.value_,
                i = !1
            }
            const u = s ? "dragValue" : "value_";
            let f = !this.valuesAreEqual(this[u], l);
            if (!c && !f && r && (l = null, f = !0), f) {
                this[u] = l,
                s || (this.dragValue = null);
                const p = this.denormalizeValue(l),
                m = this.isDragging ? "drag" : "update:modelValue";
                this.watchValue = !1,
                this.$emit(m, p),
                this.$nextTick(() => this.watchValue = !0)
            }
            i && this.hidePopover(),
            o && this.formatInput()
        },
        hasValue(e) {
            return this.isRange ? Ji(e) && !!e.start && !!e.end : !!e
        },
        normalizeValue(e, t, n, r) {
            if (!this.hasValue(e))
                return null;
            if (this.isRange) {
                const o = {},
                i = e.start > e.end ? e.end : e.start;
                o.start = this.normalizeDate(i, sn(ct({}, t[0]), {
                            fillDate: this.value_ && this.value_.start || t[0].fillDate,
                            patch: n
                        }));
                const s = e.start > e.end ? e.start : e.end;
                return o.end = this.normalizeDate(s, sn(ct({}, t[1]), {
                            fillDate: this.value_ && this.value_.end || t[1].fillDate,
                            patch: n
                        })),
                this.sortRange(o, r)
            }
            return this.normalizeDate(e, sn(ct({}, t[0]), {
                    fillDate: this.value_ || t[0].fillDate,
                    patch: n
                }))
        },
        adjustTimeForValue(e, t) {
            return this.hasValue(e) ? this.isRange ? {
                start: this.$locale.adjustTimeForDate(e.start, t[0]),
                end: this.$locale.adjustTimeForDate(e.end, t[1])
            }
             : this.$locale.adjustTimeForDate(e, t[0]) : null
        },
        sortRange(e, t = pi.NONE) {
            const {
                start: n,
                end: r
            } = e;
            if (n > r)
                switch (t) {
                case pi.START:
                    return {
                        start: n,
                        end: n
                    };
                case pi.END:
                    return {
                        start: r,
                        end: r
                    };
                case pi.BOTH:
                    return {
                        start: r,
                        end: n
                    }
                }
            return {
                start: n,
                end: r
            }
        },
        denormalizeValue(e, t = this.modelConfig_) {
            return this.isRange ? this.hasValue(e) ? {
                start: this.$locale.denormalizeDate(e.start, t[0]),
                end: this.$locale.denormalizeDate(e.end, t[1])
            }
             : null : this.$locale.denormalizeDate(e, t[0])
        },
        valuesAreEqual(e, t) {
            if (this.isRange) {
                const n = this.hasValue(e),
                r = this.hasValue(t);
                return !n && !r ? !0 : n !== r ? !1 : h2(e.start, t.start) && h2(e.end, t.end)
            }
            return h2(e, t)
        },
        valueIsDisabled(e) {
            return this.hasValue(e) && this.disabledAttribute && this.disabledAttribute.intersectsDate(e)
        },
        formatInput() {
            this.$nextTick(() => {
                const e = this.normalizeConfig({
                    type: "string",
                    mask: this.inputMask
                }),
                t = this.denormalizeValue(this.dragValue || this.value_, e);
                this.isRange ? this.inputValues = [t && t.start, t && t.end] : this.inputValues = [t, ""]
            })
        },
        showPopover(e = {}) {
            Vx(sn(ct(ct({
                            ref: this.$el
                        }, this.popover_), e), {
                    isInteractive: !0,
                    id: this.datePickerPopoverId
                }))
        },
        hidePopover(e = {}) {
            Fx(sn(ct(ct({
                            hideDelay: 10
                        }, this.showPopover_), e), {
                    id: this.datePickerPopoverId
                }))
        },
        togglePopover(e) {
            y9(sn(ct(ct({
                            ref: this.$el
                        }, this.popover_), e), {
                    isInteractive: !0,
                    id: this.datePickerPopoverId
                }))
        },
        adjustPageRange(e) {
            this.$nextTick(() => {
                const t = this.$refs.calendar,
                n = this.getPageForValue(e),
                r = e ? 1 : -1;
                n && t && !d9(n, t.firstPage, t.lastPage) && t.move(n, {
                    position: r,
                    transition: "fade"
                })
            })
        },
        getPageForValue(e) {
            return this.hasValue(this.value_) ? this.pageForDate(this.isRange ? this.value_[e ? "start" : "end"] : this.value_) : null
        },
        move(e, t) {
            return this.$refs.calendar ? this.$refs.calendar.move(e, t) : Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"))
        },
        focusDate(e, t) {
            return this.$refs.calendar ? this.$refs.calendar.focusDate(e, t) : Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"))
        }
    }
}, I8e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, T8e = P("path", {
    d: "M11.95 8.65v-4.2m8.1 0v4.2m5.868 13.466v.933h-3.6v-.933zm-8.064 0v.933h-3.6v-.933zm-8.1 0v.933h-3.6v-.933zm16.164-4.667v.933h-3.6v-.933zm-8.063 0v.933h-3.6v-.933zm-8.1 0v.933h-3.6v-.933zm16.163-4.666v.933h-3.6v-.933zm-8.064 0v.933h-3.6v-.933zm-8.1 0v.933h-3.6v-.933zM2.5 6.55h27v21h-27z"
}, null, -1), M8e = [T8e];
function P8e(e, t) {
    return _(),
    O("svg", I8e, M8e)
}
const E8e = {
    render: P8e
}, Df = (e, t) => t ? (e = z7(e) ? e : new Date(Date.UTC(0, 0)), cke(e, {
        year: c2e(t),
        month: l2e(t),
        date: s2e(t)
    })) : e, Dm = (e, t) => {
    let n = new Date(e);
    return t && (n.setHours(t.getHours()), n.setMinutes(t.getMinutes()), n.setSeconds(t.getSeconds()), n.setMilliseconds(t.getMilliseconds())),
    n
}, O8e = (e, t, n, r) => {
    if (t) {
        if (r && n)
            return n2(e, t);
        if (r) {
            const o = new Date(0);
            return n2(Dm(o, e), Dm(o, t))
        }
        if (n) {
            const o = new Date(0);
            return n2(Df(o, e), Df(o, t))
        }
    }
    return !1
}, $8e = (e, t, n, r) => {
    if (t) {
        if (r && n)
            return t2(e, t);
        if (r) {
            const o = new Date(0);
            return t2(Dm(o, e), Dm(o, t))
        }
        if (n) {
            const o = new Date(0);
            return t2(Df(o, e), Df(o, t))
        }
    }
    return !1
}, w9 = () => Intl.DateTimeFormat().resolvedOptions().timeZone, A8e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, D8e = P("path", {
    d: "M28.7 9.7 16 22.3 3.3 9.7"
}, null, -1), N8e = [D8e];
function R8e(e, t) {
    return _(),
    O("svg", A8e, N8e)
}
const al = {
    render: R8e
}, L8e = e => Math.max(Math.floor(Math.log10(Math.abs(e))), 0) + 1;
const B8e = 200, V8e = 50, F8e = 1, j8e = {
    components: {
        ArrowIcon: al
    },
    props: {
        modelValue: {
        default:
            0,
            type: [Number, String]
        },
        id: {
            type: String,
        default:
            null
        },
        min: {
        default:
            Number.MIN_SAFE_INTEGER,
            type: Number
        },
        max: {
        default:
            Number.MAX_SAFE_INTEGER,
            type: Number
        },
        minDigits: {
        default:
            0,
            type: Number
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        inputClasses: {
        default:
            "",
            type: String
        },
        disabled: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["update:modelValue", "bounds"],
    data() {
        return {
            clicked: !1,
            hovered: !1,
            localValue: this.modelValue
        }
    },
    computed: {
        stepSize() {
            return F8e
        },
        inputClassList() {
            let e = this.inputClasses;
            return this.hovered && (e += " hover"),
            e
        }
    },
    watch: {
        modelValue: {
            handler(e) {
                this.localValue = this.padValue(e)
            },
            immediate: !0
        }
    },
    spinnerArrowTimeout: null,
    spinnerArrowInterval: null,
    mounted() {
        this.initialValue = this.modelValue
    },
    methods: {
        limitBounds(e) {
            return e < this.min ? {
                type: "min",
                limit: this.min,
                input: e,
                value: this.min
            }
             : e > this.max ? {
                type: "max",
                limit: this.max,
                input: e,
                value: this.max
            }
             : {
                value: e
            }
        },
        padValue(e) {
            if (isNaN(e) || !e && e !== 0 || e < 0)
                return e;
            const t = e.toString(10);
            return this.minDigits < 1 ? t : t.padStart(this.minDigits, "0")
        },
        getValue() {
            return parseInt(this.$refs.input.value, 10)
        },
        onBlur() {
            this.localValue = this.padValue(this.modelValue)
        },
        onInput(e) {
            const t = e.target.value,
            n = parseInt(t, 10);
            if (t === "")
                this.localValue = "";
            else {
                const o = n.toString(10).length;
                if (t === "")
                    return;
                if (isNaN(n) || o > L8e(this.max)) {
                    this.$refs.input.value = this.padValue(this.localValue);
                    return
                }
            }
            const r = this.limitBounds(n);
            r.type ? this.$emit("bounds", r) : this.$emit("update:modelValue", r.value)
        },
        validate(e) {
            let t = !0,
            n;
            return e = typeof e > "u" ? this.getValue() : e,
            typeof e != "number" || isNaN(e) ? (t = !1, n = "Current value is not a number.") : (this.min > e || this.max < e) && (t = !1, n = "Current value is outside allowed range."), {
                isValid: t,
                errorMessage: n
            }
        },
        changeValue(e) {
            let t = this.getValue();
            this.validate(t).isValid || (t < this.min ? t = this.min : t > this.max ? t = this.max : t = this.initialValue);
            let n = t + e;
            if (n = Math.round(n * 10) / 10, this.validate(n).isValid)
                this.$refs.input.value = this.padValue(n), this.onInput({
                    target: this.$refs.input
                });
            else {
                const r = this.limitBounds(n);
                r.type && this.$emit("bounds", r)
            }
        },
        mouseEvent(e, t) {
            if (this.disabled)
                return;
            clearTimeout(this.spinnerArrowInterval),
            clearInterval(this.spinnerArrowTimeout);
            let n = this.stepSize;
            if (t === "decrease" && (n *= -1), e.type === "mousedown") {
                this.clicked = !0,
                this.spinnerArrowTimeout = setTimeout(() => {
                    this.spinnerArrowInterval = setInterval(() => {
                        this.changeValue(n)
                    }, V8e)
                }, B8e);
                return
            }
            this.clicked && (this.clicked = !1, this.changeValue(n))
        },
        toggleHover() {
            this.hovered = !this.hovered
        }
    }
}, W8e = ["id", "value", "min", "max", "step", "disabled"], z8e = {
    key: 0,
    class: "invalid-marker"
};
function H8e(e, t, n, r, o, i) {
    const s = B("ArrowIcon");
    return _(),
    O("div", {
        class: he(["wrapper", {
                    disabled: n.disabled
                }
            ])
    }, [P("input", {
                id: n.id,
                ref: "input",
                type: "number",
                role: "spinButton",
                value: o.localValue,
                min: n.min,
                max: n.max,
                step: i.stepSize,
                class: he(i.inputClassList),
                disabled: n.disabled,
                onInput: t[0] || (t[0] = (...a) => i.onInput && i.onInput(...a)),
                onBlur: t[1] || (t[1] = (...a) => i.onBlur && i.onBlur(...a)),
                onMouseenter: t[2] || (t[2] = (...a) => i.toggleHover && i.toggleHover(...a)),
                onMouseleave: t[3] || (t[3] = (...a) => i.toggleHover && i.toggleHover(...a))
            }, null, 42, W8e), n.isValid ? J("", !0) : (_(), O("span", z8e)), P("span", {
                class: he(["increase", {
                            disabled: n.disabled
                        }
                    ]),
                onMousedown: t[4] || (t[4] = ve(a => i.mouseEvent(a, "increase"), ["prevent"])),
                onMouseup: t[5] || (t[5] = ve(a => i.mouseEvent(a, "increase"), ["prevent"])),
                onMouseleave: t[6] || (t[6] = a => i.mouseEvent(a, "increase"))
            }, [z(s)], 34), P("span", {
                class: he(["decrease", {
                            disabled: n.disabled
                        }
                    ]),
                onMousedown: t[7] || (t[7] = ve(a => i.mouseEvent(a, "decrease"), ["prevent"])),
                onMouseup: t[8] || (t[8] = ve(a => i.mouseEvent(a, "decrease"), ["prevent"])),
                onMouseleave: t[9] || (t[9] = a => i.mouseEvent(a, "decrease"))
            }, [z(s)], 34)], 2)
}
const U8e = te(j8e, [["render", H8e], ["__scopeId", "data-v-02d11fd4"]]);
const q8e = {
    components: {
        CalendarIcon: E8e,
        TimePartInput: U8e,
        DatePicker: C8e
    },
    props: {
        modelValue: {
            type: Date,
            required: !0
        },
        id: {
            type: String,
        default:
            null
        },
        dateFormat: {
            type: String,
        default:
            "yyyy-MM-dd"
        },
        timeFormat: {
            type: String,
        default:
            "HH:mm:ss"
        },
        min: {
        default:
            null,
            type: Date
        },
        max: {
        default:
            null,
            type: Date
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        showSeconds: {
        default:
            !0,
            type: Boolean
        },
        showMilliseconds: {
        default:
            !1,
            type: Boolean
        },
        showTime: {
        default:
            !0,
            type: Boolean
        },
        showDate: {
        default:
            !0,
            type: Boolean
        },
        twoLines: {
        default:
            !1,
            type: Boolean
        },
        required: {
        default:
            !1,
            type: Boolean
        },
        timezone: {
            type: String,
        default:
            w9()
        },
        disabled: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    data() {
        return {
            popoverIsVisible: !1,
            isInvalid: !1,
            isAfterMax: !1,
            isBeforeMin: !1,
            invalidValue: null,
            localValue: new Date("")
        }
    },
    computed: {
        clientOnlyComponent() {
            return BQ()
        },
        legacyDateFormat() {
            return this.dateFormat.toUpperCase()
        },
        dateTimeHours() {
            return this.localValue.getHours()
        },
        dateTimeMinutes() {
            return this.localValue.getMinutes()
        },
        dateTimeSeconds() {
            return this.localValue.getSeconds()
        },
        dateTimeMilliseconds() {
            return this.localValue.getMilliseconds()
        }
    },
    watch: {
        modelValue: {
            handler(e) {
                this.checkMinMax(e),
                this.checkIsValid(e) && (this.localValue = eV(e, this.timezone))
            },
            immediate: !0
        }
    },
    methods: {
        formatDate(e) {
            return this.showTime && this.showDate ? f0(e, `${this.dateFormat} ${this.timeFormat}`) : this.showTime ? f0(e, this.timeFormat) : f0(e, this.dateFormat)
        },
        emitInput(e) {
            this.checkMinMax(e),
            this.$emit("update:modelValue", Nd(e, this.timezone))
        },
        onDatePickerInput(e) {
            this.emitInput(Df(this.localValue, e))
        },
        onTextInputChange(e, t) {
            let n = ske(e.target.value, this.dateFormat, new Date);
            this.checkIsValid(n) || (n = this.localValue);
            let r = Df(this.localValue, n);
            t(),
            this.onDatePickerInput(r)
        },
        checkIsValid(e) {
            return z7(e) ? !0 : (this.isInvalid = !0, this.invalidValue = e, !1)
        },
        checkMinMax(e) {
            return !this.min && !this.max ? !0 : (this.isBeforeMin = O8e(e, this.min, this.showDate, this.showTime), this.isAfterMax = $8e(e, this.max, this.showDate, this.showTime), this.isBeforeMin || this.isAfterMax ? (this.invalidValue = e, !1) : !0)
        },
        onTimeHoursBounds(e) {
            this.showDate && (["min", "max"].includes(e.type) ? this.emitInput(Z$(new Date(this.localValue), e.input)) : this.emitInput(this.localValue))
        },
        onTimeMinutesBounds(e) {
            ["min", "max"].includes(e.type) ? this.emitInput(eA(new Date(this.localValue), e.input)) : this.emitInput(this.localValue)
        },
        onTimeSecondsBounds(e) {
            ["min", "max"].includes(e.type) ? this.emitInput(tA(new Date(this.localValue), e.input)) : this.emitInput(this.localValue)
        },
        onTimeMillisecondsBounds(e) {
            ["min", "max"].includes(e.type) ? this.emitInput(Q$(new Date(this.localValue), e.input)) : this.emitInput(this.localValue)
        },
        onTimeHoursChange(e) {
            let t = new Date(this.localValue);
            Number.isSafeInteger(e) && (t = Z$(t, e)),
            this.emitInput(t)
        },
        onTimeMinutesChange(e) {
            let t = new Date(this.localValue);
            Number.isSafeInteger(e) && (t = eA(t, e)),
            this.emitInput(t)
        },
        onTimeSecondsChange(e) {
            let t = new Date(this.localValue);
            Number.isSafeInteger(e) && (t = tA(t, e)),
            this.emitInput(t)
        },
        onTimeMillisecondsChange(e) {
            let t = new Date(this.localValue);
            Number.isSafeInteger(e) && (t = Q$(t, e)),
            this.emitInput(t)
        },
        validate() {
            let e = !0,
            t;
            return this.required && this.isInvalid && (e = !1, t = "Please input a valid date"),
            this.isAfterMax && (e = !1, t = `${this.formatDate(this.invalidValue)} is after maximum ${this.formatDate(this.max)}`),
            this.isBeforeMin && (e = !1, t = `${this.formatDate(this.invalidValue)} is before minimum ${this.formatDate(this.min)}`), {
                isValid: e,
                errorMessage: t
            }
        }
    }
}, Y8e = e => (ir("data-v-3668ccf1"), e = e(), sr(), e), K8e = {
    class: "date-time-input"
}, G8e = ["id", "value", "disabled", "onChange", "onBlur"], X8e = ["onClick"], J8e = {
    key: 0,
    class: "invalid-marker"
}, Z8e = Y8e(() => P("span", {
            class: "time-colon"
        }, ":", -1)), Q8e = {
    key: 0,
    class: "time-colon"
}, eBe = {
    key: 2,
    class: "time-colon"
};
function tBe(e, t, n, r, o, i) {
    const s = B("CalendarIcon"),
    a = B("DatePicker"),
    l = B("TimePartInput");
    return _(),
    O("div", K8e, [n.showDate ? (_(), O("div", {
                    key: 0,
                    class: he(["date-picker", {
                                disabled: n.disabled
                            }
                        ])
                }, [(_(), H(Kt(i.clientOnlyComponent), null, {
                            default:
                                oe(() => [z(a, {
                                            ref: "datePicker",
                                            "model-value": o.localValue,
                                            "is-required": !0,
                                            "is-dark": !1,
                                            color: "masala",
                                            popover: {
                                                placement: "bottom",
                                                visibility: "click"
                                            },
                                            masks: {
                                                L: i.legacyDateFormat
                                            },
                                            "max-date": n.max,
                                            "min-date": n.min,
                                            onPopoverWillHide: t[0] || (t[0] = c => o.popoverIsVisible = !1),
                                            onPopoverWillShow: t[1] || (t[1] = c => o.popoverIsVisible = !0),
                                            "onUpdate:modelValue": i.onDatePickerInput
                                        }, {
                                        default:
                                            oe(({
                                                    inputValue: c,
                                                    inputEvents: u,
                                                    hidePopover: f,
                                                    togglePopover: p
                                                }) => [P("div", null, [P("input", Bt({
                                                                    id: n.id,
                                                                    value: c,
                                                                    disabled: n.disabled
                                                                }, O0(u, !0), {
                                                                    onChange: m => i.onTextInputChange(m, f),
                                                                    onBlur: f
                                                                }), null, 16, G8e), P("span", {
                                                                class: he(["button", {
                                                                            active: o.popoverIsVisible,
                                                                            disabled: n.disabled
                                                                        }
                                                                    ]),
                                                                onClick: m => n.disabled ? () => {}
                                                                 : p()
                                                            }, [z(s)], 10, X8e)])]),
                                            _: 1
                                        }, 8, ["model-value", "masks", "max-date", "min-date", "onUpdate:modelValue"])]),
                                _: 1
                            })), n.isValid ? J("", !0) : (_(), O("span", J8e))], 2)) : J("", !0), n.showTime ? (_(), O("div", {
                    key: 1,
                    class: he(["time", {
                                "two-lines": n.twoLines
                            }
                        ])
                }, [z(l, {
                            ref: "hours",
                            class: "time-part",
                            type: "integer",
                            min: 0,
                            max: 23,
                            "min-digits": 2,
                            "model-value": i.dateTimeHours,
                            disabled: n.disabled,
                            onBounds: i.onTimeHoursBounds,
                            "onUpdate:modelValue": i.onTimeHoursChange
                        }, null, 8, ["model-value", "disabled", "onBounds", "onUpdate:modelValue"]), Z8e, z(l, {
                            ref: "minutes",
                            class: "time-part",
                            type: "integer",
                            min: 0,
                            max: 59,
                            "min-digits": 2,
                            "model-value": i.dateTimeMinutes,
                            disabled: n.disabled,
                            onBounds: i.onTimeMinutesBounds,
                            "onUpdate:modelValue": i.onTimeMinutesChange
                        }, null, 8, ["model-value", "disabled", "onBounds", "onUpdate:modelValue"]), n.showSeconds ? (_(), O("span", Q8e, ":")) : J("", !0), n.showSeconds ? (_(), H(l, {
                                key: 1,
                                ref: "seconds",
                                class: "time-part",
                                type: "integer",
                                min: 0,
                                max: 59,
                                "min-digits": 2,
                                "model-value": i.dateTimeSeconds,
                                disabled: n.disabled,
                                onBounds: i.onTimeSecondsBounds,
                                "onUpdate:modelValue": i.onTimeSecondsChange
                            }, null, 8, ["model-value", "disabled", "onBounds", "onUpdate:modelValue"])) : J("", !0), n.showMilliseconds ? (_(), O("span", eBe, ".")) : J("", !0), n.showMilliseconds ? (_(), H(l, {
                                key: 3,
                                ref: "milliseconds",
                                class: "time-part",
                                type: "integer",
                                min: 0,
                                max: 999,
                                "min-digits": 3,
                                "model-value": i.dateTimeMilliseconds,
                                disabled: n.disabled,
                                onBounds: i.onTimeMillisecondsBounds,
                                "onUpdate:modelValue": i.onTimeMillisecondsChange
                            }, null, 8, ["model-value", "disabled", "onBounds", "onUpdate:modelValue"])) : J("", !0)], 2)) : J("", !0)])
}
const nBe = te(q8e, [["render", tBe], ["__scopeId", "data-v-3668ccf1"]]), b9 = function () {
    return document.ontouchstart !== null ? "click" : "touchstart"
}, Uy = "__vue_click_away__", _9 = function (e, t, n) {
    k9(e);
    let r = n.context,
    o = t.value,
    i = !1;
    setTimeout(function () {
        i = !0
    }, 0),
    e[Uy] = function (s) {
        if ((!e || !e.contains(s.target)) && o && i && typeof o == "function")
            return o.call(r, s)
    },
    document.addEventListener(b9(), e[Uy], !1)
}, k9 = function (e) {
    document.removeEventListener(b9(), e[Uy], !1),
    delete e[Uy]
}, rBe = function (e, t, n) {
    t.value !== t.oldValue && _9(e, t, n)
}, x9 = {
    mounted: _9,
    updated: rBe,
    unmounted: k9
}, XI = {
    directives: {
        ClickAway: x9
    }
};
let oBe = 0;
const BD = "ArrowDown", VD = "ArrowUp", iBe = "Home", sBe = "End", aBe = "Escape", FD = "Enter", lBe = 1e3, cBe = {
    components: {
        DropdownIcon: al
    },
    mixins: [XI],
    props: {
        id: {
            type: String,
        default () {
                return `Dropdown-${oBe++}`
            }
        },
        modelValue: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        placeholder: {
            type: String,
        default:
            null
        },
        ariaLabel: {
            type: String,
            required: !0
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        possibleValues: {
            type: Array,
        default:
            () => []
        }
    },
    emits: ["update:modelValue"],
    data() {
        return {
            typingTimeout: null,
            isExpanded: !1,
            searchQuery: ""
        }
    },
    computed: {
        selectedIndex() {
            return this.possibleValues.map(e => e.id).indexOf(this.modelValue)
        },
        showPlaceholder() {
            return !this.modelValue
        },
        displayTextMap() {
            let e = {};
            for (let t of this.possibleValues)
                e[t.id] = t.text;
            return e
        },
        displayText() {
            return this.showPlaceholder ? this.placeholder : this.displayTextMap.hasOwnProperty(this.modelValue) ? this.displayTextMap[this.modelValue] : `(MISSING) ${this.modelValue}`
        },
        isMissing() {
            return this.modelValue && !this.displayTextMap.hasOwnProperty(this.modelValue)
        },
        hasRightIcon() {
            return this.$slots["icon-right"]?.().length
        },
        hasOptionTemplate() {
            return this.possibleValues.every(e => e.slotData && !Zie(e.slotData))
        }
    },
    methods: {
        isCurrentValue(e) {
            return this.modelValue === e
        },
        setSelected(e) {
            consola.trace("ListBox setSelected on", e),
            this.$emit("update:modelValue", e)
        },
        getButtonRef() {
            return this.$refs.button
        },
        getOptionsRefs() {
            return this.$refs.options
        },
        getListBoxNodeRef() {
            return this.$refs.ul
        },
        onOptionClick(e) {
            this.setSelected(e),
            this.isExpanded = !1,
            this.getButtonRef().focus()
        },
        scrollTo(e) {
            let t = this.getListBoxNodeRef();
            if (t.scrollHeight > t.clientHeight) {
                let n = this.getOptionsRefs()[e],
                r = t.clientHeight + t.scrollTop,
                o = n.offsetTop + n.offsetHeight;
                o > r ? t.scrollTop = o - t.clientHeight : n.offsetTop < t.scrollTop && (t.scrollTop = n.offsetTop)
            }
        },
        onArrowDown() {
            let e = this.selectedIndex + 1;
            e >= this.possibleValues.length || (this.setSelected(this.possibleValues[e].id), this.scrollTo(e))
        },
        onArrowUp() {
            let e = this.selectedIndex - 1;
            e < 0 || (this.setSelected(this.possibleValues[e].id), this.scrollTo(e))
        },
        onEndKey() {
            let e = this.possibleValues.length - 1;
            this.setSelected(this.possibleValues[e].id);
            const t = this.getListBoxNodeRef();
            t.scrollTop = t.scrollHeight
        },
        onHomeKey() {
            let e = 0;
            this.setSelected(this.possibleValues[e].id),
            this.getListBoxNodeRef().scrollTop = 0
        },
        toggleExpanded() {
            this.disabled || (this.isExpanded = !this.isExpanded, this.isExpanded && this.$nextTick(() => this.getListBoxNodeRef().focus()))
        },
        handleKeyDownList(e) {
            if (e.key === BD) {
                this.onArrowDown(),
                e.preventDefault();
                return
            }
            if (e.key === VD) {
                this.onArrowUp(),
                e.preventDefault();
                return
            }
            if (e.key === sBe) {
                this.onEndKey(),
                e.preventDefault();
                return
            }
            if (e.key === iBe) {
                this.onHomeKey(),
                e.preventDefault();
                return
            }
            if (e.key === aBe) {
                this.isExpanded = !1,
                this.getButtonRef().focus(),
                e.preventDefault(),
                e.stopPropagation();
                return
            }
            if (e.key === FD) {
                this.isExpanded = !1,
                this.getButtonRef().focus(),
                e.preventDefault();
                return
            }
            this.searchItem(e)
        },
        handleKeyDownButton(e) {
            if (e.key === FD) {
                this.toggleExpanded(),
                e.preventDefault();
                return
            }
            if (e.key === BD) {
                this.onArrowDown(),
                e.preventDefault();
                return
            }
            if (e.key === VD) {
                this.onArrowUp(),
                e.preventDefault();
                return
            }
            this.searchItem(e)
        },
        searchItem(e) {
            this.typingTimeout !== null && clearTimeout(this.typingTimeout),
            this.typingTimeout = setTimeout(() => {
                this.searchQuery = ""
            }, lBe),
            this.searchQuery += e.key,
            consola.trace(`Searching for ${this.searchQuery}`);
            const t = this.possibleValues.find(n => n.text.toLowerCase().startsWith(this.searchQuery.toLowerCase()));
            t && this.setSelected(t.id)
        },
        hasSelection() {
            return this.selectedIndex >= 0
        },
        getCurrentSelectedId() {
            try {
                return this.possibleValues[this.selectedIndex].id
            } catch {
                return ""
            }
        },
        generateId(e, t = null) {
            if (!t)
                return `${e}-${this.id}`;
            let n = String(t).replace(/[^\w]/gi, "");
            return `${e}-${this.id}-${n}`
        },
        clickAway() {
            this.isExpanded = !1
        }
    }
};
const uBe = ["id"], dBe = ["id", "aria-label", "aria-labelledby", "aria-expanded"], fBe = {
    key: 0,
    class: "loading-icon"
}, hBe = ["aria-activedescendant"], pBe = ["id", "title", "aria-selected", "onClick"], mBe = ["id", "name", "value"];
function gBe(e, t, n, r, o, i) {
    const s = B("DropdownIcon"),
    a = W1("click-away");
    return Cn((_(), O("div", {
                id: n.id,
                class: he(["dropdown", {
                            collapsed: !o.isExpanded,
                            invalid: !n.isValid,
                            disabled: n.disabled
                        }
                    ])
            }, [P("div", {
                        id: i.generateId("button"),
                        ref: "button",
                        role: "button",
                        tabindex: "0",
                        "aria-haspopup": "listbox",
                        class: he({
                            placeholder: i.showPlaceholder,
                            missing: i.isMissing
                        }),
                        "aria-label": n.ariaLabel,
                        "aria-labelledby": i.generateId("button"),
                        "aria-expanded": o.isExpanded,
                        onClick: t[0] || (t[0] = (...l) => i.toggleExpanded && i.toggleExpanded(...l)),
                        onKeydown: t[1] || (t[1] = (...l) => i.handleKeyDownButton && i.handleKeyDownButton(...l))
                    }, [mt(Re(i.displayText) + " ", 1), i.hasRightIcon ? (_(), O("div", fBe, [Ye(e.$slots, "icon-right")])) : J("", !0), z(s, {
                                class: "icon"
                            })], 42, dBe), Cn(P("ul", {
                            ref: "ul",
                            role: "listbox",
                            tabindex: "-1",
                            "aria-activedescendant": o.isExpanded ? i.generateId("option", i.getCurrentSelectedId()) : void 0,
                            onKeydown: t[2] || (t[2] = (...l) => i.handleKeyDownList && i.handleKeyDownList(...l))
                        }, [(_(!0), O(Le, null, $t(n.possibleValues, l => (_(), O("li", {
                                                    id: i.generateId("option", l.id),
                                                    key: `listbox-${l.id}`,
                                                    ref_for: !0,
                                                    ref: "options",
                                                    role: "option",
                                                    title: typeof l.title > "u" ? l.text : l.title,
                                                    class: he({
                                                        focused: i.isCurrentValue(l.id),
                                                        noselect: !0,
                                                        empty: l.text.trim() === "",
                                                        "has-option-template": i.hasOptionTemplate
                                                    }),
                                                    "aria-selected": i.isCurrentValue(l.id),
                                                    onClick: c => i.onOptionClick(l.id)
                                                }, [i.hasOptionTemplate ? Ye(e.$slots, "option", {
                                                            key: 0,
                                                            slotData: l.slotData
                                                        }) : (_(), O(Le, {
                                                                key: 1
                                                            }, [mt(Re(l.text), 1)], 64))], 10, pBe))), 128))], 40, hBe), [[Kn, o.isExpanded]]), P("input", {
                        id: n.id,
                        type: "hidden",
                        name: n.name,
                        value: n.modelValue
                    }, null, 8, mBe)], 10, uBe)), [[a, i.clickAway]])
}
const jw = te(cBe, [["render", gBe], ["__scopeId", "data-v-e982415f"]]);
const vBe = {
    components: {
        Button: Pr,
        Dropdown: jw,
        Label: Xn,
        DateTimeInput: nBe,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                datestring: ""
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    data() {
        return {
            localTimeZone: w9(),
            execTime: new Date
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        value() {
            return this.valuePair
        },
        showTime() {
            return String(this.viewRep.type).includes("T")
        },
        showDate() {
            return String(this.viewRep.type).includes("D")
        },
        showZone() {
            return String(this.viewRep.type).includes("Z")
        },
        showNowButton() {
            return this.viewRep.shownowbutton
        },
        showSeconds() {
            return this.viewRep.granularity === "show_seconds" || this.showMilliseconds
        },
        showMilliseconds() {
            return this.viewRep.granularity === "show_millis"
        },
        dateValue() {
            return this.value.zonestring ? {
                datestring: this.value.datestring,
                zonestring: this.value.zonestring
            }
             : this.viewRep.usedefaultexectime && this.value?.datestring === this.viewRep?.defaultValue?.datestring ? {
                datestring: this.formatDate(this.execTime),
                zonestring: this.localTimeZone
            }
             : this.parseKnimeDateString(this.value.datestring)
        },
        dateObject() {
            return Nd(this.dateValue.datestring, this.timezone)
        },
        timezone() {
            return this.dateValue.zonestring
        },
        possibleTimeZones() {
            return (this.viewRep.zones || []).map(e => ({
                    id: e,
                    text: e
                }))
        },
        minDate() {
            if (this.viewRep.usemin) {
                const {
                    datestring: e,
                    zonestring: t
                } = this.parseKnimeDateString(this.viewRep.min);
                return this.viewRep.useminexectime ? Nd(this.execTime, this.localTimeZone) : Nd(e, t)
            }
            return null
        },
        maxDate() {
            if (this.viewRep.usemax) {
                const {
                    datestring: e,
                    zonestring: t
                } = this.parseKnimeDateString(this.viewRep.max);
                return this.viewRep.usemaxexectime ? Nd(this.execTime, this.localTimeZone) : Nd(e, t)
            }
            return null
        }
    },
    mounted() {
        const {
            datestring: e,
            zonestring: t
        } = this.value || {}, {
            datestring: n,
            zonestring: r
        } = this.dateValue;
        (n !== e || r !== t) && this.publishUpdate(n, r)
    },
    methods: {
        parseKnimeDateString(e) {
            let t = e.match(/(.+)\[(.+)]/) || [null, "", ""];
            return {
                datestring: t[1],
                zonestring: t[2]
            }
        },
        formatDate(e) {
            return f0(e, "yyyy-MM-dd'T'HH:mm:ss.SSS")
        },
        onChange(e, t) {
            let n = eV(e, t),
            r = this.formatDate(n);
            this.publishUpdate(r, t)
        },
        publishUpdate(e, t) {
            this.$emit("updateWidget", {
                nodeId: this.nodeId,
                update: {
                    "viewRepresentation.currentValue": {
                        datestring: e,
                        zonestring: t
                    }
                }
            })
        },
        onDateChange(e) {
            this.onChange(e, this.timezone)
        },
        onTimezoneChange(e) {
            this.onChange(this.dateObject, e)
        },
        nowButtonClicked() {
            let e = new Date(Date.now());
            this.showDate || (e = Dm(this.dateObject, e)),
            this.onChange(e, this.localTimeZone)
        },
        validate() {
            let e = this.$refs.dateInput.validate(),
            t = Boolean(e.isValid),
            n = e.errorMessage || "Current input is invalid.";
            return {
                isValid: t,
                errorMessage: t ? null : n
            }
        }
    }
}, yBe = {
    class: "zone-wrapper"
};
function wBe(e, t, n, r, o, i) {
    const s = B("DateTimeInput"),
    a = B("Dropdown"),
    l = B("Button"),
    c = B("ErrorMessage"),
    u = B("Label");
    return _(),
    H(u, {
        class: "date-time-label",
        text: i.label,
        large: ""
    }, {
    default:
        oe(({
                labelForId: f
            }) => [z(s, {
                    id: f,
                    ref: "dateInput",
                    "model-value": i.dateObject,
                    required: i.viewRep.required,
                    min: i.minDate,
                    max: i.maxDate,
                    "show-date": i.showDate,
                    "show-time": i.showTime,
                    "show-seconds": i.showSeconds,
                    "show-milliseconds": i.showMilliseconds,
                    "is-valid": n.isValid,
                    timezone: i.showZone ? i.timezone : o.localTimeZone,
                    "onUpdate:modelValue": i.onDateChange
                }, null, 8, ["id", "model-value", "required", "min", "max", "show-date", "show-time", "show-seconds", "show-milliseconds", "is-valid", "timezone", "onUpdate:modelValue"]), P("div", yBe, [i.showZone ? (_(), H(a, {
                                key: 0,
                                ref: "timezone",
                                "aria-label": "Timezone",
                                "model-value": i.timezone,
                                class: "timezone",
                                "possible-values": i.possibleTimeZones,
                                "onUpdate:modelValue": i.onTimezoneChange
                            }, null, 8, ["model-value", "possible-values", "onUpdate:modelValue"])) : J("", !0), i.showNowButton ? (_(), H(l, {
                                key: 1,
                                ref: "nowButton",
                                primary: "",
                                compact: "",
                                class: "now-button",
                                onClick: i.nowButtonClicked
                            }, {
                            default:
                                oe(() => [mt(Re(i.showTime ? "Now" : "Today"), 1)]),
                                _: 1
                            }, 8, ["onClick"])) : J("", !0)]), z(c, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text"])
}
const bBe = te(vBe, [["render", wBe], ["__scopeId", "data-v-0bda4aa9"]]), _Be = 200, kBe = 50, xBe = .1, SBe = 1, CBe = {
    components: {
        ArrowIcon: al
    },
    props: {
        modelValue: {
        default:
            0,
            type: [Number, String],
            validator(e) {
                return typeof e == "string" ? e.toLowerCase().includes("e") : typeof e == "number"
            }
        },
        id: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        min: {
        default:
            Number.MIN_SAFE_INTEGER,
            type: Number
        },
        max: {
        default:
            Number.MAX_SAFE_INTEGER,
            type: Number
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        type: {
        default:
            "double",
            type: String
        },
        inputClasses: {
        default:
            "",
            type: String
        },
        disabled: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    data() {
        return {
            clicked: !1,
            hovered: !1,
            initialValue: 0,
            localValue: "",
            spinnerArrowTimeout: null,
            spinnerArrowInterval: null
        }
    },
    computed: {
        isInteger() {
            return this.type === "integer"
        },
        stepSize() {
            return this.isInteger ? SBe : xBe
        },
        inputClassList() {
            let e = this.inputClasses;
            return this.hovered && (e += " hover"),
            e
        },
        inputValue() {
            return typeof this.localValue == "number" && isNaN(this.localValue) ? "" : this.isInteger ? this.localValue : this.localValue.toString()
        }
    },
    watch: {
        modelValue: {
            handler() {
                this.parseValue(this.localValue) !== this.parseValue(this.modelValue) && (this.localValue = this.parseValue(this.modelValue))
            },
            immediate: !0
        }
    },
    mounted() {
        this.localValue = this.parseValue(this.modelValue),
        this.initialValue = this.localValue
    },
    methods: {
        getInputRef() {
            return this.$refs.input
        },
        parseValue(e) {
            return this.isInteger ? parseInt(e.toString(), 10) : parseFloat(e.toString())
        },
        getParsedValue() {
            return this.parseValue(this.localValue)
        },
        onInput(e) {
            const t = e.target.value;
            e && e.data === "." && !t || (t || (this.getInputRef().value = ""), this.updateAndEmit({
                    newValue: t
                }))
        },
        updateAndEmit({
            newValue: e
        }) {
            this.localValue = e,
            this.$emit("update:modelValue", this.getParsedValue())
        },
        onBlur() {
            this.localValue = this.getParsedValue(),
            this.getInputRef().valueAsNumber = this.localValue
        },
        validate(e) {
            let t = !0,
            n;
            return e = typeof e > "u" ? this.getParsedValue() : this.parseValue(e),
            typeof e != "number" || isNaN(e) ? (t = !1, n = "Current value is not a number.") : (this.min > e || this.max < e) && (t = !1, n = "Current value is outside allowed range."), {
                isValid: t,
                errorMessage: n
            }
        },
        changeValue(e) {
            let t = this.getParsedValue();
            this.validate(t).isValid || (t = this.findNearestValidValue(t));
            let n = t + e;
            n = Math.round(n * 10) / 10,
            this.validate(n).isValid && this.updateAndEmit({
                newValue: n
            })
        },
        findNearestValidValue(e) {
            return e < this.min ? this.min : e > this.max ? this.max : this.initialValue
        },
        mouseEvent(e, t) {
            if (this.disabled)
                return;
            this.spinnerArrowInterval !== null && clearTimeout(this.spinnerArrowInterval),
            this.spinnerArrowTimeout !== null && clearInterval(this.spinnerArrowTimeout);
            let n = this.stepSize;
            if (t === "decrease" && (n *= -1), e.type === "mousedown") {
                this.clicked = !0,
                this.spinnerArrowTimeout = setTimeout(() => {
                    this.spinnerArrowInterval = setInterval(() => {
                        this.changeValue(n)
                    }, kBe)
                }, _Be);
                return
            }
            this.clicked && (this.clicked = !1, this.changeValue(n))
        },
        toggleHover() {
            this.hovered = !this.hovered
        }
    }
};
const IBe = ["id", "name", "value", "min", "max", "step", "disabled"], TBe = {
    key: 0,
    class: "invalid-marker"
};
function MBe(e, t, n, r, o, i) {
    const s = B("ArrowIcon");
    return _(),
    O("div", {
        class: he(["wrapper", {
                    disabled: n.disabled
                }
            ])
    }, [P("input", {
                id: n.id,
                ref: "input",
                name: n.name,
                type: "number",
                role: "spinButton",
                value: i.inputValue,
                min: n.min,
                max: n.max,
                step: i.stepSize,
                class: he(i.inputClassList),
                disabled: n.disabled,
                onInput: t[0] || (t[0] = a => i.onInput(a)),
                onBlur: t[1] || (t[1] = (...a) => i.onBlur && i.onBlur(...a)),
                onMouseenter: t[2] || (t[2] = (...a) => i.toggleHover && i.toggleHover(...a)),
                onMouseleave: t[3] || (t[3] = (...a) => i.toggleHover && i.toggleHover(...a))
            }, null, 42, IBe), n.isValid ? J("", !0) : (_(), O("span", TBe)), P("span", {
                class: he(["increase", {
                            disabled: n.disabled
                        }
                    ]),
                onMousedown: t[4] || (t[4] = ve(a => i.mouseEvent(a, "increase"), ["prevent"])),
                onMouseup: t[5] || (t[5] = ve(a => i.mouseEvent(a, "increase"), ["prevent"])),
                onMouseleave: t[6] || (t[6] = a => i.mouseEvent(a, "increase"))
            }, [z(s)], 34), P("span", {
                class: he(["decrease", {
                            disabled: n.disabled
                        }
                    ]),
                onMousedown: t[7] || (t[7] = ve(a => i.mouseEvent(a, "decrease"), ["prevent"])),
                onMouseup: t[8] || (t[8] = ve(a => i.mouseEvent(a, "decrease"), ["prevent"])),
                onMouseleave: t[9] || (t[9] = a => i.mouseEvent(a, "decrease"))
            }, [z(s)], 34)], 2)
}
const PBe = te(CBe, [["render", MBe], ["__scopeId", "data-v-b6ce57f8"]]);
const EBe = {
    components: {
        Label: Xn,
        NumberInput: PBe,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.viewRepresentation && e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        type: {
        default:
            "double",
            type: String,
            validator(e) {
                return ["double", "integer"].includes(e)
            }
        },
        valuePair: {
        default:
            () => ({
                double: 0
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.valuePair[this.type]
        },
        min() {
            return this.viewRep.usemin ? this.viewRep.min : -Number.MAX_SAFE_INTEGER
        },
        max() {
            return this.viewRep.usemax ? this.viewRep.max : Number.MAX_SAFE_INTEGER
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: this.type,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t,
            n = this.$refs.form.getValue();
            if (isNaN(n) && (e = !1, t = "Current value is not a number."), (n < this.min || this.max < n) && (e = !1, t = "Current value is outside allowed range."), typeof this.$refs.form.validate == "function") {
                let r = this.$refs.form.validate();
                e = Boolean(r.isValid && e),
                t = r.errorMessage || t || "Current input is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function OBe(e, t, n, r, o, i) {
    const s = B("NumberInput"),
    a = B("Label"),
    l = B("ErrorMessage");
    return _(),
    O("div", null, [z(a, {
                text: i.label,
                large: ""
            }, {
            default:
                oe(({
                        labelForId: c
                    }) => [z(s, {
                            id: c,
                            ref: "form",
                            type: n.type,
                            "model-value": i.value,
                            min: i.min,
                            max: i.max,
                            "is-valid": n.isValid,
                            title: i.description,
                            "onUpdate:modelValue": i.onChange
                        }, null, 8, ["id", "type", "model-value", "min", "max", "is-valid", "title", "onUpdate:modelValue"])]),
                _: 1
            }, 8, ["text"]), z(l, {
                error: n.errorMessage
            }, null, 8, ["error"])])
}
const S9 = te(EBe, [["render", OBe], ["__scopeId", "data-v-ee9291ec"]]), $Be = {
    components: {
        NumberWidget: S9
    },
    methods: {
        validate() {
            return this.$refs.widget.validate()
        },
        onChange(e) {
            return this.$refs.widget.onChange(e)
        }
    }
};
function ABe(e, t, n, r, o, i) {
    const s = B("NumberWidget");
    return _(),
    H(s, Bt(e.$attrs, {
            ref: "widget",
            type: "double"
        }), null, 16)
}
const DBe = te($Be, [["render", ABe]]);
/**
 * filesize
 *
 * @copyright 2022 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.0.6
 */
const NBe = "array", RBe = "bit", jD = "bits", LBe = "byte", WD = "bytes", za = "", BBe = "exponent", VBe = "function", Lv = "iec", FBe = "Invalid number", jBe = "Invalid rounding method", ep = "jedec", WBe = "object", zD = ".", C9 = "round", zBe = "s", HBe = "kbit", UBe = "kB", I9 = " ", T9 = "string", qBe = "0", y2 = {
    symbol: {
        iec: {
            bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
            bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        },
        jedec: {
            bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
            bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }
    },
    fullform: {
        iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
        jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
    }
};
function YBe(e, {
    bits: t = !1,
    pad: n = !1,
    base: r = -1,
    round: o = 2,
    locale: i = za,
    localeOptions: s = {},
    separator: a = za,
    spacer: l = I9,
    symbols: c = {},
    standard: u = za,
    output: f = T9,
    fullform: p = !1,
    fullforms: m = [],
    exponent: v = -1,
    roundingMethod: y = C9,
    precision: b = 0
} = {}) {
    let w = v,
    k = Number(e),
    C = [],
    x = 0,
    S = za;
    r === -1 && u.length === 0 ? (r = 10, u = ep) : r === -1 && u.length > 0 ? (u = u === Lv ? Lv : ep, r = u === Lv ? 2 : 10) : (r = r === 2 ? 2 : 10, u = r === 10 || u === ep ? ep : Lv);
    const T = r === 10 ? 1e3 : 1024,
    E = p === !0,
    M = k < 0,
    N = Math[y];
    if (typeof e != "bigint" && isNaN(e))
        throw new TypeError(FBe);
    if (typeof N !== VBe)
        throw new TypeError(jBe);
    if (M && (k = -k), (w === -1 || isNaN(w)) && (w = Math.floor(Math.log(k) / Math.log(T)), w < 0 && (w = 0)), w > 8 && (b > 0 && (b += 8 - w), w = 8), f === BBe)
        return w;
    if (k === 0)
        C[0] = 0, S = C[1] = y2.symbol[u][t ? jD : WD][w];
    else {
        x = k / (r === 2 ? Math.pow(2, w * 10) : Math.pow(1e3, w)),
        t && (x = x * 8, x >= T && w < 8 && (x = x / T, w++));
        const F = Math.pow(10, w > 0 ? o : 0);
        C[0] = N(x * F) / F,
        C[0] === T && w < 8 && v === -1 && (C[0] = 1, w++),
        S = C[1] = r === 10 && w === 1 ? t ? HBe : UBe : y2.symbol[u][t ? jD : WD][w]
    }
    if (M && (C[0] = -C[0]), b > 0 && (C[0] = C[0].toPrecision(b)), C[1] = c[C[1]] || C[1], i === !0 ? C[0] = C[0].toLocaleString() : i.length > 0 ? C[0] = C[0].toLocaleString(i, s) : a.length > 0 && (C[0] = C[0].toString().replace(zD, a)), n && Number.isInteger(C[0]) === !1 && o > 0) {
        const F = a || zD,
        K = C[0].toString().split(F),
        j = K[1] || za,
        G = j.length,
        Y = o - G;
        C[0] = `${K[0]}${F}${j.padEnd(G + Y, qBe)}`
    }
    return E && (C[1] = m[w] ? m[w] : y2.fullform[u][w] + (t ? RBe : LBe) + (C[0] === 1 ? za : zBe)),
    f === NBe ? C : f === WBe ? {
        value: C[0],
        symbol: C[1],
        exponent: w,
        unit: S
    }
     : C.join(l)
}
function jx({
    bits: e = !1,
    pad: t = !1,
    base: n = -1,
    round: r = 2,
    locale: o = za,
    localeOptions: i = {},
    separator: s = za,
    spacer: a = I9,
    symbols: l = {},
    standard: c = za,
    output: u = T9,
    fullform: f = !1,
    fullforms: p = [],
    exponent: m = -1,
    roundingMethod: v = C9,
    precision: y = 0
} = {}) {
    return b => YBe(b, {
        bits: e,
        pad: t,
        base: n,
        round: r,
        locale: o,
        localeOptions: i,
        separator: s,
        spacer: a,
        symbols: l,
        standard: c,
        output: u,
        fullform: f,
        fullforms: p,
        exponent: m,
        roundingMethod: v,
        precision: y
    })
}
const KBe = "knime.workflow", GBe = "knime.mountpoint", JI = e => {
    if (typeof e != "string")
        return "";
    let t = e.split(/[\\/]/).pop(),
    n = t.lastIndexOf(".");
    return t === "" || n < 1 ? "" : t.slice(n + 1)
}, XBe = e => typeof e != "string" ? "" : e.split(/[\\/]/).pop(), JBe = (e, t) => {
    if (!e || !t)
        return "";
    let n = e.replace(t, ""),
    r = n.substring(n.indexOf("/"));
    return r.length && r[r.length - 1] === "/" && (r = r.substring(0, r.length - 1)),
    r
}, ZBe = (e, t) => {
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let o = e[r];
        !o || o === "." || (o === ".." ? n.length && n[n.length - 1] !== ".." ? n.pop() : t && n.push("..") : n.push(o))
    }
    return n
}, M9 = e => {
    let t = ZBe(e.split("/"), !0).join("/");
    return t.startsWith("/") || (t = `/${t}`),
    t
}, QBe = (e, t) => {
    let n = e;
    return t && (t.endsWith("/") && (t = t.substring(0, t.length - 1)), n = M9(t + e)),
    n
}, e7e = (e, t, n, r) => {
    if (e.toLowerCase().startsWith(t)) {
        let o = e.replace(t, ""),
        i = o.indexOf("/") + 1;
        e = o.substring(i - 1);
        let s = o.substring(0, i - 1);
        s === KBe ? e = QBe(e, r) : (s === GBe || !s.startsWith(n)) && (e = M9(e))
    }
    return e
};
const w2 = "path", t7e = {
    components: {
        Label: Xn,
        ErrorMessage: Lr,
        Button: Pr,
        CircleCheckIcon: PL
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo && e.viewRepresentation
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return Boolean(e)
            }
        },
        alignment: {
            type: String,
        default:
            "horizontal",
            validator(e) {
                return ["horizontal", "vertical"].includes(e)
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [w2]: ""
            }),
            type: Object
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    emits: ["updateWidget"],
    data() {
        return {
            uploadAPI: null,
            uploadProgress: 0,
            uploading: !1,
            uploadErrorMessage: null,
            initialized: !1,
            localFileName: null,
            localFileSize: null
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description
        },
        fileTypes() {
            return this.viewRep.fileTypes
        },
        disabled() {
            return !1
        },
        path() {
            return this.valuePair?.path
        },
        fileName() {
            return this.valuePair?.fileName || this.localFileName || "No file selected."
        },
        fileSize() {
            return this.localFileSize ? jx({
                output: "object"
            })(this.localFileSize) : null
        },
        progressStyle() {
            return isNaN(this.uploadProgress) ? "width:0%;" : `width:${this.uploadProgress}%;`
        }
    },
    mounted() {
        this.uploadAPI = this.$store.getters["api/uploadResource"]
    },
    methods: {
        async onChange(e) {
            if (!e.target)
                return null;
            let t = e.target.files[0];
            if (!t)
                return null;
            if (this.uploading = !0, this.uploadErrorMessage = null, this.localFileName = t.name, this.localFileSize = t.size, window?.KnimePageLoader) {
                let o = new FileReader;
                return o.onload = i => {
                    this.setUploadProgress(100),
                    this.$emit("updateWidget", {
                        nodeId: this.nodeId,
                        type: w2,
                        update: {
                            "viewRepresentation.currentValue.path": i.target.result,
                            "viewRepresentation.currentValue.fileName": this.localFileName
                        }
                    }),
                    this.uploading = !1
                },
                o.readAsDataURL(t),
                null
            }
            let {
                response: n,
                errorResponse: r
            } = await this.uploadAPI({
                nodeId: this.nodeId,
                resource: t,
                progressCallback: this.setUploadProgress,
                context: this
            });
            return this.uploading = !1,
            r ? (this.uploadErrorMessage = r.cancelled ? "Upload cancelled." : "Upload failed.", this.localFileName = null, this.localFileSize = null, null) : (this.$emit("updateWidget", {
                    nodeId: this.nodeId,
                    type: w2,
                    update: {
                        "viewRepresentation.currentValue.path": n.location,
                        "viewRepresentation.currentValue.fileName": this.localFileName
                    }
                }), null)
        },
        setUploadProgress(e) {
            this.uploadProgress = e,
            e === 100 && (this.uploading = !1)
        },
        validate() {
            let e = !0,
            t = null;
            return this.uploadAPI ? (this.fileTypes?.length && this.fileName && (e = this.fileTypes?.map(n => n?.toLowerCase()).includes(`.${JI(this.fileName)?.toLowerCase()}`), e || (t = `The type of the selected file does not match the allowed file types (${this.fileTypes.join(", ")}).`)), this.initialized ? (this.uploading ? (e = !1, t = "Upload still in progress.") : this.path || (e = !1, t = "Input is required."), {
                    isValid: e,
                    errorMessage: e ? null : t
                }) : (this.initialized = !0, {
                    isValid: e,
                    errorMessage: t
                })) : {
                isValid: e
            }
        },
        triggerInput() {
            this.$refs.input.click()
        },
        abortUpload() {
            this.$store.getters["api/cancelUploadResource"]({
                nodeId: this.nodeId
            })
        }
    }
}, n7e = ["title"], r7e = {
    class: "upload-wrapper"
}, o7e = ["accept"];
function i7e(e, t, n, r, o, i) {
    const s = B("Button"),
    a = B("CircleCheckIcon"),
    l = B("Label"),
    c = B("ErrorMessage");
    return _(),
    O("div", {
        class: he(n.alignment),
        title: i.description
    }, [z(l, {
                text: i.label,
                large: ""
            }, {
            default:
                oe(() => [P("div", r7e, [o.uploading ? (_(), H(s, {
                                        key: 1,
                                        primary: "",
                                        compact: "",
                                        onClick: i.abortUpload
                                    }, {
                                    default:
                                        oe(() => [mt(" Cancel ")]),
                                        _: 1
                                    }, 8, ["onClick"])) : (_(), H(s, {
                                        key: 0,
                                        primary: "",
                                        compact: "",
                                        disabled: i.disabled,
                                        onClick: i.triggerInput
                                    }, {
                                    default:
                                        oe(() => [mt(" Select file ")]),
                                        _: 1
                                    }, 8, ["disabled", "onClick"])), P("p", {
                                    class: he({
                                        disabled: i.disabled
                                    })
                                }, [mt(Re(i.fileName || "No file selected.") + Re(i.fileSize ? ` (${i.fileSize.value} ${i.fileSize.symbol})` : "") + " ", 1), o.uploadProgress === 100 ? (_(), H(a, {
                                                key: 0
                                            })) : J("", !0)], 2)]), P("input", {
                            ref: "input",
                            type: "file",
                            accept: i.fileTypes.join(","),
                            onChange: t[0] || (t[0] = (...u) => i.onChange && i.onChange(...u))
                        }, null, 40, o7e), P("div", {
                            class: he(["progress-bar-wrapper", {
                                        "show-bar": o.uploading
                                    }
                                ])
                        }, [P("div", {
                                    class: "progress-bar",
                                    style: Yt(i.progressStyle)
                                }, [P("span", null, Re(o.uploadProgress) + "% ", 1)], 4)], 2)]),
                _: 1
            }, 8, ["text"]), z(c, {
                error: o.uploadErrorMessage || n.errorMessage
            }, null, 8, ["error"])], 10, n7e)
}
const s7e = te(t7e, [["render", i7e], ["__scopeId", "data-v-84249bdb"]]), a7e = {
    components: {
        NumberWidget: S9
    },
    methods: {
        validate() {
            return this.$refs.widget.validate()
        },
        onChange(e) {
            return this.$refs.widget.onChange(e)
        }
    }
};
function l7e(e, t, n, r, o, i) {
    const s = B("NumberWidget");
    return _(),
    H(s, Bt(e.$attrs, {
            ref: "widget",
            type: "integer"
        }), null, 16)
}
const c7e = te(a7e, [["render", l7e]]);
const u7e = {
    props: {
        modelValue: {
        default:
            "",
            type: [Number, String]
        },
        id: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        cols: {
        default:
            12,
            type: Number
        },
        rows: {
        default:
            4,
            type: Number
        },
        placeholder: {
        default:
            null,
            type: String
        },
        inputClasses: {
        default:
            "",
            type: String
        },
        title: {
        default:
            null,
            type: String
        },
        disabled: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    methods: {
        getValue() {
            return this.$refs.input.value
        },
        onInput() {
            this.$emit("update:modelValue", this.getValue())
        }
    }
}, d7e = ["id", "name", "title", "value", "cols", "disabled", "rows", "placeholder"], f7e = {
    key: 0,
    class: "invalid-marker"
};
function h7e(e, t, n, r, o, i) {
    return _(),
    O("div", {
        class: he({
            disabled: n.disabled
        })
    }, [P("textarea", {
                id: n.id,
                ref: "input",
                name: n.name,
                title: n.title,
                value: n.modelValue,
                class: he(n.inputClasses),
                cols: n.cols,
                disabled: n.disabled,
                rows: n.rows,
                placeholder: n.placeholder,
                onInput: t[0] || (t[0] = (...s) => i.onInput && i.onInput(...s))
            }, null, 42, d7e), n.isValid ? J("", !0) : (_(), O("span", f7e))], 2)
}
const P9 = te(u7e, [["render", h7e], ["__scopeId", "data-v-f0d0b064"]]);
const b2 = "string", p7e = {
    components: {
        Label: Xn,
        TextArea: P9,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return Boolean(e)
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [b2]: ""
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.valuePair[b2]
        },
        regex() {
            return this.viewRep.regex || null
        },
        viewErrorMessage() {
            return this.viewRep.errormessage || null
        },
        separator() {
            return this.viewRep.separator || null
        },
        separateEachCharacter() {
            return this.viewRep.separateeachcharacter || !1
        },
        omitEmpty() {
            return this.viewRep.omitempty || !1
        },
        numberVisOptions() {
            return this.viewRep.numberVisOptions
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: b2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        getSplitValues() {
            let e = this.$refs.form.getValue();
            if (!e)
                return [];
            let t = this.separator === "\\n" ? `
` : this.separator,
            n = e.split(this.separateEachCharacter ? "" : t);
            return this.omitEmpty && (n = n.filter(r => r !== "")),
            n
        },
        validate() {
            let e = this.getSplitValues(),
            t = (n, r) => ({
                isValid: !1,
                errorMessage: r ? n.replace("?", r) : n
            });
            if (this.viewRep.required && !this.$refs.form.getValue())
                return t("Input is required.");
            if (this.regex)
                for (let n = 0; n < e.length; n++) {
                    const r = e[n].match(new RegExp(`^(?:${this.regex})$`, "u"));
                    if (!(r !== null && r[0] === e[n]))
                        return t([`Value ${n + 1} is not valid.`, this.viewErrorMessage].filter(Boolean).join(" "), e[n])
                }
            return {
                isValid: !0,
                errorMessage: null
            }
        }
    }
}, m7e = {
    class: "list-box-input"
};
function g7e(e, t, n, r, o, i) {
    const s = B("TextArea"),
    a = B("ErrorMessage"),
    l = B("Label");
    return _(),
    O("div", m7e, [z(l, {
                text: i.label,
                large: ""
            }, {
            default:
                oe(({
                        labelForId: c
                    }) => [z(s, {
                            id: c,
                            ref: "form",
                            "model-value": i.value,
                            cols: 20,
                            rows: i.numberVisOptions,
                            "is-valid": n.isValid,
                            title: i.description,
                            "onUpdate:modelValue": i.onChange
                        }, null, 8, ["id", "model-value", "rows", "is-valid", "title", "onUpdate:modelValue"]), z(a, {
                            error: n.errorMessage
                        }, null, 8, ["error"])]),
                _: 1
            }, 8, ["text"])])
}
const v7e = te(p7e, [["render", g7e], ["__scopeId", "data-v-dfd7aa41"]]);
var Wx = {}, y7e = {
    get exports() {
        return Wx
    },
    set exports(e) {
        Wx = e
    }
};
const w7e = b6(oL);
(function (e, t) {
    (function (n, r) {
        e.exports = r(w7e)
    })(typeof self < "u" ? self : Mt, function (n) {
        return function () {
            var r = {
                388: function (a, l) {
                    var c,
                    u,
                    f;
                    (function (p, m) {
                        u = [],
                        c = m,
                        f = typeof c == "function" ? c.apply(l, u) : c,
                        f === void 0 || (a.exports = f)
                    })(typeof self < "u" && self, function () {
                        function p() {
                            var m = Object.getOwnPropertyDescriptor(document, "currentScript");
                            if (!m && "currentScript" in document && document.currentScript || m && m.get !== p && document.currentScript)
                                return document.currentScript;
                            try {
                                throw new Error
                            } catch (N) {
                                var v,
                                y,
                                b,
                                w = /.*at [^(]*\((.*):(.+):(.+)\)$/gi,
                                k = /@([^@]*):(\d+):(\d+)\s*$/gi,
                                C = w.exec(N.stack) || k.exec(N.stack),
                                x = C && C[1] || !1,
                                S = C && C[2] || !1,
                                T = document.location.href.replace(document.location.hash, ""),
                                E = document.getElementsByTagName("script");
                                x === T && (v = document.documentElement.outerHTML, y = new RegExp("(?:[^\\n]+?\\n){0," + (S - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i"), b = v.replace(y, "$1").trim());
                                for (var M = 0; M < E.length; M++)
                                    if (E[M].readyState === "interactive" || E[M].src === x || x === T && E[M].innerHTML && E[M].innerHTML.trim() === b)
                                        return E[M];
                                return null
                            }
                        }
                        return p
                    })
                },
                905: function (a, l, c) {
                    c.r(l);
                    var u = c(117),
                    f = c.n(u),
                    p = c(488),
                    m = c.n(p),
                    v = m()(f());
                    v.push([a.id, ".vue-slider-dot{position:absolute;-webkit-transition:all 0s;transition:all 0s;z-index:5}.vue-slider-dot:focus{outline:none}.vue-slider-dot-tooltip{position:absolute;visibility:hidden}.vue-slider-dot-hover:hover .vue-slider-dot-tooltip,.vue-slider-dot-tooltip-show{visibility:visible}.vue-slider-dot-tooltip-top{top:-10px;left:50%;-webkit-transform:translate(-50%,-100%);transform:translate(-50%,-100%)}.vue-slider-dot-tooltip-bottom{bottom:-10px;left:50%;-webkit-transform:translate(-50%,100%);transform:translate(-50%,100%)}.vue-slider-dot-tooltip-left{left:-10px;top:50%;-webkit-transform:translate(-100%,-50%);transform:translate(-100%,-50%)}.vue-slider-dot-tooltip-right{right:-10px;top:50%;-webkit-transform:translate(100%,-50%);transform:translate(100%,-50%)}", ""]),
                    l.default = v
                },
                121: function (a, l, c) {
                    c.r(l);
                    var u = c(117),
                    f = c.n(u),
                    p = c(488),
                    m = c.n(p),
                    v = m()(f());
                    v.push([a.id, ".vue-slider-marks{position:relative;width:100%;height:100%}.vue-slider-mark{position:absolute;z-index:1}.vue-slider-ltr .vue-slider-mark,.vue-slider-rtl .vue-slider-mark{width:0;height:100%;top:50%}.vue-slider-ltr .vue-slider-mark-step,.vue-slider-rtl .vue-slider-mark-step{top:0}.vue-slider-ltr .vue-slider-mark-label,.vue-slider-rtl .vue-slider-mark-label{top:100%;margin-top:10px}.vue-slider-ltr .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ltr .vue-slider-mark-step{left:0}.vue-slider-ltr .vue-slider-mark-label{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.vue-slider-rtl .vue-slider-mark{-webkit-transform:translate(50%,-50%);transform:translate(50%,-50%)}.vue-slider-rtl .vue-slider-mark-step{right:0}.vue-slider-rtl .vue-slider-mark-label{right:50%;-webkit-transform:translateX(50%);transform:translateX(50%)}.vue-slider-btt .vue-slider-mark,.vue-slider-ttb .vue-slider-mark{width:100%;height:0;left:50%}.vue-slider-btt .vue-slider-mark-step,.vue-slider-ttb .vue-slider-mark-step{left:0}.vue-slider-btt .vue-slider-mark-label,.vue-slider-ttb .vue-slider-mark-label{left:100%;margin-left:10px}.vue-slider-btt .vue-slider-mark{-webkit-transform:translate(-50%,50%);transform:translate(-50%,50%)}.vue-slider-btt .vue-slider-mark-step{top:0}.vue-slider-btt .vue-slider-mark-label{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.vue-slider-ttb .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ttb .vue-slider-mark-step{bottom:0}.vue-slider-ttb .vue-slider-mark-label{bottom:50%;-webkit-transform:translateY(50%);transform:translateY(50%)}.vue-slider-mark-label,.vue-slider-mark-step{position:absolute}", ""]),
                    l.default = v
                },
                207: function (a, l, c) {
                    c.r(l);
                    var u = c(117),
                    f = c.n(u),
                    p = c(488),
                    m = c.n(p),
                    v = m()(f());
                    v.push([a.id, ".vue-slider{position:relative;-webkit-box-sizing:content-box;box-sizing:content-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;-webkit-tap-highlight-color:rgba(0,0,0,0)}.vue-slider-rail{position:relative;width:100%;height:100%;-webkit-transition-property:width,height,left,right,top,bottom;transition-property:width,height,left,right,top,bottom}.vue-slider-process{position:absolute;z-index:1}", ""]),
                    l.default = v
                },
                488: function (a) {
                    a.exports = function (l) {
                        var c = [];
                        return c.toString = function () {
                            return this.map(function (u) {
                                var f = "",
                                p = typeof u[5] < "u";
                                return u[4] && (f += "@supports (".concat(u[4], ") {")),
                                u[2] && (f += "@media ".concat(u[2], " {")),
                                p && (f += "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {")),
                                f += l(u),
                                p && (f += "}"),
                                u[2] && (f += "}"),
                                u[4] && (f += "}"),
                                f
                            }).join("")
                        },
                        c.i = function (u, f, p, m, v) {
                            typeof u == "string" && (u = [[null, u, void 0]]);
                            var y = {};
                            if (p)
                                for (var b = 0; b < this.length; b++) {
                                    var w = this[b][0];
                                    w != null && (y[w] = !0)
                                }
                            for (var k = 0; k < u.length; k++) {
                                var C = [].concat(u[k]);
                                p && y[C[0]] || (typeof v < "u" && (typeof C[5] > "u" || (C[1] = "@layer".concat(C[5].length > 0 ? " ".concat(C[5]) : "", " {").concat(C[1], "}")), C[5] = v), f && (C[2] && (C[1] = "@media ".concat(C[2], " {").concat(C[1], "}")), C[2] = f), m && (C[4] ? (C[1] = "@supports (".concat(C[4], ") {").concat(C[1], "}"), C[4] = m) : C[4] = "".concat(m)), c.push(C))
                            }
                        },
                        c
                    }
                },
                117: function (a) {
                    a.exports = function (l) {
                        return l[1]
                    }
                },
                831: function (a, l) {
                    l.Z = (c, u) => {
                        const f = c.__vccOpts || c;
                        for (const [p, m] of u)
                            f[p] = m;
                        return f
                    }
                },
                466: function (a, l, c) {
                    var u = c(905);
                    u.__esModule && (u = u.default),
                    typeof u == "string" && (u = [[a.id, u, ""]]),
                    u.locals && (a.exports = u.locals);
                    var f = c(959).Z;
                    f("50bc1720", u, !0, {
                        sourceMap: !1,
                        shadowMode: !1
                    })
                },
                18: function (a, l, c) {
                    var u = c(121);
                    u.__esModule && (u = u.default),
                    typeof u == "string" && (u = [[a.id, u, ""]]),
                    u.locals && (a.exports = u.locals);
                    var f = c(959).Z;
                    f("10aa5f36", u, !0, {
                        sourceMap: !1,
                        shadowMode: !1
                    })
                },
                631: function (a, l, c) {
                    var u = c(207);
                    u.__esModule && (u = u.default),
                    typeof u == "string" && (u = [[a.id, u, ""]]),
                    u.locals && (a.exports = u.locals);
                    var f = c(959).Z;
                    f("1772934e", u, !0, {
                        sourceMap: !1,
                        shadowMode: !1
                    })
                },
                959: function (a, l, c) {
                    function u(j, G) {
                        for (var Y = [], ue = {}, re = 0; re < G.length; re++) {
                            var de = G[re],
                            Se = de[0],
                            Pe = de[1],
                            je = de[2],
                            Ke = de[3],
                            Ue = {
                                id: j + ":" + re,
                                css: Pe,
                                media: je,
                                sourceMap: Ke
                            };
                            ue[Se] ? ue[Se].parts.push(Ue) : Y.push(ue[Se] = {
                                    id: Se,
                                    parts: [Ue]
                                })
                        }
                        return Y
                    }
                    c.d(l, {
                        Z: function () {
                            return S
                        }
                    });
                    var f = typeof document < "u";
                    if (typeof DEBUG < "u" && DEBUG && !f)
                        throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
                    var p = {},
                    m = f && (document.head || document.getElementsByTagName("head")[0]),
                    v = null,
                    y = 0,
                    b = !1,
                    w = function () {},
                    k = null,
                    C = "data-vue-ssr-id",
                    x = typeof navigator < "u" && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
                    function S(j, G, Y, ue) {
                        b = Y,
                        k = ue || {};
                        var re = u(j, G);
                        return T(re),
                        function (de) {
                            for (var Se = [], Pe = 0; Pe < re.length; Pe++) {
                                var je = re[Pe],
                                Ke = p[je.id];
                                Ke.refs--,
                                Se.push(Ke)
                            }
                            for (de ? (re = u(j, de), T(re)) : re = [], Pe = 0; Pe < Se.length; Pe++)
                                if (Ke = Se[Pe], Ke.refs === 0) {
                                    for (var Ue = 0; Ue < Ke.parts.length; Ue++)
                                        Ke.parts[Ue]();
                                    delete p[Ke.id]
                                }
                        }
                    }
                    function T(j) {
                        for (var G = 0; G < j.length; G++) {
                            var Y = j[G],
                            ue = p[Y.id];
                            if (ue) {
                                ue.refs++;
                                for (var re = 0; re < ue.parts.length; re++)
                                    ue.parts[re](Y.parts[re]);
                                for (; re < Y.parts.length; re++)
                                    ue.parts.push(M(Y.parts[re]));
                                ue.parts.length > Y.parts.length && (ue.parts.length = Y.parts.length)
                            } else {
                                var de = [];
                                for (re = 0; re < Y.parts.length; re++)
                                    de.push(M(Y.parts[re]));
                                p[Y.id] = {
                                    id: Y.id,
                                    refs: 1,
                                    parts: de
                                }
                            }
                        }
                    }
                    function E() {
                        var j = document.createElement("style");
                        return j.type = "text/css",
                        m.appendChild(j),
                        j
                    }
                    function M(j) {
                        var G,
                        Y,
                        ue = document.querySelector("style[" + C + '~="' + j.id + '"]');
                        if (ue) {
                            if (b)
                                return w;
                            ue.parentNode.removeChild(ue)
                        }
                        if (x) {
                            var re = y++;
                            ue = v || (v = E()),
                            G = F.bind(null, ue, re, !1),
                            Y = F.bind(null, ue, re, !0)
                        } else
                            ue = E(), G = K.bind(null, ue), Y = function () {
                                ue.parentNode.removeChild(ue)
                            };
                        return G(j),
                        function (de) {
                            if (de) {
                                if (de.css === j.css && de.media === j.media && de.sourceMap === j.sourceMap)
                                    return;
                                G(j = de)
                            } else
                                Y()
                        }
                    }
                    var N = function () {
                        var j = [];
                        return function (G, Y) {
                            return j[G] = Y,
                            j.filter(Boolean).join(`
`)
                        }
                    }
                    ();
                    function F(j, G, Y, ue) {
                        var re = Y ? "" : ue.css;
                        if (j.styleSheet)
                            j.styleSheet.cssText = N(G, re);
                        else {
                            var de = document.createTextNode(re),
                            Se = j.childNodes;
                            Se[G] && j.removeChild(Se[G]),
                            Se.length ? j.insertBefore(de, Se[G]) : j.appendChild(de)
                        }
                    }
                    function K(j, G) {
                        var Y = G.css,
                        ue = G.media,
                        re = G.sourceMap;
                        if (ue && j.setAttribute("media", ue), k.ssrId && j.setAttribute(C, G.id), re && (Y += `
/*# sourceURL=` + re.sources[0] + " */", Y += `
/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(re)))) + " */"), j.styleSheet)
                            j.styleSheet.cssText = Y;
                        else {
                            for (; j.firstChild; )
                                j.removeChild(j.firstChild);
                            j.appendChild(document.createTextNode(Y))
                        }
                    }
                },
                927: function (a) {
                    a.exports = n
                }
            },
            o = {};
            function i(a) {
                var l = o[a];
                if (l !== void 0)
                    return l.exports;
                var c = o[a] = {
                    id: a,
                    exports: {}
                };
                return r[a].call(c.exports, c, c.exports, i),
                c.exports
            }
            (function () {
                i.n = function (a) {
                    var l = a && a.__esModule ? function () {
                        return a.default
                    }
                     : function () {
                        return a
                    };
                    return i.d(l, {
                        a: l
                    }),
                    l
                }
            })(),
            function () {
                i.d = function (a, l) {
                    for (var c in l)
                        i.o(l, c) && !i.o(a, c) && Object.defineProperty(a, c, {
                            enumerable: !0,
                            get: l[c]
                        })
                }
            }
            (),
            function () {
                i.o = function (a, l) {
                    return Object.prototype.hasOwnProperty.call(a, l)
                }
            }
            (),
            function () {
                i.r = function (a) {
                    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                }
            }
            (),
            function () {
                i.p = ""
            }
            ();
            var s = {};
            return function () {
                if (i.d(s, {
                    default:
                        function () {
                            return hn
                        }
                    }), typeof window < "u") {
                    var a = window.document.currentScript,
                    l = i(388);
                    a = l(),
                    "currentScript" in document || Object.defineProperty(document, "currentScript", {
                        get: l
                    });
                    var c = a && a.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
                    c && (i.p = c[1])
                }
                var u = i(927);
                function f($, D, q) {
                    return D in $ ? Object.defineProperty($, D, {
                        value: q,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : $[D] = q,
                    $
                }
                var p = {
                    key: 0,
                    class: "vue-slider-marks"
                };
                function m($, D, q, ie, Ae, it) {
                    var vt = (0, u.resolveComponent)("vue-slider-mark"),
                    gr = (0, u.resolveComponent)("vue-slider-dot");
                    return (0, u.openBlock)(),
                    (0, u.createElementBlock)("div", (0, u.mergeProps)({
                            ref: "container",
                            class: $.containerClasses,
                            style: $.containerStyles,
                            onClick: D[2] || (D[2] = function () {
                                return $.clickHandle && $.clickHandle.apply($, arguments)
                            }),
                            onTouchstartPassive: D[3] || (D[3] = function () {
                                return $.dragStartOnProcess && $.dragStartOnProcess.apply($, arguments)
                            }),
                            onMousedownPassive: D[4] || (D[4] = function () {
                                return $.dragStartOnProcess && $.dragStartOnProcess.apply($, arguments)
                            })
                        }, $.$attrs), [(0, u.createElementVNode)("div", {
                                class: "vue-slider-rail",
                                style: (0, u.normalizeStyle)($.railStyle)
                            }, [((0, u.openBlock)(!0), (0, u.createElementBlock)(u.Fragment, null, (0, u.renderList)($.processArray, function (gt, Zn) {
                                                return (0, u.renderSlot)($.$slots, "process", (0, u.normalizeProps)((0, u.guardReactiveProps)(gt)), function () {
                                                    return [((0, u.openBlock)(), (0, u.createElementBlock)("div", {
                                                                class: "vue-slider-process",
                                                                key: "process-".concat(Zn),
                                                                style: (0, u.normalizeStyle)(gt.style)
                                                            }, null, 4))]
                                                })
                                            }), 256)), $.sliderMarks && $.control ? ((0, u.openBlock)(), (0, u.createElementBlock)("div", p, [((0, u.openBlock)(!0), (0, u.createElementBlock)(u.Fragment, null, (0, u.renderList)($.control.markList, function (gt, Zn) {
                                                            return (0, u.renderSlot)($.$slots, "mark", (0, u.normalizeProps)((0, u.guardReactiveProps)(gt)), function () {
                                                                var Sr;
                                                                return [((0, u.openBlock)(), (0, u.createBlock)(vt, {
                                                                            key: "mark-".concat(Zn),
                                                                            mark: gt,
                                                                            hideLabel: $.hideLabel,
                                                                            style: (0, u.normalizeStyle)((Sr = {}, f(Sr, $.isHorizontal ? "height" : "width", "100%"), f(Sr, $.isHorizontal ? "width" : "height", $.tailSize), f(Sr, $.mainDirection, "".concat(gt.pos, "%")), Sr)),
                                                                            stepStyle: $.stepStyle,
                                                                            stepActiveStyle: $.stepActiveStyle,
                                                                            labelStyle: $.labelStyle,
                                                                            labelActiveStyle: $.labelActiveStyle,
                                                                            onPressLabel: D[0] || (D[0] = function (ce) {
                                                                                return $.clickable && $.setValueByPos(ce)
                                                                            })
                                                                        }, {
                                                                            step: (0, u.withCtx)(function () {
                                                                                return [(0, u.renderSlot)($.$slots, "step", (0, u.normalizeProps)((0, u.guardReactiveProps)(gt)))]
                                                                            }),
                                                                            label: (0, u.withCtx)(function () {
                                                                                return [(0, u.renderSlot)($.$slots, "label", (0, u.normalizeProps)((0, u.guardReactiveProps)(gt)))]
                                                                            }),
                                                                            _: 2
                                                                        }, 1032, ["mark", "hideLabel", "style", "stepStyle", "stepActiveStyle", "labelStyle", "labelActiveStyle"]))]
                                                            })
                                                        }), 256))])) : (0, u.createCommentVNode)("", !0), ((0, u.openBlock)(!0), (0, u.createElementBlock)(u.Fragment, null, (0, u.renderList)($.dots, function (gt, Zn) {
                                                var Sr;
                                                return (0, u.openBlock)(),
                                                (0, u.createBlock)(gr, (0, u.mergeProps)({
                                                        ref_for: !0,
                                                        ref: "dot-".concat(Zn),
                                                        key: "dot-".concat(Zn),
                                                        value: gt.value,
                                                        disabled: gt.disabled,
                                                        focus: gt.focus,
                                                        "dot-style": [gt.style, gt.disabled ? gt.disabledStyle : null, gt.focus ? gt.focusStyle : null],
                                                        tooltip: gt.tooltip || $.tooltip,
                                                        "tooltip-style": [$.tooltipStyle, gt.tooltipStyle, gt.disabled ? gt.tooltipDisabledStyle : null, gt.focus ? gt.tooltipFocusStyle : null],
                                                        "tooltip-formatter": Array.isArray($.sliderTooltipFormatter) ? $.sliderTooltipFormatter[Zn] : $.sliderTooltipFormatter,
                                                        "tooltip-placement": $.tooltipDirections[Zn],
                                                        style: [$.dotBaseStyle, (Sr = {}, f(Sr, $.mainDirection, "".concat(gt.pos, "%")), f(Sr, "transition", "".concat($.mainDirection, " ").concat($.animateTime, "s")), Sr)],
                                                        onDragStart: function () {
                                                            return $.dragStart(Zn)
                                                        },
                                                        role: "slider",
                                                        "aria-valuenow": gt.value,
                                                        "aria-valuemin": $.min,
                                                        "aria-valuemax": $.max,
                                                        "aria-orientation": $.isHorizontal ? "horizontal" : "vertical",
                                                        tabindex: "0",
                                                        onFocus: function () {
                                                            return $.focus(gt, Zn)
                                                        },
                                                        onBlur: D[1] || (D[1] = function () {
                                                            return $.blur()
                                                        })
                                                    }, $.dotAttrs), {
                                                    dot: (0, u.withCtx)(function () {
                                                        return [(0, u.renderSlot)($.$slots, "dot", (0, u.normalizeProps)((0, u.guardReactiveProps)(gt)))]
                                                    }),
                                                    tooltip: (0, u.withCtx)(function () {
                                                        return [(0, u.renderSlot)($.$slots, "tooltip", (0, u.normalizeProps)((0, u.guardReactiveProps)(gt)))]
                                                    }),
                                                    _: 2
                                                }, 1040, ["value", "disabled", "focus", "dot-style", "tooltip", "tooltip-style", "tooltip-formatter", "tooltip-placement", "style", "onDragStart", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "onFocus"])
                                            }), 128))], 4), (0, u.renderSlot)($.$slots, "default", {
                                value: $.getValue()
                            })], 16)
                }
                var v = ["aria-valuetext"],
                y = {
                    class: "vue-slider-dot-tooltip-text"
                };
                function b($, D, q, ie, Ae, it) {
                    var vt;
                    return (0, u.openBlock)(),
                    (0, u.createElementBlock)("div", {
                        ref: "dot",
                        class: (0, u.normalizeClass)($.dotClasses),
                        "aria-valuetext": (vt = $.tooltipValue) === null || vt === void 0 ? void 0 : vt.toString(),
                        onMousedownPassive: D[0] || (D[0] = function () {
                            return $.dragStart && $.dragStart.apply($, arguments)
                        }),
                        onTouchstartPassive: D[1] || (D[1] = function () {
                            return $.dragStart && $.dragStart.apply($, arguments)
                        })
                    }, [(0, u.renderSlot)($.$slots, "dot", {}, function () {
                                return [(0, u.createElementVNode)("div", {
                                        class: (0, u.normalizeClass)($.handleClasses),
                                        style: (0, u.normalizeStyle)($.dotStyle)
                                    }, null, 6)]
                            }), $.tooltip !== "none" ? ((0, u.openBlock)(), (0, u.createElementBlock)("div", {
                                    key: 0,
                                    class: (0, u.normalizeClass)($.tooltipClasses)
                                }, [(0, u.renderSlot)($.$slots, "tooltip", {}, function () {
                                            return [(0, u.createElementVNode)("div", {
                                                    class: (0, u.normalizeClass)($.tooltipInnerClasses),
                                                    style: (0, u.normalizeStyle)($.tooltipStyle)
                                                }, [(0, u.createElementVNode)("span", y, (0, u.toDisplayString)($.tooltipValue), 1)], 6)]
                                        })], 2)) : (0, u.createCommentVNode)("", !0)], 42, v)
                }
                i(466);
                var w = (0, u.defineComponent)({
                    name: "VueSliderDot",
                    emits: ["drag-start"],
                    props: {
                        value: {
                            type: [String, Number],
                        default:
                            0
                        },
                        tooltip: {
                            type: String,
                            required: !0
                        },
                        tooltipPlacement: {
                            type: String,
                            validator: function ($) {
                                return ["top", "right", "bottom", "left"].indexOf($) > -1
                            },
                            required: !0
                        },
                        tooltipFormatter: {
                            type: [String, Function]
                        },
                        focus: {
                            type: Boolean,
                        default:
                            !1
                        },
                        disabled: {
                            type: Boolean,
                        default:
                            !1
                        },
                        dotStyle: {
                            type: Object
                        },
                        tooltipStyle: {
                            type: Object
                        }
                    },
                    computed: {
                        dotClasses: function () {
                            return ["vue-slider-dot", {
                                    "vue-slider-dot-hover": this.tooltip === "hover" || this.tooltip === "active",
                                    "vue-slider-dot-disabled": this.disabled,
                                    "vue-slider-dot-focus": this.focus
                                }
                            ]
                        },
                        handleClasses: function () {
                            return ["vue-slider-dot-handle", {
                                    "vue-slider-dot-handle-disabled": this.disabled,
                                    "vue-slider-dot-handle-focus": this.focus
                                }
                            ]
                        },
                        tooltipClasses: function () {
                            return ["vue-slider-dot-tooltip", ["vue-slider-dot-tooltip-".concat(this.tooltipPlacement)], {
                                    "vue-slider-dot-tooltip-show": this.showTooltip
                                }
                            ]
                        },
                        tooltipInnerClasses: function () {
                            return ["vue-slider-dot-tooltip-inner", ["vue-slider-dot-tooltip-inner-".concat(this.tooltipPlacement)], {
                                    "vue-slider-dot-tooltip-inner-disabled": this.disabled,
                                    "vue-slider-dot-tooltip-inner-focus": this.focus
                                }
                            ]
                        },
                        showTooltip: function () {
                            switch (this.tooltip) {
                            case "always":
                                return !0;
                            case "none":
                                return !1;
                            case "focus":
                            case "active":
                                return !!this.focus;
                            default:
                                return !1
                            }
                        },
                        tooltipValue: function () {
                            return this.tooltipFormatter ? typeof this.tooltipFormatter == "string" ? this.tooltipFormatter.replace(/\{value\}/, String(this.value)) : this.tooltipFormatter(this.value) : this.value
                        }
                    },
                    methods: {
                        dragStart: function () {
                            if (this.disabled)
                                return !1;
                            this.$emit("drag-start")
                        }
                    }
                }),
                k = i(831),
                x = (0, k.Z)(w, [["render", b]]);
                function S($, D, q, ie, Ae, it) {
                    return (0, u.openBlock)(),
                    (0, u.createElementBlock)("div", {
                        class: (0, u.normalizeClass)($.marksClasses)
                    }, [(0, u.renderSlot)($.$slots, "step", {}, function () {
                                return [(0, u.createElementVNode)("div", {
                                        class: (0, u.normalizeClass)($.stepClasses),
                                        style: (0, u.normalizeStyle)([$.stepStyle, $.mark.style || {}, $.mark.active && $.stepActiveStyle ? $.stepActiveStyle : {}, $.mark.active && $.mark.activeStyle ? $.mark.activeStyle : {}
                                            ])
                                    }, null, 6)]
                            }), $.hideLabel ? (0, u.createCommentVNode)("", !0) : (0, u.renderSlot)($.$slots, "label", {
                                key: 0
                            }, function () {
                                return [(0, u.createElementVNode)("div", {
                                        class: (0, u.normalizeClass)($.labelClasses),
                                        style: (0, u.normalizeStyle)([$.labelStyle, $.mark.labelStyle || {}, $.mark.active && $.labelActiveStyle ? $.labelActiveStyle : {}, $.mark.active && $.mark.labelActiveStyle ? $.mark.labelActiveStyle : {}
                                            ]),
                                        onClick: D[0] || (D[0] = function () {
                                            return $.labelClickHandle && $.labelClickHandle.apply($, arguments)
                                        })
                                    }, (0, u.toDisplayString)($.mark.label), 7)]
                            })], 2)
                }
                i(18);
                var T = (0, u.defineComponent)({
                    name: "VueSliderMark",
                    emits: ["press-label"],
                    props: {
                        mark: {
                            type: Object,
                            required: !0
                        },
                        hideLabel: {
                            type: Boolean
                        },
                        stepStyle: {
                            type: Object,
                        default:
                            function () {
                                return {}
                            }
                        },
                        stepActiveStyle: {
                            type: Object,
                        default:
                            function () {
                                return {}
                            }
                        },
                        labelStyle: {
                            type: Object,
                        default:
                            function () {
                                return {}
                            }
                        },
                        labelActiveStyle: {
                            type: Object,
                        default:
                            function () {
                                return {}
                            }
                        }
                    },
                    computed: {
                        marksClasses: function () {
                            return ["vue-slider-mark", {
                                    "vue-slider-mark-active": this.mark.active
                                }
                            ]
                        },
                        stepClasses: function () {
                            return ["vue-slider-mark-step", {
                                    "vue-slider-mark-step-active": this.mark.active
                                }
                            ]
                        },
                        labelClasses: function () {
                            return ["vue-slider-mark-label", {
                                    "vue-slider-mark-label-active": this.mark.active
                                }
                            ]
                        }
                    },
                    methods: {
                        labelClickHandle: function ($) {
                            $.stopPropagation(),
                            this.$emit("press-label", this.mark.pos)
                        }
                    }
                });
                const E = (0, k.Z)(T, [["render", S]]);
                var M,
                N = E,
                F = function ($) {
                    return typeof $ == "number" ? "".concat($, "px") : $
                },
                K = function ($) {
                    var D = document.documentElement,
                    q = document.body,
                    ie = $.getBoundingClientRect(),
                    Ae = {
                        y: ie.top + (window.pageYOffset || D.scrollTop) - (D.clientTop || q.clientTop || 0),
                        x: ie.left + (window.pageXOffset || D.scrollLeft) - (D.clientLeft || q.clientLeft || 0)
                    };
                    return Ae
                },
                j = function ($, D, q) {
                    var ie = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1,
                    Ae = "targetTouches" in $ ? $.targetTouches[0] : $,
                    it = K(D),
                    vt = {
                        x: Ae.pageX - it.x,
                        y: Ae.pageY - it.y
                    };
                    return {
                        x: q ? D.offsetWidth * ie - vt.x : vt.x,
                        y: q ? D.offsetHeight * ie - vt.y : vt.y
                    }
                };
                (function ($) {
                    $[$.PAGE_UP = 33] = "PAGE_UP",
                    $[$.PAGE_DOWN = 34] = "PAGE_DOWN",
                    $[$.END = 35] = "END",
                    $[$.HOME = 36] = "HOME",
                    $[$.LEFT = 37] = "LEFT",
                    $[$.UP = 38] = "UP",
                    $[$.RIGHT = 39] = "RIGHT",
                    $[$.DOWN = 40] = "DOWN"
                })(M || (M = {}));
                var G = function ($, D) {
                    if (D.hook) {
                        var q = D.hook($);
                        if (typeof q == "function")
                            return q;
                        if (!q)
                            return null
                    }
                    switch ($.keyCode) {
                    case M.UP:
                        return function (ie) {
                            return D.direction === "ttb" ? ie - 1 : ie + 1
                        };
                    case M.RIGHT:
                        return function (ie) {
                            return D.direction === "rtl" ? ie - 1 : ie + 1
                        };
                    case M.DOWN:
                        return function (ie) {
                            return D.direction === "ttb" ? ie + 1 : ie - 1
                        };
                    case M.LEFT:
                        return function (ie) {
                            return D.direction === "rtl" ? ie + 1 : ie - 1
                        };
                    case M.END:
                        return function () {
                            return D.max
                        };
                    case M.HOME:
                        return function () {
                            return D.min
                        };
                    case M.PAGE_UP:
                        return function (ie) {
                            return ie + 10
                        };
                    case M.PAGE_DOWN:
                        return function (ie) {
                            return ie - 10
                        };
                    default:
                        return null
                    }
                };
                function Y($, D) {
                    if (!($ instanceof D))
                        throw new TypeError("Cannot call a class as a function")
                }
                function ue($, D) {
                    for (var q = 0; q < D.length; q++) {
                        var ie = D[q];
                        ie.enumerable = ie.enumerable || !1,
                        ie.configurable = !0,
                        "value" in ie && (ie.writable = !0),
                        Object.defineProperty($, ie.key, ie)
                    }
                }
                function re($, D, q) {
                    return D && ue($.prototype, D),
                    q && ue($, q),
                    Object.defineProperty($, "prototype", {
                        writable: !1
                    }),
                    $
                }
                function de($, D, q) {
                    return D in $ ? Object.defineProperty($, D, {
                        value: q,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : $[D] = q,
                    $
                }
                var Se,
                Pe,
                je = function () {
                    function $(D) {
                        Y(this, $),
                        de(this, "num", void 0),
                        this.num = D
                    }
                    return re($, [{
                                key: "decimal",
                                value: function (D, q) {
                                    var ie = this.num,
                                    Ae = this.getDecimalLen(ie),
                                    it = this.getDecimalLen(D),
                                    vt = 0;
                                    switch (q) {
                                    case "+":
                                        vt = this.getExponent(Ae, it),
                                        this.num = (this.safeRoundUp(ie, vt) + this.safeRoundUp(D, vt)) / vt;
                                        break;
                                    case "-":
                                        vt = this.getExponent(Ae, it),
                                        this.num = (this.safeRoundUp(ie, vt) - this.safeRoundUp(D, vt)) / vt;
                                        break;
                                    case "*":
                                        this.num = this.safeRoundUp(this.safeRoundUp(ie, this.getExponent(Ae)), this.safeRoundUp(D, this.getExponent(it))) / this.getExponent(Ae + it);
                                        break;
                                    case "/":
                                        vt = this.getExponent(Ae, it),
                                        this.num = this.safeRoundUp(ie, vt) / this.safeRoundUp(D, vt);
                                        break;
                                    case "%":
                                        vt = this.getExponent(Ae, it),
                                        this.num = this.safeRoundUp(ie, vt) % this.safeRoundUp(D, vt) / vt;
                                        break
                                    }
                                    return this
                                }
                            }, {
                                key: "plus",
                                value: function (D) {
                                    return this.decimal(D, "+")
                                }
                            }, {
                                key: "minus",
                                value: function (D) {
                                    return this.decimal(D, "-")
                                }
                            }, {
                                key: "multiply",
                                value: function (D) {
                                    return this.decimal(D, "*")
                                }
                            }, {
                                key: "divide",
                                value: function (D) {
                                    return this.decimal(D, "/")
                                }
                            }, {
                                key: "remainder",
                                value: function (D) {
                                    return this.decimal(D, "%")
                                }
                            }, {
                                key: "toNumber",
                                value: function () {
                                    return this.num
                                }
                            }, {
                                key: "getDecimalLen",
                                value: function (D) {
                                    var q = "".concat(D).split("e");
                                    return ("".concat(q[0]).split(".")[1] || "").length - (q[1] ? +q[1] : 0)
                                }
                            }, {
                                key: "getExponent",
                                value: function (D, q) {
                                    return Math.pow(10, q !== void 0 ? Math.max(D, q) : D)
                                }
                            }, {
                                key: "safeRoundUp",
                                value: function (D, q) {
                                    return Math.round(D * q)
                                }
                            }
                        ]),
                    $
                }
                ();
                function Ke($, D) {
                    return at($) || yt($, D) || xe($, D) || Ue()
                }
                function Ue() {
                    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function yt($, D) {
                    var q = $ == null ? null : typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
                    if (q != null) {
                        var ie,
                        Ae,
                        it = [],
                        vt = !0,
                        gr = !1;
                        try {
                            for (q = q.call($); !(vt = (ie = q.next()).done) && (it.push(ie.value), !(D && it.length === D)); vt = !0);
                        } catch (gt) {
                            gr = !0,
                            Ae = gt
                        } finally {
                            try {
                                vt || q.return == null || q.return()
                            } finally {
                                if (gr)
                                    throw Ae
                            }
                        }
                        return it
                    }
                }
                function at($) {
                    if (Array.isArray($))
                        return $
                }
                function le($, D) {
                    var q = Object.keys($);
                    if (Object.getOwnPropertySymbols) {
                        var ie = Object.getOwnPropertySymbols($);
                        D && (ie = ie.filter(function (Ae) {
                                return Object.getOwnPropertyDescriptor($, Ae).enumerable
                            })),
                        q.push.apply(q, ie)
                    }
                    return q
                }
                function ye($) {
                    for (var D = 1; D < arguments.length; D++) {
                        var q = arguments[D] != null ? arguments[D] : {};
                        D % 2 ? le(Object(q), !0).forEach(function (ie) {
                            Z($, ie, q[ie])
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(q)) : le(Object(q)).forEach(function (ie) {
                            Object.defineProperty($, ie, Object.getOwnPropertyDescriptor(q, ie))
                        })
                    }
                    return $
                }
                function ge($) {
                    return Xe($) || et($) || xe($) || pe()
                }
                function pe() {
                    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function xe($, D) {
                    if ($) {
                        if (typeof $ == "string")
                            return W($, D);
                        var q = Object.prototype.toString.call($).slice(8, -1);
                        return q === "Object" && $.constructor && (q = $.constructor.name),
                        q === "Map" || q === "Set" ? Array.from($) : q === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(q) ? W($, D) : void 0
                    }
                }
                function et($) {
                    if (typeof Symbol < "u" && $[Symbol.iterator] != null || $["@@iterator"] != null)
                        return Array.from($)
                }
                function Xe($) {
                    if (Array.isArray($))
                        return W($)
                }
                function W($, D) {
                    (D == null || D > $.length) && (D = $.length);
                    for (var q = 0, ie = new Array(D); q < D; q++)
                        ie[q] = $[q];
                    return ie
                }
                function R($, D) {
                    if (!($ instanceof D))
                        throw new TypeError("Cannot call a class as a function")
                }
                function X($, D) {
                    for (var q = 0; q < D.length; q++) {
                        var ie = D[q];
                        ie.enumerable = ie.enumerable || !1,
                        ie.configurable = !0,
                        "value" in ie && (ie.writable = !0),
                        Object.defineProperty($, ie.key, ie)
                    }
                }
                function Q($, D, q) {
                    return D && X($.prototype, D),
                    q && X($, q),
                    Object.defineProperty($, "prototype", {
                        writable: !1
                    }),
                    $
                }
                function Z($, D, q) {
                    return D in $ ? Object.defineProperty($, D, {
                        value: q,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : $[D] = q,
                    $
                }
                (function ($) {
                    $[$.VALUE = 1] = "VALUE",
                    $[$.INTERVAL = 2] = "INTERVAL",
                    $[$.MIN = 3] = "MIN",
                    $[$.MAX = 4] = "MAX",
                    $[$.ORDER = 5] = "ORDER"
                })(Pe || (Pe = {}));
                var fe = (Se = {}, Z(Se, Pe.VALUE, 'The type of the "value" is illegal'), Z(Se, Pe.INTERVAL, 'The prop "interval" is invalid, "(max - min)" must be divisible by "interval"'), Z(Se, Pe.MIN, 'The "value" must be greater than or equal to the "min".'), Z(Se, Pe.MAX, 'The "value" must be less than or equal to the "max".'), Z(Se, Pe.ORDER, 'When "order" is false, the parameters "minRange", "maxRange", "fixed", "enabled" are invalid.'), Se),
                be = function () {
                    function $(D) {
                        R(this, $),
                        Z(this, "dotsPos", []),
                        Z(this, "dotsValue", []),
                        Z(this, "data", void 0),
                        Z(this, "enableCross", void 0),
                        Z(this, "fixed", void 0),
                        Z(this, "max", void 0),
                        Z(this, "min", void 0),
                        Z(this, "interval", void 0),
                        Z(this, "minRange", void 0),
                        Z(this, "maxRange", void 0),
                        Z(this, "order", void 0),
                        Z(this, "marks", void 0),
                        Z(this, "included", void 0),
                        Z(this, "process", void 0),
                        Z(this, "adsorb", void 0),
                        Z(this, "dotOptions", void 0),
                        Z(this, "onError", void 0),
                        Z(this, "cacheRangeDir", {}),
                        this.data = D.data,
                        this.max = D.max,
                        this.min = D.min,
                        this.interval = D.interval,
                        this.order = D.order,
                        this.marks = D.marks,
                        this.included = D.included,
                        this.process = D.process,
                        this.adsorb = D.adsorb,
                        this.dotOptions = D.dotOptions,
                        this.onError = D.onError,
                        this.order ? (this.minRange = D.minRange || 0, this.maxRange = D.maxRange || 0, this.enableCross = D.enableCross, this.fixed = D.fixed) : ((D.minRange || D.maxRange || !D.enableCross || D.fixed) && this.emitError(Pe.ORDER), this.minRange = 0, this.maxRange = 0, this.enableCross = !0, this.fixed = !1),
                        this.setValue(D.value)
                    }
                    return Q($, [{
                                key: "setValue",
                                value: function (D) {
                                    this.setDotsValue(Array.isArray(D) ? ge(D) : [D], !0)
                                }
                            }, {
                                key: "setDotsValue",
                                value: function (D, q) {
                                    this.dotsValue = D,
                                    q && this.syncDotsPos()
                                }
                            }, {
                                key: "setDotsPos",
                                value: function (D) {
                                    var q = this,
                                    ie = this.order ? ge(D).sort(function (Ae, it) {
                                        return Ae - it
                                    }) : D;
                                    this.dotsPos = ie,
                                    this.setDotsValue(ie.map(function (Ae) {
                                            return q.getValueByPos(Ae)
                                        }), this.adsorb)
                                }
                            }, {
                                key: "getValueByPos",
                                value: function (D) {
                                    var q = this.parsePos(D);
                                    if (this.included) {
                                        var ie = 100;
                                        this.markList.forEach(function (Ae) {
                                            var it = Math.abs(Ae.pos - D);
                                            it < ie && (ie = it, q = Ae.value)
                                        })
                                    }
                                    return q
                                }
                            }, {
                                key: "syncDotsPos",
                                value: function () {
                                    var D = this;
                                    this.dotsPos = this.dotsValue.map(function (q) {
                                        return D.parseValue(q)
                                    })
                                }
                            }, {
                                key: "markList",
                                get: function () {
                                    var D = this;
                                    if (!this.marks)
                                        return [];
                                    var q = function (ie, Ae) {
                                        var it = D.parseValue(ie);
                                        return ye({
                                            pos: it,
                                            value: ie,
                                            label: ie,
                                            active: D.isActiveByPos(it)
                                        }, Ae)
                                    };
                                    return this.marks === !0 ? this.getValues().map(function (ie) {
                                        return q(ie)
                                    }) : Object.prototype.toString.call(this.marks) === "[object Object]" ? Object.keys(this.marks).sort(function (ie, Ae) {
                                        return +ie - +Ae
                                    }).map(function (ie) {
                                        var Ae = D.marks[ie];
                                        return q(ie, typeof Ae != "string" ? Ae : {
                                            label: Ae
                                        })
                                    }) : Array.isArray(this.marks) ? this.marks.map(function (ie) {
                                        return q(ie)
                                    }) : typeof this.marks == "function" ? this.getValues().map(function (ie) {
                                        return {
                                            value: ie,
                                            result: D.marks(ie)
                                        }
                                    }).filter(function (ie) {
                                        var Ae = ie.result;
                                        return !!Ae
                                    }).map(function (ie) {
                                        var Ae = ie.value,
                                        it = ie.result;
                                        return q(Ae, it)
                                    }) : []
                                }
                            }, {
                                key: "getRecentDot",
                                value: function (D) {
                                    var q = this.dotsPos.map(function (ie) {
                                        return Math.abs(ie - D)
                                    });
                                    return q.indexOf(Math.min.apply(Math, ge(q)))
                                }
                            }, {
                                key: "getIndexByValue",
                                value: function (D) {
                                    return this.data ? this.data.indexOf(D) : new je(+D).minus(this.min).divide(this.interval).toNumber()
                                }
                            }, {
                                key: "getValueByIndex",
                                value: function (D) {
                                    return D < 0 ? D = 0 : D > this.total && (D = this.total),
                                    this.data ? this.data[D] : new je(D).multiply(this.interval).plus(this.min).toNumber()
                                }
                            }, {
                                key: "setDotPos",
                                value: function (D, q) {
                                    D = this.getValidPos(D, q).pos;
                                    var ie = D - this.dotsPos[q];
                                    if (ie) {
                                        var Ae = new Array(this.dotsPos.length);
                                        this.fixed ? Ae = this.getFixedChangePosArr(ie, q) : this.minRange || this.maxRange ? Ae = this.getLimitRangeChangePosArr(D, ie, q) : Ae[q] = ie,
                                        this.setDotsPos(this.dotsPos.map(function (it, vt) {
                                                return it + (Ae[vt] || 0)
                                            }))
                                    }
                                }
                            }, {
                                key: "getFixedChangePosArr",
                                value: function (D, q) {
                                    var ie = this;
                                    return this.dotsPos.forEach(function (Ae, it) {
                                        if (it !== q) {
                                            var vt = ie.getValidPos(Ae + D, it),
                                            gr = vt.pos,
                                            gt = vt.inRange;
                                            gt || (D = Math.min(Math.abs(gr - Ae), Math.abs(D)) * (D < 0 ? -1 : 1))
                                        }
                                    }),
                                    this.dotsPos.map(function (Ae) {
                                        return D
                                    })
                                }
                            }, {
                                key: "getLimitRangeChangePosArr",
                                value: function (D, q, ie) {
                                    var Ae = this,
                                    it = [{
                                            index: ie,
                                            changePos: q
                                        }
                                    ],
                                    vt = q;
                                    return [this.minRange, this.maxRange].forEach(function (gr, gt) {
                                        if (!gr)
                                            return !1;
                                        var Zn = gt === 0,
                                        Sr = q > 0,
                                        ce = 0;
                                        ce = Zn ? Sr ? 1 : -1 : Sr ? -1 : 1;
                                        for (var Ie = function (ar, Nn) {
                                            var Rn = Math.abs(ar - Nn);
                                            return Zn ? Rn < Ae.minRangeDir : Rn > Ae.maxRangeDir
                                        }, Ve = ie + ce, kt = Ae.dotsPos[Ve], Qt = D; Ae.isPos(kt) && Ie(kt, Qt); ) {
                                            var qn = Ae.getValidPos(kt + vt, Ve),
                                            Qn = qn.pos;
                                            it.push({
                                                index: Ve,
                                                changePos: Qn - kt
                                            }),
                                            Ve += ce,
                                            Qt = Qn,
                                            kt = Ae.dotsPos[Ve]
                                        }
                                    }),
                                    this.dotsPos.map(function (gr, gt) {
                                        var Zn = it.filter(function (Sr) {
                                            return Sr.index === gt
                                        });
                                        return Zn.length ? Zn[0].changePos : 0
                                    })
                                }
                            }, {
                                key: "isPos",
                                value: function (D) {
                                    return typeof D == "number"
                                }
                            }, {
                                key: "getValidPos",
                                value: function (D, q) {
                                    var ie = this.valuePosRange[q],
                                    Ae = !0;
                                    return D < ie[0] ? (D = ie[0], Ae = !1) : D > ie[1] && (D = ie[1], Ae = !1), {
                                        pos: D,
                                        inRange: Ae
                                    }
                                }
                            }, {
                                key: "parseValue",
                                value: function (D) {
                                    if (this.data)
                                        D = this.data.indexOf(D);
                                    else if (typeof D == "number" || typeof D == "string") {
                                        if (D = +D, D < this.min)
                                            return this.emitError(Pe.MIN), 0;
                                        if (D > this.max)
                                            return this.emitError(Pe.MAX), 0;
                                        if (typeof D != "number" || D !== D)
                                            return this.emitError(Pe.VALUE), 0;
                                        D = new je(D).minus(this.min).divide(this.interval).toNumber()
                                    }
                                    var q = new je(D).multiply(this.gap).toNumber();
                                    return q < 0 ? 0 : q > 100 ? 100 : q
                                }
                            }, {
                                key: "parsePos",
                                value: function (D) {
                                    var q = Math.round(D / this.gap);
                                    return this.getValueByIndex(q)
                                }
                            }, {
                                key: "isActiveByPos",
                                value: function (D) {
                                    return this.processArray.some(function (q) {
                                        var ie = Ke(q, 2),
                                        Ae = ie[0],
                                        it = ie[1];
                                        return D >= Ae && D <= it
                                    })
                                }
                            }, {
                                key: "getValues",
                                value: function () {
                                    if (this.data)
                                        return this.data;
                                    for (var D = [], q = 0; q <= this.total; q++)
                                        D.push(new je(q).multiply(this.interval).plus(this.min).toNumber());
                                    return D
                                }
                            }, {
                                key: "getRangeDir",
                                value: function (D) {
                                    return D ? new je(D).divide(new je(this.data ? this.data.length - 1 : this.max).minus(this.data ? 0 : this.min).toNumber()).multiply(100).toNumber() : 100
                                }
                            }, {
                                key: "emitError",
                                value: function (D) {
                                    this.onError && this.onError(D, fe[D])
                                }
                            }, {
                                key: "processArray",
                                get: function () {
                                    if (this.process) {
                                        if (typeof this.process == "function")
                                            return this.process(this.dotsPos);
                                        if (this.dotsPos.length === 1)
                                            return [[0, this.dotsPos[0]]];
                                        if (this.dotsPos.length > 1)
                                            return [[Math.min.apply(Math, ge(this.dotsPos)), Math.max.apply(Math, ge(this.dotsPos))]]
                                    }
                                    return []
                                }
                            }, {
                                key: "total",
                                get: function () {
                                    var D = 0;
                                    return D = this.data ? this.data.length - 1 : new je(this.max).minus(this.min).divide(this.interval).toNumber(),
                                    D - Math.floor(D) !== 0 ? (this.emitError(Pe.INTERVAL), 0) : D
                                }
                            }, {
                                key: "gap",
                                get: function () {
                                    return 100 / this.total
                                }
                            }, {
                                key: "minRangeDir",
                                get: function () {
                                    return this.cacheRangeDir[this.minRange] ? this.cacheRangeDir[this.minRange] : this.cacheRangeDir[this.minRange] = this.getRangeDir(this.minRange)
                                }
                            }, {
                                key: "maxRangeDir",
                                get: function () {
                                    return this.cacheRangeDir[this.maxRange] ? this.cacheRangeDir[this.maxRange] : this.cacheRangeDir[this.maxRange] = this.getRangeDir(this.maxRange)
                                }
                            }, {
                                key: "getDotRange",
                                value: function (D, q, ie) {
                                    if (!this.dotOptions)
                                        return ie;
                                    var Ae = Array.isArray(this.dotOptions) ? this.dotOptions[D] : this.dotOptions;
                                    return Ae && Ae[q] !== void 0 ? this.parseValue(Ae[q]) : ie
                                }
                            }, {
                                key: "valuePosRange",
                                get: function () {
                                    var D = this,
                                    q = this.dotsPos,
                                    ie = [];
                                    return q.forEach(function (Ae, it) {
                                        ie.push([Math.max(D.minRange ? D.minRangeDir * it : 0, D.enableCross ? 0 : q[it - 1] || 0, D.getDotRange(it, "min", 0)), Math.min(D.minRange ? 100 - D.minRangeDir * (q.length - 1 - it) : 100, D.enableCross ? 100 : q[it + 1] || 100, D.getDotRange(it, "max", 100))])
                                    }),
                                    ie
                                }
                            }, {
                                key: "dotsIndex",
                                get: function () {
                                    var D = this;
                                    return this.dotsValue.map(function (q) {
                                        return D.getIndexByValue(q)
                                    })
                                }
                            }
                        ]),
                    $
                }
                ();
                function Ee($, D) {
                    if (!($ instanceof D))
                        throw new TypeError("Cannot call a class as a function")
                }
                function Me($, D) {
                    for (var q = 0; q < D.length; q++) {
                        var ie = D[q];
                        ie.enumerable = ie.enumerable || !1,
                        ie.configurable = !0,
                        "value" in ie && (ie.writable = !0),
                        Object.defineProperty($, ie.key, ie)
                    }
                }
                function we($, D, q) {
                    return D && Me($.prototype, D),
                    q && Me($, q),
                    Object.defineProperty($, "prototype", {
                        writable: !1
                    }),
                    $
                }
                function He($, D, q) {
                    return D in $ ? Object.defineProperty($, D, {
                        value: q,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : $[D] = q,
                    $
                }
                var We = function () {
                    function $(D) {
                        Ee(this, $),
                        He(this, "map", void 0),
                        He(this, "states", 0),
                        this.map = D
                    }
                    return we($, [{
                                key: "add",
                                value: function (D) {
                                    this.states |= D
                                }
                            }, {
                                key: "delete",
                                value: function (D) {
                                    this.states &= ~D
                                }
                            }, {
                                key: "toggle",
                                value: function (D) {
                                    this.has(D) ? this.delete(D) : this.add(D)
                                }
                            }, {
                                key: "has",
                                value: function (D) {
                                    return !!(this.states & D)
                                }
                            }
                        ]),
                    $
                }
                ();
                i(631);
                function Je($) {
                    return Et($) || wt($) || vo($) || qe()
                }
                function qe() {
                    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function wt($) {
                    if (typeof Symbol < "u" && $[Symbol.iterator] != null || $["@@iterator"] != null)
                        return Array.from($)
                }
                function Et($) {
                    if (Array.isArray($))
                        return Pn($)
                }
                function bt($) {
                    return bt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (D) {
                        return typeof D
                    }
                     : function (D) {
                        return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D
                    },
                    bt($)
                }
                function ze($, D) {
                    var q = Object.keys($);
                    if (Object.getOwnPropertySymbols) {
                        var ie = Object.getOwnPropertySymbols($);
                        D && (ie = ie.filter(function (Ae) {
                                return Object.getOwnPropertyDescriptor($, Ae).enumerable
                            })),
                        q.push.apply(q, ie)
                    }
                    return q
                }
                function Ze($) {
                    for (var D = 1; D < arguments.length; D++) {
                        var q = arguments[D] != null ? arguments[D] : {};
                        D % 2 ? ze(Object(q), !0).forEach(function (ie) {
                            Lt($, ie, q[ie])
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(q)) : ze(Object(q)).forEach(function (ie) {
                            Object.defineProperty($, ie, Object.getOwnPropertyDescriptor(q, ie))
                        })
                    }
                    return $
                }
                function Lt($, D, q) {
                    return D in $ ? Object.defineProperty($, D, {
                        value: q,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : $[D] = q,
                    $
                }
                function pn($, D) {
                    return $o($) || Jn($, D) || vo($, D) || mr()
                }
                function mr() {
                    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function vo($, D) {
                    if ($) {
                        if (typeof $ == "string")
                            return Pn($, D);
                        var q = Object.prototype.toString.call($).slice(8, -1);
                        return q === "Object" && $.constructor && (q = $.constructor.name),
                        q === "Map" || q === "Set" ? Array.from($) : q === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(q) ? Pn($, D) : void 0
                    }
                }
                function Pn($, D) {
                    (D == null || D > $.length) && (D = $.length);
                    for (var q = 0, ie = new Array(D); q < D; q++)
                        ie[q] = $[q];
                    return ie
                }
                function Jn($, D) {
                    var q = $ == null ? null : typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
                    if (q != null) {
                        var ie,
                        Ae,
                        it = [],
                        vt = !0,
                        gr = !1;
                        try {
                            for (q = q.call($); !(vt = (ie = q.next()).done) && (it.push(ie.value), !(D && it.length === D)); vt = !0);
                        } catch (gt) {
                            gr = !0,
                            Ae = gt
                        } finally {
                            try {
                                vt || q.return == null || q.return()
                            } finally {
                                if (gr)
                                    throw Ae
                            }
                        }
                        return it
                    }
                }
                function $o($) {
                    if (Array.isArray($))
                        return $
                }
                var ln = {
                    None: 0,
                    Drag: 2,
                    Focus: 4
                },
                on = 4,
                _t = (0, u.defineComponent)({
                    name: "VueSlider",
                    components: {
                        VueSliderDot: x,
                        VueSliderMark: N
                    },
                    emits: ["change", "drag-start", "dragging", "drag-end", "error", "update:modelValue"],
                    data: function () {
                        return {
                            control: null,
                            states: new We(ln),
                            scale: 1,
                            focusDotIndex: 0
                        }
                    },
                    props: {
                        modelValue: {
                            type: [Number, String, Array],
                        default:
                            0
                        },
                        silent: {
                            type: Boolean,
                        default:
                            !1
                        },
                        direction: {
                            type: String,
                        default:
                            "ltr",
                            validator: function ($) {
                                return ["ltr", "rtl", "ttb", "btt"].indexOf($) > -1
                            }
                        },
                        width: {
                            type: [Number, String]
                        },
                        height: {
                            type: [Number, String]
                        },
                        dotSize: {
                            type: [Number, Array],
                        default:
                            14
                        },
                        contained: {
                            type: Boolean,
                        default:
                            !1
                        },
                        min: {
                            type: Number,
                        default:
                            0
                        },
                        max: {
                            type: Number,
                        default:
                            100
                        },
                        interval: {
                            type: Number,
                        default:
                            1
                        },
                        disabled: {
                            type: Boolean,
                        default:
                            !1
                        },
                        clickable: {
                            type: Boolean,
                        default:
                            !0
                        },
                        dragOnClick: {
                            type: Boolean,
                        default:
                            !1
                        },
                        duration: {
                            type: Number,
                        default:
                            .5
                        },
                        data: {
                            type: [Object, Array]
                        },
                        dataValue: {
                            type: String,
                        default:
                            "value"
                        },
                        dataLabel: {
                            type: String,
                        default:
                            "label"
                        },
                        lazy: {
                            type: Boolean,
                        default:
                            !1
                        },
                        tooltip: {
                            type: String,
                        default:
                            "active",
                            validator: function ($) {
                                return ["none", "always", "focus", "hover", "active"].indexOf($) > -1
                            }
                        },
                        tooltipPlacement: {
                            type: [String, Array],
                            validator: function ($) {
                                return (Array.isArray($) ? $ : [$]).every(function (D) {
                                    return ["top", "right", "bottom", "left"].indexOf(D) > -1
                                })
                            }
                        },
                        tooltipFormatter: {
                            type: [String, Array, Function]
                        },
                        useKeyboard: {
                            type: Boolean,
                        default:
                            !0
                        },
                        keydownHook: {
                            type: Function
                        },
                        enableCross: {
                            type: Boolean,
                        default:
                            !0
                        },
                        fixed: {
                            type: Boolean,
                        default:
                            !1
                        },
                        order: {
                            type: Boolean,
                        default:
                            !0
                        },
                        minRange: {
                            type: Number
                        },
                        maxRange: {
                            type: Number
                        },
                        marks: {
                            type: [Boolean, Object, Array, Function],
                        default:
                            !1
                        },
                        process: {
                            type: [Boolean, Function],
                        default:
                            !0
                        },
                        zoom: {
                            type: Number
                        },
                        included: {
                            type: Boolean
                        },
                        adsorb: {
                            type: Boolean
                        },
                        hideLabel: {
                            type: Boolean
                        },
                        dotOptions: {
                            type: [Object, Array]
                        },
                        dotAttrs: {
                            type: Object
                        },
                        railStyle: {
                            type: Object
                        },
                        processStyle: {
                            type: Object
                        },
                        dotStyle: {
                            type: Object
                        },
                        tooltipStyle: {
                            type: Object
                        },
                        stepStyle: {
                            type: Object
                        },
                        stepActiveStyle: {
                            type: Object
                        },
                        labelStyle: {
                            type: Object
                        },
                        labelActiveStyle: {
                            type: Object
                        }
                    },
                    computed: {
                        isHorizontal: function () {
                            return this.direction === "ltr" || this.direction === "rtl"
                        },
                        isReverse: function () {
                            return this.direction === "rtl" || this.direction === "btt"
                        },
                        tailSize: function () {
                            return F((this.isHorizontal ? this.height : this.width) || on)
                        },
                        containerClasses: function () {
                            return ["vue-slider", ["vue-slider-".concat(this.direction)], {
                                    "vue-slider-disabled": this.disabled
                                }
                            ]
                        },
                        containerStyles: function () {
                            var $ = Array.isArray(this.dotSize) ? this.dotSize : [this.dotSize, this.dotSize],
                            D = pn($, 2),
                            q = D[0],
                            ie = D[1],
                            Ae = this.width ? F(this.width) : this.isHorizontal ? "auto" : F(on),
                            it = this.height ? F(this.height) : this.isHorizontal ? F(on) : "auto";
                            return {
                                padding: this.contained ? "".concat(ie / 2, "px ").concat(q / 2, "px") : this.isHorizontal ? "".concat(ie / 2, "px 0") : "0 ".concat(q / 2, "px"),
                                width: Ae,
                                height: it
                            }
                        },
                        processArray: function () {
                            var $ = this;
                            return this.control.processArray.map(function (D, q) {
                                var ie,
                                Ae = pn(D, 3),
                                it = Ae[0],
                                vt = Ae[1],
                                gr = Ae[2];
                                if (it > vt) {
                                    var gt = [vt, it];
                                    it = gt[0],
                                    vt = gt[1]
                                }
                                var Zn = $.isHorizontal ? "width" : "height";
                                return {
                                    start: it,
                                    end: vt,
                                    index: q,
                                    style: Ze(Ze((ie = {}, Lt(ie, $.isHorizontal ? "height" : "width", "100%"), Lt(ie, $.isHorizontal ? "top" : "left", 0), Lt(ie, $.mainDirection, "".concat(it, "%")), Lt(ie, Zn, "".concat(vt - it, "%")), Lt(ie, "transitionProperty", "".concat(Zn, ",").concat($.mainDirection)), Lt(ie, "transitionDuration", "".concat($.animateTime, "s")), ie), $.processStyle), gr)
                                }
                            })
                        },
                        dotBaseStyle: function () {
                            var $,
                            D = Array.isArray(this.dotSize) ? this.dotSize : [this.dotSize, this.dotSize],
                            q = pn(D, 2),
                            ie = q[0],
                            Ae = q[1];
                            return $ = this.isHorizontal ? Lt({
                                transform: "translate(".concat(this.isReverse ? "50%" : "-50%", ", -50%)"),
                                WebkitTransform: "translate(".concat(this.isReverse ? "50%" : "-50%", ", -50%)"),
                                top: "50%"
                            }, this.direction === "ltr" ? "left" : "right", "0") : Lt({
                                transform: "translate(-50%, ".concat(this.isReverse ? "50%" : "-50%", ")"),
                                WebkitTransform: "translate(-50%, ".concat(this.isReverse ? "50%" : "-50%", ")"),
                                left: "50%"
                            }, this.direction === "btt" ? "bottom" : "top", "0"),
                            Ze({
                                width: "".concat(ie, "px"),
                                height: "".concat(Ae, "px")
                            }, $)
                        },
                        mainDirection: function () {
                            switch (this.direction) {
                            case "ltr":
                                return "left";
                            case "rtl":
                                return "right";
                            case "btt":
                                return "bottom";
                            case "ttb":
                                return "top";
                            default:
                                return "left"
                            }
                        },
                        tooltipDirections: function () {
                            var $ = this.tooltipPlacement || (this.isHorizontal ? "top" : "left");
                            return Array.isArray($) ? $ : this.dots.map(function () {
                                return $
                            })
                        },
                        dots: function () {
                            var $ = this;
                            return this.control.dotsPos.map(function (D, q) {
                                return Ze({
                                    pos: D,
                                    index: q,
                                    value: $.control.dotsValue[q],
                                    focus: $.states.has(ln.Focus) && $.focusDotIndex === q,
                                    disabled: $.disabled,
                                    style: $.dotStyle
                                }, (Array.isArray($.dotOptions) ? $.dotOptions[q] : $.dotOptions) || {})
                            })
                        },
                        animateTime: function () {
                            return this.states.has(ln.Drag) ? 0 : this.duration
                        },
                        canSort: function () {
                            return this.order && !this.minRange && !this.maxRange && !this.fixed && this.enableCross
                        },
                        sliderData: function () {
                            var $ = this;
                            return this.isObjectArrayData(this.data) ? this.data.map(function (D) {
                                return D[$.dataValue]
                            }) : this.isObjectData(this.data) ? Object.keys(this.data) : this.data
                        },
                        sliderMarks: function () {
                            var $ = this;
                            return this.marks ? this.marks : this.isObjectArrayData(this.data) ? function (D) {
                                var q = {
                                    label: D
                                };
                                return $.data.some(function (ie) {
                                    return ie[$.dataValue] === D && (q.label = ie[$.dataLabel], !0)
                                }),
                                q
                            }
                             : this.isObjectData(this.data) ? this.data : void 0
                        },
                        sliderTooltipFormatter: function () {
                            var $ = this;
                            if (this.tooltipFormatter)
                                return this.tooltipFormatter;
                            if (this.isObjectArrayData(this.data))
                                return function (q) {
                                    var ie = "" + q;
                                    return $.data.some(function (Ae) {
                                        return Ae[$.dataValue] === q && (ie = Ae[$.dataLabel], !0)
                                    }),
                                    ie
                                };
                            if (this.isObjectData(this.data)) {
                                var D = this.data;
                                return function (q) {
                                    return D[q]
                                }
                            }
                        },
                        isNotSync: function () {
                            var $ = this.control.dotsValue;
                            return Array.isArray(this.modelValue) ? this.modelValue.length !== $.length || this.modelValue.some(function (D, q) {
                                return D !== $[q]
                            }) : this.modelValue !== $[0]
                        },
                        dragRange: function () {
                            var $ = this.dots[this.focusDotIndex - 1],
                            D = this.dots[this.focusDotIndex + 1];
                            return [$ ? $.pos : -1 / 0, D ? D.pos : 1 / 0]
                        }
                    },
                    watch: {
                        modelValue: function () {
                            this.control && !this.states.has(ln.Drag) && this.isNotSync && this.control.setValue(this.modelValue)
                        }
                    },
                    methods: {
                        isObjectData: function ($) {
                            return !!$ && Object.prototype.toString.call($) === "[object Object]"
                        },
                        isObjectArrayData: function ($) {
                            return !!$ && Array.isArray($) && $.length > 0 && bt($[0]) === "object"
                        },
                        bindEvent: function () {
                            document.addEventListener("touchmove", this.dragMove, {
                                passive: !1
                            }),
                            document.addEventListener("touchend", this.dragEnd, {
                                passive: !1
                            }),
                            document.addEventListener("mousedown", this.blurHandle),
                            document.addEventListener("mousemove", this.dragMove),
                            document.addEventListener("mouseup", this.dragEnd),
                            document.addEventListener("mouseleave", this.dragEnd),
                            document.addEventListener("keydown", this.keydownHandle)
                        },
                        unbindEvent: function () {
                            document.removeEventListener("touchmove", this.dragMove),
                            document.removeEventListener("touchend", this.dragEnd),
                            document.removeEventListener("mousedown", this.blurHandle),
                            document.removeEventListener("mousemove", this.dragMove),
                            document.removeEventListener("mouseup", this.dragEnd),
                            document.removeEventListener("mouseleave", this.dragEnd),
                            document.removeEventListener("keydown", this.keydownHandle)
                        },
                        setScale: function () {
                            this.scale = new je(Math.floor(this.isHorizontal ? this.$el.offsetWidth : this.$el.offsetHeight)).multiply(this.zoom || 1).divide(100).toNumber()
                        },
                        initControl: function () {
                            var $ = this;
                            this.control = new be({
                                value: this.modelValue,
                                data: this.sliderData,
                                enableCross: this.enableCross,
                                fixed: this.fixed,
                                max: this.max,
                                min: this.min,
                                interval: this.interval,
                                minRange: this.minRange,
                                maxRange: this.maxRange,
                                order: this.order,
                                marks: this.sliderMarks,
                                included: this.included,
                                process: this.process,
                                adsorb: this.adsorb,
                                dotOptions: this.dotOptions,
                                onError: this.emitError
                            }),
                            ["data", "enableCross", "fixed", "max", "min", "interval", "minRange", "maxRange", "order", "marks", "process", "adsorb", "included", "dotOptions"].forEach(function (D) {
                                $.$watch(D, function (q) {
                                    if (D === "data" && Array.isArray($.control.data) && Array.isArray(q) && $.control.data.length === q.length && q.every(function (ie, Ae) {
                                            return ie === $.control.data[Ae]
                                        }))
                                        return !1;
                                    switch (D) {
                                    case "data":
                                    case "dataLabel":
                                    case "dataValue":
                                        $.control.data = $.sliderData;
                                        break;
                                    case "mark":
                                        $.control.marks = $.sliderMarks;
                                        break;
                                    default:
                                        $.control[D] = q
                                    }
                                    ["data", "max", "min", "interval"].indexOf(D) > -1 && $.control.syncDotsPos()
                                })
                            })
                        },
                        syncValueByPos: function () {
                            var $ = this.control.dotsValue;
                            if (this.isDiff($, Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue])) {
                                var D = $.length === 1 ? $[0] : Je($);
                                this.$emit("change", D, this.focusDotIndex),
                                this.$emit("update:modelValue", D)
                            }
                        },
                        isDiff: function ($, D) {
                            return $.length !== D.length || $.some(function (q, ie) {
                                return q !== D[ie]
                            })
                        },
                        emitError: function ($, D) {
                            this.silent || console.error("[VueSlider error]: ".concat(D)),
                            this.$emit("error", $, D)
                        },
                        dragStartOnProcess: function ($) {
                            if (this.dragOnClick) {
                                this.setScale();
                                var D = this.getPosByEvent($),
                                q = this.control.getRecentDot(D);
                                if (this.dots[q].disabled)
                                    return;
                                this.dragStart(q),
                                this.control.setDotPos(D, this.focusDotIndex),
                                this.lazy || this.syncValueByPos()
                            }
                        },
                        dragStart: function ($) {
                            this.focusDotIndex = $,
                            this.setScale(),
                            this.states.add(ln.Drag),
                            this.states.add(ln.Focus),
                            this.$emit("drag-start", this.focusDotIndex)
                        },
                        dragMove: function ($) {
                            if (!this.states.has(ln.Drag))
                                return !1;
                            $.preventDefault();
                            var D = this.getPosByEvent($);
                            this.isCrossDot(D),
                            this.control.setDotPos(D, this.focusDotIndex),
                            this.lazy || this.syncValueByPos();
                            var q = this.control.dotsValue;
                            this.$emit("dragging", q.length === 1 ? q[0] : Je(q), this.focusDotIndex)
                        },
                        isCrossDot: function ($) {
                            if (this.canSort) {
                                var D = this.focusDotIndex,
                                q = $;
                                if (q > this.dragRange[1] ? (q = this.dragRange[1], this.focusDotIndex++) : q < this.dragRange[0] && (q = this.dragRange[0], this.focusDotIndex--), D !== this.focusDotIndex) {
                                    var ie = this.$refs["dot-".concat(this.focusDotIndex)];
                                    ie && ie.$el && ie.$el.focus(),
                                    this.control.setDotPos(q, D)
                                }
                            }
                        },
                        dragEnd: function ($) {
                            var D = this;
                            if (!this.states.has(ln.Drag))
                                return !1;
                            setTimeout(function () {
                                D.lazy && D.syncValueByPos(),
                                D.included && D.isNotSync ? D.control.setValue(D.modelValue) : D.control.syncDotsPos(),
                                D.states.delete(ln.Drag),
                                D.useKeyboard && !("targetTouches" in $) || D.states.delete(ln.Focus),
                                D.$emit("drag-end", D.focusDotIndex)
                            })
                        },
                        blurHandle: function ($) {
                            if (!this.states.has(ln.Focus) || !this.$refs.container || this.$refs.container.contains($.target))
                                return !1;
                            this.states.delete(ln.Focus)
                        },
                        clickHandle: function ($) {
                            if (!this.clickable || this.disabled)
                                return !1;
                            if (!this.states.has(ln.Drag)) {
                                this.setScale();
                                var D = this.getPosByEvent($);
                                this.setValueByPos(D)
                            }
                        },
                        focus: function ($) {
                            var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                            $.disabled || (this.states.add(ln.Focus), this.focusDotIndex = D)
                        },
                        blur: function () {
                            this.states.delete(ln.Focus)
                        },
                        getValue: function () {
                            var $ = this.control.dotsValue;
                            return $.length === 1 ? $[0] : $
                        },
                        getIndex: function () {
                            var $ = this.control.dotsIndex;
                            return $.length === 1 ? $[0] : $
                        },
                        setValue: function ($) {
                            this.control.setValue(Array.isArray($) ? Je($) : [$]),
                            this.syncValueByPos()
                        },
                        setIndex: function ($) {
                            var D = this,
                            q = Array.isArray($) ? $.map(function (ie) {
                                return D.control.getValueByIndex(ie)
                            }) : this.control.getValueByIndex($);
                            this.setValue(q)
                        },
                        setValueByPos: function ($) {
                            var D = this,
                            q = this.control.getRecentDot($);
                            if (this.disabled || this.dots[q].disabled)
                                return !1;
                            this.focusDotIndex = q,
                            this.control.setDotPos($, q),
                            this.syncValueByPos(),
                            this.useKeyboard && this.states.add(ln.Focus),
                            setTimeout(function () {
                                D.included && D.isNotSync ? D.control.setValue(D.modelValue) : D.control.syncDotsPos()
                            })
                        },
                        keydownHandle: function ($) {
                            var D = this;
                            if (!this.useKeyboard || !this.states.has(ln.Focus))
                                return !1;
                            var q = this.included && this.marks,
                            ie = G($, {
                                direction: this.direction,
                                max: q ? this.control.markList.length - 1 : this.control.total,
                                min: 0,
                                hook: this.keydownHook
                            });
                            if (ie) {
                                $.preventDefault();
                                var Ae = -1,
                                it = 0;
                                q ? (this.control.markList.some(function (vt, gr) {
                                        return vt.value === D.control.dotsValue[D.focusDotIndex] && (Ae = ie(gr), !0)
                                    }), Ae < 0 ? Ae = 0 : Ae > this.control.markList.length - 1 && (Ae = this.control.markList.length - 1), it = this.control.markList[Ae].pos) : (Ae = ie(this.control.getIndexByValue(this.control.dotsValue[this.focusDotIndex])), it = this.control.parseValue(this.control.getValueByIndex(Ae))),
                                this.isCrossDot(it),
                                this.control.setDotPos(it, this.focusDotIndex),
                                this.syncValueByPos()
                            }
                        },
                        getPosByEvent: function ($) {
                            return j($, this.$el, this.isReverse, this.zoom)[this.isHorizontal ? "x" : "y"] / this.scale
                        },
                        renderSlot: function ($, D, q) {
                            var ie = this.$slots[$];
                            return ie ? ie(D) : q
                        }
                    },
                    created: function () {
                        this.initControl()
                    },
                    mounted: function () {
                        this.bindEvent()
                    },
                    beforeUnmount: function () {
                        this.unbindEvent()
                    }
                }),
                Tt = (0, k.Z)(_t, [["render", m]]);
                Tt.VueSliderMark = N,
                Tt.VueSliderDot = x;
                var mn = Tt,
                hn = mn
            }
            (),
            s = s.default,
            s
        }
        ()
    })
})(y7e);
const b7e = og(Wx);
const _7e = .5, k7e = .1, x7e = 20, S7e = {
    components: {
        VueSlider: b7e
    },
    props: {
        modelValue: {
        default:
            _7e,
            type: [Number, Array]
        },
        maximum: {
        default:
            1,
            type: Number
        },
        minimum: {
        default:
            0,
            type: Number
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        direction: {
        default:
            "ltr",
            type: String
        },
        stepSize: {
        default:
            k7e,
            type: Number
        },
        height: {
        default:
            x7e,
            type: Number
        },
        tooltips: {
        default:
            () => [{
                    tooltip: "always"
                }
            ],
            type: Array
        },
        tooltipFormat: {
        default:
            () => [e => `${e}`],
            type: Array
        },
        marks: {
        default:
            () => ({}),
            type: Object
        },
        process: {
            type: [Boolean, Function],
        default:
            !0
        },
        connect: {
        default:
            "both",
            type: String
        },
        dragOnClick: {
        default:
            !1,
            type: Boolean
        },
        contained: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    methods: {
        getValue() {
            return this.$refs.slider.getValue()
        },
        onChange() {
            this.$emit("update:modelValue", this.getValue())
        },
        validate() {
            let e = this.getValue(),
            t,
            n = !0;
            return (this.minimum >= this.maximum || this.maximum <= this.minimum) && (t = "Specified range is not valid.", n = !1),
            typeof e != "number" && (t = "Value is not a number.", n = !1),
            (e < this.minimum || e > this.maximum) && (t = "Value is not inside the valid range.", n = !1), {
                isValid: n,
                errorMessage: n ? null : t
            }
        }
    }
}, C7e = {
    class: "slider-container"
}, I7e = ["onFocus", "onBlur"];
function T7e(e, t, n, r, o, i) {
    const s = B("VueSlider");
    return _(),
    O("div", C7e, [(_(!0), O(Le, null, $t(n.modelValue.length ? n.modelValue : [n.modelValue], (a, l) => (_(), O("div", {
                                key: l,
                                class: "slider-focusable",
                                tabindex: "0",
                                onFocus: c => e.$refs.slider.focus(l),
                                onBlur: c => e.$refs.slider.blur(l)
                            }, null, 40, I7e))), 128)), z(s, {
                ref: "slider",
                width: n.direction.includes("tt") ? 1 : "auto",
                "model-value": n.modelValue,
                min: n.minimum,
                max: n.maximum,
                silent: !0,
                "use-keyboard": !0,
                direction: n.direction,
                interval: n.stepSize,
                marks: n.marks,
                process: n.process,
                height: n.direction.includes("tt") ? n.height : 1,
                "dot-options": n.tooltips,
                "tooltip-formatter": n.tooltipFormat,
                class: he([n.connect]),
                "drag-on-click": n.dragOnClick,
                contained: n.contained,
                lazy: !0,
                "enable-cross": !1,
                "x-ms-format-detection": "none",
                onChange: i.onChange
            }, null, 8, ["width", "model-value", "min", "max", "direction", "interval", "marks", "process", "height", "dot-options", "tooltip-formatter", "class", "drag-on-click", "contained", "onChange"])])
}
const M7e = te(S7e, [["render", T7e], ["__scopeId", "data-v-607d0ad1"]]), jc = (e, t) => {
    let n = t.decimals ? e.toFixed(t.decimals) : e.toString();
    if (Math.abs(e) >= 1e3 && t.thousand) {
        let o = n.split("."),
        i = o[0][0];
        const s = 3;
        for (let a = 1; a < o[0].length; a++)
            i += ((o[0].length - a) % s === 0 ? t.thousand : "") + o[0][a];
        o[1] && (i += (t.mark || ".") + o[1]),
        n = i
    } else
        t.mark && (n = n.replace(".", t.mark));
    let r = t.prefix || "";
    return e < 0 && (r += (t.negativeBefore || "") + (t.negative || "-"), n = n.substring(1)),
    n = r + n,
    n += t.postfix || "",
    n
}, HD = 5, UD = 10, P7e = 8, E7e = 6, O7e = 1.5, zx = (e, t) => ({
    label: "",
    style: {
        [t.includes("b") ? "width" : "height"]: `${e}px !important`
    },
    labelStyle: {
        display: "none"
    }
}), $7e = (e, t) => {
    switch (!0) {
    case e === 0:
    case e === t:
    case t % 2 === 0:
        return HD;
    case Math.ceil(t / 2) === e:
        return P7e;
    case e % 2 === 0:
        return E7e;
    default:
        return HD
    }
}, A7e = (e, t) => {
    const {
        prevValue: n,
        diff: r,
        direction: o,
        densitySize: i
    } = t;
    let s = Math.floor(r.value / i),
    a = r.value / s;
    for (let l = 1; l < s; l++) {
        let c = n + a * l,
        u = $7e(l, s - 1);
        typeof e[c] > "u" && (e[c] = zx(u, o))
    }
    return s
}, D7e = (e, t, n) => {
    const {
        min: r,
        max: o,
        direction: i,
        density: s,
        hasSteps: a,
        mode: l
    } = n;
    if (s) {
        !a && l === "steps" && (e[r] = r.toString(), e[o] = o.toString()),
        e[r] || (e[r] = zx(UD, i)),
        e[o] || (e[o] = zx(UD, i));
        const c = Array.from(t);
        let u = 100 / s,
        f = u + c.length;
        const p = (o - r) / u,
        m = c.reduce((w, k, C, x) => C < c.length - 1 ? [...w, x[C + 1] - k] : w, []);
        let v = 0,
        y = m[Symbol.iterator](),
        b = {
            prevValue: c[v],
            diff: y.next(),
            direction: i,
            densitySize: p
        };
        do
            b.diff.value > p * O7e && (f -= A7e(e, b)), f--, v++, b.prevValue = c[v], b.diff = y.next();
        while (f > 0 && !b.diff.done)
    }
}, N7e = e => {
    const {
        config: t,
        min: n,
        max: r,
        direction: o,
        stepSize: i,
        hasSteps: s
    } = e;
    let a = {};
    const l = new Set([n]);
    if (t) {
        switch (t.mode) {
        case "steps":
        case "count": {
                let p = t.mode === "steps" ? Number(i) : (r - n) / t.values[0];
                if ((r - n) / p > 1e4) {
                    t.density = t.density || 3;
                    break
                }
                for (let m = 0; m < (r - n) / p; m++) {
                    let v = n + p * m;
                    a[v] = jc(v, t.format),
                    l.add(v)
                }
                a[r] = jc(r, t.format);
                break
            }
        case "values": {
                t.values.forEach(u => {
                    a[u] = jc(u, t.format),
                    l.add(u)
                });
                break
            }
        case "range":
            a[n] = jc(n, t.format),
            a[r] = jc(r, t.format);
            break;
        case "positions": {
                t.values.forEach(u => {
                    let p = (r - n) * (u / 100) + n;
                    n <= p && p <= r && (a[p] = jc(p, t.format), l.add(p))
                });
                break
            }
        }
        const c = {
            min: n,
            max: r,
            direction: o,
            density: t.density,
            hasSteps: s,
            mode: t.mode
        };
        l.add(r),
        D7e(a, l, c)
    }
    return a
};
const _2 = "double", R7e = 1e-7, qD = 7, L7e = 533, B7e = {
    components: {
        Label: Xn,
        Slider: M7e,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo && e.viewRepresentation.sliderSettings
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [_2]: 0
            }),
            type: [Object, Array]
        },
        invertProcess: {
            type: Boolean,
        default:
            !1
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        sliderSettings() {
            return this.viewRep.sliderSettings
        },
        label() {
            return this.viewRep.label
        },
        min() {
            return parseFloat(this.sliderSettings.range.min[0].toFixed(qD))
        },
        max() {
            return parseFloat(this.sliderSettings.range.max[0].toFixed(qD))
        },
        value() {
            return Array.isArray(this.valuePair) ? this.valuePair : this.valuePair[_2]
        },
        direction() {
            const e = this.sliderSettings.direction === "ltr" ? "ttb" : "btt";
            return this.sliderSettings.orientation === "horizontal" ? this.sliderSettings.direction : e
        },
        stepSize() {
            return this.sliderSettings.step || R7e
        },
        process() {
            return !Array.isArray(this.value) && this.invertProcess ? e => [[e[0], 100]] : !0
        },
        height() {
            return this.direction.includes("b") ? L7e : null
        },
        tooltips() {
            let e = t => ({
                tooltip: t
            });
            return this.sliderSettings.tooltips ? this.sliderSettings.tooltips.map(t => e(t ? "always" : "none")) : [e("none")]
        },
        tooltipFormat() {
            const {
                tooltips: e
            } = this.sliderSettings,
            t = n => `${n}`;
            return e ? e.map(n => typeof n == "object" ? r => jc(r, n) : t) : [t]
        },
        connect() {
            const {
                connect: e
            } = this.sliderSettings;
            return e ? e[0] ? e[1] ? "both" : "top" : e[1] ? "bottom" : "none" : null
        },
        marks() {
            return Object.freeze(N7e({
                    config: this.sliderSettings.pips,
                    min: this.min,
                    max: this.max,
                    direction: this.direction,
                    stepSize: this.stepSize,
                    hasSteps: this.sliderSettings.step
                }))
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: _2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t,
            n = this.$refs.form.getValue();
            if (typeof this.$refs.form.validate == "function") {
                let r = this.$refs.form.validate();
                e = r.isValid && Boolean(n || n === 0),
                t = r.errorMessage || "Current input is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function V7e(e, t, n, r, o, i) {
    const s = B("Slider"),
    a = B("ErrorMessage"),
    l = B("Label");
    return _(),
    O("div", null, [z(l, {
                text: i.label,
                class: he([`slider-${i.sliderSettings.orientation}-label`, {
                            "tooltip-label": i.tooltips
                        }
                    ]),
                large: ""
            }, {
            default:
                oe(({
                        labelForId: c
                    }) => [z(s, {
                            id: c,
                            ref: "form",
                            minimum: i.min,
                            maximum: i.max,
                            "model-value": i.value,
                            process: i.process,
                            "is-valid": n.isValid,
                            direction: i.direction,
                            "step-size": i.stepSize,
                            height: i.height,
                            tooltips: i.tooltips,
                            "tooltip-format": i.tooltipFormat,
                            marks: i.marks,
                            connect: i.connect,
                            class: he([`slider-${i.sliderSettings.orientation}`, {
                                        "tooltip-slider": i.tooltips
                                    }
                                ]),
                            "onUpdate:modelValue": i.onChange
                        }, null, 8, ["id", "minimum", "maximum", "model-value", "process", "is-valid", "direction", "step-size", "height", "tooltips", "tooltip-format", "marks", "connect", "class", "onUpdate:modelValue"]), z(a, {
                            error: n.errorMessage,
                            class: he([`slider-${i.sliderSettings.orientation}-error`, {
                                        "tooltip-error": i.tooltips
                                    }
                                ])
                        }, null, 8, ["error", "class"])]),
                _: 1
            }, 8, ["text", "class"])])
}
const E9 = te(B7e, [["render", V7e], ["__scopeId", "data-v-56a16518"]]);
const k2 = "string", F7e = {
    components: {
        Label: Xn,
        InputField: wf,
        TextArea: P9,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [k2]: 0
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.valuePair[k2]
        },
        isMultiLine() {
            return this.viewRep.editorType === "Multi-line"
        },
        multiColumns() {
            return this.viewRep.multilineEditorWidth
        },
        multiRows() {
            return this.viewRep.multilineEditorHeight
        },
        regex() {
            return this.viewRep.regex || null
        },
        customErrorMessage() {
            return this.viewRep.errorMessage?.split("?").join(this.value)
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: k2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t;
            if (this.viewRep.required && !this.$refs.form.getValue() && (e = !1, t = "Input is required."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = this.customErrorMessage || n.errorMessage || t || "Current input is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function j7e(e, t, n, r, o, i) {
    const s = B("TextArea"),
    a = B("InputField"),
    l = B("ErrorMessage"),
    c = B("Label");
    return _(),
    H(c, {
        class: "label",
        text: i.label,
        large: ""
    }, {
    default:
        oe(({
                labelForId: u
            }) => [i.isMultiLine ? (_(), H(s, {
                        key: 0,
                        id: u,
                        ref: "form",
                        "model-value": i.value,
                        cols: i.multiColumns,
                        rows: i.multiRows,
                        "is-valid": n.isValid,
                        title: i.description,
                        "onUpdate:modelValue": i.onChange
                    }, null, 8, ["id", "model-value", "cols", "rows", "is-valid", "title", "onUpdate:modelValue"])) : (_(), H(a, {
                        key: 1,
                        id: u,
                        ref: "form",
                        "model-value": i.value,
                        "is-valid": n.isValid,
                        title: i.description,
                        pattern: i.regex,
                        "onUpdate:modelValue": i.onChange
                    }, null, 8, ["id", "model-value", "is-valid", "title", "pattern", "onUpdate:modelValue"])), z(l, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text"])
}
const W7e = te(F7e, [["render", j7e], ["__scopeId", "data-v-83dbe07d"]]), z7e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, H7e = P("circle", {
    cx: "13.2",
    cy: "13.2",
    r: "10"
}, null, -1), U7e = P("path", {
    d: "m20.2 20.2 8.6 8.6"
}, null, -1), q7e = [H7e, U7e];
function Y7e(e, t) {
    return _(),
    O("svg", z7e, q7e)
}
const O9 = {
    render: Y7e
}, K7e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, G7e = P("path", {
    d: "M6 22.7h21.3m-6.8 6.8 6.8-6.8-6.8-6.7M26 9.3H4.7m6.8-6.8L4.7 9.3l6.8 6.7"
}, null, -1), X7e = [G7e];
function J7e(e, t) {
    return _(),
    O("svg", K7e, X7e)
}
const Z7e = {
    render: J7e
}, Q7e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, eVe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M13.297 19.097H5.444l-1.763 4.891H1.132L8.29 5.246h2.163l7.17 18.742h-2.536ZM6.19 17.063h6.372L9.371 8.297ZM28.37 23.988q-.205-.412-.334-1.467-1.66 1.725-3.965 1.725-2.06 0-3.385-1.159-1.313-1.171-1.313-2.96 0-2.176 1.647-3.373 1.66-1.21 4.66-1.21h2.317V14.45q0-1.249-.746-1.983-.747-.746-2.202-.746-1.274 0-2.136.643-.863.644-.863 1.558h-2.394q0-1.043.734-2.008.746-.979 2.008-1.545 1.274-.566 2.793-.566 2.407 0 3.772 1.21 1.364 1.197 1.416 3.308v6.41q0 1.919.489 3.051v.206zm-3.951-1.815q1.12 0 2.124-.579 1.004-.58 1.454-1.506V17.23h-1.866q-4.377 0-4.377 2.562 0 1.12.747 1.75.746.631 1.918.631z",
    class: "text"
}, null, -1), tVe = [eVe];
function nVe(e, t) {
    return _(),
    O("svg", Q7e, tVe)
}
const rVe = {
    render: nVe
};
const oVe = {
    components: {
        InputField: wf,
        FunctionButton: ti,
        CloseIcon: qu,
        LensIcon: O9,
        InverseSearchIcon: Z7e,
        UpperLowerCaseIcon: rVe
    },
    props: {
        id: {
            type: String,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        modelValue: {
            type: String,
        default:
            ""
        },
        placeholder: {
            type: String,
        default:
            " "
        },
        initialCaseSensitiveSearch: {
        default:
            !1,
            type: Boolean
        },
        initialInverseSearch: {
        default:
            !1,
            type: Boolean
        },
        showCaseSensitiveSearchButton: {
        default:
            !1,
            type: Boolean
        },
        showInverseSearchButton: {
        default:
            !1,
            type: Boolean
        },
        autofocus: {
        default:
            !1,
            type: Boolean
        },
        disabled: {
        default:
            !1,
            type: Boolean
        }
    },
    emits: ["clear", "update:modelValue", "toggle-case-sensitive-search", "toggle-inverse-search", "focus"],
    data() {
        return {
            caseSensitiveSearch: this.initialCaseSensitiveSearch,
            inverseSearch: this.initialInverseSearch
        }
    },
    computed: {
        showClearButton() {
            return !this.disabled && this.modelValue !== ""
        },
        showSpacer() {
            return this.showClearButton && (this.showCaseSensitiveSearchButton || this.showInverseSearchButton)
        }
    },
    methods: {
        clearSearch() {
            this.$emit("clear"),
            this.$emit("update:modelValue", ""),
            this.focus()
        },
        toggleCaseSensitiveSearch() {
            this.caseSensitiveSearch = !this.caseSensitiveSearch,
            this.$emit("toggle-case-sensitive-search", this.caseSensitiveSearch),
            this.focus()
        },
        toggleInverseSearch() {
            this.inverseSearch = !this.inverseSearch,
            this.$emit("toggle-inverse-search", this.inverseSearch),
            this.focus()
        },
        focus() {
            this.$refs.searchInput.focus()
        }
    }
}, iVe = {
    key: 0,
    class: "icon-slot-wrapper"
}, sVe = {
    key: 1,
    class: "spacer"
};
function aVe(e, t, n, r, o, i) {
    const s = B("LensIcon"),
    a = B("CloseIcon"),
    l = B("FunctionButton"),
    c = B("UpperLowerCaseIcon"),
    u = B("InverseSearchIcon"),
    f = B("InputField");
    return _(),
    H(f, {
        id: n.id,
        ref: "searchInput",
        name: n.name,
        "model-value": n.modelValue,
        placeholder: n.placeholder,
        autofocus: n.autofocus,
        disabled: n.disabled,
        class: he(["search-input", {
                    disabled: n.disabled
                }
            ]),
        autocomplete: "off",
        role: "searchbox",
        onFocus: t[0] || (t[0] = p => e.$emit("focus", p)),
        "onUpdate:modelValue": t[1] || (t[1] = p => e.$emit("update:modelValue", p))
    }, {
        icon: oe(() => [n.disabled ? J("", !0) : (_(), O("div", iVe, [Ye(e.$slots, "icon", {}, () => [z(s)], !0)]))]),
        iconRight: oe(() => [i.showClearButton ? (_(), H(l, {
                        key: 0,
                        class: "clear-search",
                        onClick: i.clearSearch
                    }, {
                    default:
                        oe(() => [z(a)]),
                        _: 1
                    }, 8, ["onClick"])) : J("", !0), i.showSpacer ? (_(), O("span", sVe)) : J("", !0), !n.disabled && n.showCaseSensitiveSearchButton ? (_(), H(l, {
                        key: 2,
                        class: "toggle-case-sensitive-search",
                        active: o.caseSensitiveSearch,
                        onClick: i.toggleCaseSensitiveSearch
                    }, {
                    default:
                        oe(() => [z(c)]),
                        _: 1
                    }, 8, ["active", "onClick"])) : J("", !0), !n.disabled && n.showInverseSearchButton ? (_(), H(l, {
                        key: 3,
                        class: "toggle-inverse-search",
                        active: o.inverseSearch,
                        onClick: i.toggleInverseSearch
                    }, {
                    default:
                        oe(() => [z(u)]),
                        _: 1
                    }, 8, ["active", "onClick"])) : J("", !0)]),
        _: 3
    }, 8, ["id", "name", "model-value", "placeholder", "autofocus", "disabled", "class"])
}
const $9 = te(oVe, [["render", aVe], ["__scopeId", "data-v-b3dc00cf"]]), lVe = (e, t) => {
    let n,
    r = 0;
    return (...o) => {
        clearTimeout(n);
        const i = Date.now();
        i - r > t ? (r = i, e(...o)) : n = setTimeout(() => {
            r = i,
            e(...o)
        }, t)
    }
};
const cVe = {
    props: {
        text: {
            type: String,
        default:
            " "
        },
        selected: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
            type: Boolean,
        default:
            !1
        },
        invalid: {
            type: Boolean,
        default:
            !1
        },
        special: {
            type: Boolean,
        default:
            !1
        },
        lineHeight: {
            type: Number,
        default:
            null
        }
    },
    emits: ["mousedown", "mousemove", "dblclick-exact", "dblclick-shift", "click"]
}, uVe = ["title", "aria-selected"];
function dVe(e, t, n, r, o, i) {
    return _(),
    O("li", Bt(e.$attrs, {
            role: "option",
            title: n.text,
            style: {
                ...n.lineHeight !== null ? {
                    lineHeight: `${n.lineHeight}px`
                }
                 : {}
            },
            class: {
                selected: n.selected,
                invalid: n.invalid,
                empty: !Boolean(n.text.trim()),
                disabled: n.disabled,
                special: n.special
            },
            "aria-selected": n.selected,
            onClick: t[0] || (t[0] = s => e.$emit("click", s)),
            onDblclick: [t[1] || (t[1] = ve(s => e.$emit("dblclick-shift"), ["shift"])), t[2] || (t[2] = ve(s => e.$emit("dblclick-exact"), ["exact"]))],
            onMousedown: t[3] || (t[3] = s => e.$emit("mousedown", s)),
            onMousemove: t[4] || (t[4] = s => e.$emit("mousemove", s))
        }), Re(n.text), 17, uVe)
}
const fVe = te(cVe, [["render", dVe], ["__scopeId", "data-v-d6bb9d59"]]);
let hVe = 0;
const pVe = 250, mVe = {
    components: {
        StyledListItem: fVe
    },
    props: {
        id: {
            type: String,
        default () {
                return `MultiselectListBox-${hVe++}`
            }
        },
        modelValue: {
            type: Array,
        default:
            () => []
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        withIsEmptyState: {
        default:
            !1,
            type: Boolean
        },
        emptyStateLabel: {
        default:
            "No entries in this list",
            type: String
        },
        emptyStateComponent: {
        default:
            null,
            type: Object
        },
        multiselectByClick: {
            type: Boolean,
        default:
            !1
        },
        withBottomValue: {
            type: Boolean,
        default:
            !1
        },
        bottomValue: {
            type: Object,
        default:
            () => ({
                id: "bottom",
                text: "Other"
            }),
            validator(e) {
                return e.hasOwnProperty("id") && e.hasOwnProperty("text")
            }
        },
        size: {
            type: Number,
        default:
            0,
            validator(e) {
                return e >= 0
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        ariaLabel: {
            type: String,
            required: !0
        },
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e) ? e.every(t => t.hasOwnProperty("id") && t.hasOwnProperty("text")) : !1
            }
        }
    },
    emits: ["update:modelValue", "doubleClickOnItem", "doubleClickShift", "keyArrowLeft", "keyArrowRight"],
    setup(e) {
        const {
            containerProps: n,
            wrapperProps: r,
            list: o,
            scrollTo: i
        } = AQ(ca(e, "possibleValues"), {
            itemHeight: 22
        });
        return Ht(() => e.possibleValues, () => {
            i(Math.max(Math.min(Math.floor(n.ref.value.scrollTop / 22), e.possibleValues.length - 1), 0))
        }), {
            optionLineHeight: 22,
            containerProps: n,
            wrapperProps: r,
            list: o
        }
    },
    data() {
        return {
            selectedValues: this.modelValue,
            currentKeyNavIndex: 0,
            shiftStartIndex: -1,
            draggingStartIndex: -1,
            draggingInverseMode: !1
        }
    },
    computed: {
        cssStyleSize() {
            const e = `${this.size * this.optionLineHeight + 2}px`;
            return this.size > 0 ? {
                height: e
            }
             : {}
        },
        possibleValuesWithBottom() {
            return [...this.possibleValues, ...this.withBottomValue ? [this.bottomValue] : []]
        },
        bottomIndex() {
            return this.possibleValues.length
        },
        showEmptyState() {
            return this.withIsEmptyState && this.possibleValues.length === 0
        }
    },
    watch: {
        modelValue: {
            handler(e) {
                this.selectedValues = e
            },
            deep: !0
        }
    },
    mounted() {
        if (window.addEventListener("mouseup", this.onStopDrag), this.modelValue.length > 0) {
            const e = this.modelValue[this.modelValue.length - 1];
            this.currentKeyNavIndex = this.possibleValues.map(t => t.id).indexOf(e)
        }
    },
    beforeUnmount() {
        window.removeEventListener("mouseup", this.onStopDrag)
    },
    created() {
        this.debouncedHandleCtrlClick = lVe(this.handleCtrlClick, pVe)
    },
    methods: {
        isCurrentValue(e) {
            return this.selectedValues.includes(e)
        },
        handleCtrlClick(e, t) {
            this.currentKeyNavIndex = t,
            this.toggleSelection(e)
        },
        handleShiftClick(e, t) {
            this.setSelected(this.getPossibleValuesInSection(this.currentKeyNavIndex, t))
        },
        getPossibleValuesInSection(e, t) {
            const n = e > t ? t : e,
            r = e > t ? e : t;
            return this.possibleValuesWithBottom.slice(n, r + 1).map(o => o.id)
        },
        onStartDrag(e, t = !1) {
            if (this.disabled || e.shiftKey)
                return;
            (e.ctrlKey || e.metaKey) && (this.draggingInverseMode = !0);
            const n = t ? this.bottomIndex : e.target.getAttribute("data-option-index");
            n && (this.draggingStartIndex = Number(n))
        },
        onDrag(e) {
            if (this.draggingStartIndex !== -1) {
                const t = e.target.getAttribute("data-option-index");
                if (!t)
                    return;
                const n = Number(t);
                let r = this.getPossibleValuesInSection(this.draggingStartIndex, n);
                this.draggingInverseMode && (r = this.selectedValues.filter(o => !r.includes(o))),
                this.setSelected(r)
            }
        },
        onBottomStartDrag(e) {
            this.focus(),
            this.onStartDrag(e)
        },
        onBottomDrag(e) {
            this.focus(),
            this.onDrag(e)
        },
        onStopDrag() {
            this.draggingStartIndex = -1,
            this.draggingInverseMode = !1
        },
        handleClick(e, t, n) {
            if (!this.disabled) {
                if (e.preventDefault(), e.metaKey) {
                    this.debouncedHandleCtrlClick(t, n);
                    return
                }
                if (e.ctrlKey) {
                    this.handleCtrlClick(t, n);
                    return
                }
                if (e.shiftKey) {
                    this.handleShiftClick(t, n);
                    return
                }
                this.multiselectByClick || (this.selectedValues = []),
                this.currentKeyNavIndex = n,
                this.toggleSelection(t)
            }
        },
        handleDblClick(e, t) {
            this.disabled || this.$emit("doubleClickOnItem", e, t)
        },
        handleBottomClick(e) {
            this.handleClick(e, this.bottomValue.id, this.bottomIndex),
            this.focus()
        },
        handleBottomDblClick() {
            this.handleDblClick(this.bottomValue.id, this.bottomIndex)
        },
        handleShiftDblClick() {
            this.disabled || this.$emit("doubleClickShift", this.selectedValues)
        },
        addToSelection(e) {
            let t = !1;
            const n = this.selectedValues;
            return n.includes(e) || (n.push(e), t = !0),
            this.setSelected(n),
            t
        },
        removeFromSelection(e) {
            let t = !1;
            const n = this.selectedValues;
            return n.includes(e) && (n.splice(n.indexOf(e), 1), t = !0),
            this.setSelected(n),
            t
        },
        toggleSelection(e) {
            this.selectedValues.includes(e) ? this.removeFromSelection(e) : this.addToSelection(e)
        },
        setSelectedNoShiftReset(e) {
            consola.trace("MultiselectListBox setSelected on", e),
            this.selectedValues = e,
            this.$emit("update:modelValue", e)
        },
        setSelected(e) {
            this.shiftStartIndex = -1,
            this.setSelectedNoShiftReset(e)
        },
        setSelectedToIndex(e) {
            const t = this.possibleValuesWithBottom[e];
            t && t.id && this.setSelected([t.id])
        },
        scrollToCurrent() {
            if (this.currentKeyNavIndex === this.bottomIndex)
                return;
            const e = this.containerProps.ref.value;
            if (e.scrollHeight > e.clientHeight) {
                const t = e.clientHeight + e.scrollTop,
                n = this.currentKeyNavIndex * this.optionLineHeight,
                r = n + this.optionLineHeight;
                r > t ? e.scrollTop = r - e.clientHeight : n < e.scrollTop && (e.scrollTop = n)
            }
        },
        isOutOfRange(e) {
            return e < 0 ? !0 : this.withBottomValue ? e > this.bottomIndex : e >= this.bottomIndex
        },
        onArrowDown() {
            if (this.disabled)
                return;
            const e = this.currentKeyNavIndex + 1;
            this.isOutOfRange(e) || (this.setSelectedToIndex(e), this.currentKeyNavIndex = e, this.scrollToCurrent())
        },
        onArrowUp() {
            if (this.disabled)
                return;
            const e = this.currentKeyNavIndex - 1;
            this.isOutOfRange(e) || (this.setSelectedToIndex(e), this.currentKeyNavIndex = e, this.scrollToCurrent())
        },
        onArrowDownShift() {
            if (this.disabled)
                return;
            this.shiftStartIndex === -1 && (this.shiftStartIndex = this.currentKeyNavIndex);
            const e = this.currentKeyNavIndex + 1;
            this.isOutOfRange(e) || (this.setSelectedNoShiftReset(this.getPossibleValuesInSection(this.shiftStartIndex, e)), this.currentKeyNavIndex = e, this.scrollToCurrent())
        },
        onArrowUpShift() {
            if (this.disabled)
                return;
            this.shiftStartIndex === -1 && (this.shiftStartIndex = this.currentKeyNavIndex);
            const e = this.currentKeyNavIndex - 1;
            this.isOutOfRange(e) || (this.setSelectedNoShiftReset(this.getPossibleValuesInSection(this.shiftStartIndex, e)), this.currentKeyNavIndex = e, this.scrollToCurrent())
        },
        onEndKey() {
            const e = this.possibleValues.length - 1;
            this.setSelectedToIndex(e),
            this.currentKeyNavIndex = e,
            this.containerProps.ref.value.scrollTop = this.containerProps.ref.value.scrollHeight
        },
        onHomeKey() {
            this.setSelectedToIndex(0),
            this.currentKeyNavIndex = 0,
            this.containerProps.ref.value.scrollTop = 0
        },
        onArrowLeft() {
            this.disabled || this.$emit("keyArrowLeft", this.selectedValues)
        },
        onArrowRight() {
            this.disabled || this.$emit("keyArrowRight", this.selectedValues)
        },
        onCtrlA() {
            this.disabled || this.setSelected(this.possibleValuesWithBottom.map(e => e.id))
        },
        hasSelection() {
            return this.selectedValues.length > 0
        },
        getCurrentKeyNavItem() {
            try {
                return this.possibleValues[this.currentKeyNavIndex]
            } catch {
                return {
                    id: "",
                    text: ""
                }
            }
        },
        generateOptionId(e) {
            if (!e)
                return "";
            const n = (typeof e.id == "symbol" ? e.id.description : e.id).replace(/[^\w]/gi, "");
            return `option-${this.id}-${n}`
        },
        focus() {
            this.disabled || this.containerProps.ref.value.focus()
        },
        clearSelection() {
            this.disabled || this.setSelected([])
        }
    }
}, gVe = {
    class: "box"
}, vVe = ["id", "aria-label", "aria-activedescendant"], yVe = {
    key: 0,
    class: "empty-state"
}, wVe = {
    key: 1
}, bVe = {
    key: 1,
    role: "bottom-box"
};
function _Ve(e, t, n, r, o, i) {
    const s = B("StyledListItem");
    return _(),
    O("div", {
        class: he(["multiselect-list-box", {
                    invalid: !n.isValid,
                    disabled: n.disabled
                }
            ]),
        style: Yt(i.cssStyleSize)
    }, [P("div", gVe, [P("ul", Bt(r.containerProps, {
                            id: n.id,
                            role: "listbox",
                            tabindex: "0",
                            class: {
                                disabled: n.disabled,
                                "empty-box": i.showEmptyState
                            },
                            "aria-label": n.ariaLabel,
                            "aria-activedescendant": i.generateOptionId(i.getCurrentKeyNavItem()),
                            onKeydown: [t[1] || (t[1] = Rt(ve((...a) => i.onCtrlA && i.onCtrlA(...a), ["ctrl", "prevent", "exact"]), ["a"])), t[2] || (t[2] = Rt(ve((...a) => i.onArrowUp && i.onArrowUp(...a), ["prevent", "exact"]), ["up"])), t[3] || (t[3] = Rt(ve((...a) => i.onArrowDown && i.onArrowDown(...a), ["prevent", "exact"]), ["down"])), t[4] || (t[4] = Rt(ve((...a) => i.onArrowUpShift && i.onArrowUpShift(...a), ["shift", "prevent", "exact"]), ["up"])), t[5] || (t[5] = Rt(ve((...a) => i.onArrowDownShift && i.onArrowDownShift(...a), ["shift", "prevent", "exact"]), ["down"])), t[6] || (t[6] = Rt(ve((...a) => i.onArrowLeft && i.onArrowLeft(...a), ["prevent", "exact"]), ["left"])), t[7] || (t[7] = Rt(ve((...a) => i.onArrowRight && i.onArrowRight(...a), ["prevent", "exact"]), ["right"])), t[8] || (t[8] = Rt(ve((...a) => i.onHomeKey && i.onHomeKey(...a), ["prevent", "exact"]), ["home"])), t[9] || (t[9] = Rt(ve((...a) => i.onEndKey && i.onEndKey(...a), ["prevent", "exact"]), ["end"]))],
                            onMousedown: t[10] || (t[10] = (...a) => i.onStartDrag && i.onStartDrag(...a)),
                            onMousemove: t[11] || (t[11] = (...a) => i.onDrag && i.onDrag(...a))
                        }), [P("div", wu(tc(r.wrapperProps)), [(_(!0), O(Le, null, $t(r.list, ({
                                                    data: a,
                                                    index: l
                                                }) => (_(), H(s, {
                                                        id: i.generateOptionId(a),
                                                        key: `listbox-${a.id}`,
                                                        text: a.text,
                                                        "data-option-index": l,
                                                        "line-height": r.optionLineHeight,
                                                        selected: i.isCurrentValue(a.id),
                                                        invalid: a.invalid,
                                                        disabled: n.disabled,
                                                        onClick: c => i.handleClick(c, a.id, l),
                                                        onDblclickShift: t[0] || (t[0] = c => i.handleShiftDblClick()),
                                                        onDblclickExact: c => i.handleDblClick(a.id, l)
                                                    }, null, 8, ["id", "text", "data-option-index", "line-height", "selected", "invalid", "disabled", "onClick", "onDblclickExact"]))), 128))], 16)], 16, vVe), i.showEmptyState ? (_(), O("div", yVe, [n.emptyStateComponent ? (_(), H(Kt(n.emptyStateComponent), {
                                        key: 0
                                    })) : (_(), O("span", wVe, Re(n.emptyStateLabel), 1))])) : J("", !0), n.withBottomValue ? (_(), O("div", bVe, [z(s, {
                                    id: i.generateOptionId(n.bottomValue),
                                    special: "",
                                    text: n.bottomValue.text,
                                    "data-option-index": i.bottomIndex,
                                    selected: i.isCurrentValue(n.bottomValue.id),
                                    disabled: n.disabled,
                                    onClick: i.handleBottomClick,
                                    onDblclickShift: t[12] || (t[12] = a => i.handleShiftDblClick()),
                                    onDblclickExact: i.handleBottomDblClick,
                                    onMousedown: i.onBottomStartDrag,
                                    onMousemove: i.onBottomDrag
                                }, null, 8, ["id", "text", "data-option-index", "selected", "disabled", "onClick", "onDblclickExact", "onMousedown", "onMousemove"])])) : J("", !0)])], 6)
}
const A9 = te(mVe, [["render", _Ve], ["__scopeId", "data-v-52364254"]]), kVe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, xVe = P("path", {
    d: "m10.5 5 11 11-11 11"
}, null, -1), SVe = [xVe];
function CVe(e, t) {
    return _(),
    O("svg", kVe, SVe)
}
const Ww = {
    render: CVe
}, IVe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, TVe = P("path", {
    d: "m14.8 5 11 11-11 11M6.2 5l11 11-11 11"
}, null, -1), MVe = [TVe];
function PVe(e, t) {
    return _(),
    O("svg", IVe, MVe)
}
const EVe = {
    render: PVe
}, OVe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, $Ve = P("path", {
    d: "m17.2 27-11-11 11-11m8.6 22-11-11 11-11"
}, null, -1), AVe = [$Ve];
function DVe(e, t) {
    return _(),
    O("svg", OVe, AVe)
}
const NVe = {
    render: DVe
}, RVe = [{
        id: "search",
        normalize(e, t) {
            return t ? e : e.toLowerCase()
        },
        test(e, t, n, r) {
            const i = (n ? e : e.toLowerCase()).includes(t);
            return r ? !i : i
        }
    }, {
        id: "wildcard",
        normalize(e, t) {
            if (e.length > 0)
                e = `^${e.replace(/[-[\]{}()+.,\\^$|#\s]/g, "\\$&").replace(/\*/g, ".*").replace(/\?/g, ".?")}$`;
            else
                return {
                    test: () => !1
                };
            try {
                const n = t ? "" : "i";
                return new RegExp(e, n)
            } catch {
                return /$^/
            }
        },
        test(e, t, n, r) {
            const o = t.test(e);
            return r ? !o : o
        }
    }, {
        id: "regex",
        normalize(e, t) {
            try {
                const n = t ? "" : "i";
                return new RegExp(`^${e}$`, n)
            } catch {
                return /$^/
            }
        },
        test(e, t, n, r) {
            const o = t.test(e);
            return r ? !o : o
        }
    }, {
        id: "type",
        normalize(e) {
            return {
                test: t => e.includes(t)
            }
        },
        test(e, t) {
            return typeof e > "u" ? !1 : t.test(e)
        }
    }
], YD = Object.assign({}, ...RVe.map(e => ({
            [e.id]: e
        }))), Bv = "Enter", KD = 5, LVe = {
    components: {
        ArrowNextDoubleIcon: EVe,
        ArrowNextIcon: Ww,
        ArrowPrevDoubleIcon: NVe,
        ArrowPrevIcon: w7,
        MultiselectListBox: A9,
        Label: Xn,
        SearchInput: $9
    },
    props: {
        modelValue: {
            type: Array,
        default:
            null
        },
        initialCaseSensitiveSearch: {
        default:
            !1,
            type: Boolean
        },
        initialSearchTerm: {
            type: String,
            required: !1,
        default:
            ""
        },
        initialIncludeUnknownValues: {
            type: Boolean,
        default:
            !1
        },
        showSearch: {
        default:
            !1,
            type: Boolean
        },
        showUnknownValues: {
            type: Boolean,
        default:
            !1
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        showEmptyState: {
        default:
            !0,
            type: Boolean
        },
        leftLabel: {
            type: String,
            required: !0,
        default:
            "Possible values"
        },
        rightLabel: {
            type: String,
            required: !0,
        default:
            "Selected values"
        },
        withSearchLabel: {
        default:
            !1,
            type: Boolean
        },
        searchLabel: {
            type: String,
            required: !1,
        default:
            "Search values"
        },
        searchPlaceholder: {
            type: String,
            required: !1,
        default:
            "Search"
        },
        unknownValuesText: {
            type: String,
            required: !1,
        default:
            "Unknown values"
        },
        emptyStateLabel: {
        default:
            "No entries in this list",
            type: String
        },
        emptyStateComponent: {
        default:
            null,
            type: Object
        },
        size: {
            type: Number,
        default:
            0,
            validator(e) {
                return e >= 0
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        possibleValues: {
            type: Array,
        default:
            () => []
        },
        filterChosenValuesOnPossibleValuesChange: {
            type: Boolean,
        default:
            !0,
            required: !1
        }
    },
    emits: ["update:modelValue", "includeUnknownValuesInput"],
    data() {
        return {
            chosenValues: this.modelValue,
            invalidPossibleValueIds: new Set,
            rightSelected: [],
            leftSelected: [],
            searchTerm: this.initialSearchTerm,
            caseSensitiveSearch: this.initialCaseSensitiveSearch,
            includeUnknownValues: this.initialIncludeUnknownValues,
            unknownValuesId: Symbol("Unknown values")
        }
    },
    computed: {
        possibleValueMap() {
            return Object.assign({}, ...this.possibleValues.map((e, t) => ({
                        [e.id]: {
                            item: e,
                            index: t
                        }
                    })))
        },
        possibleValueIds() {
            return this.possibleValues.map(e => e.id)
        },
        invalidValueIds() {
            return this.chosenValues === null ? [] : this.chosenValues.filter(e => !this.possibleValueMap[e])
        },
        matchingInvalidValueIds() {
            return this.invalidValueIds.filter(e => this.itemMatchesSearch(this.generateInvalidItem(e)))
        },
        matchingValidIds() {
            return this.possibleValues.filter(e => this.itemMatchesSearch(e)).map(e => e.id)
        },
        visibleValueIds() {
            return this.chosenValues === null ? new Set : new Set([...this.matchingValidIds, ...this.matchingInvalidValueIds])
        },
        leftItems() {
            if (this.visibleValueIds.size === 0)
                return [];
            const e = new Set(this.chosenValues);
            return this.possibleValues.filter(t => this.visibleValueIds.has(t.id) && !e.has(t.id))
        },
        rightItems() {
            return this.chosenValues === null ? [] : this.chosenValues.map(e => this.possibleValueMap[e]?.item || this.generateInvalidItem(e)).filter(e => this.visibleValueIds.has(e.id))
        },
        listSize() {
            const e = this.size === 0 ? this.possibleValues.length : this.size;
            return e > KD ? e : KD
        },
        showUnknownValuesLeft() {
            return this.showUnknownValues && !this.includeUnknownValues
        },
        showUnknownValuesRight() {
            return this.showUnknownValues && this.includeUnknownValues
        },
        moveAllRightButtonDisabled() {
            return this.leftItems.length === 0 && !this.showUnknownValuesLeft
        },
        moveRightButtonDisabled() {
            return this.leftSelected.length === 0
        },
        moveAllLeftButtonDisabled() {
            return this.rightItems.length === 0 && !this.showUnknownValuesRight
        },
        moveLeftButtonDisabled() {
            return this.rightSelected.length === 0
        },
        normalizedSearchTerm() {
            return this.showSearch ? YD.search.normalize(this.searchTerm, this.caseSensitiveSearch) : ""
        },
        numAllItems() {
            return this.invalidValueIds.length + this.possibleValues.length
        },
        numAllRightItems() {
            return this.chosenValues === null ? 0 : this.chosenValues.length
        },
        numShownRightItems() {
            return this.rightItems.length
        },
        numAllLeftItems() {
            return this.possibleValues.length + this.invalidValueIds.length - this.numAllRightItems
        },
        numShownLeftItems() {
            return this.leftItems.length
        },
        hasActiveSearch() {
            return this.showSearch && this.searchTerm !== ""
        },
        leftInfo() {
            return this.getInfoText(this.numShownLeftItems, this.numAllLeftItems)
        },
        rightInfo() {
            return this.getInfoText(this.numShownRightItems, this.numAllRightItems)
        }
    },
    watch: {
        modelValue(e) {
            (this.chosenValues?.length !== e.length || JSON.stringify(e) !== JSON.stringify(this.chosenValues)) && (this.chosenValues = e)
        },
        possibleValues(e) {
            if (this.filterChosenValuesOnPossibleValuesChange) {
                let t = e.reduce((n, r) => (n.push(...Object.values(r)), n), []);
                this.chosenValues = (this.chosenValues ?? []).filter(n => t.includes(n))
            }
        },
        chosenValues(e, t) {
            (t === null || e.length !== t.length || t.some((n, r) => n !== e[r])) && this.$emit("update:modelValue", this.chosenValues)
        },
        includeUnknownValues(e) {
            this.$emit("includeUnknownValuesInput", e)
        }
    },
    methods: {
        generateInvalidItem(e) {
            return {
                id: e,
                text: `(MISSING) ${String(e)}`,
                invalid: !0
            }
        },
        getIndex(e) {
            return this.possibleValueMap[e]?.index ?? -1
        },
        compareByOriginalSorting(e, t) {
            return this.getIndex(e) - this.getIndex(t)
        },
        clearSelections() {
            this.$refs.right.clearSelection(),
            this.$refs.left.clearSelection()
        },
        moveRight(e = null) {
            const t = e ?? this.leftSelected;
            this.chosenValues !== null && (this.chosenValues = [...t.filter(n => n !== this.unknownValuesId), ...this.chosenValues].sort(this.compareByOriginalSorting)),
            t.includes(this.unknownValuesId) && (this.includeUnknownValues = !0),
            this.clearSelections()
        },
        moveLeft(e = null) {
            const t = e ?? this.rightSelected,
            n = new Set(this.invalidValueIds);
            t.filter(i => n.has(i)).forEach(i => this.invalidPossibleValueIds.add(i));
            const o = new Set(t);
            this.chosenValues !== null && (this.chosenValues = this.chosenValues.filter(i => !o.has(i)).sort(this.compareByOriginalSorting)),
            o.has(this.unknownValuesId) && (this.includeUnknownValues = !1),
            this.clearSelections()
        },
        onMoveRightButtonClick() {
            this.moveRight()
        },
        onMoveAllRightButtonClick() {
            this.moveRight(this.leftItems.filter(e => !e.invalid).map(e => e.id)),
            this.includeUnknownValues = !0
        },
        onMoveAllRightButtonKey(e) {
            e.key === Bv && (this.onMoveAllRightButtonClick(), this.stopPropagation(e))
        },
        onMoveRightButtonKey(e) {
            e.key === Bv && (this.moveRight(), this.stopPropagation(e))
        },
        onMoveLeftButtonClick() {
            this.moveLeft()
        },
        onMoveAllLeftButtonClick() {
            this.moveLeft(this.rightItems.map(e => e.id)),
            this.includeUnknownValues = !1
        },
        onMoveLeftButtonKey(e) {
            e.key === Bv && (this.moveLeft(), this.stopPropagation(e))
        },
        onMoveAllLeftButtonKey(e) {
            e.key === Bv && (this.onMoveAllLeftButtonClick(), this.stopPropagation(e))
        },
        stopPropagation(e) {
            e.preventDefault(),
            e.stopPropagation()
        },
        onLeftListBoxDoubleClick(e) {
            this.moveRight([e])
        },
        onLeftListBoxShiftDoubleClick(e) {
            this.moveRight(e)
        },
        onRightListBoxDoubleClick(e) {
            this.moveLeft([e])
        },
        onRightListBoxShiftDoubleClick(e) {
            this.moveLeft(e)
        },
        onLeftInput(e) {
            e.length > 0 && this.$refs.right.clearSelection(),
            this.leftSelected = e
        },
        onRightInput(e) {
            e.length > 0 && this.$refs.left.clearSelection(),
            this.rightSelected = e
        },
        onKeyRightArrow() {
            this.moveRight()
        },
        onKeyLeftArrow() {
            this.moveLeft()
        },
        onSearchInput(e) {
            this.searchTerm = e
        },
        hasSelection() {
            return (this.chosenValues?.length ?? 0) > 0
        },
        validate() {
            let e = !this.rightItems.some(t => t.invalid);
            return {
                isValid: e,
                errorMessage: e ? null : "One or more of the selected items is invalid."
            }
        },
        itemMatchesSearch(e) {
            return YD.search.test(e.text, this.normalizedSearchTerm, this.caseSensitiveSearch, !1)
        },
        getInfoText(e, t) {
            return this.hasActiveSearch ? `${e} of ${t} entries` : null
        }
    }
};
const BVe = e => (ir("data-v-2f37027b"), e = e(), sr(), e), VVe = {
    class: "twinlist"
}, FVe = {
    class: "header"
}, jVe = {
    class: "title"
}, WVe = ["title"], zVe = ["title"], HVe = BVe(() => P("div", {
            class: "space"
        }, null, -1)), UVe = {
    class: "title"
}, qVe = ["title"], YVe = ["title"], KVe = {
    class: "buttons"
};
function GVe(e, t, n, r, o, i) {
    const s = B("SearchInput"),
    a = B("Label"),
    l = B("MultiselectListBox"),
    c = B("ArrowNextIcon"),
    u = B("ArrowNextDoubleIcon"),
    f = B("ArrowPrevIcon"),
    p = B("ArrowPrevDoubleIcon");
    return _(),
    O("div", VVe, [n.showSearch ? (_(), H(a, {
                    key: 0,
                    active: n.withSearchLabel,
                    text: n.searchLabel,
                    class: "search-wrapper"
                }, {
                default:
                    oe(({
                            labelForId: m
                        }) => [z(s, {
                                id: m,
                                ref: "search",
                                placeholder: n.searchPlaceholder,
                                "model-value": o.searchTerm,
                                label: n.searchLabel,
                                "initial-case-sensitive-search": n.initialCaseSensitiveSearch,
                                "show-case-sensitive-search-button": "",
                                disabled: n.disabled,
                                "onUpdate:modelValue": i.onSearchInput,
                                onToggleCaseSensitiveSearch: t[0] || (t[0] = v => o.caseSensitiveSearch = v)
                            }, null, 8, ["id", "placeholder", "model-value", "label", "initial-case-sensitive-search", "disabled", "onUpdate:modelValue"])]),
                    _: 1
                }, 8, ["active", "text"])) : J("", !0), P("div", FVe, [P("div", jVe, [P("div", {
                                class: "label",
                                title: n.leftLabel
                            }, Re(n.leftLabel), 9, WVe), i.leftInfo ? (_(), O("div", {
                                    key: 0,
                                    title: i.leftInfo,
                                    class: "info"
                                }, Re(i.leftInfo), 9, zVe)) : J("", !0)]), HVe, P("div", UVe, [P("div", {
                                class: "label",
                                title: n.rightLabel
                            }, Re(n.rightLabel), 9, qVe), i.rightInfo ? (_(), O("div", {
                                    key: 0,
                                    title: i.rightInfo,
                                    class: "info"
                                }, Re(i.rightInfo), 9, YVe)) : J("", !0)])]), P("div", {
                class: he(["lists", {
                            disabled: n.disabled
                        }
                    ])
            }, [z(l, {
                        ref: "left",
                        "with-is-empty-state": n.showEmptyState,
                        "empty-state-label": n.emptyStateLabel,
                        "empty-state-component": n.emptyStateComponent,
                        size: i.listSize,
                        class: "list-box",
                        "model-value": o.leftSelected,
                        "with-bottom-value": i.showUnknownValuesLeft,
                        "bottom-value": {
                            id: o.unknownValuesId,
                            text: n.unknownValuesText
                        },
                        "is-valid": n.isValid,
                        "possible-values": i.leftItems,
                        ariaLabel: n.leftLabel,
                        disabled: n.disabled,
                        onDoubleClickOnItem: i.onLeftListBoxDoubleClick,
                        onDoubleClickShift: i.onLeftListBoxShiftDoubleClick,
                        onKeyArrowRight: i.onKeyRightArrow,
                        "onUpdate:modelValue": i.onLeftInput
                    }, null, 8, ["with-is-empty-state", "empty-state-label", "empty-state-component", "size", "model-value", "with-bottom-value", "bottom-value", "is-valid", "possible-values", "ariaLabel", "disabled", "onDoubleClickOnItem", "onDoubleClickShift", "onKeyArrowRight", "onUpdate:modelValue"]), P("div", KVe, [P("div", {
                                ref: "moveRight",
                                class: he({
                                    disabled: i.moveRightButtonDisabled || n.disabled
                                }),
                                role: "button",
                                tabindex: "0",
                                onClick: t[1] || (t[1] = (...m) => i.onMoveRightButtonClick && i.onMoveRightButtonClick(...m)),
                                onKeydown: t[2] || (t[2] = (...m) => i.onMoveRightButtonKey && i.onMoveRightButtonKey(...m))
                            }, [z(c, {
                                        class: "icon"
                                    })], 34), P("div", {
                                ref: "moveAllRight",
                                class: he({
                                    disabled: i.moveAllRightButtonDisabled || n.disabled
                                }),
                                role: "button",
                                tabindex: "0",
                                onClick: t[3] || (t[3] = (...m) => i.onMoveAllRightButtonClick && i.onMoveAllRightButtonClick(...m)),
                                onKeydown: t[4] || (t[4] = (...m) => i.onMoveAllRightButtonKey && i.onMoveAllRightButtonKey(...m))
                            }, [z(u, {
                                        class: "icon"
                                    })], 34), P("div", {
                                ref: "moveLeft",
                                class: he({
                                    disabled: i.moveLeftButtonDisabled || n.disabled
                                }),
                                role: "button",
                                tabindex: "0",
                                onClick: t[5] || (t[5] = (...m) => i.onMoveLeftButtonClick && i.onMoveLeftButtonClick(...m)),
                                onKeydown: t[6] || (t[6] = (...m) => i.onMoveLeftButtonKey && i.onMoveLeftButtonKey(...m))
                            }, [z(f, {
                                        class: "icon"
                                    })], 34), P("div", {
                                ref: "moveAllLeft",
                                class: he({
                                    disabled: i.moveAllLeftButtonDisabled || n.disabled
                                }),
                                role: "button",
                                tabindex: "0",
                                onClick: t[7] || (t[7] = (...m) => i.onMoveAllLeftButtonClick && i.onMoveAllLeftButtonClick(...m)),
                                onKeydown: t[8] || (t[8] = (...m) => i.onMoveAllLeftButtonKey && i.onMoveAllLeftButtonKey(...m))
                            }, [z(p, {
                                        class: "icon"
                                    })], 34)]), z(l, {
                        ref: "right",
                        class: he(["list-box", {
                                    "with-empty-state-icon": n.emptyStateComponent
                                }
                            ]),
                        "model-value": o.rightSelected,
                        "with-bottom-value": i.showUnknownValuesRight,
                        "bottom-value": {
                            id: o.unknownValuesId,
                            text: n.unknownValuesText
                        },
                        "with-is-empty-state": n.showEmptyState,
                        "empty-state-label": n.emptyStateLabel,
                        "empty-state-component": n.emptyStateComponent,
                        "possible-values": i.rightItems,
                        size: i.listSize,
                        ariaLabel: n.rightLabel,
                        disabled: n.disabled,
                        onDoubleClickOnItem: i.onRightListBoxDoubleClick,
                        onDoubleClickShift: i.onRightListBoxShiftDoubleClick,
                        onKeyArrowLeft: i.onKeyLeftArrow,
                        "onUpdate:modelValue": i.onRightInput
                    }, null, 8, ["class", "model-value", "with-bottom-value", "bottom-value", "with-is-empty-state", "empty-state-label", "empty-state-component", "possible-values", "size", "ariaLabel", "disabled", "onDoubleClickOnItem", "onDoubleClickShift", "onKeyArrowLeft", "onUpdate:modelValue"])], 2)])
}
const D9 = te(LVe, [["render", GVe], ["__scopeId", "data-v-2f37027b"]]), x2 = "columns", XVe = {
    components: {
        Twinlist: D9,
        Fieldset: mc,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [x2]: []
            }),
            type: Object
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        possibleColumns() {
            return [...new Set(this.viewRep.possibleColumns)].map(e => ({
                    id: e,
                    text: e
                }))
        },
        description() {
            return this.viewRep.description || null
        },
        maxVisibleListEntries() {
            return this.viewRep.limitNumberVisOptions ? this.viewRep.numberVisOptions : 0
        },
        value() {
            return this.valuePair[x2]
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: x2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t;
            if (this.viewRep.required && !this.$refs.form.hasSelection() && (e = !1, t = "Selection is required."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = n.errorMessage || t || "Current selection is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function JVe(e, t, n, r, o, i) {
    const s = B("Twinlist"),
    a = B("ErrorMessage"),
    l = B("Fieldset");
    return _(),
    H(l, {
        text: i.label
    }, {
    default:
        oe(() => [z(s, {
                    ref: "form",
                    "left-label": "Excludes",
                    "right-label": "Includes",
                    "model-value": i.value,
                    size: i.maxVisibleListEntries,
                    "possible-values": i.possibleColumns,
                    "is-valid": n.isValid,
                    title: i.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["model-value", "size", "possible-values", "is-valid", "title", "onUpdate:modelValue"]), z(a, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text"])
}
const ZVe = te(XVe, [["render", JVe]]);
const QVe = {
    components: {
        BaseRadioButtons: A7
    },
    props: {
        id: {
            type: String,
        default:
            null
        },
        modelValue: {
            type: String,
        default:
            ""
        },
        disabled: {
        default:
            !1,
            type: Boolean
        },
        possibleValues: {
            type: Array,
        default:
            () => []
        },
        alignment: {
            type: String,
        default:
            "horizontal",
            validator(e) {
                return ["horizontal", "vertical"].includes(e)
            }
        }
    },
    emits: ["update:modelValue"],
    methods: {
        hasSelection() {
            return this.$refs.radioButton.$refs.input.some(e => e.checked)
        }
    }
};
function e9e(e, t, n, r, o, i) {
    const s = B("BaseRadioButtons");
    return _(),
    H(s, {
        id: n.id,
        ref: "radioButton",
        "possible-values": n.possibleValues,
        "model-value": n.modelValue,
        disabled: n.disabled,
        class: he(["radio-buttons", n.alignment, {
                    disabled: n.disabled
                }
            ]),
        "onUpdate:modelValue": t[0] || (t[0] = a => e.$emit("update:modelValue", a))
    }, null, 8, ["id", "possible-values", "model-value", "disabled", "class"])
}
const t9e = te(QVe, [["render", e9e], ["__scopeId", "data-v-7c11ecc2"]]);
let n9e = 0;
const r9e = 40, o9e = 38, i9e = 36, s9e = 35, a9e = {
    props: {
        id: {
            type: String,
        default () {
                return `ListBox-${n9e++}`
            }
        },
        modelValue: {
            type: String,
        default:
            ""
        },
        size: {
            type: Number,
        default:
            0,
            validator(e) {
                return e >= 0
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        ariaLabel: {
            type: String,
            required: !0
        },
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e) ? e.every(t => t.hasOwnProperty("id") && t.hasOwnProperty("text")) : !1
            }
        }
    },
    emits: ["update:modelValue"],
    data() {
        return {
            selectedIndex: -1,
            invalidPossibleValueIds: [],
            optionLineHeight: 22
        }
    },
    computed: {
        ulSizeStyle() {
            const e = t => `${t * this.optionLineHeight + 2}px`;
            return this.size > 0 ? {
                height: e(this.size)
            }
             : {
                minHeight: e(2)
            }
        },
        selectableValues() {
            return [...this.invalidPossibleValueIds.map(e => this.generateInvalidItem(e)), ...this.possibleValues]
        }
    },
    watch: {
        modelValue(e) {
            this.updateSelectedIndexAndInvalidValue(e)
        }
    },
    mounted() {
        this.updateSelectedIndexAndInvalidValue(this.modelValue)
    },
    methods: {
        updateSelectedIndexAndInvalidValue(e) {
            const t = this.selectableValues.findIndex(n => n.id === e);
            t === -1 && e ? (this.invalidPossibleValueIds.includes(e) || this.invalidPossibleValueIds.push(e), this.selectedIndex = this.selectableValues.findIndex(n => n.id === e)) : this.selectedIndex = t
        },
        isCurrentValue(e) {
            return this.modelValue === e
        },
        setSelected(e, t) {
            consola.trace("ListBox setSelected on", e),
            this.selectedIndex = t,
            this.$emit("update:modelValue", e)
        },
        scrollToCurrent() {
            let e = this.$refs.ul;
            if (e.scrollHeight > e.clientHeight) {
                let t = this.$refs.options[this.selectedIndex],
                n = e.clientHeight + e.scrollTop,
                r = t.offsetTop + t.offsetHeight;
                r > n ? e.scrollTop = r - e.clientHeight : t.offsetTop < e.scrollTop && (e.scrollTop = t.offsetTop)
            }
        },
        onArrowDown() {
            let e = this.selectedIndex + 1;
            e >= this.selectableValues.length || (this.setSelected(this.selectableValues[e].id, e), this.scrollToCurrent())
        },
        onArrowUp() {
            let e = this.selectedIndex - 1;
            e < 0 || (this.setSelected(this.selectableValues[e].id, e), this.scrollToCurrent())
        },
        onEndKey() {
            let e = this.selectableValues.length - 1;
            this.setSelected(this.selectableValues[e].id, e),
            this.$refs.ul.scrollTop = this.$refs.ul.scrollHeight
        },
        onHomeKey() {
            let e = 0;
            this.setSelected(this.selectableValues[e].id, e),
            this.$refs.ul.scrollTop = 0
        },
        handleKeyDown(e) {
            e.keyCode === r9e && (this.onArrowDown(), e.preventDefault()),
            e.keyCode === o9e && (this.onArrowUp(), e.preventDefault()),
            e.keyCode === s9e && (this.onEndKey(), e.preventDefault()),
            e.keyCode === i9e && (this.onHomeKey(), e.preventDefault())
        },
        hasSelection() {
            return this.selectedIndex >= 0
        },
        validate() {
            return {
                isValid: !this.getCurrentItem().invalid,
                errorMessage: null
            }
        },
        getCurrentItem() {
            return this.selectableValues[this.selectedIndex] || {
                id: "",
                text: ""
            }
        },
        generateInvalidItem(e) {
            return {
                id: e,
                text: `(MISSING) ${e}`,
                invalid: !0
            }
        },
        generateOptionId(e) {
            if (!e || !e.id)
                return "";
            let t = e.id.replace(/[^\w]/gi, "");
            return `option-${this.id}-${t}`
        }
    }
}, l9e = ["id", "aria-label", "aria-activedescendant"], c9e = ["id", "title", "aria-selected", "onClick", "onFocus"];
function u9e(e, t, n, r, o, i) {
    return _(),
    O("div", {
        class: he(["list-box", {
                    invalid: !n.isValid
                }
            ])
    }, [P("ul", {
                id: n.id,
                ref: "ul",
                role: "listbox",
                tabindex: "0",
                "aria-label": n.ariaLabel,
                style: Yt(i.ulSizeStyle),
                "aria-activedescendant": i.generateOptionId(i.getCurrentItem()),
                onKeydown: t[0] || (t[0] = (...s) => i.handleKeyDown && i.handleKeyDown(...s))
            }, [(_(!0), O(Le, null, $t(i.selectableValues, (s, a) => (_(), O("li", {
                                        id: i.generateOptionId(s),
                                        key: `listbox-${s.id}`,
                                        ref_for: !0,
                                        ref: "options",
                                        role: "option",
                                        style: Yt({
                                            "line-height": `${o.optionLineHeight}px`
                                        }),
                                        title: s.text,
                                        class: he({
                                            focused: i.isCurrentValue(s.id),
                                            noselect: !0,
                                            invalid: s.invalid,
                                            empty: s.text.trim() === ""
                                        }),
                                        "aria-selected": i.isCurrentValue(s.id),
                                        onClick: l => i.setSelected(s.id, a),
                                        onFocus: l => i.setSelected(s.id, a)
                                    }, Re(s.text), 47, c9e))), 128))], 44, l9e)], 2)
}
const d9e = te(a9e, [["render", u9e], ["__scopeId", "data-v-96f30bfb"]]), f9e = {
    components: {
        ListBox: d9e,
        Dropdown: jw,
        RadioButtons: t9e
    },
    props: {
        isValid: {
        default:
            !0,
            type: Boolean
        },
        id: {
            type: String,
        default:
            null
        },
        type: {
        default:
            "List",
            type: String
        },
        possibleValueList: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e)
            }
        },
        limitNumberVisOptions: {
            type: Boolean,
        default:
            !1
        },
        numberVisOptions: {
            type: Number,
        default:
            0
        },
        description: {
            type: String,
        default:
            ""
        },
        label: {
            type: String,
        default:
            ""
        },
        modelValue: {
            type: String,
        default:
            () => ""
        }
    },
    emits: ["update:modelValue"],
    data() {
        return {
            customValidationErrorMessage: null
        }
    },
    computed: {
        possibleChoices() {
            return [...new Set(this.possibleValueList)].map(e => ({
                    id: e,
                    text: e
                }))
        },
        maxVisibleListEntries() {
            return this.limitNumberVisOptions ? this.numberVisOptions : 0
        },
        isList() {
            return this.type === "List"
        },
        isDropdown() {
            return this.type === "Dropdown"
        },
        isRadioButtons() {
            return this.type === "Radio buttons (vertical)" || this.type === "Radio buttons (horizontal)"
        },
        radioButtonsAlignment() {
            return this.type === "Radio buttons (vertical)" ? "vertical" : this.type === "Radio buttons (horizontal)" ? "horizontal" : null
        }
    },
    methods: {
        onChange(e) {
            this.$emit("update:modelValue", e)
        },
        hasSelection() {
            return this.$refs.form.hasSelection()
        },
        validate() {
            return typeof this.$refs.form.validate == "function" ? this.$refs.form.validate() : {
                isValid: !0
            }
        }
    }
};
function h9e(e, t, n, r, o, i) {
    const s = B("RadioButtons"),
    a = B("ListBox"),
    l = B("Dropdown");
    return _(),
    O("div", null, [i.isRadioButtons ? (_(), H(s, {
                    key: 0,
                    id: n.id,
                    ref: "form",
                    alignment: i.radioButtonsAlignment,
                    "model-value": n.modelValue,
                    "possible-values": i.possibleChoices,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "alignment", "model-value", "possible-values", "is-valid", "title", "onUpdate:modelValue"])) : J("", !0), i.isList ? (_(), H(a, {
                    key: 1,
                    id: n.id,
                    ref: "form",
                    "model-value": n.modelValue,
                    size: i.maxVisibleListEntries,
                    "aria-label": n.label,
                    "possible-values": i.possibleChoices,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "size", "aria-label", "possible-values", "is-valid", "title", "onUpdate:modelValue"])) : J("", !0), i.isDropdown ? (_(), H(l, {
                    key: 2,
                    id: n.id,
                    ref: "form",
                    "model-value": n.modelValue,
                    "aria-label": n.label,
                    "possible-values": i.possibleChoices,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "aria-label", "possible-values", "is-valid", "title", "onUpdate:modelValue"])) : J("", !0)])
}
const zw = te(f9e, [["render", h9e]]), S2 = "column", p9e = {
    components: {
        SingleSelect: zw,
        Fieldset: mc,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [S2]: ""
            }),
            type: Object
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.valuePair[S2]
        },
        isRadioButtons() {
            return this.viewRep.type === "Radio buttons (vertical)" || this.viewRep.type === "Radio buttons (horizontal)"
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: S2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t;
            if (this.viewRep.required && !this.$refs.form.hasSelection() && (e = !1, t = "Selection is required."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = n.errorMessage || t || "Current column is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function m9e(e, t, n, r, o, i) {
    const s = B("SingleSelect"),
    a = B("ErrorMessage");
    return _(),
    H(Kt(i.isRadioButtons ? "Fieldset" : "Label"), {
        text: i.label,
        large: !i.isRadioButtons
    }, {
    default:
        oe(({
                labelForId: l
            }) => [z(s, {
                    id: l,
                    ref: "form",
                    "model-value": i.value,
                    type: i.viewRep.type,
                    "number-vis-options": i.viewRep.numberVisOptions,
                    "limit-number-vis-options": i.viewRep.limitNumberVisOptions,
                    "is-valid": n.isValid,
                    title: i.description,
                    "possible-value-list": i.viewRep.possibleColumns,
                    label: i.label,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "type", "number-vis-options", "limit-number-vis-options", "is-valid", "title", "possible-value-list", "label", "onUpdate:modelValue"]), z(a, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text", "large"])
}
const g9e = te(p9e, [["render", m9e]]), v9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, y9e = P("path", {
    d: "M15.3 19.8s-.2-1.8 1.8-3.4c.9-.7 1.2-1.5 1.2-2.5 0-1.7-1.3-3.1-3-3.1s-3 1.3-3 3m8.9-11.3 5.4 5.4h-5.4zm5.4 27H5.4v-27h15.8l5.4 5.4z"
}, null, -1), w9e = P("path", {
    "stroke-linecap": "round",
    "stroke-width": "1.6",
    d: "M15.3 22.1h0"
}, null, -1), b9e = [y9e, w9e];
function _9e(e, t) {
    return _(),
    O("svg", v9e, b9e)
}
const Hx = {
    render: _9e
}, k9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, x9e = P("path", {
    d: "M29.5 26.8h-27V5.2h9.1l4.6 6h13.3zm0-15.6v-4H13.1"
}, null, -1), S9e = [x9e];
function C9e(e, t) {
    return _(),
    O("svg", k9e, S9e)
}
const Ux = {
    render: C9e
}, I9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, T9e = P("path", {
    d: "m21.156 2.5 5.423 5.423h-5.423zm5.423 27H5.421v-27h15.735l5.423 5.423zM16.447 11.489H8.756m9.249-2.978H8.756m7.691 8.926H8.756m9.249-2.975H8.756"
}, null, -1), M9e = [T9e];
function P9e(e, t) {
    return _(),
    O("svg", I9e, M9e)
}
const ZI = {
    render: P9e
}, E9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, O9e = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M11.936 25.375a1.231 1.231 0 0 1-.843.252 1.055 1.055 0 0 1-.931-.467 2.4 2.4 0 0 1-.317-1.355v-.485a2.268 2.268 0 0 1 .34-1.331 1.111 1.111 0 0 1 .954-.454 1.141 1.141 0 0 1 .811.262 1.355 1.355 0 0 1 .344.853h.948a2.054 2.054 0 0 0-.643-1.391 2.116 2.116 0 0 0-1.459-.49 2.2 2.2 0 0 0-1.187.319 2.073 2.073 0 0 0-.788.91 3.2 3.2 0 0 0-.274 1.365v.512a3.169 3.169 0 0 0 .282 1.325 2.03 2.03 0 0 0 .769.882 2.136 2.136 0 0 0 1.158.318 2.206 2.206 0 0 0 1.5-.491 1.975 1.975 0 0 0 .647-1.367h-.95a1.312 1.312 0 0 1-.361.833zm5.223-1.764a4.2 4.2 0 0 0-1.027-.433 3.189 3.189 0 0 1-.918-.392.6.6 0 0 1-.278-.5.665.665 0 0 1 .257-.557 1.159 1.159 0 0 1 .724-.2 1.114 1.114 0 0 1 .77.242.861.861 0 0 1 .269.672h.944a1.535 1.535 0 0 0-.256-.863 1.668 1.668 0 0 0-.7-.6 2.37 2.37 0 0 0-1.019-.21 2.184 2.184 0 0 0-1.4.429 1.335 1.335 0 0 0-.54 1.091 1.407 1.407 0 0 0 .749 1.227 4.478 4.478 0 0 0 1.053.443 3.069 3.069 0 0 1 .916.4.665.665 0 0 1 .254.558.655.655 0 0 1-.249.533 1.176 1.176 0 0 1-.747.2 1.354 1.354 0 0 1-.884-.256.886.886 0 0 1-.309-.723h-.952a1.519 1.519 0 0 0 .276.9 1.853 1.853 0 0 0 .775.607 2.675 2.675 0 0 0 1.093.22 2.271 2.271 0 0 0 1.424-.4 1.306 1.306 0 0 0 .524-1.089 1.451 1.451 0 0 0-.181-.735 1.618 1.618 0 0 0-.568-.564zm5.951-2.766-1.971 5.477h-.922l-1.963-5.477H19.3l1.376 4.284 1.393-4.284z",
    class: "text"
}, null, -1), $9e = P("path", {
    d: "M5.813 29V3h15.152l5.222 5.222V29zM26.187 8.222h-5.222V3"
}, null, -1), A9e = [O9e, $9e];
function D9e(e, t) {
    return _(),
    O("svg", E9e, A9e)
}
const N9e = {
    render: D9e
}, R9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, L9e = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M9.396 26.321v-5.477h1.618c.484 0 .913.107 1.288.323s.665.521.871.918c.206.396.308.85.308 1.361v.274c0 .52-.103.976-.31 1.369a2.176 2.176 0 0 1-.884.911c-.382.213-.82.319-1.314.319H9.396v.002zm.952-4.71v3.95h.621c.499 0 .882-.156 1.149-.469.267-.312.403-.76.408-1.345v-.305c0-.594-.129-1.048-.388-1.361s-.633-.471-1.125-.471l-.665.001zm8.452 2.115c0 .537-.093 1.008-.278 1.413-.186.404-.451.716-.796.933s-.742.325-1.19.325c-.444 0-.839-.108-1.187-.325a2.129 2.129 0 0 1-.805-.928c-.189-.4-.285-.863-.288-1.388v-.309c0-.534.095-1.006.284-1.414.189-.409.457-.722.801-.938s.741-.325 1.187-.325.841.106 1.186.321.611.522.8.926c.188.402.283.87.286 1.404v.305zm-.952-.287c0-.606-.114-1.071-.344-1.396-.229-.323-.555-.484-.976-.484-.412 0-.733.161-.965.483s-.351.777-.355 1.367v.315c0 .603.117 1.067.352 1.396.234.329.56.493.976.493.421 0 .745-.16.973-.481.227-.321.34-.79.34-1.407v-.286h-.001zm6.079 1.099c-.056.585-.271 1.04-.647 1.367s-.876.491-1.501.491c-.436 0-.82-.104-1.152-.311-.333-.207-.589-.501-.77-.882s-.274-.824-.282-1.328v-.512c0-.517.092-.972.274-1.365.184-.394.446-.697.788-.91a2.202 2.202 0 0 1 1.188-.319c.604 0 1.091.163 1.459.49.369.327.583.791.644 1.391h-.948c-.045-.395-.16-.678-.344-.853-.185-.174-.455-.262-.811-.262-.414 0-.732.151-.954.454s-.335.746-.34 1.331v.485c0 .593.105 1.044.317 1.355s.522.467.931.467c.374 0 .655-.084.843-.252.188-.168.308-.447.357-.839h.948v.002zm2.735-1.715 1.15-1.979h1.099l-1.655 2.716 1.693 2.761h-1.11l-1.177-2.009-1.182 2.009h-1.105l1.696-2.761-1.659-2.716h1.099l1.151 1.979z",
    class: "text"
}, null, -1), B9e = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222v10.55m0-10.55h-5.222V3"
}, null, -1), V9e = [L9e, B9e];
function F9e(e, t) {
    return _(),
    O("svg", R9e, V9e)
}
const j9e = {
    render: F9e
}, W9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, z9e = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222v10.55m0-10.55h-5.222V3"
}, null, -1), H9e = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M12.797 20.844h.948v5.477h-.948v-2.43h-2.449v2.43h-.952v-5.477h.952v2.279h2.449v-2.279zm1.576.767h1.692v4.71h.944v-4.71h1.708v-.767h-4.344v.767zm7.876 3.43-1.58-4.197h-1.233v5.477h.947v-1.806l-.094-2.411 1.614 4.217h.681l1.617-4.221-.094 2.415v1.806h.947v-5.477h-1.229l-1.576 4.197zm4.883.52v-4.717h-.952v5.477h3.438v-.76h-2.486z",
    class: "text"
}, null, -1), U9e = [z9e, H9e];
function q9e(e, t) {
    return _(),
    O("svg", W9e, U9e)
}
const Y9e = {
    render: q9e
}, K9e = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, G9e = P("path", {
    fill: "#000",
    stroke: "none",
    d: "m11.825 20.845 1.58 4.197 1.576-4.197h1.23v5.477h-.948v-1.806l.094-2.415-1.618 4.221h-.681l-1.614-4.217.094 2.411v1.806h-.948v-5.477h1.235zm5.51 5.476v-5.477h1.617c.484 0 .913.107 1.288.323s.665.521.871.918.309.85.309 1.361v.274c0 .52-.104.976-.311 1.369a2.176 2.176 0 0 1-.884.911c-.383.213-.82.319-1.314.319h-1.576v.002zm.951-4.71v3.95h.621c.499 0 .882-.156 1.149-.469.267-.312.402-.76.408-1.345v-.305c0-.594-.13-1.048-.388-1.361-.259-.313-.634-.471-1.125-.471l-.665.001z",
    class: "text"
}, null, -1), X9e = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), J9e = [G9e, X9e];
function Z9e(e, t) {
    return _(),
    O("svg", K9e, J9e)
}
const Q9e = {
    render: Z9e
}, eFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, tFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M13.235 23.726c0 .537-.093 1.008-.278 1.413a2.113 2.113 0 0 1-.796.933 2.188 2.188 0 0 1-1.19.325c-.444 0-.839-.108-1.187-.325a2.129 2.129 0 0 1-.805-.928c-.189-.4-.285-.863-.288-1.388v-.309c0-.534.095-1.006.284-1.414.189-.409.457-.722.801-.938s.741-.325 1.187-.325.842.106 1.187.321.611.522.799.926c.188.402.284.87.286 1.404v.305zm-.952-.287c0-.606-.115-1.071-.344-1.396-.229-.323-.555-.484-.976-.484-.412 0-.733.161-.965.483s-.35.778-.355 1.368v.315c0 .603.117 1.067.352 1.396.234.329.56.493.976.493.421 0 .746-.16.973-.481.227-.321.34-.79.34-1.407l-.001-.287zm1.9 2.882v-5.477h1.618c.484 0 .913.107 1.288.323s.665.521.871.918.309.85.309 1.361v.274c0 .52-.104.976-.311 1.369a2.176 2.176 0 0 1-.884.911c-.382.213-.82.319-1.314.319h-1.577v.002zm.952-4.71v3.95h.621c.499 0 .882-.156 1.149-.469.267-.312.402-.76.408-1.345v-.305c0-.594-.13-1.048-.388-1.361-.258-.313-.633-.471-1.125-.471l-.665.001zm5.032 2.679v2.031h-.951v-5.477h2.095c.612 0 1.098.159 1.458.478.359.319.54.741.54 1.266 0 .537-.177.955-.529 1.254s-.846.448-1.479.448h-1.134zm0-.768h1.144c.339 0 .597-.079.775-.238s.267-.39.267-.69c0-.296-.09-.532-.271-.709s-.429-.268-.745-.273h-1.17v1.91z",
    class: "text"
}, null, -1), nFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), rFe = [tFe, nFe];
function oFe(e, t) {
    return _(),
    O("svg", eFe, rFe)
}
const iFe = {
    render: oFe
}, sFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, aFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M13.375 23.726c0 .537-.093 1.008-.278 1.413a2.113 2.113 0 0 1-.796.933 2.188 2.188 0 0 1-1.19.325c-.444 0-.839-.108-1.187-.325a2.129 2.129 0 0 1-.805-.928c-.189-.4-.285-.863-.288-1.388v-.309c0-.534.095-1.006.284-1.414.189-.409.457-.722.801-.938s.741-.325 1.187-.325.842.106 1.187.321.611.522.799.926c.188.402.284.87.286 1.404v.305zm-.952-.287c0-.606-.115-1.071-.344-1.396-.229-.323-.555-.484-.976-.484-.412 0-.733.161-.965.483s-.351.778-.356 1.368v.315c0 .603.117 1.067.352 1.396.234.329.56.493.976.493.421 0 .746-.16.973-.481.227-.321.34-.79.34-1.407v-.287zm1.899 2.882v-5.477h1.618c.484 0 .913.107 1.288.323s.665.521.871.918c.205.396.308.85.308 1.361v.274c0 .52-.103.976-.31 1.369a2.178 2.178 0 0 1-.885.911c-.382.213-.82.319-1.314.319h-1.576v.002zm.952-4.71v3.95h.621c.499 0 .882-.156 1.149-.469.268-.312.403-.76.408-1.345v-.305c0-.594-.129-1.048-.388-1.361-.258-.313-.633-.471-1.124-.471l-.666.001zm6.944 3.3c0-.241-.085-.427-.254-.558-.17-.13-.475-.262-.916-.395s-.793-.281-1.054-.443c-.499-.313-.748-.723-.748-1.227 0-.441.18-.805.539-1.091.36-.286.827-.429 1.401-.429.381 0 .721.07 1.02.21.299.141.533.341.703.601.171.26.256.547.256.863h-.947c0-.286-.09-.51-.27-.672-.179-.161-.436-.242-.77-.242-.311 0-.552.066-.724.199s-.258.318-.258.557c0 .2.093.368.278.502.186.135.491.265.918.392.427.126.769.271 1.027.433.258.161.447.347.567.557.12.209.181.454.181.735 0 .456-.175.819-.524 1.089s-.824.404-1.424.404c-.396 0-.761-.073-1.093-.22s-.591-.35-.775-.607a1.52 1.52 0 0 1-.276-.903h.952c0 .312.103.552.309.723.205.17.5.256.884.256.331 0 .58-.067.746-.201a.65.65 0 0 0 .252-.533z",
    class: "text"
}, null, -1), lFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), cFe = [aFe, lFe];
function uFe(e, t) {
    return _(),
    O("svg", sFe, cFe)
}
const dFe = {
    render: uFe
}, fFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, hFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M13.463 23.726c0 .537-.093 1.008-.278 1.413a2.113 2.113 0 0 1-.796.933 2.188 2.188 0 0 1-1.19.325c-.444 0-.839-.108-1.187-.325a2.129 2.129 0 0 1-.805-.928c-.189-.4-.285-.863-.288-1.388v-.309c0-.534.095-1.006.284-1.414.189-.409.457-.722.801-.938s.741-.325 1.187-.325.842.106 1.187.321.611.522.799.926c.188.402.284.87.286 1.404v.305zm-.952-.287c0-.606-.115-1.071-.344-1.396-.229-.323-.555-.484-.976-.484-.412 0-.733.161-.965.483s-.35.778-.355 1.368v.315c0 .603.117 1.067.352 1.396.234.329.56.493.976.493.421 0 .746-.16.973-.481.227-.321.34-.79.34-1.407v-.287h-.001zm1.9 2.882v-5.477h1.618c.484 0 .913.107 1.288.323s.665.521.871.918.309.85.309 1.361v.274c0 .52-.104.976-.311 1.369a2.176 2.176 0 0 1-.884.911c-.382.213-.82.319-1.314.319h-1.577v.002zm.952-4.71v3.95h.621c.499 0 .882-.156 1.149-.469.267-.312.402-.76.408-1.345v-.305c0-.594-.13-1.048-.388-1.361-.258-.313-.633-.471-1.125-.471l-.665.001zm7.718 0h-1.707v4.71h-.944v-4.71h-1.692v-.767h4.344l-.001.767z",
    class: "text"
}, null, -1), pFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), mFe = [hFe, pFe];
function gFe(e, t) {
    return _(),
    O("svg", fFe, mFe)
}
const vFe = {
    render: gFe
}, yFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, wFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M10.233 24.29v2.031h-.951v-5.477h2.095c.612 0 1.098.159 1.458.478s.54.741.54 1.266c0 .537-.176.955-.529 1.254-.352.299-.846.448-1.48.448h-1.133zm0-.768h1.144c.338 0 .597-.079.775-.238s.267-.39.267-.69c0-.296-.09-.532-.271-.709-.18-.177-.429-.268-.745-.273h-1.17v1.91zm3.972 2.799v-5.477h1.618c.484 0 .913.107 1.288.323s.665.521.871.918.309.85.309 1.361v.274c0 .52-.104.976-.311 1.369a2.176 2.176 0 0 1-.884.911c-.382.213-.82.319-1.314.319h-1.577v.002zm.952-4.71v3.95h.621c.499 0 .882-.156 1.149-.469.267-.312.402-.76.408-1.345v-.305c0-.594-.13-1.048-.388-1.361-.258-.313-.633-.471-1.125-.471l-.665.001zM22.395 24H20.19v2.321h-.951v-5.477h3.479v.767H20.19v1.629h2.205V24z",
    class: "text"
}, null, -1), bFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), _Fe = [wFe, bFe];
function kFe(e, t) {
    return _(),
    O("svg", yFe, _Fe)
}
const xFe = {
    render: kFe
}, SFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, CFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M10.348 24.29v2.031h-.952v-5.477h2.095c.612 0 1.098.159 1.458.478s.54.741.54 1.266c0 .537-.176.955-.529 1.254-.352.299-.846.448-1.48.448h-1.132zm0-.768h1.144c.338 0 .597-.079.775-.238s.267-.39.267-.69c0-.296-.09-.532-.271-.709-.18-.177-.429-.268-.745-.273h-1.17v1.91zm4.923.768v2.031h-.952v-5.477h2.095c.612 0 1.097.159 1.458.478.359.319.54.741.54 1.266 0 .537-.177.955-.529 1.254s-.846.448-1.479.448h-1.133zm0-.768h1.144c.338 0 .596-.079.775-.238.178-.159.267-.39.267-.69 0-.296-.09-.532-.271-.709s-.429-.268-.745-.273h-1.17V23.522zm7.93-1.911h-1.708v4.71h-.945v-4.71h-1.692v-.767h4.345v.767zm2.603 1.212 1.15-1.979h1.099l-1.655 2.717 1.693 2.761h-1.11l-1.177-2.009-1.182 2.009h-1.105l1.696-2.761-1.659-2.716h1.099l1.151 1.978z",
    class: "text"
}, null, -1), IFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222v10.55m0-10.55h-5.222V3"
}, null, -1), TFe = [CFe, IFe];
function MFe(e, t) {
    return _(),
    O("svg", SFe, TFe)
}
const PFe = {
    render: MFe
}, EFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, OFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M12.583 24.29v2.031h-.952v-5.477h2.095c.612 0 1.098.159 1.458.478s.54.741.54 1.266c0 .537-.176.955-.529 1.254-.352.299-.846.448-1.48.448h-1.132zm0-.768h1.144c.338 0 .597-.079.775-.238s.267-.39.267-.69c0-.296-.09-.532-.271-.709-.18-.177-.429-.268-.745-.273h-1.17v1.91zm6.835 1.389c0-.241-.085-.427-.254-.558-.17-.13-.475-.262-.916-.395s-.792-.281-1.053-.443c-.499-.313-.749-.723-.749-1.227 0-.441.18-.805.54-1.091s.827-.429 1.401-.429c.381 0 .721.07 1.02.21.299.141.533.341.703.601.171.26.256.547.256.863h-.947c0-.286-.09-.51-.27-.672-.179-.161-.436-.242-.77-.242-.311 0-.552.066-.724.199a.665.665 0 0 0-.257.557c0 .2.093.368.278.502.186.135.491.265.917.392.427.126.769.271 1.027.433.258.161.447.347.567.557.12.209.181.454.181.735 0 .456-.175.819-.524 1.089s-.824.404-1.424.404c-.396 0-.76-.073-1.093-.22a1.853 1.853 0 0 1-.775-.607 1.52 1.52 0 0 1-.276-.903h.952c0 .312.103.552.309.723.206.17.5.256.884.256.331 0 .58-.067.746-.201a.651.651 0 0 0 .251-.533z",
    class: "text"
}, null, -1), $Fe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), AFe = [OFe, $Fe];
function DFe(e, t) {
    return _(),
    O("svg", EFe, AFe)
}
const NFe = {
    render: DFe
}, RFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, LFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "m11.658 22.823 1.151-1.979h1.099l-1.655 2.716 1.693 2.761h-1.11l-1.177-2.009-1.181 2.009H9.371l1.696-2.761-1.659-2.716h1.098l1.152 1.979zm3.942 2.739h2.486v.76h-3.438v-5.477h.952v4.717zm6.079-.651c0-.241-.085-.427-.254-.558-.169-.13-.475-.262-.916-.395s-.792-.281-1.053-.443c-.499-.313-.749-.723-.749-1.227 0-.441.18-.805.54-1.091.359-.286.827-.429 1.401-.429.381 0 .721.07 1.02.21.298.142.532.342.703.602.17.26.256.547.256.863h-.948c0-.286-.09-.51-.269-.672-.18-.161-.437-.242-.77-.242-.311 0-.553.066-.725.199a.665.665 0 0 0-.257.557c0 .2.093.368.278.502.186.135.491.265.918.392.426.126.769.271 1.026.433.259.161.447.347.568.557.12.209.181.454.181.735 0 .456-.176.819-.525 1.089s-.824.404-1.424.404c-.396 0-.76-.073-1.093-.22a1.844 1.844 0 0 1-.774-.607 1.512 1.512 0 0 1-.276-.903h.951c0 .312.104.552.309.723.206.17.5.256.884.256.331 0 .58-.067.747-.201a.652.652 0 0 0 .251-.534z",
    class: "text"
}, null, -1), BFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), VFe = [LFe, BFe];
function FFe(e, t) {
    return _(),
    O("svg", RFe, VFe)
}
const jFe = {
    render: FFe
}, WFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, zFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "m11.683 22.823 1.151-1.979h1.099l-1.655 2.716 1.693 2.761h-1.11l-1.177-2.009-1.181 2.009H9.396l1.696-2.761-1.659-2.716h1.098l1.152 1.979zm3.942 2.739h2.486v.76h-3.438v-5.477h.952v4.717zm6.078-.651c0-.241-.085-.427-.254-.558-.169-.13-.475-.262-.916-.395s-.792-.281-1.053-.443c-.499-.313-.749-.723-.749-1.227 0-.441.18-.805.54-1.091.359-.286.827-.429 1.401-.429.381 0 .721.07 1.02.21.298.141.532.341.703.601.17.26.256.547.256.863h-.948c0-.286-.09-.51-.269-.672-.18-.161-.437-.242-.77-.242-.311 0-.553.066-.725.199a.665.665 0 0 0-.257.557c0 .2.093.368.278.502.186.135.491.265.918.392.426.126.769.271 1.026.433.259.161.447.347.568.557.12.209.181.454.181.735 0 .456-.176.819-.525 1.089s-.824.404-1.424.404c-.396 0-.76-.073-1.093-.22a1.844 1.844 0 0 1-.774-.607 1.512 1.512 0 0 1-.276-.903h.951c0 .312.104.552.309.723.206.17.5.256.884.256.331 0 .58-.067.747-.201a.649.649 0 0 0 .251-.533zm3.671-2.088 1.151-1.979h1.099l-1.655 2.716 1.692 2.761h-1.109l-1.178-2.009-1.181 2.009h-1.106l1.696-2.761-1.658-2.716h1.098l1.151 1.979z",
    class: "text"
}, null, -1), HFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222v10.55m0-10.55h-5.222V3"
}, null, -1), UFe = [zFe, HFe];
function qFe(e, t) {
    return _(),
    O("svg", WFe, UFe)
}
const YFe = {
    render: qFe
}, KFe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, GFe = P("path", {
    fill: "#000",
    stroke: "none",
    d: "m10.558 22.823 1.151-1.979h1.099l-1.655 2.716 1.693 2.761h-1.11l-1.177-2.009-1.181 2.009H8.271l1.696-2.761-1.659-2.716h1.098l1.152 1.979zm4.224-1.978 1.58 4.197 1.575-4.197h1.23v5.477h-.948v-1.806l.095-2.415-1.618 4.221h-.681l-1.614-4.217.094 2.411v1.806h-.948v-5.477h1.235zm6.461 4.717h2.486v.76h-3.437v-5.477h.951v4.717z",
    class: "text"
}, null, -1), XFe = P("path", {
    d: "M26.187 29H5.813V3h15.152l5.222 5.222V29zm0-20.778h-5.222V3"
}, null, -1), JFe = [GFe, XFe];
function ZFe(e, t) {
    return _(),
    O("svg", KFe, JFe)
}
const QFe = {
    render: ZFe
}, eje = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    viewBox: "0 0 32 32"
}, tje = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M11.507 25.929h3.039v.789h-4.234v-.641l2.941-4.25h-2.922v-.797h4.121v.625l-2.945 4.274zm4.93.789h-.984V21.03h.984v5.688zm2.203-2.11v2.109h-.988V21.03h2.176c.636 0 1.141.166 1.514.497.374.331.561.769.561 1.313 0 .559-.183.992-.549 1.303-.365.31-.878.465-1.537.465H.64zm0-.796h1.188c.352 0 .62-.082.805-.248.186-.165.277-.404.277-.717 0-.307-.094-.553-.281-.736s-.445-.277-.773-.283H18.64v1.984z",
    class: "text"
}, null, -1), nje = P("path", {
    d: "m21.156 2.5 5.423 5.423h-5.423zm5.423 27H5.421v-27h15.735l5.423 5.423zM13 2.775v11.363m0-3.558h1.936M13 7.488h1.936M13 4.396h1.936m-3.872 7.73H13m-1.936-3.092H13m-1.936-3.092H13m-1.936 8.196v2.357c0 .557.867 1.009 1.936 1.009s1.936-.452 1.936-1.009v-2.357h-3.872z"
}, null, -1), rje = [tje, nje];
function oje(e, t) {
    return _(),
    O("svg", eje, rje)
}
const ije = {
    render: oje
}, sje = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    viewBox: "0 0 32 32"
}, aje = P("path", {
    fill: "#000",
    stroke: "none",
    d: "M12.94 24.179h-2.336v1.75h2.73v.789H9.616V21.03h3.691v.797h-2.703v1.57h2.336v.782zm3.157-1.094 1.195-2.055h1.141l-1.719 2.82 1.758 2.867H17.32l-1.223-2.086-1.227 2.086h-1.148l1.762-2.867-1.723-2.82h1.141l1.195 2.055zm6.429 1.094H20.19v1.75h2.73v.789h-3.719V21.03h3.691v.797H20.19v1.57h2.336v.782z",
    class: "text"
}, null, -1), lje = P("path", {
    d: "m21.156 2.5 5.423 5.423h-5.423zm5.423 27H5.421v-27h15.735l5.423 5.423zM13 2.775v11.363m0-3.558h1.936M13 7.488h1.936M13 4.396h1.936m-3.872 7.73H13m-1.936-3.092H13m-1.936-3.092H13m-1.936 8.196v2.357c0 .557.867 1.009 1.936 1.009s1.936-.452 1.936-1.009v-2.357h-3.872z"
}, null, -1), cje = [aje, lje];
function uje(e, t) {
    return _(),
    O("svg", sje, cje)
}
const dje = {
    render: uje
}, QI = {
    csvIcon: N9e,
    docxIcon: j9e,
    htmlIcon: Y9e,
    mdIcon: Q9e,
    odpIcon: iFe,
    odsIcon: dFe,
    odtIcon: vFe,
    pdfIcon: xFe,
    pptxIcon: PFe,
    psIcon: NFe,
    xlsIcon: jFe,
    xlsxIcon: YFe,
    xmlIcon: QFe,
    zipIcon: ije,
    exeIcon: dje,
    txtIcon: ZI,
    fileIcon: Hx
}, fje = function (e) {
    return QI.hasOwnProperty(e)
};
const hje = 300, pje = {
    name: "TreeSelectItem",
    components: {
        itemIcon: Hx,
        folderIcon: Ux,
        fileIcon: ZI,
        arrowNextIcon: Ww,
        ...QI
    },
    props: {
        data: {
            type: Object,
            required: !0
        },
        allowTransition: {
            type: Boolean,
        default:
            !0
        },
        height: {
            type: Number,
        default:
            22
        },
        parentItem: {
            type: Array,
            required: !0
        },
        onItemClick: {
            type: Function,
        default:
            () => !1
        },
        onHoverItem: {
            type: Function,
        default:
            () => !1
        },
        onItemToggle: {
            type: Function,
        default:
            () => !1
        }
    },
    data() {
        return {
            isHover: !1,
            isKeyNav: !1,
            model: this.data,
            maxHeight: 0
        }
    },
    computed: {
        isFolder() {
            return this.model.children?.length
        },
        classes() {
            return ["tree-node", {
                    "tree-open": this.model.opened
                }, {
                    "tree-closed": !this.model.opened
                }, {
                    "tree-leaf": !this.isFolder
                }
            ]
        },
        anchorClasses() {
            return ["tree-anchor", {
                    "tree-disabled": this.model.disabled
                }, {
                    "tree-selected": this.model.selected
                }, {
                    "tree-hovered": this.isHover || this.isKeyNav
                }
            ]
        },
        wholeRowClasses() {
            return [{
                    "tree-wholerow": this.isWholeRow
                }, {
                    "tree-wholerow-selected": this.model.selected
                }, {
                    "tree-wholerow-hovered": this.isHover || this.isKeyNav
                }
            ]
        },
        treeOclClasses() {
            return ["tree-icon", "tree-ocl", {
                    "tree-ocl-selected": this.model.selected
                }, {
                    "tree-ocl-hovered": this.isHover || this.isKeyNav
                }
            ]
        },
        cssVars() {
            return {
                "--height": `${this.height}px`
            }
        },
        isWholeRow() {
            return typeof this.$parent.model > "u" ? !0 : this.$parent.model.opened === !0
        },
        groupStyle() {
            return {
                position: this.model.opened ? "" : "relative",
                "max-height": this.allowTransition ? `${this.maxHeight}px` : "",
                "transition-duration": this.allowTransition ? `${Math.ceil(this.model.children.length / 100) * hje}ms` : "",
                "transition-property": this.allowTransition ? "max-height" : "",
                display: this.allowTransition || this.model.opened ? "block" : "none"
            }
        },
        icon() {
            return this.model.icon ? this.model.selected && this.model.selectedIcon ? this.model.selectedIcon : this.model.icon : this.isFolder ? Ux : Hx
        }
    },
    watch: {
        data(e) {
            this.model = e
        },
        "model.opened": {
            handler() {
                this.onItemToggle(this, this.model),
                this.handleGroupMaxHeight()
            },
            deep: !0
        }
    },
    mounted() {
        this.handleGroupMaxHeight()
    },
    methods: {
        handleItemToggle() {
            this.isFolder && (this.model.opened = !this.model.opened, this.onItemToggle(this, this.model))
        },
        handleGroupMaxHeight() {
            if (this.allowTransition) {
                let e = 0,
                t = 0;
                if (this.model.opened) {
                    e = this.$refs.children.length;
                    for (let n of this.$refs.children)
                        t += n.maxHeight
                }
                this.maxHeight = e * this.height + t,
                this.$parent.$options.name === "TreeSelectItem" && this.$parent.handleGroupMaxHeight()
            }
        },
        handleItemClick(e) {
            this.model.disabled || this.onItemClick(this, this.model, e)
        },
        handleMouseOver(e) {
            this.isHover = !0,
            this.onHoverItem(this, this.model, e)
        },
        handleMouseOut() {
            this.isHover = !1
        }
    }
}, mje = ["aria-expanded"], gje = {
    class: "tree-icon",
    role: "presentation"
}, vje = ["title"];
function yje(e, t, n, r, o, i) {
    const s = B("arrowNextIcon"),
    a = B("TreeSelectItem", !0);
    return _(),
    O("li", {
        class: he(i.classes),
        style: Yt(i.cssVars),
        role: "treeitem",
        "aria-expanded": i.isFolder ? String(Boolean(o.model.opened)) : null
    }, [i.isWholeRow ? (_(), O("div", {
                    key: 0,
                    role: "presentation",
                    class: he(i.wholeRowClasses)
                }, "   ", 2)) : J("", !0), P("i", {
                class: he(i.treeOclClasses),
                role: "presentation",
                onClick: t[0] || (t[0] = (...l) => i.handleItemToggle && i.handleItemToggle(...l))
            }, [i.isFolder ? (_(), H(s, {
                            key: 0
                        })) : J("", !0)], 2), P("div", {
                class: he(i.anchorClasses),
                onClick: t[1] || (t[1] = (...l) => i.handleItemClick && i.handleItemClick(...l)),
                onDblclick: t[2] || (t[2] = (...l) => i.handleItemToggle && i.handleItemToggle(...l)),
                onMouseover: t[3] || (t[3] = (...l) => i.handleMouseOver && i.handleMouseOver(...l)),
                onMouseout: t[4] || (t[4] = (...l) => i.handleMouseOut && i.handleMouseOut(...l))
            }, [P("i", gje, [(_(), H(Kt(i.icon)))]), P("span", {
                        title: o.model.text
                    }, Re(o.model.text), 9, vje)], 34), i.isFolder ? (_(), O("ul", {
                    key: 1,
                    ref: "group",
                    role: "group",
                    class: "tree-children",
                    style: Yt(i.groupStyle)
                }, [(_(!0), O(Le, null, $t(o.model.children, (l, c) => (_(), H(a, {
                                            key: c,
                                            ref_for: !0,
                                            ref: "children",
                                            data: l,
                                            "allow-transition": n.allowTransition,
                                            height: n.height,
                                            "parent-item": o.model.children,
                                            "on-item-click": n.onItemClick,
                                            "on-item-toggle": n.onItemToggle,
                                            "on-hover-item": n.onHoverItem
                                        }, null, 8, ["data", "allow-transition", "height", "parent-item", "on-item-click", "on-item-toggle", "on-hover-item"]))), 128))], 4)) : J("", !0)], 14, mje)
}
const wje = te(pje, [["render", yje], ["__scopeId", "data-v-f5dc9f58"]]);
let bje = 0;
const _je = {
    components: {
        TreeSelectItem: wje
    },
    props: {
        data: {
            type: Array,
            required: !0
        },
        multiple: {
            type: Boolean,
        default:
            !1
        },
        allowTransition: {
            type: Boolean,
        default:
            !0
        },
        itemHeight: {
            type: Number,
        default:
            22
        },
        ariaLabel: {
            type: String,
            required: !0
        },
        isValid: {
            type: Boolean,
        default:
            !0
        }
    },
    emits: ["item-click", "item-toggle"],
    data() {
        return {
            lastClickedNode: null,
            currentKeyboardNavNode: null
        }
    },
    created() {
        this.initializeData(this.data)
    },
    methods: {
        createModelObject(e) {
            let t = {
                id: e.id || bje++,
                text: e.text || "",
                value: e.value || e.text,
                icon: e.icon || "",
                selectedIcon: e.selectedIcon || "",
                opened: Boolean(e.opened),
                selected: Boolean(e.selected),
                disabled: Boolean(e.disabled),
                children: e.children || []
            };
            return e.userData && (t.userData = e.userData),
            t
        },
        initializeData(e) {
            if (e?.length > 0)
                for (let t = 0; t < e.length; t++)
                    e[t] = this.createModelObject(e[t]), this.initializeData(e[t].children)
        },
        handleRecursionNodeChildren(e, t) {
            if (t(e) !== !1 && e.$refs.children?.length > 0)
                for (let n of e.$refs.children)
                    n.disabled || this.handleRecursionNodeChildren(n, t)
        },
        runInSection(e, t, n, r) {
            let o = t > n ? n : t,
            i = t > n ? t : n;
            e.slice(o, i + 1).forEach(r)
        },
        onItemClick(e, t, n) {
            if (this.multiple) {
                if (n.shiftKey)
                    if (e.$parent === this.lastClickedNode?.$parent) {
                        let r = e.$parent.$refs.children,
                        o = r.findIndex(s => s === this.lastClickedNode),
                        i = r.findIndex(s => s === e);
                        this.runInSection(r, o, i, s => {
                            s.model.selected = !0
                        })
                    } else
                        this.handleSingleSelectItems(e);
                else
                    n.ctrlKey || n.metaKey ? e.model.selected = !e.model.selected : this.handleSingleSelectItems(e);
                this.lastClickedNode = e
            } else
                this.handleSingleSelectItems(e);
            this.currentKeyboardNavNode = e,
            this.$emit("item-click", e, t, n)
        },
        handleSingleSelectItems(e) {
            this.handleRecursionNodeChildren(this, t => {
                t.model && (t.model.selected = !1)
            }),
            e.model.selected = !0
        },
        onItemToggle(e, t, n) {
            this.$emit("item-toggle", e, t, n)
        },
        onHoverItem() {
            this.currentKeyboardNavNode !== null && (this.currentKeyboardNavNode.$data.isKeyNav = !1)
        },
        nextNode(e, t) {
            let n = this.filterForTreeSelectItems(e.$parent.$refs.children),
            o = n.findIndex(i => i === e) + t;
            return o in n ? n[o] : null
        },
        resetIsHover() {
            this.handleRecursionNodeChildren(this, e => {
                e.isHover && (e.isHover = !1)
            })
        },
        filterForTreeSelectItems(e) {
            return e?.filter(t => t.$options.name === "TreeSelectItem") || []
        },
        moveKeyBoardFocus(e) {
            let t = e < 0,
            n = !t;
            if (this.currentKeyboardNavNode === null) {
                const i = this.filterForTreeSelectItems(this.$refs.children);
                if (i.length === 0)
                    return;
                this.currentKeyboardNavNode = i[0]
            }
            let r = null;
            this.currentKeyboardNavNode.model.children.length > 0 && this.currentKeyboardNavNode.model.opened && n ? r = this.filterForTreeSelectItems(this.currentKeyboardNavNode.$refs.children)[0] : r = this.nextNode(this.currentKeyboardNavNode, e);
            let o = r === null;
            if (o) {
                if (!this.currentKeyboardNavNode.$parent.model)
                    return;
                if (t)
                    r = this.currentKeyboardNavNode.$parent;
                else if (r = this.nextNode(this.currentKeyboardNavNode.$parent, e), r === null)
                    return
            }
            if (r.model.opened && t && !o) {
                const i = this.filterForTreeSelectItems(r.$refs.children);
                r = i[i.length - 1]
            }
            this.resetIsHover(),
            this.currentKeyboardNavNode.$data.isKeyNav = !1,
            r.$data.isKeyNav = !0,
            this.currentKeyboardNavNode = r
        },
        onArrowUp() {
            this.moveKeyBoardFocus(-1),
            this.scrollToCurrent()
        },
        onArrowDown() {
            this.moveKeyBoardFocus(1),
            this.scrollToCurrent()
        },
        onArrowLeft(e) {
            this.currentKeyboardNavNode && this.currentKeyboardNavNode.model.opened && this.currentKeyboardNavNode.handleItemToggle(e)
        },
        onArrowRight(e) {
            this.currentKeyboardNavNode && (this.currentKeyboardNavNode.model.opened || this.currentKeyboardNavNode.handleItemToggle(e))
        },
        onEnterKey(e) {
            this.currentKeyboardNavNode && (this.currentKeyboardNavNode.model.disabled || this.currentKeyboardNavNode.$data.isKeyNav === !1 || (this.multiple && (e.ctrlKey || e.metaKey) ? this.currentKeyboardNavNode.model.selected = !this.currentKeyboardNavNode.model.selected : this.handleSingleSelectItems(this.currentKeyboardNavNode), this.$emit("item-click", this.currentKeyboardNavNode, this.currentKeyboardNavNode.model, e)))
        },
        scrollToCurrent() {
            this.currentKeyboardNavNode && this.scrollToElement(this.$refs.treeDiv, this.currentKeyboardNavNode.$el.querySelector(".tree-wholerow"))
        },
        scrollToElement(e, t) {
            if (e.scrollHeight > e.clientHeight) {
                let n = e.clientHeight + e.scrollTop,
                r = t.offsetTop + t.offsetHeight;
                r > n ? e.scrollTop = r - e.clientHeight : t.offsetTop < e.scrollTop && (e.scrollTop = t.offsetTop)
            }
        }
    }
}, kje = {
    ref: "treeDiv",
    class: "tree",
    role: "tree"
}, xje = ["aria-label"], Sje = {
    key: 0,
    class: "invalid-marker"
};
function Cje(e, t, n, r, o, i) {
    const s = B("TreeSelectItem");
    return _(),
    O("div", {
        class: he(["tree-wrapper", {
                    invalid: !n.isValid
                }
            ])
    }, [P("div", kje, [P("ul", {
                        "aria-label": n.ariaLabel,
                        class: "tree-container-ul tree-children tree-wholerow-ul",
                        role: "group",
                        tabindex: "0",
                        onKeydown: [t[0] || (t[0] = Rt(ve((...a) => i.onArrowUp && i.onArrowUp(...a), ["prevent", "exact"]), ["up"])), t[1] || (t[1] = Rt(ve((...a) => i.onArrowDown && i.onArrowDown(...a), ["prevent", "exact"]), ["down"])), t[2] || (t[2] = Rt(ve((...a) => i.onEnterKey && i.onEnterKey(...a), ["prevent"]), ["enter"])), t[3] || (t[3] = Rt(ve((...a) => i.onArrowLeft && i.onArrowLeft(...a), ["prevent", "exact"]), ["left"])), t[4] || (t[4] = Rt(ve((...a) => i.onArrowRight && i.onArrowRight(...a), ["prevent", "exact"]), ["right"]))]
                    }, [(_(!0), O(Le, null, $t(n.data, (a, l) => (_(), H(s, {
                                                key: l,
                                                ref_for: !0,
                                                ref: "children",
                                                data: a,
                                                "allow-transition": n.allowTransition,
                                                height: n.itemHeight,
                                                "parent-item": n.data,
                                                "on-item-click": i.onItemClick,
                                                "on-item-toggle": i.onItemToggle,
                                                "on-hover-item": i.onHoverItem
                                            }, null, 8, ["data", "allow-transition", "height", "parent-item", "on-item-click", "on-item-toggle", "on-hover-item"]))), 128))], 40, xje), n.isValid ? J("", !0) : (_(), O("span", Sje))], 512)], 2)
}
const Ije = te(_je, [["render", Cje], ["__scopeId", "data-v-e4685feb"]]), Tje = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Mje = P("circle", {
    cx: "16",
    cy: "16",
    r: "4.5"
}, null, -1), Pje = P("path", {
    d: "m24.6 10.6 1.5-2.1-2.7-2.7-2.1 1.6-3.1-1.3-.3-2.6h-3.8l-.4 2.6-3.1 1.3-2.1-1.6-2.7 2.7 1.6 2.1-1.3 3.1-2.6.4v3.8l2.6.3 1.3 3.2-1.6 2.1 2.7 2.7 2.1-1.6 3.1 1.3.4 2.6h3.8l.4-2.6 3.1-1.3 2.1 1.5 2.7-2.7-1.6-2 1.3-3.1 2.6-.4V14l-2.6-.3z"
}, null, -1), Eje = [Mje, Pje];
function Oje(e, t) {
    return _(),
    O("svg", Tje, Eje)
}
const $je = {
    render: Oje
}, Aje = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Dje = P("path", {
    d: "M28.2 2.3h-5.6c-.7 0-1.2.5-1.2 1.2v5.6c0 .7.5 1.2 1.2 1.2h5.6c.7 0 1.2-.5 1.2-1.2V3.5c0-.6-.5-1.2-1.2-1.2zM9.4 11.9H3.8c-.7 0-1.2.5-1.2 1.2v5.6c0 .7.5 1.2 1.2 1.2h5.6c.7 0 1.2-.5 1.2-1.2v-5.6c0-.6-.6-1.2-1.2-1.2zm-6.5.4 7.3 7.3M21.7 2.7 29 10m-.8 11.5h-5.6c-.7 0-1.2.5-1.2 1.2v5.6c0 .7.5 1.2 1.2 1.2h5.6c.7 0 1.2-.5 1.2-1.2v-5.6c0-.7-.6-1.2-1.2-1.2zm-6.5.4 7.3 7.3M10.6 16h5.2V7.3c0-.6.4-1 1-1h4.7m-.1 19.2h-4.6c-.5 0-1-.4-1-1V16h-5.2"
}, null, -1), Nje = [Dje];
function Rje(e, t) {
    return _(),
    O("svg", Aje, Nje)
}
const Lje = {
    render: Rje
};
let N9, qx, R9;
const C2 = {
    WORKFLOW: "Workflow",
    WORKFLOW_GROUP: "WorkflowGroup",
    DATA: "Data"
}, Vv = {
    WORKFLOW: "WORKFLOW",
    DIR: "DIRECTORY",
    DATA: "DATA",
    UNKNOWN: "UNKNOWN"
}, Bje = (e, t, n) => qx(e, t, n);
qx = (e, t, n) => {
    let r = {
        id: e.path,
        text: XBe(e.path),
        state: {
            opened: !1,
            disabled: !1,
            selected: !1
        },
        children: []
    };
    if (e.type === C2.WORKFLOW) {
        if (!n.selectWorkflows)
            return null;
        r.type = Vv.WORKFLOW
    } else if (e.type === C2.WORKFLOW_GROUP)
        r.type = Vv.DIR, n.selectDirectories || (r.state.disabled = !0);
    else if (e.type === C2.DATA) {
        if (!n.selectDataFiles)
            return null;
        let o = JI(r.id);
        if (n.fileTypes && n.fileTypes.length > 0 && !n.fileTypes.includes(`.${o.toLowerCase()}`))
            return null;
        r.type = Vv.DATA,
        r.icon = N9(o)
    }
    return R9(t, r),
    r.type === Vv.DIR && (e.children && e.children.forEach(o => {
            let i = qx(o, t, n);
            i && r.children.push(i)
        }), !r.children?.length && !n.selectDirectories) ? null : r
};
R9 = (e, t) => {
    e?.length && e.forEach(n => {
        n?.startsWith(t.id) && (t.state.opened = !0, n === t.id && !t.state.disabled && (t.state.opened = !1, t.state.selected = !0))
    })
};
N9 = e => {
    let t = `${e}Icon`;
    return fje(t) ? t : "fileIcon"
};
const GD = "items", L9 = "knime", I2 = `${L9}://`, Vje = {
    components: {
        TreeSelect: Ije,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo && e.viewRepresentation
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [GD]: []
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    data() {
        return {
            repositoryAPI: null,
            treeData: this.transformTree(this.nodeConfig.viewRepresentation.tree),
            dataReady: !1,
            prefix: ""
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        infoMessage() {
            return !this.viewRep.runningOnServer && !this.runningInWebPortal ? "File selection only possible on server." : this.treeData.length === 0 ? "No items found for selection." : null
        },
        multipleSelection() {
            return this.viewRep.multipleSelection || !1
        },
        rawTree() {
            return this.viewRep.tree
        },
        defaultPaths() {
            return this.viewRep.currentValue.items?.reduce((e, t) => {
                let n = JBe(t.path, I2);
                return e.push(decodeURIComponent(n)),
                e
            }, [])
        },
        rootPath() {
            let e = decodeURIComponent(this.viewRep.rootDir || "/"),
            t = this.$store.getters["wizardExecution/workflowPath"];
            return e7e(e, I2, L9, t) || e
        },
        runningInWebPortal() {
            return !window.KnimePageLoader || window.KnimePageLoader?.isRunningInWebportal()
        },
        showWidget() {
            return !this.runningInWebPortal || this.dataReady
        }
    },
    watch: {
        rawTree(e) {
            this.treeData = this.transformTree(e)
        }
    },
    mounted() {
        this.runningInWebPortal && (this.repositoryAPI = this.$store.getters["api/repository"], this.requestRepository(this.rootPath))
    },
    methods: {
        async requestRepository(e) {
            try {
                let {
                    response: t,
                    errorResponse: n
                } = await this.repositoryAPI({
                    path: e
                });
                const r = this.defaultPaths;
                if (this.dataReady = !0, n)
                    return null;
                t && (this.setRepository(t, r), this.onChange())
            } catch {
                return null
            }
            return null
        },
        setRepository(e, t) {
            if (e?.children?.length) {
                let n = [];
                e.children.forEach(r => {
                    let o = this.createTreeItemRecursively(r, t);
                    o && n.push(o)
                }),
                n.length > 0 && (this.treeData = this.transformTree(n))
            }
        },
        createTreeItemRecursively(e, t) {
            return e?.path ? Bje(e, t, this.viewRep) : null
        },
        iconForItem(e) {
            switch (e.type) {
            case "WORKFLOW":
                return Lje;
            case "DIRECTORY":
                return Ux;
            default:
                return ZI
            }
        },
        transformTree(e) {
            return e?.map(t => this.transformTreeItem(t)) || []
        },
        transformTreeItem(e) {
            const t = e.state || {};
            return oa({
                text: e.text,
                value: e.text,
                opened: Boolean(t.opened),
                selected: Boolean(t.selected),
                disabled: Boolean(t.disabled),
                icon: _u(e.icon || this.iconForItem(e)),
                selectedIcon: e.children ? "" : _u($je),
                userData: {
                    path: e.id,
                    type: e.type
                },
                children: e.children?.map(n => this.transformTreeItem(n)) || []
            })
        },
        buildSelectedPaths(e, t) {
            t = t || [];
            for (const n of e)
                n.selected && t.push({
                    path: `${this.nodeConfig.viewRepresentation.prefix || this.prefix || ""}${encodeURI(n.userData.path)}`,
                    type: n.userData.type
                }), n.children?.length && t.concat(this.buildSelectedPaths(n.children, t));
            return t
        },
        onChange() {
            this.runningInWebPortal && this.checkMountId();
            const e = {
                nodeId: this.nodeId,
                type: GD,
                value: JSON.parse(JSON.stringify(this.buildSelectedPaths(this.treeData)))
            };
            this.$emit("updateWidget", e)
        },
        async checkMountId() {
            let e = this.viewRep.customMountId;
            this.viewRep.useDefaultMountId && (e = await this.$store.getters["api/defaultMountId"]),
            e && (this.prefix = I2 + e)
        },
        validate() {
            if (this.infoMessage)
                return {
                    isValid: !0,
                    errorMessage: ""
                };
            let e = !0,
            t;
            return this.viewRep.required && this.buildSelectedPaths(this.treeData).length === 0 && (e = !1, t = "Selection is required."), {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
}, Fje = {
    key: 0,
    class: "info"
};
function jje(e, t, n, r, o, i) {
    const s = B("TreeSelect"),
    a = B("ErrorMessage"),
    l = B("Label");
    return i.showWidget ? (_(), H(l, {
            key: 0,
            text: i.label,
            large: ""
        }, {
        default:
            oe(({
                    labelForId: c
                }) => [i.infoMessage ? (_(), O("div", Fje, Re(i.infoMessage), 1)) : (_(), H(s, {
                            key: 1,
                            id: c,
                            ref: "form",
                            "aria-label": i.label,
                            data: o.treeData,
                            multiple: i.multipleSelection,
                            "is-valid": n.isValid,
                            "allow-transition": !0,
                            title: i.description,
                            onItemClick: i.onChange
                        }, null, 8, ["id", "aria-label", "data", "multiple", "is-valid", "title", "onItemClick"])), z(a, {
                        error: n.errorMessage
                    }, null, 8, ["error"])]),
            _: 1
        }, 8, ["text"])) : J("", !0)
}
const Wje = te(Vje, [["render", jje], ["__scopeId", "data-v-6772492c"]]);
const zje = {
    components: {
        Checkbox: Tw
    },
    props: {
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e) ? e.every(t => t.hasOwnProperty("id") && t.hasOwnProperty("text")) : !1
            }
        },
        alignment: {
            type: String,
        default:
            "horizontal",
            validator(e) {
                return ["horizontal", "vertical"].includes(e)
            }
        },
        modelValue: {
            type: Array,
        default:
            () => []
        }
    },
    emits: ["update:modelValue"],
    methods: {
        onUpdateModelValue(e, t) {
            let n = Array.from(this.modelValue);
            t ? n.indexOf(e) === -1 && n.push(e) : n = n.filter(r => r !== e),
            consola.trace("Checkboxes value changed to", n),
            this.$emit("update:modelValue", n)
        },
        hasSelection() {
            return this.$refs.boxes.some(e => e.isChecked())
        }
    }
};
function Hje(e, t, n, r, o, i) {
    const s = B("Checkbox");
    return _(),
    O("div", {
        class: he(["checkboxes", n.alignment])
    }, [(_(!0), O(Le, null, $t(n.possibleValues, a => (_(), H(s, {
                                ref_for: !0,
                                ref: "boxes",
                                key: `checkboxes-${a.id}`,
                                "model-value": n.modelValue.indexOf(a.id) > -1,
                                title: a.text,
                                class: "box",
                                "onUpdate:modelValue": l => i.onUpdateModelValue(a.id, l)
                            }, {
                            default:
                                oe(() => [mt(Re(a.text), 1)]),
                                _: 2
                            }, 1032, ["model-value", "title", "onUpdate:modelValue"]))), 128))], 2)
}
const Uje = te(zje, [["render", Hje], ["__scopeId", "data-v-32f18fdb"]]);
const T2 = 1, qje = 28.5, Yje = 8, Kje = {
    components: {
        Checkbox: Tw,
        DropdownIcon: al
    },
    props: {
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e) ? e.every(t => t.hasOwnProperty("id") && t.hasOwnProperty("text")) : !1
            }
        },
        modelValue: {
            type: Array,
        default:
            () => []
        },
        placeholder: {
            type: String,
        default:
            null
        },
        isValid: {
            type: Boolean,
        default:
            !0
        },
        separator: {
            type: String,
        default:
            ", "
        },
        summaryMaxItemCount: {
            type: Number,
        default:
            1 / 0
        },
        summaryName: {
            type: String,
        default:
            null
        },
        useCustomListBox: {
            type: Boolean,
        default:
            !1
        },
        sizeVisibleOptions: {
            type: Number,
        default:
            0,
            validator(e) {
                return e >= 0
            }
        },
        parentFocusElement: {
            type: Object,
        default:
            () => ({})
        },
        parentRefocusElementOnClose: {
            type: Object,
        default:
            () => ({})
        },
        closeDropdownOnSelection: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["update:modelValue", "focusOutside"],
    data() {
        return {
            checkedValue: this.modelValue,
            collapsed: !0,
            focusOptions: []
        }
    },
    computed: {
        focusElements() {
            return [...this.focusOptions, this.parentFocusElement]
        },
        summary() {
            return this.checkedValue.length === 0 ? this.placeholder : this.checkedValue.length > this.summaryMaxItemCount ? `${this.checkedValue.length} ${this.summaryName}` : this.possibleValues.filter(({
                    id: e
                }) => this.checkedValue.indexOf(e) > -1).map(({
                    text: e,
                    selectedText: t = e
                }) => t).join(this.separator)
        },
        showOptions() {
            return !this.collapsed && this.possibleValues.length > 0
        },
        useSpecificOptionsHeight() {
            return this.sizeVisibleOptions > 0 && this.sizeVisibleOptions < this.possibleValues.length
        },
        optionsHeight() {
            return this.useSpecificOptionsHeight ? {
                "max-height": `${this.sizeVisibleOptions * qje + Yje}px`
            }
             : {}
        },
        refocusElementOnClose() {
            return this.useCustomListBox ? this.parentRefocusElementOnClose : this.$refs.toggle
        }
    },
    watch: {
        modelValue: {
            handler(e) {
                this.checkedValue = e
            },
            deep: !0
        }
    },
    mounted() {
        this.updateFocusOptions()
    },
    methods: {
        getNextElement(e) {
            return this.focusOptions[this.focusOptions.indexOf(document.activeElement) + e] || (e < 0 ? this.focusOptions[this.focusOptions.length - 1] : this.focusOptions[0])
        },
        onUpdateModelValue(e, t) {
            t ? this.checkedValue.indexOf(e) === -1 && this.checkedValue.push(e) : this.checkedValue = this.checkedValue.filter(n => n !== e),
            consola.trace("Multiselect value changed to", this.checkedValue),
            this.$emit("update:modelValue", this.checkedValue),
            this.closeDropdownOnSelection && this.closeOptions()
        },
        toggle() {
            this.collapsed = !this.collapsed,
            setTimeout(() => {
                this.$refs.toggle?.focus()
            }, T2)
        },
        isChecked(e) {
            return this.checkedValue.includes(e)
        },
        closeOptions(e = !0) {
            this.collapsed = !0,
            e && setTimeout(() => {
                this.refocusElementOnClose.focus()
            }, T2)
        },
        closeOptionsAndStop(e) {
            this.collapsed || (this.closeOptions(), e.stopPropagation(), e.preventDefault())
        },
        onUp() {
            document.activeElement !== this.$refs.toggle && this.getNextElement(-1).focus()
        },
        onDown() {
            this.getNextElement(1).focus()
        },
        onFocusOut() {
            setTimeout(() => {
                this.focusElements.includes(document.activeElement) || (this.closeOptions(!1), this.useCustomListBox && this.$emit("focusOutside"))
            }, T2)
        },
        onMousedown(e) {
            e.preventDefault(),
            e.stopPropagation(),
            e.stopImmediatePropagation()
        },
        updateFocusOptions() {
            this.$refs.option && (this.focusOptions = this.$refs.option.sort((e, t) => parseInt(e.$el.dataset.index, 10) - parseInt(t.$el.dataset.index, 10)).map(e => e.$el && e.$el.firstChild))
        }
    }
}, Gje = {
    key: 1
};
function Xje(e, t, n, r, o, i) {
    const s = B("DropdownIcon"),
    a = B("Checkbox");
    return _(),
    O("div", {
        ref: "multiselect",
        class: he(["multiselect", {
                    collapsed: o.collapsed,
                    invalid: !n.isValid
                }
            ]),
        onKeydown: [t[2] || (t[2] = Rt((...l) => i.closeOptionsAndStop && i.closeOptionsAndStop(...l), ["esc"])), t[3] || (t[3] = Rt(ve((...l) => i.onUp && i.onUp(...l), ["stop", "prevent"]), ["up"])), t[4] || (t[4] = Rt(ve((...l) => i.onDown && i.onDown(...l), ["stop", "prevent"]), ["down"]))],
        onFocusout: t[5] || (t[5] = ve((...l) => i.onFocusOut && i.onFocusOut(...l), ["stop"])),
        onMousedown: t[6] || (t[6] = (...l) => i.onMousedown && i.onMousedown(...l))
    }, [n.useCustomListBox ? Ye(e.$slots, "listBox", {
                key: 0
            }, void 0, !0) : (_(), O("div", Gje, [P("div", {
                            ref: "toggle",
                            role: "button",
                            tabindex: "0",
                            class: he({
                                placeholder: !o.checkedValue.length
                            }),
                            onClick: t[0] || (t[0] = (...l) => i.toggle && i.toggle(...l)),
                            onKeydown: t[1] || (t[1] = Rt(ve((...l) => i.toggle && i.toggle(...l), ["prevent"]), ["space"]))
                        }, Re(i.summary), 35), z(s, {
                            class: "icon"
                        })])), Cn(P("div", {
                    class: "options",
                    style: Yt(i.optionsHeight)
                }, [(_(!0), O(Le, null, $t(n.possibleValues, (l, c) => (_(), H(a, {
                                            ref_for: !0,
                                            ref: "option",
                                            key: `multiselect-${l.id}`,
                                            "data-index": c,
                                            "model-value": i.isChecked(l.id),
                                            disabled: l.disabled,
                                            class: "boxes",
                                            "onUpdate:modelValue": u => i.onUpdateModelValue(l.id, u)
                                        }, {
                                        default:
                                            oe(() => [mt(Re(l.text), 1)]),
                                            _: 2
                                        }, 1032, ["data-index", "model-value", "disabled", "onUpdate:modelValue"]))), 128)), Ye(e.$slots, "selectAction", {}, void 0, !0)], 4), [[Kn, i.showOptions]])], 34)
}
const Jje = te(Kje, [["render", Xje], ["__scopeId", "data-v-0559bf18"]]), M2 = "draft-id-combobox-preview-item", Zje = Fe({
    components: {
        Multiselect: Jje,
        FunctionButton: ti,
        CloseIcon: qu
    },
    props: {
        possibleValues: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e) ? e.every(t => t.hasOwnProperty("id") && t.hasOwnProperty("text")) : !1
            }
        },
        modelValue: {
            type: Array,
        default:
            () => []
        },
        sizeVisibleOptions: {
            type: Number,
        default:
            5,
            validator(e) {
                return e >= 0
            }
        },
        closeDropdownOnSelection: {
            type: Boolean,
        default:
            !1
        },
        isValid: {
            type: Boolean,
        default:
            !0
        },
        allowNewValues: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: {
        "update:modelValue": e => !0,
        change: e => !0
    },
    data() {
        return {
            searchValue: "",
            inputOrOptionsFocussed: !1,
            focusElement: null,
            refocusElement: null,
            allPossibleItems: this.possibleValues
        }
    },
    computed: {
        isSearchEmpty() {
            return !this.searchValue.trim()
        },
        searchResults() {
            const e = this.allPossibleItems.some(({
                        text: n
                    }) => n.toLowerCase() === this.searchValue.toLowerCase()),
            t = this.allPossibleItems.filter(({
                        text: n
                    }) => n.toLowerCase().includes(this.searchValue.toLowerCase()));
            return this.allowNewValues && !e && !this.isSearchEmpty ? [{
                    id: M2,
                    text: `${this.searchValue} (new item)`
                }, ...t] : t
        },
        hasSelection() {
            return this.selectedValues.length > 0
        },
        inputWidth() {
            return this.inputOrOptionsFocussed && this.searchResults.length > 0 ? {}
             : {
                width: "0%"
            }
        },
        selectedValues() {
            return this.getSelectedValues(this.modelValue)
        },
        maxSizeVisibleOptions() {
            return this.searchResults.length < this.sizeVisibleOptions ? this.searchResults.length : this.sizeVisibleOptions
        }
    },
    mounted() {
        this.focusElement = this.$refs.searchInput,
        this.refocusElement = this.$refs.listBox
    },
    methods: {
        emitNewSelection(e) {
            this.$emit("update:modelValue", e),
            this.$emit("change", this.getSelectedValues(e))
        },
        getSelectedValues(e) {
            return e.map(t => this.allPossibleItems.find(r => r.id === t) || {
                id: t,
                text: t
            })
        },
        focusInput() {
            this.$refs.searchInput.focus()
        },
        onDown() {
            this.$refs.combobox.onDown()
        },
        onEnter() {
            this.isSearchEmpty || (this.updateSelectedIds([...this.modelValue, this.searchResults[0]?.id]), this.searchValue = "")
        },
        onBackspace() {
            this.searchValue || this.emitNewSelection(this.modelValue.slice(0, -1))
        },
        onFocusOutside() {
            this.inputOrOptionsFocussed = !1,
            this.searchValue = ""
        },
        onInput() {
            this.$refs.combobox.updateFocusOptions()
        },
        onInputFocus() {
            this.inputOrOptionsFocussed || this.$refs.combobox.toggle(),
            this.inputOrOptionsFocussed = !0,
            this.$refs.combobox.updateFocusOptions()
        },
        updateSelectedIds(e) {
            const t = i => {
                this.emitNewSelection(lse(i).filter(Boolean))
            };
            if (!e.includes(M2)) {
                t(e);
                return
            }
            const r = {
                id: ese(this.searchValue),
                text: this.searchValue.trim()
            };
            this.allPossibleItems.some(i => i.id === r.id) || (this.allPossibleItems.push(r), t(e.map(i => i === M2 ? r.id : i)))
        },
        removeTag(e) {
            this.updateSelectedIds(this.modelValue.filter(t => t !== e)),
            this.closeOptions()
        },
        removeAllTags() {
            this.updateSelectedIds([]),
            this.closeOptions()
        },
        closeOptionsAndStop(e) {
            this.$refs.combobox.closeOptionsAndStop(e)
        },
        closeOptions() {
            this.$refs.combobox.closeOptions()
        }
    }
});
const Qje = ["title"], eWe = {
    class: "text"
}, tWe = {
    class: "icon-right"
};
function nWe(e, t, n, r, o, i) {
    const s = B("CloseIcon"),
    a = B("FunctionButton"),
    l = B("Multiselect");
    return _(),
    H(l, {
        ref: "combobox",
        "model-value": e.modelValue,
        "possible-values": e.searchResults,
        "use-custom-list-box": "",
        "size-visible-options": e.maxSizeVisibleOptions,
        "parent-focus-element": e.focusElement,
        "parent-refocus-element-on-close": e.refocusElement,
        "close-dropdown-on-selection": e.closeDropdownOnSelection,
        "is-valid": e.isValid,
        onFocusOutside: e.onFocusOutside,
        "onUpdate:modelValue": e.updateSelectedIds
    }, {
        listBox: oe(() => [P("div", {
                    ref: "listBox",
                    class: "summary-input-icon-wrapper",
                    tabindex: "0",
                    onKeydown: t[8] || (t[8] = Rt(ve((...c) => e.focusInput && e.focusInput(...c), ["prevent", "self"]), ["enter"]))
                }, [P("div", {
                            class: he(["summary-input-wrapper", {
                                        "with-icon-right": e.hasSelection
                                    }
                                ]),
                            onClick: t[7] || (t[7] = ve((...c) => e.focusInput && e.focusInput(...c), ["stop"]))
                        }, [(_(!0), O(Le, null, $t(e.selectedValues, (c, u) => (_(), O("div", {
                                                    key: `item.id${u}`,
                                                    class: "tag",
                                                    title: c.text
                                                }, [P("span", eWe, Re(c.text), 1), z(a, {
                                                            class: "remove-tag-button",
                                                            onClick: ve(f => e.removeTag(c.id), ["stop"])
                                                        }, {
                                                        default:
                                                            oe(() => [z(s, {
                                                                        class: "remove-tag-button-icon"
                                                                    })]),
                                                            _: 2
                                                        }, 1032, ["onClick"])], 8, Qje))), 128)), Cn(P("input", {
                                        ref: "searchInput",
                                        "onUpdate:modelValue": t[0] || (t[0] = c => e.searchValue = c),
                                        class: "search-input",
                                        type: "text",
                                        style: Yt(e.inputWidth),
                                        onFocus: t[1] || (t[1] = (...c) => e.onInputFocus && e.onInputFocus(...c)),
                                        onInput: t[2] || (t[2] = (...c) => e.onInput && e.onInput(...c)),
                                        onKeydown: [t[3] || (t[3] = Rt(ve((...c) => e.onEnter && e.onEnter(...c), ["prevent"]), ["enter"])), t[4] || (t[4] = Rt((...c) => e.onBackspace && e.onBackspace(...c), ["backspace"])), t[5] || (t[5] = Rt(ve((...c) => e.onDown && e.onDown(...c), ["stop", "prevent"]), ["down"])), t[6] || (t[6] = Rt((...c) => e.closeOptionsAndStop && e.closeOptionsAndStop(...c), ["esc"]))]
                                    }, null, 36), [[am, e.searchValue]])], 2), Cn(P("div", tWe, [z(a, {
                                        ref: "removeAllTags",
                                        class: "remove-all-tags-button",
                                        onClick: ve(e.removeAllTags, ["stop"])
                                    }, {
                                    default:
                                        oe(() => [z(s)]),
                                        _: 1
                                    }, 8, ["onClick"])], 512), [[Kn, e.hasSelection]])], 544)]),
        _: 1
    }, 8, ["model-value", "possible-values", "size-visible-options", "parent-focus-element", "parent-refocus-element-on-close", "close-dropdown-on-selection", "is-valid", "onFocusOutside", "onUpdate:modelValue"])
}
const rWe = te(Zje, [["render", nWe], ["__scopeId", "data-v-b7cdde11"]]), oWe = {
    components: {
        Checkboxes: Uje,
        ComboBox: rWe,
        MultiselectListBox: A9,
        Twinlist: D9
    },
    props: {
        isValid: {
        default:
            !0,
            type: Boolean
        },
        id: {
            type: String,
        default:
            null
        },
        type: {
        default:
            "List",
            type: String
        },
        possibleValueList: {
            type: Array,
        default:
            () => [],
            validator(e) {
                return Array.isArray(e)
            }
        },
        limitNumberVisOptions: {
            type: Boolean,
        default:
            !1
        },
        numberVisOptions: {
            type: Number,
        default:
            0
        },
        isReExecutionWidget: {
            type: Boolean,
        default:
            !1
        },
        description: {
            type: String,
        default:
            ""
        },
        label: {
            type: String,
        default:
            ""
        },
        modelValue: {
            type: Array,
        default:
            () => []
        }
    },
    emits: ["update:modelValue"],
    computed: {
        maxVisibleListEntries() {
            return this.limitNumberVisOptions ? this.numberVisOptions : 0
        },
        isList() {
            return this.type === "List"
        },
        isTwinlist() {
            return this.type === "Twinlist"
        },
        isCheckboxes() {
            return this.type === "Check boxes (horizontal)" || this.type === "Check boxes (vertical)"
        },
        isComboBox() {
            return this.type === "ComboBox"
        },
        checkBoxesAlignment() {
            return this.type === "Check boxes (vertical)" ? "vertical" : this.type === "Check boxes (horizontal)" ? "horizontal" : null
        },
        possibleValues() {
            return [...new Set(this.possibleValueList)].map(e => ({
                    id: e,
                    text: e
                }))
        }
    },
    methods: {
        onChange(e) {
            this.$emit("update:modelValue", e)
        },
        hasSelection() {
            return this.$refs.form.hasSelection()
        },
        validate() {
            return typeof this.$refs.form.validate == "function" ? this.$refs.form.validate() : {
                isValid: !0
            }
        }
    }
};
function iWe(e, t, n, r, o, i) {
    const s = B("Checkboxes"),
    a = B("Twinlist"),
    l = B("MultiselectListBox"),
    c = B("ComboBox");
    return _(),
    O("div", null, [i.isCheckboxes ? (_(), H(s, {
                    key: 0,
                    id: n.id,
                    ref: "form",
                    "model-value": n.modelValue,
                    alignment: i.checkBoxesAlignment,
                    "aria-label": n.label,
                    "possible-values": i.possibleValues,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "alignment", "aria-label", "possible-values", "is-valid", "title", "onUpdate:modelValue"])) : J("", !0), i.isTwinlist ? (_(), H(a, {
                    key: 1,
                    id: n.id,
                    ref: "form",
                    "model-value": n.modelValue,
                    size: i.maxVisibleListEntries,
                    "left-label": "Excludes",
                    "right-label": "Includes",
                    "possible-values": i.possibleValues,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "size", "possible-values", "is-valid", "title", "onUpdate:modelValue"])) : J("", !0), i.isList ? (_(), H(l, {
                    key: 2,
                    id: n.id,
                    ref: "form",
                    "model-value": n.modelValue,
                    size: i.maxVisibleListEntries,
                    "aria-label": n.label,
                    "possible-values": i.possibleValues,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "size", "aria-label", "possible-values", "is-valid", "title", "onUpdate:modelValue"])) : J("", !0), i.isComboBox ? (_(), H(c, {
                    key: 3,
                    id: n.id,
                    ref: "form",
                    "initial-selected-ids": n.modelValue,
                    "size-visible-options": i.maxVisibleListEntries,
                    "aria-label": n.label,
                    "possible-values": i.possibleValues,
                    "close-dropdown-on-selection": n.isReExecutionWidget,
                    "is-valid": n.isValid,
                    title: n.description,
                    "onUpdate:selectedIds": i.onChange
                }, null, 8, ["id", "initial-selected-ids", "size-visible-options", "aria-label", "possible-values", "close-dropdown-on-selection", "is-valid", "title", "onUpdate:selectedIds"])) : J("", !0)])
}
const eT = te(oWe, [["render", iWe]]), P2 = "value", sWe = {
    components: {
        Multiselect: eT,
        Fieldset: mc,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [P2]: []
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.valuePair[P2]
        },
        isList() {
            return this.viewRep.type === "List"
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: P2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t;
            if (this.viewRep.required && !this.$refs.form.hasSelection() && (e = !1, t = "Selection is required."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = n.errorMessage || t || "Current selection is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function aWe(e, t, n, r, o, i) {
    const s = B("Multiselect"),
    a = B("ErrorMessage");
    return _(),
    H(Kt(i.isList ? "Label" : "Fieldset"), {
        text: i.label,
        large: i.isList
    }, {
    default:
        oe(({
                labelForId: l
            }) => [z(s, {
                    id: l,
                    ref: "form",
                    "model-value": i.value,
                    type: i.viewRep.type,
                    "number-vis-options": i.viewRep.numberVisOptions,
                    "limit-number-vis-options": i.viewRep.limitNumberVisOptions,
                    "possible-value-list": i.viewRep.possibleChoices,
                    "is-re-execution-widget": i.viewRep.triggerReExecution,
                    "is-valid": n.isValid,
                    description: i.description,
                    label: i.label,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "type", "number-vis-options", "limit-number-vis-options", "possible-value-list", "is-re-execution-widget", "is-valid", "description", "label", "onUpdate:modelValue"]), z(a, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text", "large"])
}
const lWe = te(sWe, [["render", aWe]]), E2 = "value", cWe = {
    components: {
        SingleSelect: zw,
        Fieldset: mc,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [E2]: ""
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.valuePair[E2][0]
        },
        isRadioButtons() {
            return this.viewRep.type === "Radio buttons (vertical)" || this.viewRep.type === "Radio buttons (horizontal)"
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: E2,
                value: [e]
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            if (this.viewRep.possibleChoices.length === 0)
                return {
                    isValid: !1,
                    errorMessage: "No choices were specified."
                };
            let e = !0,
            t;
            if (this.viewRep.required && !this.$refs.form.hasSelection() && (e = !1, t = "Selection is required."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = n.errorMessage || t || "Current selection is invalid."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function uWe(e, t, n, r, o, i) {
    const s = B("SingleSelect"),
    a = B("ErrorMessage");
    return _(),
    H(Kt(i.isRadioButtons ? "Fieldset" : "Label"), {
        text: i.label,
        large: !i.isRadioButtons
    }, {
    default:
        oe(({
                labelForId: l
            }) => [z(s, {
                    id: l,
                    ref: "form",
                    "model-value": i.value,
                    type: i.viewRep.type,
                    "number-vis-options": i.viewRep.numberVisOptions,
                    "limit-number-vis-options": i.viewRep.limitNumberVisOptions,
                    "is-valid": n.isValid,
                    title: i.description,
                    "possible-value-list": i.viewRep.possibleChoices,
                    label: i.label,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "type", "number-vis-options", "limit-number-vis-options", "is-valid", "title", "possible-value-list", "label", "onUpdate:modelValue"]), z(a, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text", "large"])
}
const dWe = te(cWe, [["render", uWe]]);
const O2 = "values", $2 = "column", fWe = {
    components: {
        Multiselect: eT,
        Dropdown: jw,
        Label: Xn,
        Fieldset: mc,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [$2]: "",
                [O2]: []
            }),
            type: Object
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        possibleValues() {
            return this.isColumnValid ? this.viewRep.possibleValues[this.column] : []
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.isColumnValid ? this.valuePair[O2] : []
        },
        column() {
            return this.valuePair[$2]
        },
        possibleColumns() {
            return [...new Set(this.viewRep.possibleColumns)].map(e => ({
                    id: e,
                    text: e
                }))
        },
        isColumnLocked() {
            return this.viewRep.lockColumn
        },
        isColumnValid() {
            return this.viewRep.possibleColumns.includes(this.column)
        },
        isList() {
            return this.viewRep.type === "List"
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: O2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        onColumnChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: $2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t;
            if (this.viewRep.required && !this.$refs.form.hasSelection() && (e = !1, t = "Selection is required."), this.isColumnValid || (e = !1, t = "Selected column is invalid."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = n.errorMessage || t || "Selection is invalid or missing."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function hWe(e, t, n, r, o, i) {
    const s = B("Dropdown"),
    a = B("Label"),
    l = B("Multiselect"),
    c = B("ErrorMessage");
    return _(),
    H(Kt(i.isColumnLocked ? "div" : "Fieldset"), {
        text: i.isColumnLocked ? null : i.label
    }, {
    default:
        oe(() => [i.isColumnLocked ? J("", !0) : (_(), H(a, {
                        key: 0,
                        text: "Column",
                        large: ""
                    }, {
                    default:
                        oe(({
                                labelForId: u
                            }) => [i.isColumnLocked ? J("", !0) : (_(), H(s, {
                                        key: 0,
                                        id: u,
                                        ref: "column",
                                        "model-value": i.column,
                                        "is-valid": i.isColumnValid,
                                        "aria-label": "Column",
                                        "possible-values": i.possibleColumns,
                                        "onUpdate:modelValue": i.onColumnChange
                                    }, null, 8, ["id", "model-value", "is-valid", "possible-values", "onUpdate:modelValue"]))]),
                        _: 1
                    })), (_(), H(Kt(i.isList ? "Label" : "Fieldset"), {
                        text: i.isColumnLocked ? i.label : "Value",
                        large: i.isList
                    }, {
                    default:
                        oe(({
                                labelForId: u
                            }) => [z(l, {
                                    id: u,
                                    ref: "form",
                                    "model-value": i.value,
                                    type: i.viewRep.type,
                                    "number-vis-options": i.viewRep.numberVisOptions,
                                    "limit-number-vis-options": i.viewRep.limitNumberVisOptions,
                                    "possible-value-list": i.possibleValues,
                                    "is-valid": n.isValid,
                                    description: i.description,
                                    label: i.label,
                                    "onUpdate:modelValue": i.onChange
                                }, null, 8, ["id", "model-value", "type", "number-vis-options", "limit-number-vis-options", "possible-value-list", "is-valid", "description", "label", "onUpdate:modelValue"]), z(c, {
                                    error: n.errorMessage
                                }, null, 8, ["error"])]),
                        _: 1
                    }, 8, ["text", "large"]))]),
        _: 1
    }, 8, ["text"])
}
const pWe = te(fWe, [["render", hWe], ["__scopeId", "data-v-47ad7999"]]), A2 = "value", D2 = "column", mWe = {
    components: {
        SingleSelect: zw,
        Dropdown: jw,
        Fieldset: mc,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        valuePair: {
        default:
            () => ({
                [A2]: "",
                [D2]: ""
            }),
            type: Object
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        possibleValueList() {
            return this.isColumnValid ? this.viewRep.possibleValues[this.column] : []
        },
        possibleColumns() {
            return [...new Set(this.viewRep.possibleColumns)].map(e => ({
                    id: e,
                    text: e
                }))
        },
        description() {
            return this.viewRep.description || null
        },
        value() {
            return this.isColumnValid ? this.valuePair[A2] : ""
        },
        column() {
            return this.valuePair[D2]
        },
        isRadioButtons() {
            return this.viewRep.type === "Radio buttons (vertical)" || this.viewRep.type === "Radio buttons (horizontal)"
        },
        isColumnLocked() {
            return this.viewRep.lockColumn
        },
        isColumnValid() {
            return this.viewRep.possibleColumns.includes(this.column)
        },
        hasSelection() {
            return this.isColumnValid && this.possibleValueList.includes(this.value)
        }
    },
    methods: {
        onChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: A2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        onColumnChange(e) {
            const t = {
                nodeId: this.nodeId,
                type: D2,
                value: e
            };
            this.$emit("updateWidget", t)
        },
        validate() {
            let e = !0,
            t;
            if (this.viewRep.required && !this.hasSelection && (e = !1, t = "Selection is required."), this.isColumnValid || (e = !1, t = "Selected column is invalid."), typeof this.$refs.form.validate == "function") {
                let n = this.$refs.form.validate();
                e = Boolean(n.isValid && e),
                t = n.errorMessage || t || "Selection is invalid or missing."
            }
            return {
                isValid: e,
                errorMessage: e ? null : t
            }
        }
    }
};
function gWe(e, t, n, r, o, i) {
    const s = B("Dropdown"),
    a = B("Label"),
    l = B("SingleSelect"),
    c = B("ErrorMessage");
    return _(),
    H(Kt(i.isColumnLocked && !i.isRadioButtons ? "Label" : "Fieldset"), {
        text: i.label,
        class: "fieldset",
        large: i.isColumnLocked && !i.isRadioButtons
    }, {
    default:
        oe(u => [i.isColumnLocked ? J("", !0) : (_(), H(a, {
                        key: 0,
                        text: "Column",
                        large: ""
                    }, {
                    default:
                        oe(f => [z(s, {
                                    id: f.labelForId,
                                    ref: "column",
                                    "model-value": i.column,
                                    "is-valid": i.isColumnValid,
                                    "aria-label": "Column",
                                    "possible-values": i.possibleColumns,
                                    "onUpdate:modelValue": i.onColumnChange
                                }, null, 8, ["id", "model-value", "is-valid", "possible-values", "onUpdate:modelValue"])]),
                        _: 1
                    })), i.isColumnLocked ? J("", !0) : (_(), H(a, {
                        key: 1,
                        "generate-id": !1,
                        text: "Value",
                        large: ""
                    })), z(l, {
                    id: u.labelForId,
                    ref: "form",
                    "model-value": i.value,
                    type: i.viewRep.type,
                    "number-vis-options": i.viewRep.numberVisOptions,
                    "limit-number-vis-options": i.viewRep.limitNumberVisOptions,
                    "is-valid": n.isValid,
                    title: i.description,
                    "possible-value-list": i.possibleValueList,
                    label: i.label,
                    "onUpdate:modelValue": i.onChange
                }, null, 8, ["id", "model-value", "type", "number-vis-options", "limit-number-vis-options", "is-valid", "title", "possible-value-list", "label", "onUpdate:modelValue"]), z(c, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text", "large"])
}
const vWe = te(mWe, [["render", gWe]]);
function Hw() {
    this._types = Object.create(null),
    this._extensions = Object.create(null);
    for (let e = 0; e < arguments.length; e++)
        this.define(arguments[e]);
    this.define = this.define.bind(this),
    this.getType = this.getType.bind(this),
    this.getExtension = this.getExtension.bind(this)
}
Hw.prototype.define = function (e, t) {
    for (let n in e) {
        let r = e[n].map(function (o) {
            return o.toLowerCase()
        });
        n = n.toLowerCase();
        for (let o = 0; o < r.length; o++) {
            const i = r[o];
            if (i[0] !== "*") {
                if (!t && i in this._types)
                    throw new Error('Attempt to change mapping for "' + i + '" extension from "' + this._types[i] + '" to "' + n + '". Pass `force=true` to allow this, otherwise remove "' + i + '" from the list of extensions for "' + n + '".');
                this._types[i] = n
            }
        }
        if (t || !this._extensions[n]) {
            const o = r[0];
            this._extensions[n] = o[0] !== "*" ? o : o.substr(1)
        }
    }
};
Hw.prototype.getType = function (e) {
    e = String(e);
    let t = e.replace(/^.*[/\\]/, "").toLowerCase(),
    n = t.replace(/^.*\./, "").toLowerCase(),
    r = t.length < e.length;
    return (n.length < t.length - 1 || !r) && this._types[n] || null
};
Hw.prototype.getExtension = function (e) {
    return e = /^\s*([^;\s]*)/.test(e) && RegExp.$1,
    e && this._extensions[e.toLowerCase()] || null
};
var yWe = Hw, wWe = {
    "application/andrew-inset": ["ez"],
    "application/applixware": ["aw"],
    "application/atom+xml": ["atom"],
    "application/atomcat+xml": ["atomcat"],
    "application/atomdeleted+xml": ["atomdeleted"],
    "application/atomsvc+xml": ["atomsvc"],
    "application/atsc-dwd+xml": ["dwd"],
    "application/atsc-held+xml": ["held"],
    "application/atsc-rsat+xml": ["rsat"],
    "application/bdoc": ["bdoc"],
    "application/calendar+xml": ["xcs"],
    "application/ccxml+xml": ["ccxml"],
    "application/cdfx+xml": ["cdfx"],
    "application/cdmi-capability": ["cdmia"],
    "application/cdmi-container": ["cdmic"],
    "application/cdmi-domain": ["cdmid"],
    "application/cdmi-object": ["cdmio"],
    "application/cdmi-queue": ["cdmiq"],
    "application/cu-seeme": ["cu"],
    "application/dash+xml": ["mpd"],
    "application/davmount+xml": ["davmount"],
    "application/docbook+xml": ["dbk"],
    "application/dssc+der": ["dssc"],
    "application/dssc+xml": ["xdssc"],
    "application/ecmascript": ["es", "ecma"],
    "application/emma+xml": ["emma"],
    "application/emotionml+xml": ["emotionml"],
    "application/epub+zip": ["epub"],
    "application/exi": ["exi"],
    "application/express": ["exp"],
    "application/fdt+xml": ["fdt"],
    "application/font-tdpfr": ["pfr"],
    "application/geo+json": ["geojson"],
    "application/gml+xml": ["gml"],
    "application/gpx+xml": ["gpx"],
    "application/gxf": ["gxf"],
    "application/gzip": ["gz"],
    "application/hjson": ["hjson"],
    "application/hyperstudio": ["stk"],
    "application/inkml+xml": ["ink", "inkml"],
    "application/ipfix": ["ipfix"],
    "application/its+xml": ["its"],
    "application/java-archive": ["jar", "war", "ear"],
    "application/java-serialized-object": ["ser"],
    "application/java-vm": ["class"],
    "application/javascript": ["js", "mjs"],
    "application/json": ["json", "map"],
    "application/json5": ["json5"],
    "application/jsonml+json": ["jsonml"],
    "application/ld+json": ["jsonld"],
    "application/lgr+xml": ["lgr"],
    "application/lost+xml": ["lostxml"],
    "application/mac-binhex40": ["hqx"],
    "application/mac-compactpro": ["cpt"],
    "application/mads+xml": ["mads"],
    "application/manifest+json": ["webmanifest"],
    "application/marc": ["mrc"],
    "application/marcxml+xml": ["mrcx"],
    "application/mathematica": ["ma", "nb", "mb"],
    "application/mathml+xml": ["mathml"],
    "application/mbox": ["mbox"],
    "application/mediaservercontrol+xml": ["mscml"],
    "application/metalink+xml": ["metalink"],
    "application/metalink4+xml": ["meta4"],
    "application/mets+xml": ["mets"],
    "application/mmt-aei+xml": ["maei"],
    "application/mmt-usd+xml": ["musd"],
    "application/mods+xml": ["mods"],
    "application/mp21": ["m21", "mp21"],
    "application/mp4": ["mp4s", "m4p"],
    "application/msword": ["doc", "dot"],
    "application/mxf": ["mxf"],
    "application/n-quads": ["nq"],
    "application/n-triples": ["nt"],
    "application/node": ["cjs"],
    "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
    "application/oda": ["oda"],
    "application/oebps-package+xml": ["opf"],
    "application/ogg": ["ogx"],
    "application/omdoc+xml": ["omdoc"],
    "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
    "application/oxps": ["oxps"],
    "application/p2p-overlay+xml": ["relo"],
    "application/patch-ops-error+xml": ["xer"],
    "application/pdf": ["pdf"],
    "application/pgp-encrypted": ["pgp"],
    "application/pgp-signature": ["asc", "sig"],
    "application/pics-rules": ["prf"],
    "application/pkcs10": ["p10"],
    "application/pkcs7-mime": ["p7m", "p7c"],
    "application/pkcs7-signature": ["p7s"],
    "application/pkcs8": ["p8"],
    "application/pkix-attr-cert": ["ac"],
    "application/pkix-cert": ["cer"],
    "application/pkix-crl": ["crl"],
    "application/pkix-pkipath": ["pkipath"],
    "application/pkixcmp": ["pki"],
    "application/pls+xml": ["pls"],
    "application/postscript": ["ai", "eps", "ps"],
    "application/provenance+xml": ["provx"],
    "application/pskc+xml": ["pskcxml"],
    "application/raml+yaml": ["raml"],
    "application/rdf+xml": ["rdf", "owl"],
    "application/reginfo+xml": ["rif"],
    "application/relax-ng-compact-syntax": ["rnc"],
    "application/resource-lists+xml": ["rl"],
    "application/resource-lists-diff+xml": ["rld"],
    "application/rls-services+xml": ["rs"],
    "application/route-apd+xml": ["rapd"],
    "application/route-s-tsid+xml": ["sls"],
    "application/route-usd+xml": ["rusd"],
    "application/rpki-ghostbusters": ["gbr"],
    "application/rpki-manifest": ["mft"],
    "application/rpki-roa": ["roa"],
    "application/rsd+xml": ["rsd"],
    "application/rss+xml": ["rss"],
    "application/rtf": ["rtf"],
    "application/sbml+xml": ["sbml"],
    "application/scvp-cv-request": ["scq"],
    "application/scvp-cv-response": ["scs"],
    "application/scvp-vp-request": ["spq"],
    "application/scvp-vp-response": ["spp"],
    "application/sdp": ["sdp"],
    "application/senml+xml": ["senmlx"],
    "application/sensml+xml": ["sensmlx"],
    "application/set-payment-initiation": ["setpay"],
    "application/set-registration-initiation": ["setreg"],
    "application/shf+xml": ["shf"],
    "application/sieve": ["siv", "sieve"],
    "application/smil+xml": ["smi", "smil"],
    "application/sparql-query": ["rq"],
    "application/sparql-results+xml": ["srx"],
    "application/srgs": ["gram"],
    "application/srgs+xml": ["grxml"],
    "application/sru+xml": ["sru"],
    "application/ssdl+xml": ["ssdl"],
    "application/ssml+xml": ["ssml"],
    "application/swid+xml": ["swidtag"],
    "application/tei+xml": ["tei", "teicorpus"],
    "application/thraud+xml": ["tfi"],
    "application/timestamped-data": ["tsd"],
    "application/toml": ["toml"],
    "application/trig": ["trig"],
    "application/ttml+xml": ["ttml"],
    "application/ubjson": ["ubj"],
    "application/urc-ressheet+xml": ["rsheet"],
    "application/urc-targetdesc+xml": ["td"],
    "application/voicexml+xml": ["vxml"],
    "application/wasm": ["wasm"],
    "application/widget": ["wgt"],
    "application/winhlp": ["hlp"],
    "application/wsdl+xml": ["wsdl"],
    "application/wspolicy+xml": ["wspolicy"],
    "application/xaml+xml": ["xaml"],
    "application/xcap-att+xml": ["xav"],
    "application/xcap-caps+xml": ["xca"],
    "application/xcap-diff+xml": ["xdf"],
    "application/xcap-el+xml": ["xel"],
    "application/xcap-ns+xml": ["xns"],
    "application/xenc+xml": ["xenc"],
    "application/xhtml+xml": ["xhtml", "xht"],
    "application/xliff+xml": ["xlf"],
    "application/xml": ["xml", "xsl", "xsd", "rng"],
    "application/xml-dtd": ["dtd"],
    "application/xop+xml": ["xop"],
    "application/xproc+xml": ["xpl"],
    "application/xslt+xml": ["*xsl", "xslt"],
    "application/xspf+xml": ["xspf"],
    "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
    "application/yang": ["yang"],
    "application/yin+xml": ["yin"],
    "application/zip": ["zip"],
    "audio/3gpp": ["*3gpp"],
    "audio/adpcm": ["adp"],
    "audio/amr": ["amr"],
    "audio/basic": ["au", "snd"],
    "audio/midi": ["mid", "midi", "kar", "rmi"],
    "audio/mobile-xmf": ["mxmf"],
    "audio/mp3": ["*mp3"],
    "audio/mp4": ["m4a", "mp4a"],
    "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
    "audio/ogg": ["oga", "ogg", "spx", "opus"],
    "audio/s3m": ["s3m"],
    "audio/silk": ["sil"],
    "audio/wav": ["wav"],
    "audio/wave": ["*wav"],
    "audio/webm": ["weba"],
    "audio/xm": ["xm"],
    "font/collection": ["ttc"],
    "font/otf": ["otf"],
    "font/ttf": ["ttf"],
    "font/woff": ["woff"],
    "font/woff2": ["woff2"],
    "image/aces": ["exr"],
    "image/apng": ["apng"],
    "image/avif": ["avif"],
    "image/bmp": ["bmp"],
    "image/cgm": ["cgm"],
    "image/dicom-rle": ["drle"],
    "image/emf": ["emf"],
    "image/fits": ["fits"],
    "image/g3fax": ["g3"],
    "image/gif": ["gif"],
    "image/heic": ["heic"],
    "image/heic-sequence": ["heics"],
    "image/heif": ["heif"],
    "image/heif-sequence": ["heifs"],
    "image/hej2k": ["hej2"],
    "image/hsj2": ["hsj2"],
    "image/ief": ["ief"],
    "image/jls": ["jls"],
    "image/jp2": ["jp2", "jpg2"],
    "image/jpeg": ["jpeg", "jpg", "jpe"],
    "image/jph": ["jph"],
    "image/jphc": ["jhc"],
    "image/jpm": ["jpm"],
    "image/jpx": ["jpx", "jpf"],
    "image/jxr": ["jxr"],
    "image/jxra": ["jxra"],
    "image/jxrs": ["jxrs"],
    "image/jxs": ["jxs"],
    "image/jxsc": ["jxsc"],
    "image/jxsi": ["jxsi"],
    "image/jxss": ["jxss"],
    "image/ktx": ["ktx"],
    "image/ktx2": ["ktx2"],
    "image/png": ["png"],
    "image/sgi": ["sgi"],
    "image/svg+xml": ["svg", "svgz"],
    "image/t38": ["t38"],
    "image/tiff": ["tif", "tiff"],
    "image/tiff-fx": ["tfx"],
    "image/webp": ["webp"],
    "image/wmf": ["wmf"],
    "message/disposition-notification": ["disposition-notification"],
    "message/global": ["u8msg"],
    "message/global-delivery-status": ["u8dsn"],
    "message/global-disposition-notification": ["u8mdn"],
    "message/global-headers": ["u8hdr"],
    "message/rfc822": ["eml", "mime"],
    "model/3mf": ["3mf"],
    "model/gltf+json": ["gltf"],
    "model/gltf-binary": ["glb"],
    "model/iges": ["igs", "iges"],
    "model/mesh": ["msh", "mesh", "silo"],
    "model/mtl": ["mtl"],
    "model/obj": ["obj"],
    "model/step+xml": ["stpx"],
    "model/step+zip": ["stpz"],
    "model/step-xml+zip": ["stpxz"],
    "model/stl": ["stl"],
    "model/vrml": ["wrl", "vrml"],
    "model/x3d+binary": ["*x3db", "x3dbz"],
    "model/x3d+fastinfoset": ["x3db"],
    "model/x3d+vrml": ["*x3dv", "x3dvz"],
    "model/x3d+xml": ["x3d", "x3dz"],
    "model/x3d-vrml": ["x3dv"],
    "text/cache-manifest": ["appcache", "manifest"],
    "text/calendar": ["ics", "ifb"],
    "text/coffeescript": ["coffee", "litcoffee"],
    "text/css": ["css"],
    "text/csv": ["csv"],
    "text/html": ["html", "htm", "shtml"],
    "text/jade": ["jade"],
    "text/jsx": ["jsx"],
    "text/less": ["less"],
    "text/markdown": ["markdown", "md"],
    "text/mathml": ["mml"],
    "text/mdx": ["mdx"],
    "text/n3": ["n3"],
    "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
    "text/richtext": ["rtx"],
    "text/rtf": ["*rtf"],
    "text/sgml": ["sgml", "sgm"],
    "text/shex": ["shex"],
    "text/slim": ["slim", "slm"],
    "text/spdx": ["spdx"],
    "text/stylus": ["stylus", "styl"],
    "text/tab-separated-values": ["tsv"],
    "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
    "text/turtle": ["ttl"],
    "text/uri-list": ["uri", "uris", "urls"],
    "text/vcard": ["vcard"],
    "text/vtt": ["vtt"],
    "text/xml": ["*xml"],
    "text/yaml": ["yaml", "yml"],
    "video/3gpp": ["3gp", "3gpp"],
    "video/3gpp2": ["3g2"],
    "video/h261": ["h261"],
    "video/h263": ["h263"],
    "video/h264": ["h264"],
    "video/iso.segment": ["m4s"],
    "video/jpeg": ["jpgv"],
    "video/jpm": ["*jpm", "jpgm"],
    "video/mj2": ["mj2", "mjp2"],
    "video/mp2t": ["ts"],
    "video/mp4": ["mp4", "mp4v", "mpg4"],
    "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
    "video/ogg": ["ogv"],
    "video/quicktime": ["qt", "mov"],
    "video/webm": ["webm"]
};
let bWe = yWe;
var _We = new bWe(wWe);
const kWe = {
    components: {
        ...QI
    },
    props: {
        text: {
            type: String,
            required: !0
        },
        href: {
            type: String,
            required: !0
        },
        fileExt: {
            type: String,
        default:
            ""
        },
        mimeType: {
            type: String,
        default:
            "application/octet-stream"
        },
        size: {
            type: Number,
        default:
            0
        }
    },
    computed: {
        icon() {
            let e = `${this.fileExt}Icon`;
            return this.fileExt && this.$options.components[e] ? e : "fileIcon"
        },
        humanFileSizeObject() {
            return jx({
                output: "object",
                standard: "jedec",
                base: 2
            })(this.size)
        },
        humanFileSizeUnitFull() {
            return jx({
                output: "object",
                standard: "jedec",
                base: 2,
                fullform: !0
            })(this.size).symbol
        },
        hasFileInfo() {
            return this.size || this.fileExt
        },
        fileInfoText() {
            let e = "";
            return this.hasFileInfo && (this.fileExt && (e += this.fileExt), this.size && (e += `, ${this.humanFileSizeObject.value} `)),
            e
        },
        linkHtmlTitle() {
            let e = this.text;
            return this.fileInfoText && (e += ` (${this.fileInfoText}${this.size ? this.humanFileSizeObject.symbol : ""})`),
            e
        }
    }
}, xWe = {
    class: "file-link"
}, SWe = ["href", "title", "type"], CWe = {
    key: 0
}, IWe = ["title"];
function TWe(e, t, n, r, o, i) {
    return _(),
    O("figure", xWe, [P("a", {
                href: n.href,
                download: "",
                title: i.linkHtmlTitle,
                type: n.mimeType
            }, [(_(), H(Kt(i.icon))), mt(Re(n.text || "Download File"), 1)], 8, SWe), i.hasFileInfo ? (_(), O("figcaption", CWe, [mt(" (" + Re(i.fileInfoText), 1), n.size ? (_(), O("abbr", {
                                key: 0,
                                title: i.humanFileSizeUnitFull
                            }, Re(i.humanFileSizeObject.symbol), 9, IWe)) : J("", !0), mt(") ")])) : J("", !0)])
}
const MWe = te(kWe, [["render", TWe], ["__scopeId", "data-v-1803604b"]]), PWe = {
    components: {
        Label: Xn,
        FileLink: MWe,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo && e.viewRepresentation
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return Boolean(e)
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    data() {
        return {
            runningInAPWrapper: Boolean(window.KnimePageLoader)
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description
        },
        linkTitle() {
            return this.viewRep.linkTitle
        },
        fileType() {
            return _We.getType(this.viewRep.path) || "application/octet-stream"
        },
        fileExt() {
            return JI(this.viewRep.path)
        },
        link() {
            if (this.runningInAPWrapper)
                return `file://${this.viewRep.path}`;
            let e = this.$store.getters["api/downloadResourceLink"];
            return e ? e({
                resourceId: this.viewRep.resourceName,
                nodeId: this.nodeId
            }) : null
        },
        size() {
            return 0
        }
    },
    methods: {
        validate() {
            let e = this.link !== null;
            return {
                isValid: e,
                errorMessage: e ? null : "File download only available on server."
            }
        }
    }
}, EWe = ["title"];
function OWe(e, t, n, r, o, i) {
    const s = B("Label"),
    a = B("FileLink"),
    l = B("ErrorMessage");
    return _(),
    O("div", {
        title: i.description
    }, [z(s, {
                text: i.label,
                large: ""
            }, null, 8, ["text"]), i.link != null ? (_(), H(a, {
                    key: 0,
                    href: i.link,
                    text: i.linkTitle,
                    "file-ext": i.fileExt,
                    "mime-type": i.fileType,
                    size: i.size
                }, null, 8, ["href", "text", "file-ext", "mime-type", "size"])) : J("", !0), z(l, {
                error: n.errorMessage
            }, null, 8, ["error"])], 8, EWe)
}
const $We = te(PWe, [["render", OWe]]);
const AWe = {
    components: {
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo && e.viewRepresentation
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return Boolean(e)
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        errorMessage: {
        default:
            null,
            type: String
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || ""
        },
        value() {
            return this.viewRep.imageData
        },
        imageFormat() {
            return this.viewRep.imageFormat || ""
        },
        maxHeight() {
            return this.viewRep.maxHeight || -1
        },
        maxWidth() {
            return this.viewRep.maxWidth || -1
        },
        cssStyle() {
            return {
                maxHeight: this.maxHeight > 0 ? `${this.maxHeight}px` : null,
                maxWidth: this.maxWidth > 0 ? `${this.maxWidth}px` : null
            }
        },
        valueAsDataUri() {
            return `data:image/${this.imageFormat.toLowerCase()};base64,${this.value}`
        }
    },
    watch: {
        value() {
            this.$nextTick(this.updateSvgSize)
        }
    },
    mounted() {
        this.updateSvgSize()
    },
    methods: {
        updateSvgSize() {
            let e = this.$refs.svg?.children[0];
            e && this.svgModifySize(e, this.maxWidth, this.maxHeight)
        },
        svgModifySize(e, t, n) {
            let r = parseInt(e.getAttribute("width"), 10),
            o = parseInt(e.getAttribute("height"), 10),
            i = r,
            s = o,
            a = i / s;
            t >= 0 && i > t && (i = t, s = i / a, this.svgCreateViewBox(e, i, s, r, o), e.style.overflow = "hidden"),
            n >= 0 && s > n && (s = n, i = s * a, this.svgCreateViewBox(e, i, s, r, o), e.style.overflow = "hidden"),
            e.style.width = `${i}px`,
            e.style.height = `${s}px`
        },
        svgCreateViewBox(e, t, n, r, o) {
            e.setAttribute("viewBox", `0 0 ${r} ${o}`),
            e.setAttribute("preserveAspectRatio", "xMinYMin meet"),
            e.setAttribute("width", Math.round(t)),
            e.setAttribute("height", Math.round(n)),
            e.style.width = `${Math.round(t)}px`,
            e.style.height = `${Math.round(n)}px`
        },
        validate() {
            return ["SVG", "PNG"].includes(this.imageFormat) ? {
                isValid: !0,
                errorMessage: null
            }
             : {
                isValid: !0,
                errorMessage: `Unsupported image format: ${this.imageFormat}`
            }
        }
    }
}, DWe = ["title"], NWe = ["innerHTML"], RWe = ["src", "alt"];
function LWe(e, t, n, r, o, i) {
    const s = B("Label"),
    a = B("ErrorMessage");
    return _(),
    O("div", {
        class: "image-output",
        title: i.description
    }, [z(s, {
                text: i.label,
                large: ""
            }, null, 8, ["text"]), i.imageFormat === "SVG" ? (_(), O("div", {
                    key: 0,
                    ref: "svg",
                    innerHTML: i.value
                }, null, 8, NWe)) : (_(), O("img", {
                    key: 1,
                    style: Yt(i.cssStyle),
                    src: i.valueAsDataUri,
                    alt: i.description
                }, null, 12, RWe)), z(a, {
                error: n.errorMessage
            }, null, 8, ["error"])], 8, DWe)
}
const BWe = te(AWe, [["render", LWe], ["__scopeId", "data-v-efa57fcf"]]);
const XD = "viewRepresentation.text", VWe = {
    components: {
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo && e.viewRepresentation && typeof bx(e, XD) == "string"
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        }
    },
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        label() {
            return this.viewRep.label
        },
        description() {
            return this.viewRep.description || ""
        },
        errorMessage() {
            return this.isValid ? null : this.viewRep.errorMessage ? this.viewRep.errorMessage : this.nodeConfig.nodeInfo.nodeErrorMessage ? this.nodeConfig.nodeInfo.nodeErrorMessage : this.nodeConfig.nodeInfo.nodeWarnMessage ? this.nodeConfig.nodeInfo.nodeWarnMessage : "Current text output value is invalid"
        },
        value() {
            return bx(this.nodeConfig, XD)
        },
        elementType() {
            return this.viewRep.textFormat === "Text" ? "p" : this.viewRep.textFormat === "Preformatted" ? "pre" : !1
        }
    }
}, FWe = ["title"], jWe = ["innerHTML"];
function WWe(e, t, n, r, o, i) {
    const s = B("Label"),
    a = B("ErrorMessage");
    return _(),
    O("div", {
        title: i.description
    }, [z(s, {
                text: i.label,
                large: ""
            }, null, 8, ["text"]), i.elementType ? (_(), H(Kt(i.elementType), {
                    key: 0,
                    class: "multiline",
                    textContent: Re(i.value)
                }, null, 8, ["textContent"])) : (_(), O("div", {
                    key: 1,
                    class: "multiline",
                    innerHTML: i.value
                }, null, 8, jWe)), z(a, {
                error: i.errorMessage
            }, null, 8, ["error"])], 8, FWe)
}
const zWe = te(VWe, [["render", WWe], ["__scopeId", "data-v-e164648b"]]), JD = "double", ZD = "viewValue.filter.columns.0.minimum", QD = "viewValue.filter.columns.0.maximum", eN = 7, HWe = {
    components: {
        SliderWidget: E9
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        errorMessage: {
            type: String,
        default:
            null
        },
        valuePair: {
        default:
            () => ({
                [JD]: 0
            }),
            type: [Object, Array]
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewValue() {
            return this.nodeConfig.viewValue
        },
        filter() {
            return this.viewValue.filter
        },
        valueMinimum() {
            let e = this.filter.columns[0].minimum;
            return e === "-Infinity" ? !1 : parseFloat(e.toFixed(eN))
        },
        valueMaximum() {
            let e = this.filter.columns[0].maximum;
            return e === "Infinity" ? !1 : parseFloat(e.toFixed(eN))
        },
        isRangeSlider() {
            return this.valueMinimum !== !1 && this.valueMaximum !== !1
        },
        invertProcess() {
            return this.valueMaximum === !1
        },
        value() {
            return this.isRangeSlider ? [this.valueMinimum, this.valueMaximum] : {
                [JD]: this.valueMinimum === !1 ? this.valueMaximum : this.valueMinimum
            }
        }
    },
    mounted() {
        this.updateCallback()
    },
    methods: {
        getValue() {
            let e = JSON.parse(JSON.stringify(this.viewValue));
            return e.filter.columns[0].maximum = typeof this.valueMaximum == "number" ? this.valueMaximum : "Infinity",
            e.filter.columns[0].minimum = typeof this.valueMinimum == "number" ? this.valueMinimum : "-Infinity",
            e
        },
        onChange(e) {
            let t = {};
            if (this.isRangeSlider)
                t[ZD] = e.value[0], t[QD] = e.value[1];
            else {
                let n = this.valueMinimum === !1 ? [QD] : [ZD];
                t[n] = e.value
            }
            this.$emit("updateWidget", {
                nodeId: this.nodeId,
                update: t,
                callback: this.updateCallback
            })
        },
        updateCallback() {
            this.$store.dispatch("pagebuilder/interactivity/updateFilter", {
                id: `filter-${this.nodeConfig.viewRepresentation.tableId}`,
                data: this.filter
            })
        },
        validate() {
            return {
                isValid: typeof this.getValue() < "u"
            }
        }
    }
};
function UWe(e, t, n, r, o, i) {
    const s = B("SliderWidget");
    return _(),
    H(s, Bt(e.$props, {
            "value-pair": i.value,
            "invert-process": i.invertProcess,
            onUpdateWidget: i.onChange
        }), null, 16, ["value-pair", "invert-process", "onUpdateWidget"])
}
const qWe = te(HWe, [["render", UWe]]), YWe = "viewValue.filter.columns.0.values", KWe = {
    components: {
        Multiselect: eT,
        SingleSelect: zw,
        Fieldset: mc,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        isValid: {
        default:
            !0,
            type: Boolean
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        viewValue() {
            return this.nodeConfig.viewValue
        },
        filter() {
            return this.viewValue.filter
        },
        isMultiselect() {
            return this.viewRep.multipleValues
        },
        formComponentType() {
            return this.isMultiselect ? "Multiselect" : "SingleSelect"
        },
        labelComponentType() {
            return this.isMultiselect ? this.isList ? "Label" : "Fieldset" : this.isRadioButtons ? "Fieldset" : "Label"
        },
        label() {
            return this.viewRep.label || ""
        },
        valueArray() {
            return this.viewValue.filter.columns[0].values
        },
        value() {
            return this.isMultiselect ? this.valueArray : this.valueArray[0]
        },
        isList() {
            return this.viewRep.type === "List"
        },
        isRadioButtons() {
            return this.viewRep.type === "Radio buttons (vertical)" || this.viewRep.type === "Radio buttons (horizontal)"
        }
    },
    mounted() {
        this.updateCallback()
    },
    methods: {
        getValue() {
            return this.viewValue
        },
        onChange(e) {
            this.$emit("updateWidget", {
                nodeId: this.nodeId,
                update: {
                    [YWe]: Array.isArray(e) ? e : [e]
                },
                callback: this.updateCallback
            })
        },
        updateCallback() {
            this.$store.dispatch("pagebuilder/interactivity/updateFilter", {
                id: `filter-${this.viewRep.tableID}`,
                data: this.filter
            })
        },
        validate() {
            return {
                isValid: typeof this.getValue() < "u"
            }
        }
    }
};
function GWe(e, t, n, r, o, i) {
    const s = B("ErrorMessage");
    return _(),
    H(Kt(i.labelComponentType), {
        text: i.label
    }, {
    default:
        oe(() => [(_(), H(Kt(i.formComponentType), {
                        ref: "form",
                        "model-value": i.value,
                        type: i.viewRep.type,
                        "number-vis-options": i.viewRep.numberVisOptions,
                        "limit-number-vis-options": i.viewRep.limitNumberVisOptions,
                        "possible-value-list": i.viewRep.possibleValues,
                        "is-valid": n.isValid,
                        label: i.label,
                        "onUpdate:modelValue": i.onChange
                    }, null, 8, ["model-value", "type", "number-vis-options", "limit-number-vis-options", "possible-value-list", "is-valid", "label", "onUpdate:modelValue"])), z(s, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text"])
}
const XWe = te(KWe, [["render", GWe]]), JWe = {
    components: {
        Button: Pr,
        Label: Xn,
        ErrorMessage: Lr
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.nodeInfo
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        errorMessage: {
            type: String,
        default:
            null
        }
    },
    emits: ["updateWidget"],
    computed: {
        ...ut("pagebuilder", ["nodesReExecuting"]),
        viewRep() {
            return this.nodeConfig.viewRepresentation
        },
        isExecuting() {
            return Boolean(this.nodesReExecuting?.length)
        }
    },
    methods: {
        onClick() {
            this.$emit("updateWidget", {
                nodeId: this.nodeId
            })
        }
    }
};
function ZWe(e, t, n, r, o, i) {
    const s = B("Button"),
    a = B("ErrorMessage"),
    l = B("Label");
    return _(),
    H(l, {
        text: i.viewRep.label,
        title: i.viewRep.description,
        large: ""
    }, {
    default:
        oe(() => [z(s, {
                    primary: "",
                    compact: "",
                    class: "refresh-button",
                    disabled: i.isExecuting,
                    onClick: i.onClick
                }, {
                default:
                    oe(() => [mt(Re(i.viewRep.buttonText), 1)]),
                    _: 1
                }, 8, ["disabled", "onClick"]), z(a, {
                    error: n.errorMessage
                }, null, 8, ["error"])]),
        _: 1
    }, 8, ["text", "title"])
}
const QWe = te(JWe, [["render", ZWe]]);
const eze = {
    components: {
        BooleanWidget: Hbe,
        CredentialsWidget: Zbe,
        DateTimeWidget: bBe,
        DoubleWidget: DBe,
        FileUploadWidget: s7e,
        IntegerWidget: c7e,
        ListBoxInputWidget: v7e,
        SliderWidget: E9,
        StringWidget: W7e,
        ColumnFilterSelectionWidget: ZVe,
        ColumnSelectionWidget: g9e,
        FileChooserWidget: Wje,
        MultipleSelectionWidget: lWe,
        SingleSelectionWidget: dWe,
        ValueFilterSelectionWidget: pWe,
        ValueSelectionWidget: vWe,
        FileDownloadWidget: $We,
        ImageWidget: BWe,
        TextWidget: zWe,
        InteractiveRangeWidget: qWe,
        InteractiveValueWidget: XWe,
        RefreshButtonWidget: QWe
    },
    props: {
        nodeConfig: {
            required: !0,
            type: Object,
            validator(e) {
                return e.viewRepresentation && e.viewRepresentation["@class"]
            }
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        },
        widgetName: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        }
    },
    data() {
        return {
            isValid: !0,
            errorMessage: null,
            serverValidationErrorMessage: null
        }
    },
    computed: {
        hasValidator() {
            return typeof this.$refs.widget.validate == "function"
        },
        hasValueGetter() {
            return typeof this.$refs.widget.onChange == "function"
        },
        hasValidationErrorMessage() {
            return typeof this.nodeConfig.nodeInfo < "u"
        },
        valuePair() {
            return this.nodeConfig.viewRepresentation.currentValue
        },
        isInteractiveWidget() {
            return typeof this.valuePair > "u" && typeof this.$refs.widget.getValue == "function"
        },
        isReactive() {
            return this.nodeConfig.viewRepresentation.triggerReExecution
        }
    },
    async mounted() {
        this.nodeConfig.viewRepresentation.required && this.updateWebNode({
            nodeId: this.nodeId,
            update: {
                "viewRepresentation.required": !1
            }
        }),
        this.hasValidationErrorMessage && this.$store.dispatch("pagebuilder/addValidationErrorSetter", {
            nodeId: this.nodeId,
            errorSetter: this.setValidationError
        }),
        this.hasValueGetter && this.$store.dispatch("pagebuilder/addValueGetter", {
            nodeId: this.nodeId,
            valueGetter: this.getValue
        }),
        this.hasValidator && (this.$store.dispatch("pagebuilder/addValidator", {
                nodeId: this.nodeId,
                validator: this.validate
            }), await this.validate())
    },
    beforeUnmount() {
        this.hasValidationErrorMessage && this.$store.dispatch("pagebuilder/removeValidationErrorSetter", {
            nodeId: this.nodeId
        }),
        this.hasValidator && this.$store.dispatch("pagebuilder/removeValidator", {
            nodeId: this.nodeId
        }),
        this.hasValueGetter && this.$store.dispatch("pagebuilder/removeValueGetter", {
            nodeId: this.nodeId
        })
    },
    methods: {
        async publishUpdate(e) {
            this.hasValueGetter && !e.update && (e.update = {
                    [`viewRepresentation.currentValue.${e.type}`]: e.value
                }),
            e.update && await this.updateWebNode(e),
            e.update && this.hasValidator && await this.validate(),
            typeof e.callback == "function" && e.callback(),
            this.isReactive && this.isValid && this.triggerReExecution({
                nodeId: this.nodeId
            })
        },
        getValue() {
            return new Promise((e, t) => {
                try {
                    let n = this.isInteractiveWidget ? this.$refs.widget.getValue() : this.valuePair;
                    typeof n > "u" ? t(new Error("Value of widget could not be retrieved.")) : e({
                        nodeId: this.nodeId,
                        value: n
                    })
                } catch (n) {
                    t(new Error(n))
                }
            })
        },
        validate() {
            return new Promise(e => {
                let t = !0,
                n = null;
                try {
                    ({
                        isValid: t,
                        errorMessage: n
                    } = this.$refs.widget.validate())
                } catch {
                    t = !1,
                    n = "Something is not right. Please check this element."
                }
                finally {
                    this.isValid = t,
                    this.errorMessage = n,
                    e({
                        nodeId: this.nodeId,
                        isValid: t,
                        errorMessage: n
                    })
                }
            })
        },
        setValidationError(e) {
            return new Promise(t => {
                this.serverValidationErrorMessage = e,
                this.isValid = !1,
                t()
            })
        },
        ...Er({
            updateWebNode: "pagebuilder/updateWebNode",
            triggerReExecution: "pagebuilder/triggerReExecution"
        })
    }
}, tze = {
    class: "widget"
};
function nze(e, t, n, r, o, i) {
    return _(),
    O("div", tze, [(_(), H(Kt(n.widgetName), Bt({
                        ref: "widget"
                    }, e.$props, {
                        "is-valid": o.isValid,
                        "value-pair": i.valuePair,
                        "error-message": o.serverValidationErrorMessage || o.errorMessage,
                        onUpdateWidget: i.publishUpdate
                    }), null, 16, ["is-valid", "value-pair", "error-message", "onUpdateWidget"]))])
}
const rze = te(eze, [["render", nze], ["__scopeId", "data-v-5bea752d"]]), oze = {
    "org.knime.js.base.node.widget.input.slider.SliderWidgetNodeRepresentation": "SliderWidget",
    "org.knime.js.base.node.base.input.string.StringNodeRepresentation": "StringWidget",
    "org.knime.js.base.node.base.input.dbl.DoubleNodeRepresentation": "DoubleWidget",
    "org.knime.js.base.node.base.input.integer.IntegerNodeRepresentation": "IntegerWidget",
    "org.knime.js.base.node.base.input.bool.BooleanNodeRepresentation": "BooleanWidget",
    "org.knime.js.base.node.widget.input.bool.ReExecutableBooleanNodeRepresentation": "BooleanWidget",
    "org.knime.js.base.node.base.input.listbox.ListBoxNodeRepresentation": "ListBoxInputWidget",
    "org.knime.js.base.node.base.input.credentials.CredentialsNodeRepresentation": "CredentialsWidget",
    "org.knime.js.base.node.widget.input.date.DateWidgetNodeRepresentation": "DateTimeWidget",
    "org.knime.js.base.node.base.input.fileupload.FileUploadNodeRepresentation": "FileUploadWidget",
    "org.knime.js.base.node.widget.selection.single.SingleSelectionWidgetRepresentation": "SingleSelectionWidget",
    "org.knime.js.base.node.widget.selection.multiple.MultipleSelectionWidgetRepresentation": "MultipleSelectionWidget",
    "org.knime.js.base.node.base.filter.column.ColumnFilterNodeRepresentation": "ColumnFilterSelectionWidget",
    "org.knime.js.base.node.widget.filter.column.ReExecutableColumnFilterNodeRepresentation": "ColumnFilterSelectionWidget",
    "org.knime.js.base.node.base.selection.column.ColumnSelectionNodeRepresentation": "ColumnSelectionWidget",
    "org.knime.js.base.node.widget.selection.column.ReExecutableColumnSelectionNodeRepresentation": "ColumnSelectionWidget",
    "org.knime.js.base.node.base.filter.value.ValueFilterNodeRepresentation": "ValueFilterSelectionWidget",
    "org.knime.js.base.node.widget.filter.value.ReExecutableValueFilterNodeRepresentation": "ValueFilterSelectionWidget",
    "org.knime.js.base.node.base.selection.value.ValueSelectionNodeRepresentation": "ValueSelectionWidget",
    "org.knime.js.base.node.widget.selection.value.ReExecutableValueSelectionNodeRepresentation": "ValueSelectionWidget",
    "org.knime.js.base.node.base.input.filechooser.FileChooserNodeRepresentation": "FileChooserWidget",
    "org.knime.js.base.node.widget.output.text.TextOutputWidgetRepresentation": "TextWidget",
    "org.knime.js.base.node.widget.output.image.ImageOutputWidgetRepresentation": "ImageWidget",
    "org.knime.js.base.node.widget.output.filedownload.FileDownloadWidgetRepresentation": "FileDownloadWidget",
    "org.knime.js.base.node.widget.filter.definition.value.ValueFilterDefinitionWidgetRepresentation": "InteractiveValueWidget",
    "org.knime.js.base.node.widget.filter.definition.rangeslider.RangeSliderFilterWidgetRepresentation": "InteractiveRangeWidget"
}, tN = {
    "org.knime.js.base.node.widget.reexecution.refresh.RefreshButtonWidgetViewRepresentation": "RefreshButtonWidget"
}, B9 = {
    computed: {
        resizeMethod() {
            return this.viewConfig.resizeMethod || ""
        },
        layoutClasses() {
            let e = [];
            return this.isReporting && e.push("reporting-replaceable"),
            this.resizeMethod.startsWith("aspectRatio") ? e.push(this.resizeMethod) : this.resizeMethod.startsWith("view") && e.push("fill-container"),
            Array.isArray(this.viewConfig.additionalClasses) && (e = e.concat(this.viewConfig.additionalClasses)),
            e
        },
        layoutStyle() {
            let e = [];
            if (this.viewConfig.additionalStyles && (e = e.concat(this.viewConfig.additionalStyles)), this.resizeMethod.startsWith("viewLowestElement") && (this.isWidget || this.extensionConfig)) {
                let {
                    maxHeight: t = null,
                    maxWidth: n = null,
                    minHeight: r = null,
                    minWidth: o = null
                } = this.viewConfig;
                t !== null && e.push(`max-height:${t}px`),
                n !== null && e.push(`max-width:${n}px`),
                r !== null && e.push(`min-height:${r}px`),
                o !== null && e.push(`min-width:${o}px`)
            }
            return e.join(";").replace(/;;/g, ";")
        }
    }
};
const ize = {
    components: {
        Label: Xn,
        SignWarningIcon: _I
    },
    props: {
        nodeInfo: {
            type: Object,
        default:
            () => {}
        },
        nodeId: {
            type: String,
        default:
            ""
        },
        showError: {
            type: Boolean,
        default:
            !0
        },
        notSupported: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        nodeAnnotation() {
            return this.nodeInfo?.nodeAnnotation
        },
        hasErrorMessage() {
            return this.nodeInfo?.nodeErrorMessage
        },
        hasWarnMessages() {
            return this.nodeInfo?.nodeWarnMessage
        },
        nodeName() {
            return this.nodeInfo?.nodeName || "Missing node"
        },
        text() {
            let e = this.nodeAnnotation ? ` - ${this.nodeAnnotation}` : "";
            return `${this.nodeName}${e} (${this.nodeId}) can’t be displayed`
        }
    }
}, sze = {
    key: 0
}, aze = {
    key: 0
}, lze = {
    key: 1
}, cze = {
    key: 2
};
function uze(e, t, n, r, o, i) {
    const s = B("SignWarningIcon"),
    a = B("Label");
    return _(),
    O("div", {
        class: he({
            "not-supported": n.notSupported
        })
    }, [n.notSupported ? (_(), O("span", sze, " This view is not supported. ")) : n.showError ? (_(), O(Le, {
                    key: 1
                }, [z(s, {
                            class: "icon"
                        }), z(a, {
                            text: i.text,
                            large: ""
                        }, null, 8, ["text"]), i.hasErrorMessage ? (_(), O("span", aze, " Error message on node: " + Re(n.nodeInfo.nodeErrorMessage), 1)) : i.hasWarnMessages ? (_(), O("span", lze, " Warn message on node: " + Re(n.nodeInfo.nodeWarnMessage), 1)) : (_(), O("span", cze, " No further information available. Please check the configuration of the workflow. "))], 64)) : J("", !0)], 2)
}
const V9 = te(ize, [["render", uze], ["__scopeId", "data-v-60709438"]]);
const dze = {
    components: {
        WebNodeIFrame: Lbe,
        Widget: rze,
        NotDisplayable: V9
    },
    mixins: [B9],
    props: {
        viewConfig: {
        default:
            () => ({}),
            type: Object
        },
        nodeConfig: {
        default:
            () => ({}),
            type: Object
        },
        nodeId: {
            required: !0,
            type: String,
            validator(e) {
                return e !== ""
            }
        }
    },
    data() {
        return {
            nodeViewIFrameKey: 0
        }
    },
    computed: {
        ...ut("pagebuilder", ["isReporting"]),
        nodeState() {
            return this.nodeConfig?.nodeInfo?.nodeState
        },
        legacyModeDisabled() {
            return this.viewConfig.useLegacyMode === !1
        },
        widgetComponentName() {
            return {
                ...oze,
                ...tN
            }
            [this.nodeConfig?.viewRepresentation?.["@class"]]
        },
        isWidget() {
            return Boolean(tN[this.nodeConfig?.viewRepresentation?.["@class"]] || this.legacyModeDisabled && this.widgetComponentName)
        }
    },
    watch: {
        nodeConfig() {
            this.nodeViewIFrameKey += 1
        }
    },
    mounted() {
        this.isReporting && this.$store.dispatch("pagebuilder/setReportingContent", {
            nodeId: this.nodeId
        })
    }
};
function fze(e, t, n, r, o, i) {
    const s = B("NotDisplayable"),
    a = B("Widget"),
    l = B("WebNodeIFrame");
    return _(),
    O("div", {
        class: he(e.layoutClasses),
        style: Yt(e.layoutStyle)
    }, [e.isReporting ? (_(), H(s, {
                    key: 0,
                    "not-supported": ""
                })) : i.isWidget ? (_(), H(a, {
                    key: 1,
                    "widget-name": i.widgetComponentName,
                    "node-config": n.nodeConfig,
                    "node-id": n.nodeId
                }, null, 8, ["widget-name", "node-config", "node-id"])) : (_(), H(l, Bt({
                        key: o.nodeViewIFrameKey
                    }, e.$props), null, 16))], 6)
}
const hze = te(dze, [["render", fze], ["__scopeId", "data-v-8490223a"]]), pze = {
    components: {},
    inject: ["getKnimeService"],
    props: {
        resourceLocation: {
        default:
            null,
            type: String,
            required: !0
        },
        nodeId: {
        default:
            null,
            type: String,
            required: !0
        }
    },
    computed: {
        ...ut("pagebuilder", ["isReporting"]),
        knimeService() {
            return this.getKnimeService()
        },
        extensionConfig() {
            return this.knimeService?.extensionConfig
        },
        resourceInfo() {
            return this.extensionConfig?.resourceInfo
        },
        componentId() {
            return this.resourceInfo?.id
        }
    },
    created() {
        this.$options.components[this.componentId] = M7({
            resourceLocation: this.resourceLocation,
            componentName: this.componentId
        })
    }
};
function mze(e, t, n, r, o, i) {
    return _(),
    H(Kt(i.componentId))
}
const gze = te(pze, [["render", mze]]);
const vze = {
    inject: ["getKnimeService"],
    props: {
        resourceLocation: {
        default:
            null,
            type: String,
            required: !0
        }
    },
    computed: {
        knimeService() {
            return this.getKnimeService()
        }
    },
    mounted() {
        this.knimeService.updateEventListener(),
        this.knimeService.setIFrameWindow(this.$refs.iframe.contentWindow)
    },
    beforeUnmount() {
        this.knimeService.destroy()
    }
}, yze = ["src"];
function wze(e, t, n, r, o, i) {
    return _(),
    O("iframe", {
        ref: "iframe",
        src: n.resourceLocation,
        sandbox: "allow-downloads allow-scripts allow-same-origin"
    }, null, 8, yze)
}
const bze = te(vze, [["render", wze], ["__scopeId", "data-v-ba554a71"]]);
const _ze = {
    components: {
        FunctionButton: ti,
        WarningIcon: Q1
    }
};
function kze(e, t, n, r, o, i) {
    const s = B("WarningIcon"),
    a = B("FunctionButton");
    return _(),
    H(a, Bt(e.$attrs, {
            primary: "",
            class: "button",
            title: "Show messages"
        }), {
    default:
        oe(() => [z(s)]),
        _: 1
    }, 16)
}
const xze = te(_ze, [["render", kze], ["__scopeId", "data-v-261f6c95"]]);
const Sze = {
    components: {
        UIExtComponent: gze,
        UIExtIFrame: bze,
        AlertLocal: j7,
        WarningLocal: xze
    },
    mixins: [B9],
    provide() {
        return this.initKnimeService(), {
            getKnimeService: () => this.knimeService
        }
    },
    props: {
        extensionConfig: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return typeof e != "object" ? !1 : ["nodeId", "workflowId", "projectId", "resourceInfo"].every(n => e.hasOwnProperty(n))
            }
        },
        viewConfig: {
        default:
            () => ({}),
            type: Object
        }
    },
    data() {
        return {
            configKey: 0,
            knimeService: null,
            alert: null,
            isWidget: !1
        }
    },
    computed: {
        ...ut("pagebuilder", ["page", "isDialogLayout", "isReporting"]),
        isUIExtComponent() {
            return this.extensionConfig?.resourceInfo?.type === "VUE_COMPONENT_LIB"
        },
        resourceLocation() {
            return this.$store.getters["api/uiExtResourceLocation"]({
                resourceInfo: this.extensionConfig?.resourceInfo
            })
        },
        displayError() {
            return this.alert?.type === "error"
        },
        displayWarning() {
            return this.alert?.type === "warn"
        },
        pageIdPrefix() {
            return this.page?.wizardPageContent?.webNodePageConfiguration?.projectRelativePageIDSuffix
        },
        nodeId() {
            return this.pageIdPrefix ? `${this.pageIdPrefix}:${this.viewConfig.nodeID}` : this.viewConfig.nodeID
        }
    },
    watch: {
        extensionConfig() {
            this.$store.dispatch("pagebuilder/service/deregisterService", {
                service: this.knimeService
            }),
            this.initKnimeService(),
            this.configKey += 1
        }
    },
    beforeUnmount() {
        this.$store.dispatch("pagebuilder/service/deregisterService", {
            service: this.knimeService
        })
    },
    mounted() {
        const e = this.extensionConfig.nodeInfo,
        t = e?.nodeErrorMessage || e?.nodeWarnMessage;
        if (t) {
            const n = e?.nodeErrorMessage,
            r = this.extensionConfig.nodeId;
            this.handleAlert({
                message: t,
                type: n ? "error" : "warn",
                subtitle: "",
                nodeId: r
            })
        }
    },
    methods: {
        initKnimeService() {
            const e = this.isUIExtComponent ? vI : y1e;
            let t = new e(Xt(this.extensionConfig), this.callService, this.pushEvent);
            if (this.isReporting)
                this.extensionConfig.generatedImageActionId = "generatingReportContent", this.isUIExtComponent || t.registerImageGeneratedCallback(n => this.$store.dispatch("pagebuilder/setReportingContent", {
                        nodeId: this.nodeId,
                        reportingContent: `<img style="width:${this.$el.offsetWidth}px" src="${n}" />`
                    }));
            else if (this.extensionConfig?.generatedImageActionId) {
                const n = this.extensionConfig.generatedImageActionId;
                t.registerImageGeneratedCallback(r => window.EquoCommService.send(n, r))
            }
            this.knimeService = oa(t),
            this.$store.dispatch("pagebuilder/service/registerService", {
                service: this.knimeService
            })
        },
        callService(e, t, n) {
            return this.$store.dispatch("api/callService", {
                extensionConfig: Xt(this.extensionConfig),
                nodeService: e,
                serviceRequest: t,
                requestParams: n
            })
        },
        pushEvent(e) {
            return e?.type === "alert" ? this.handleAlert(e.alert) : this.$store.dispatch("pagebuilder/service/pushEvent", e)
        },
        handleAlert(e) {
            this.isDialogLayout ? this.showAlert(e) : this.alert = e
        },
        showAlert(e) {
            return this.$store.dispatch("pagebuilder/alert/showAlert", {
                ...e,
                callback: this.closeAlert
            })
        },
        closeAlert(e) {
            e && (this.alert = null)
        }
    }
};
function Cze(e, t, n, r, o, i) {
    const s = B("UIExtComponent"),
    a = B("UIExtIFrame"),
    l = B("AlertLocal"),
    c = B("WarningLocal");
    return _(),
    O("div", {
        class: he(e.layoutClasses),
        style: Yt(e.layoutStyle)
    }, [i.isUIExtComponent ? (_(), H(s, {
                    key: o.configKey + "-1",
                    "node-id": i.nodeId,
                    "resource-location": i.resourceLocation
                }, null, 8, ["node-id", "resource-location"])) : (_(), H(a, {
                    key: o.configKey + "-2",
                    "resource-location": i.resourceLocation
                }, null, 8, ["resource-location"])), i.displayError ? (_(), H(l, {
                    key: 2,
                    active: "",
                    onShowAlert: t[0] || (t[0] = u => i.showAlert(o.alert))
                })) : J("", !0), i.displayWarning ? (_(), H(c, {
                    key: 3,
                    class: "local-warning",
                    onClick: t[1] || (t[1] = u => i.showAlert(o.alert))
                })) : J("", !0)], 6)
}
const Ize = te(Sze, [["render", Cze], ["__scopeId", "data-v-feb4558e"]]);
const Tze = 40, Mze = {
    props: {
        show: {
            type: Boolean,
        default:
            !1
        },
        showSpinner: {
            type: Boolean,
        default:
            !1
        },
        useCssTransition: {
            type: Boolean,
        default:
            !0
        }
    },
    data() {
        return {
            overlayRefAvailable: !1,
            SVG_STROKE_PIXEL_OFFSET: 3
        }
    },
    computed: {
        spinnerHeight() {
            return this.showSpinner ? this.getSpinnerHeight() : 0
        },
        circleRadius() {
            return Math.max(this.spinnerHeight / 2 - this.SVG_STROKE_PIXEL_OFFSET, 0)
        },
        svgLeft() {
            return this.showSpinner ? this.getHalfOverlayWidth() : 0
        },
        svgTop() {
            return this.showSpinner ? this.getHalfOverlayHeight() : 0
        },
        svgStyle() {
            return `height:${this.spinnerHeight}px;width:${this.spinnerHeight}px;top:${this.svgTop - this.spinnerHeight / 2}px;left:${this.svgLeft - this.spinnerHeight / 2}px;`
        },
        spinnerStyle() {
            return `transform-origin: ${this.circleRadius + this.SVG_STROKE_PIXEL_OFFSET}px ${this.circleRadius + this.SVG_STROKE_PIXEL_OFFSET}px 0;`
        }
    },
    methods: {
        getSpinnerHeight() {
            return Math.min(this.getHalfOverlayHeight(), Tze)
        },
        getHalfOverlayWidth() {
            return this.$refs.overlay?.offsetWidth / 2 || 0
        },
        getHalfOverlayHeight() {
            return this.$refs.overlay?.offsetHeight / 2 || 0
        }
    }
}, Pze = {
    ref: "overlay"
}, Eze = ["view-box"], Oze = ["r", "cy", "cx"];
function $ze(e, t, n, r, o, i) {
    return n.show ? (_(), H(ho, {
            key: 0,
            appear: "",
            name: "fade",
            css: n.useCssTransition,
            onAfterEnter: t[0] || (t[0] = s => o.overlayRefAvailable = !0)
        }, {
        default:
            oe(() => [P("div", Pze, [n.showSpinner && o.overlayRefAvailable ? (_(), H(ho, {
                                    key: 0,
                                    appear: "",
                                    name: "fade",
                                    css: n.useCssTransition
                                }, {
                                default:
                                    oe(() => [(_(), O("svg", {
                                                    "view-box": `0 0 ${i.spinnerHeight} ${i.spinnerHeight}`,
                                                    style: Yt(i.svgStyle)
                                                }, [P("circle", {
                                                            r: i.circleRadius,
                                                            cy: i.circleRadius + o.SVG_STROKE_PIXEL_OFFSET,
                                                            cx: i.circleRadius + o.SVG_STROKE_PIXEL_OFFSET,
                                                            style: Yt(i.spinnerStyle)
                                                        }, null, 12, Oze)], 12, Eze))]),
                                    _: 1
                                }, 8, ["css"])) : J("", !0)], 512)]),
            _: 1
        }, 8, ["css"])) : J("", !0)
}
const F9 = te(Mze, [["render", $ze], ["__scopeId", "data-v-2a8c2360"]]), Aze = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 93 93"
}, Dze = iC('<path stroke-miterlimit="10" d="M82.667 15.45h-5v13.951h5v-13.95zM64.333 26.508h-5v5.787h5v-5.787zm0-2.893h-5v2.893h5v-2.893zm9.167 3.316h-5v5.364h5v-5.364zm9.167-16.609h-5v5.128h5v-5.128zM73.5 22.09h-5v4.84h5v-4.84zm9.167 7.312h-5v2.893h5v-2.893z"></path><path stroke-miterlimit="10" d="M64.333 16.37h-5v7.245h5V16.37zM85.07 35.678H56.93M60 80l10-10V56.385M83.615 70H70.142"></path><path stroke-miterlimit="10" d="M70 83.615c7.52 0 13.615-6.096 13.615-13.615 0-7.52-6.096-13.615-13.615-13.615-7.52 0-13.615 6.095-13.615 13.615 0 7.52 6.096 13.615 13.615 13.615zM11.5 57v25m-.5-.5h25"></path><path stroke-linecap="round" stroke-width="2.4%" d="M20 62h0m10.5-3.5h0m-5 6h0m8-1h0m-3 4h0m-10 0h0m-3 4h0m-3 5h0"></path><path stroke-miterlimit="10" d="M23 9.653 8.966 19.849l5.361 16.498h17.346l5.361-16.498L23 9.653z"></path><path stroke-miterlimit="10" d="M37.034 19.849 23 23.925V9.653m8.673 26.694L23 23.925l-8.673 12.422L8.966 19.85 23 23.925"></path><path stroke-miterlimit="10" d="m23 15.66-7.635 6.048 2.519 9.544 10.259.236 6.379-10.909L23 15.66z"></path><path d="M0 46.5h93M46.5 0v93"></path>', 8), Nze = [Dze];
function Rze(e, t) {
    return _(),
    O("svg", Aze, Nze)
}
const Lze = {
    render: Rze
};
const Bze = {
    components: {
        Button: Pr,
        ExecutingOverlay: F9,
        ExecutableImage: Lze
    },
    props: {
        extensionConfig: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return typeof e != "object" || Array.isArray(e) ? !1 : ["nodeId", "workflowId", "projectId", "nodeInfo"].every(n => e.hasOwnProperty(n))
            }
        }
    },
    computed: {
        canExecute() {
            return this.extensionConfig.nodeInfo.canExecute !== !1
        },
        isExecuting() {
            return this.extensionConfig.nodeInfo.nodeState === "executing"
        }
    },
    watch: {
        "extensionConfig.nodeInfo": {
            handler() {
                this.showAlert()
            },
            deep: !0
        }
    },
    mounted() {
        this.showAlert()
    },
    methods: {
        async executeViewSaveSettings() {
            await this.$store.dispatch("pagebuilder/dialog/callApplySettings"),
            await this.$store.dispatch("api/changeNodeStates", {
                extensionConfig: this.extensionConfig,
                action: "execute"
            })
        },
        showAlert() {
            const e = this.extensionConfig.nodeInfo,
            t = e?.nodeErrorMessage || e?.nodeWarnMessage;
            if (t) {
                const n = e?.nodeErrorMessage,
                r = this.extensionConfig.nodeId,
                o = {
                    message: t,
                    type: n ? "error" : "warn",
                    subtitle: "",
                    nodeId: r
                };
                this.$store.dispatch("pagebuilder/alert/showAlert", o)
            }
        }
    }
}, Vze = {
    class: "view-container"
}, Fze = {
    key: 0,
    class: "message"
}, jze = {
    key: 1,
    class: "message"
};
function Wze(e, t, n, r, o, i) {
    const s = B("ExecutableImage"),
    a = B("Button"),
    l = B("ExecutingOverlay");
    return _(),
    O("div", Vze, [i.canExecute ? (_(), O("p", Fze, " Please execute the node to see the preview. ")) : (_(), O("p", jze, " Node cannot be executed in order to show the preview. Please check the workflow. ")), z(s), z(a, {
                disabled: !i.canExecute,
                "with-border": "",
                title: "Save & execute",
                onClick: i.executeViewSaveSettings
            }, {
            default:
                oe(() => [mt(" Save & execute ")]),
                _: 1
            }, 8, ["disabled", "onClick"]), z(l, {
                show: i.isExecuting,
                "show-spinner": i.isExecuting,
                "use-css-transition": !1
            }, null, 8, ["show", "show-spinner"])])
}
const zze = te(Bze, [["render", Wze], ["__scopeId", "data-v-0bec830d"]]);
const Hze = {
    components: {
        WebNode: hze,
        UIExtension: Ize,
        NotDisplayable: V9,
        ViewExecutable: zze,
        ExecutingOverlay: F9
    },
    props: {
        viewConfig: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return !(typeof e != "object" || !e.hasOwnProperty("nodeID"))
            }
        }
    },
    computed: {
        ...ut("pagebuilder", ["page", "isDialogLayout", "isReporting"]),
        ...ut("pagebuilder/dialog", ["dirtyModelSettings"]),
        ...zt("pagebuilder", ["nodesReExecuting", "reExecutionUpdates"]),
        pageIdPrefix() {
            return this.page?.wizardPageContent?.webNodePageConfiguration?.projectRelativePageIDSuffix
        },
        nodeId() {
            return this.pageIdPrefix ? `${this.pageIdPrefix}:${this.viewConfig.nodeID}` : this.viewConfig.nodeID
        },
        webNodeConfig() {
            return this.page.wizardPageContent?.webNodes?.[this.nodeId]
        },
        uiExtensionConfig() {
            return this.page.wizardPageContent?.nodeViews?.[this.nodeId]
        },
        nodeInfo() {
            return (this.webNodeConfig || this.uiExtensionConfig)?.nodeInfo
        },
        isWebNodeView() {
            return Boolean(this.webNodeConfig)
        },
        isUIExtension() {
            return Boolean(this.uiExtensionConfig)
        },
        isNodeDialog() {
            return this.isUIExtension ? this.nodeId === "DIALOG" || this.uiExtensionConfig.extensionType === "dialog" : !1
        },
        isSingleView() {
            return this.isUIExtension && this.nodeId === "SINGLE"
        },
        isInComponentView() {
            return this.nodeId !== "SINGLE" && this.nodeId !== "DIALOG" && this.nodeId !== "VIEW"
        },
        isExecuted() {
            return this.nodeInfo?.nodeState === "executed"
        },
        isImageGeneration() {
            return this.isUIExtension && this.uiExtensionConfig?.generatedImageActionId
        },
        viewAvailable() {
            return this.isWebNodeView || this.isUIExtension
        },
        viewDisplayable() {
            return this.isUIExtension ? this.isExecuted || this.isImageGeneration || this.isDialogLayout || this.isNodeDialog : this.nodeInfo?.displayPossible
        },
        showViewExecutable() {
            return this.isUIExtension && !this.isNodeDialog && (!this.isExecuted || this.dirtyModelSettings) && !this.isImageGeneration
        },
        showExecutionOverlay() {
            let e = this.nodesReExecuting?.includes(this.nodeId);
            return this.isWebNodeView && !e && (e = this.nodeInfo?.nodeState === "executing"),
            e
        },
        showSpinner() {
            return this.reExecutionUpdates >= 2
        }
    }
}, Uze = {
    class: "node-view"
};
function qze(e, t, n, r, o, i) {
    const s = B("NotDisplayable"),
    a = B("ViewExecutable"),
    l = B("WebNode"),
    c = B("UIExtension"),
    u = B("ExecutingOverlay");
    return _(),
    O("div", Uze, [i.viewAvailable ? (_(), O(Le, {
                    key: 0
                }, [i.viewDisplayable ? i.showViewExecutable ? (_(), H(a, {
                                key: 1,
                                "extension-config": i.uiExtensionConfig
                            }, null, 8, ["extension-config"])) : i.isWebNodeView ? (_(), H(l, {
                                key: 2,
                                "view-config": n.viewConfig,
                                "node-config": i.webNodeConfig,
                                "node-id": i.nodeId
                            }, null, 8, ["view-config", "node-config", "node-id"])) : i.isUIExtension ? (_(), H(c, {
                                key: 3,
                                "view-config": n.viewConfig,
                                class: he({
                                    "single-view": i.isSingleView,
                                    "single-dialog": i.isNodeDialog && i.isSingleView,
                                    "view-and-dialog": !i.isNodeDialog && !i.isSingleView && !i.isInComponentView
                                }),
                                "extension-config": i.uiExtensionConfig,
                                "node-id": i.nodeId
                            }, null, 8, ["view-config", "class", "extension-config", "node-id"])) : J("", !0) : (_(), H(s, {
                                key: 0,
                                "node-info": i.nodeInfo,
                                "node-id": i.nodeId,
                                "show-error": !i.showExecutionOverlay
                            }, null, 8, ["node-info", "node-id", "show-error"])), z(u, {
                            show: i.showExecutionOverlay,
                            "show-spinner": i.showSpinner
                        }, null, 8, ["show", "show-spinner"])], 64)) : J("", !0)])
}
const j9 = te(Hze, [["render", qze], ["__scopeId", "data-v-72ce2b85"]]);
const Yze = 12, Kze = {
    components: {
        NodeView: j9,
        Row: Ha(() => Ks(() => Promise.resolve().then(() => eHe), void 0, import.meta.url))
    },
    props: {
        columnConfig: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return !(typeof e != "object" || !e.hasOwnProperty("content"))
            }
        }
    },
    computed: {
        ...ut("pagebuilder", ["isWebNode"]),
        content() {
            return hbe(this.columnConfig.content)
        },
        classes() {
            let e = ["col"],
            t = !1;
            return ["XS", "SM", "MD", "LG", "XL"].forEach((n, r) => {
                const o = this.columnConfig[`width${n}`];
                if (o > 0 && o <= Yze) {
                    t = !0;
                    const i = r ? `-${n.toLowerCase()}` : "";
                    e.push(`col${i}-${o}`)
                }
            }),
            t || e.push("col-12"),
            Array.isArray(this.columnConfig.additionalClasses) && (e = e.concat(this.columnConfig.additionalClasses)),
            this.isWebNode && e.push("col-padding"),
            e
        },
        styles() {
            return Array.isArray(this.columnConfig.additionalStyles) ? this.columnConfig.additionalStyles.join("; ").replace(/;;/g, ";") : null
        }
    }
}, Gze = ["innerHTML"];
function Xze(e, t, n, r, o, i) {
    const s = B("NodeView"),
    a = B("Row");
    return _(),
    O("div", {
        class: he(i.classes),
        style: Yt(i.styles)
    }, [(_(!0), O(Le, null, $t(i.content, (l, c) => (_(), O(Le, null, [l.type === "view" || l.type === "JSONLayoutViewContent" ? (_(), H(s, {
                                            key: c + "-" + Date.now(),
                                            "view-config": l
                                        }, null, 8, ["view-config"])) : l.type === "row" || l.type === "JSONLayoutRow" ? (_(), H(a, {
                                            key: c + "-" + l.type + "-1",
                                            "row-config": l
                                        }, null, 8, ["row-config"])) : (l.type === "nestedLayout" || l.type === "JSONNestedLayout") && l.layout ? (_(!0), O(Le, {
                                            key: 2
                                        }, $t(l.layout.rows, (u, f) => (_(), H(a, {
                                                        key: c + "-" + f + "-2",
                                                        "row-config": u
                                                    }, null, 8, ["row-config"]))), 128)) : l.type === "html" || l.type === "JSONLayoutHTMLContent" ? (_(), O("div", {
                                            key: c + "-" + l.type + "-3",
                                            innerHTML: l.value
                                        }, null, 8, Gze)) : J("", !0)], 64))), 256))], 6)
}
const Jze = te(Kze, [["render", Xze], ["__scopeId", "data-v-d09ab5ff"]]);
const Zze = {
    components: {
        Column: Jze
    },
    props: {
        rowConfig: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return !(typeof e != "object" || !e.hasOwnProperty("columns"))
            }
        }
    },
    computed: {
        columns() {
            return this.rowConfig.columns
        },
        classes() {
            let e = ["row"];
            return window.headless && e.push("headless"),
            Array.isArray(this.rowConfig.additionalClasses) && (e = e.concat(this.rowConfig.additionalClasses)),
            e
        },
        styles() {
            return Array.isArray(this.rowConfig.additionalStyles) ? this.rowConfig.additionalStyles.join("; ").replace(/;;/g, ";") : null
        }
    }
};
function Qze(e, t, n, r, o, i) {
    const s = B("Column");
    return _(),
    O("div", {
        class: he(i.classes),
        style: Yt(i.styles)
    }, [(_(!0), O(Le, null, $t(i.columns, (a, l) => (_(), H(s, {
                                key: l,
                                "column-config": a
                            }, null, 8, ["column-config"]))), 128))], 6)
}
const W9 = te(Zze, [["render", Qze], ["__scopeId", "data-v-35ed96d6"]]), eHe = Object.freeze(Object.defineProperty({
            __proto__: null,
        default:
            W9
        }, Symbol.toStringTag, {
            value: "Module"
        }));
const tHe = {
    components: {
        Row: W9
    },
    props: {
        layout: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return !(typeof e != "object" || !e.hasOwnProperty("rows"))
            }
        }
    },
    computed: {
        ...ut("pagebuilder", ["isReporting"])
    },
    mounted() {
        this.isReporting && this.$store.dispatch("pagebuilder/setReportingContent", {
            nodeId: "layout"
        })
    }
}, nHe = {
    id: "knime-layout",
    class: "container-fluid"
};
function rHe(e, t, n, r, o, i) {
    const s = B("Row");
    return _(),
    O("div", nHe, [(_(!0), O(Le, null, $t(n.layout.rows, (a, l) => (_(), H(s, {
                                key: l,
                                "row-config": a,
                                class: "parent-row"
                            }, null, 8, ["row-config"]))), 128))])
}
const oHe = te(tHe, [["render", rHe], ["__scopeId", "data-v-3a5a42fa"]]);
const iHe = {
    props: {
        type: {
            type: String,
        default:
            "info",
            validator(e = "info") {
                return ["info", "error", "success", "warn"].includes(e)
            }
        }
    }
}, sHe = {
    class: "grid-container"
}, aHe = {
    class: "grid-item-12"
};
function lHe(e, t, n, r, o, i) {
    return _(),
    O("section", {
        class: he(n.type)
    }, [P("div", sHe, [P("div", aHe, [Ye(e.$slots, "default", {}, void 0, !0)])])], 2)
}
const z9 = te(iHe, [["render", lHe], ["__scopeId", "data-v-da159f3a"]]);
const cHe = {
    components: {
        Button: Pr,
        CloseIcon: qu
    },
    props: {
        type: {
            type: String,
        default:
            "info",
            validator(e = "info") {
                return ["info", "error", "success", "warn"].includes(e)
            }
        },
        showCloseButton: {
            type: Boolean,
        default:
            !0
        },
        button: {
            type: String,
        default:
            null
        },
        count: {
            type: Number,
        default:
            1
        }
    },
    emits: ["dismiss"],
    methods: {
        onDismiss() {
            this.$emit("dismiss")
        }
    }
}, uHe = {
    class: "message"
};
function dHe(e, t, n, r, o, i) {
    const s = B("Button"),
    a = B("CloseIcon");
    return _(),
    O(Le, null, [Ye(e.$slots, "icon", {}, void 0, !0), P("span", uHe, [Ye(e.$slots, "default", {}, void 0, !0), Cn(P("span", {
                            class: he(["message-count", n.type])
                        }, Re("×" + n.count), 3), [[Kn, n.count && n.count > 1]])]), n.showCloseButton ? (_(), O(Le, {
                    key: 0
                }, [n.button ? (_(), H(s, {
                                key: 0,
                                class: he(["close", n.type]),
                                primary: "",
                                compact: "",
                                "on-dark": "",
                                onClick: i.onDismiss,
                                onKeydown: Rt(ve(i.onDismiss, ["stop", "prevent"]), ["space"])
                            }, {
                            default:
                                oe(() => [mt(Re(n.button), 1)]),
                                _: 1
                            }, 8, ["class", "onClick", "onKeydown"])) : (_(), O("span", {
                                key: 1,
                                tabindex: "0",
                                class: he(["close", n.type]),
                                title: "Discard message",
                                onClick: t[0] || (t[0] = (...l) => i.onDismiss && i.onDismiss(...l)),
                                onKeydown: t[1] || (t[1] = Rt(ve((...l) => i.onDismiss && i.onDismiss(...l), ["stop", "prevent"]), ["space"]))
                            }, [z(a, {
                                        class: "close-icon"
                                    })], 34))], 64)) : J("", !0)], 64)
}
const fHe = te(cHe, [["render", dHe], ["__scopeId", "data-v-c48c14a5"]]);
const hHe = {
    props: {
        isExpanded: {
            type: Boolean,
        default:
            !1
        }
    },
    methods: {
        onBeforeEnter(e) {
            e.style.height = 0
        },
        onEnter(e) {
            e.style.height = `${e.scrollHeight}px`
        },
        onAfterEnter(e) {
            e.style.height = ""
        },
        onBeforeLeave(e) {
            e.style.height = `${e.scrollHeight}px`,
            getComputedStyle(e).height
        },
        onLeave(e) {
            e.style.height = 0
        }
    }
}, pHe = {
    class: "panel"
};
function mHe(e, t, n, r, o, i) {
    return _(),
    H(ho, {
        name: "expand",
        onBeforeEnter: i.onBeforeEnter,
        onEnter: i.onEnter,
        onBeforeLeave: i.onBeforeLeave,
        onLeave: i.onLeave,
        onAfterEnter: i.onAfterEnter
    }, {
    default:
        oe(() => [Cn(P("div", pHe, [Ye(e.$slots, "default", {}, void 0, !0)], 512), [[Kn, n.isExpanded]])]),
        _: 3
    }, 8, ["onBeforeEnter", "onEnter", "onBeforeLeave", "onLeave", "onAfterEnter"])
}
const gHe = te(hHe, [["render", mHe], ["__scopeId", "data-v-3c5cf47f"]]);
const vHe = {
    components: {
        DropdownIcon: al,
        BaseButton: Z1,
        ExpandTransition: gHe
    },
    props: {
        initiallyExpanded: {
            type: Boolean,
        default:
            !1
        }
    },
    data() {
        return {
            isExpanded: this.initiallyExpanded
        }
    },
    methods: {
        onTrigger() {
            this.isExpanded = !this.isExpanded
        }
    }
}, yHe = {
    class: "dropdown"
};
function wHe(e, t, n, r, o, i) {
    const s = B("DropdownIcon"),
    a = B("BaseButton"),
    l = B("ExpandTransition");
    return _(),
    O("div", null, [z(a, {
                class: "button",
                "aria-expanded": String(o.isExpanded),
                onClick: ve(i.onTrigger, ["prevent"])
            }, {
            default:
                oe(() => [Ye(e.$slots, "title", {}, void 0, !0), P("div", yHe, [z(s, {
                                    class: he(["dropdown-icon", {
                                                flip: o.isExpanded
                                            }
                                        ])
                                }, null, 8, ["class"])])]),
                _: 3
            }, 8, ["aria-expanded", "onClick"]), z(l, {
                "is-expanded": o.isExpanded
            }, {
            default:
                oe(() => [Ye(e.$slots, "default", {}, void 0, !0)]),
                _: 3
            }, 8, ["is-expanded"])])
}
const bHe = te(vHe, [["render", wHe], ["__scopeId", "data-v-0f4e1b06"]]);
const _He = {
    props: {
        link: {
            type: Object,
        default:
            () => ({})
        }
    },
    computed: {
        linkComponent() {
            return hC()
        }
    }
}, kHe = ["href", "target"];
function xHe(e, t, n, r, o, i) {
    return n.link.to ? (_(), H(Kt(i.linkComponent), {
            key: 0,
            to: n.link.to,
            class: "message-link"
        }, {
        default:
            oe(() => [mt(Re(" " + n.link.text), 1)]),
            _: 1
        }, 8, ["to"])) : n.link.href ? (_(), O("a", {
            key: 1,
            href: n.link.href,
            target: n.link.newTab ? "_blank" : null,
            class: "message-link"
        }, Re(" " + n.link.text), 9, kHe)) : J("", !0)
}
const H9 = te(_He, [["render", xHe], ["__scopeId", "data-v-69663cbb"]]);
const SHe = {
    components: {
        BaseMessage: z9,
        MessageTitle: fHe,
        Collapser: bHe,
        MessageLink: H9,
        CopyIcon: lw
    },
    props: {
        type: {
            type: String,
        default:
            "info",
            validator(e = "info") {
                return ["info", "error", "success", "warn"].includes(e)
            }
        },
        showCloseButton: {
            type: Boolean,
        default:
            !0
        },
        showCollapser: {
            type: Boolean,
        default:
            !0
        },
        button: {
            type: String,
        default:
            null
        },
        count: {
            type: Number,
        default:
            1
        },
        details: {
            type: [String, Object],
        default:
            ""
        }
    },
    emits: ["copied", "dismiss"],
    data() {
        return {
            active: !0
        }
    },
    computed: {
        detailsText() {
            let e = this.details;
            return e && typeof e != "string" && (e = this.details.text),
            e
        },
        detailsLink() {
            return this.detailsText && this.details.link && this.details.link.text ? this.details.link : !1
        },
        showDetailsCollapser() {
            return this.detailsText && this.showCollapser
        }
    },
    methods: {
        onDismiss() {
            consola.trace("dismissing message"),
            this.active = !1,
            this.$emit("dismiss")
        },
        copyMessage(e) {
            $C(this.details),
            this.$emit("copied"),
            e.target.focus()
        }
    }
}, CHe = {
    key: 0,
    class: "title"
}, IHe = {
    key: 1,
    class: "details"
}, THe = {
    class: "detail-text"
};
function MHe(e, t, n, r, o, i) {
    const s = B("MessageTitle"),
    a = B("MessageLink"),
    l = B("CopyIcon"),
    c = B("BaseMessage");
    return o.active ? (_(), H(c, {
            key: 0,
            type: n.type,
            class: he(n.type)
        }, {
        default:
            oe(() => [(_(), H(Kt(i.showDetailsCollapser ? "Collapser" : "div"), {
                            class: he(i.showDetailsCollapser ? "collapser" : "banner")
                        }, tC({
                            default:
                                oe(() => [i.showDetailsCollapser ? J("", !0) : (_(), O("div", CHe, [z(s, {
                                                        type: n.type,
                                                        button: n.button,
                                                        "show-close-button": n.showCloseButton,
                                                        count: n.count,
                                                        onDismiss: i.onDismiss
                                                    }, {
                                                        icon: oe(() => [Ye(e.$slots, "icon", {}, void 0, !0)]),
                                                    default:
                                                        oe(() => [Ye(e.$slots, "default", {}, void 0, !0)]),
                                                        _: 3
                                                    }, 8, ["type", "button", "show-close-button", "count", "onDismiss"])])), i.detailsText ? (_(), O("div", IHe, [P("span", THe, [mt(Re(i.detailsText) + " ", 1), i.detailsLink ? (_(), H(a, {
                                                                    key: 0,
                                                                    link: i.detailsLink
                                                                }, null, 8, ["link"])) : J("", !0)]), n.showCollapser ? (_(), O("div", {
                                                            key: 0,
                                                            class: "copy-button",
                                                            title: "Copy to clipboard",
                                                            tabindex: "0",
                                                            onClick: t[0] || (t[0] = u => i.copyMessage(u)),
                                                            onKeyup: t[1] || (t[1] = Rt(ve(u => i.copyMessage(u), ["prevent"]), ["space"]))
                                                        }, [z(l)], 32)) : J("", !0)])) : J("", !0)]),
                                _: 2
                            }, [i.showDetailsCollapser ? {
                                        name: "title",
                                        fn: oe(() => [z(s, {
                                                    type: n.type,
                                                    button: n.button,
                                                    "show-close-button": n.showCloseButton,
                                                    count: n.count,
                                                    onDismiss: i.onDismiss
                                                }, {
                                                    icon: oe(() => [Ye(e.$slots, "icon", {}, void 0, !0)]),
                                                default:
                                                    oe(() => [Ye(e.$slots, "default", {}, void 0, !0)]),
                                                    _: 3
                                                }, 8, ["type", "button", "show-close-button", "count", "onDismiss"])]),
                                        key: "0"
                                    }
                                     : void 0]), 1032, ["class"]))]),
            _: 3
        }, 8, ["type", "class"])) : J("", !0)
}
const PHe = te(SHe, [["render", MHe], ["__scopeId", "data-v-8a76c532"]]);
const EHe = {
    components: {
        BaseMessage: z9,
        Message: PHe,
        MessageLink: H9
    },
    props: {
        messages: {
            type: Array,
        default:
            () => []
        }
    },
    emits: ["copied", "dismiss"]
};
function OHe(e, t, n, r, o, i) {
    const s = B("BaseMessage"),
    a = B("MessageLink"),
    l = B("Message");
    return _(),
    H(Qm, {
        class: he([{
                    active: n.messages.length > 0
                }, "messages"]),
        tag: "div",
        name: "messages"
    }, {
    default:
        oe(() => [(_(!0), O(Le, null, $t(n.messages, c => (_(), O(Le, {
                                    key: c.id
                                }, [c.content ? (_(), H(s, {
                                                key: 0,
                                                type: c.type.toLowerCase()
                                            }, {
                                            default:
                                                oe(() => [(_(), H(Kt(c.content)))]),
                                                _: 2
                                            }, 1032, ["type"])) : (_(), H(l, {
                                                key: 1,
                                                type: c.type.toLowerCase(),
                                                count: c.count,
                                                button: c.button,
                                                details: c.details,
                                                "show-close-button": c.showCloseButton,
                                                "show-collapser": c.showCollapser,
                                                class: he({
                                                    "offset-details": c.icon
                                                }),
                                                onCopied: t[0] || (t[0] = u => e.$emit("copied")),
                                                onDismiss: u => e.$emit("dismiss", c.id)
                                            }, {
                                                icon: oe(() => [(_(), H(Kt(c.icon)))]),
                                            default:
                                                oe(() => [mt(" " + Re(c.message) + " ", 1), c.link ? (_(), H(a, {
                                                                key: 0,
                                                                link: c.link
                                                            }, null, 8, ["link"])) : J("", !0)]),
                                                _: 2
                                            }, 1032, ["type", "count", "button", "details", "show-close-button", "show-collapser", "class", "onDismiss"]))], 64))), 128))]),
        _: 1
    }, 8, ["class"])
}
const $He = te(EHe, [["render", OHe], ["__scopeId", "data-v-6a24c03a"]]);
const AHe = {
    components: {
        NodeView: j9,
        Messages: $He
    },
    props: {
        layout: {
        default:
            () => ({}),
            type: Object,
            validate(e) {
                return !(typeof e != "object" || !e.hasOwnProperty("rows"))
            }
        }
    },
    computed: {
        ...zt({
            message: "pagebuilder/alert/alertAsMessage"
        }),
        columns() {
            return this.layout.rows[0].columns
        },
        dialogContent() {
            return this.columns[1].content[0]
        },
        viewContent() {
            return this.columns[0].content[0]
        },
        messages() {
            return this.message ? [this.message] : []
        },
        showMessages() {
            return Boolean(this.messages.length)
        }
    },
    methods: {
        onClose(e) {
            this.$store.dispatch("pagebuilder/alert/closeAlert", e)
        }
    }
}, DHe = {
    class: "layout"
}, NHe = {
    class: "item view"
}, RHe = {
    class: "item dialog"
};
function LHe(e, t, n, r, o, i) {
    const s = B("NodeView"),
    a = B("Messages");
    return _(),
    O("div", DHe, [P("div", NHe, [z(s, {
                        class: "view-content",
                        "view-config": i.viewContent
                    }, null, 8, ["view-config"]), i.showMessages ? (_(), H(a, {
                            key: 0,
                            class: "messages",
                            messages: i.messages,
                            onDismiss: i.onClose
                        }, null, 8, ["messages", "onDismiss"])) : J("", !0)]), P("div", RHe, [z(s, {
                        "view-config": i.dialogContent
                    }, null, 8, ["view-config"])])])
}
const BHe = te(AHe, [["render", LHe], ["__scopeId", "data-v-b40edc79"]]), VHe = {
    name: "Page",
    components: {
        Layout: oHe,
        DialogLayout: BHe
    },
    computed: {
        ...ut("pagebuilder", ["isDialogLayout"]),
        pageContent() {
            return this.$store.state.pagebuilder.page?.wizardPageContent
        },
        layout() {
            return this.pageContent?.webNodePageConfiguration?.layout
        }
    }
};
function FHe(e, t, n, r, o, i) {
    const s = B("DialogLayout"),
    a = B("Layout");
    return _(),
    O("div", null, [i.pageContent ? (_(), O(Le, {
                    key: 0
                }, [e.isDialogLayout ? (_(), H(s, {
                                key: 0,
                                layout: i.layout
                            }, null, 8, ["layout"])) : (_(), H(a, {
                                key: 1,
                                layout: i.layout
                            }, null, 8, ["layout"]))], 64)) : J("", !0)])
}
const jHe = te(VHe, [["render", FHe]]), WHe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, zHe = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), HHe = P("path", {
    d: "M9.9 16h12.2"
}, null, -1), UHe = [zHe, HHe];
function qHe(e, t) {
    return _(),
    O("svg", WHe, UHe)
}
const YHe = {
    render: qHe
};
const KHe = 280, GHe = {
    components: {
        Label: Xn,
        Button: Pr,
        FunctionButton: ti,
        SignWarningIcon: _I,
        CircleWarningIcon: Q1,
        CircleMinus: YHe,
        CloseIcon: qu,
        DropdownIcon: al,
        CopyIcon: lw
    },
    props: {
        type: {
            type: String,
        default:
            "error"
        },
        title: {
            type: String,
        default:
            ""
        },
        subtitle: {
            type: String,
        default:
            ""
        },
        messageBody: {
            type: String,
        default:
            ""
        }
    },
    emits: ["closeAlert"],
    data() {
        return {
            messageExpanded: !1
        }
    },
    computed: {
        expandable() {
            return this.messageBody?.length > KHe
        },
        expanded() {
            return !this.expandable || this.messageExpanded
        }
    },
    methods: {
        onClose(e) {
            this.$emit("closeAlert", e)
        },
        expandMessage() {
            this.messageExpanded = !this.messageExpanded
        },
        copyText() {
            $C(this.$refs.messageContent.textContent),
            this.$store.dispatch("notification/show", {
                message: "Text copied!",
                type: "success",
                autoRemove: !0
            }, {
                root: !0
            })
        }
    }
}, XHe = {
    key: 0,
    class: "message-body"
}, JHe = {
    class: "expand-controls"
}, ZHe = {
    key: 0,
    class: "expand-text"
}, QHe = {
    ref: "messageContent",
    class: "scrollable-message"
}, eUe = {
    class: "message-block"
}, tUe = {
    class: "copy-button-container"
};
function nUe(e, t, n, r, o, i) {
    const s = B("Label"),
    a = B("CircleMinus"),
    l = B("Button"),
    c = B("CloseIcon"),
    u = B("DropdownIcon"),
    f = B("CopyIcon"),
    p = B("FunctionButton");
    return _(),
    O("div", {
        class: he(["pop-over", {
                    expanded: i.expanded,
                    expandable: i.expandable
                }, n.type])
    }, [P("header", null, [(_(), H(Kt(n.type === "error" ? "SignWarningIcon" : "CircleWarningIcon"), {
                            class: "icon warn-icon"
                        })), z(s, {
                        text: n.title,
                        class: "label",
                        large: ""
                    }, null, 8, ["text"]), n.type !== "warn" ? (_(), H(l, {
                            key: 0,
                            title: "Minimize",
                            class: "minimize-button",
                            onClick: t[0] || (t[0] = m => i.onClose())
                        }, {
                        default:
                            oe(() => [z(a, {
                                        class: "icon minimize-icon"
                                    })]),
                            _: 1
                        })) : J("", !0), z(l, {
                        title: "Close",
                        class: "close-button",
                        onClick: t[1] || (t[1] = m => i.onClose(!0))
                    }, {
                    default:
                        oe(() => [z(c, {
                                    class: "icon"
                                })]),
                        _: 1
                    })]), n.messageBody ? (_(), O("div", XHe, [P("div", JHe, [P("span", null, Re(n.subtitle), 1), i.expandable ? (_(), O("span", ZHe, [mt(" (See " + Re(i.expanded ? "less" : "more") + ") ", 1), z(l, {
                                                class: "expand-button",
                                                title: "Show more",
                                                onClick: i.expandMessage
                                            }, {
                                            default:
                                                oe(() => [z(u)]),
                                                _: 1
                                            }, 8, ["onClick"])])) : J("", !0)]), z(ho, {
                            name: "message-fade"
                        }, {
                        default:
                            oe(() => [Cn(P("div", QHe, [Ye(e.$slots, "messageBodyHeader", {}, void 0, !0), P("span", eUe, Re(n.messageBody), 1)], 512), [[Kn, i.expanded]])]),
                            _: 3
                        }), P("div", tUe, [Cn(z(p, {
                                        compact: !0,
                                        class: "copy-button",
                                        onClick: i.copyText
                                    }, {
                                    default:
                                        oe(() => [z(f), mt(" Copy Text ")]),
                                        _: 1
                                    }, 8, ["onClick"]), [[Kn, i.expanded]])])])) : J("", !0)], 2)
}
const rUe = te(GHe, [["render", nUe], ["__scopeId", "data-v-a3c5e1f2"]]);
const oUe = {
    components: {
        Popover: F7,
        PopoverMessage: rUe
    },
    computed: {
        ...ut("pagebuilder/alert", ["alert"]),
        type() {
            return this.alert?.type || "error"
        },
        isError() {
            return this.type === "error"
        },
        nodeId() {
            return this.alert?.nodeId || ""
        },
        nodeInfo() {
            return this.alert?.nodeInfo || {}
        },
        nodeName() {
            return this.nodeInfo.nodeName || "Missing node"
        },
        title() {
            return `${this.isError ? "ERROR" : "WARNING"}: ${this.nodeName}`
        },
        subtitle() {
            return this.alert?.subtitle && this.alert?.message ? this.alert.subtitle : this.isError ? "Sorry, a problem occurred:" : "Message(s) on node:"
        },
        messageText() {
            return this.alert?.message || this.alert?.subtitle || "No further information available. Please check the workflow configuration."
        }
    },
    methods: {
        onClose(e) {
            this.$store.dispatch("pagebuilder/alert/closeAlert", e)
        }
    }
}, U9 = e => (ir("data-v-d5e9b3ad"), e = e(), sr(), e), iUe = {
    key: 0
}, sUe = U9(() => P("span", {
            class: "info-header"
        }, "Node:", -1)), aUe = U9(() => P("span", {
            class: "info-header"
        }, "Message:", -1));
function lUe(e, t, n, r, o, i) {
    const s = B("PopoverMessage"),
    a = B("Popover");
    return _(),
    H(a, {
        class: "container",
        active: Boolean(e.alert),
        level: "global",
        onClickAway: t[0] || (t[0] = l => i.onClose(!i.isError))
    }, {
        popoverContent: oe(() => [z(s, {
                    type: i.type,
                    title: i.title,
                    subtitle: i.subtitle,
                    "message-body": i.messageText,
                    onCloseAlert: i.onClose
                }, {
                    messageBodyHeader: oe(() => [i.isError ? (_(), O("span", iUe, [sUe, mt(" " + Re(`${i.nodeId} ${i.nodeInfo.nodeAnnotation ? "(" + i.nodeInfo.nodeAnnotation + ")" : ""}
`) + " ", 1), aUe])) : J("", !0)]),
                    _: 1
                }, 8, ["type", "title", "subtitle", "message-body", "onCloseAlert"])]),
        _: 1
    }, 8, ["active"])
}
const cUe = te(oUe, [["render", lUe], ["__scopeId", "data-v-d5e9b3ad"]]), uUe = {
    components: {
        Page: jHe,
        AlertGlobal: cUe
    },
    initStore(e) {
        e.registerModule("pagebuilder", Pwe),
        e.registerModule("pagebuilder/interactivity", Gwe),
        e.registerModule("pagebuilder/alert", tbe),
        e.registerModule("pagebuilder/service", sbe),
        e.registerModule("pagebuilder/dialog", dbe)
    },
    computed: {
        ...ut("pagebuilder", ["isDialogLayout", "isReporting"]),
        hasPage() {
            let e = this.$store.state.pagebuilder.page;
            return Boolean(e?.wizardPageContent)
        }
    }
};
function dUe(e, t, n, r, o, i) {
    const s = B("Page"),
    a = B("AlertGlobal");
    return _(),
    O("div", null, [i.hasPage ? (_(), H(s, {
                    key: 0
                })) : J("", !0), !e.isDialogLayout && !e.isReporting ? (_(), H(a, {
                    key: 1
                })) : J("", !0)])
}
const q9 = te(uUe, [["render", dUe]]), fUe = {
    "@class": "org.knime.js.core.JSONWebNodePage",
    webNodePageConfiguration: {
        "@class": "org.knime.js.core.JSONWebNodePageConfiguration",
        layout: {
            parentLayoutLegacyMode: !1,
            rows: [{
                    type: "JSONLayoutRow",
                    additionalClasses: [],
                    additionalStyles: [],
                    columns: [{
                            content: [{
                                    type: "JSONLayoutViewContent",
                                    resizeMethod: "viewLowestElement",
                                    useLegacyMode: !1,
                                    scrolling: !1,
                                    minWidth: null,
                                    minHeight: null,
                                    maxWidth: null,
                                    maxHeight: null,
                                    nodeID: "ROOT",
                                    resizeInterval: null,
                                    resizeTolerance: 5,
                                    autoResize: !0,
                                    sizeHeight: !0,
                                    sizeWidth: !1,
                                    additionalClasses: [],
                                    additionalStyles: []
                                }
                            ],
                            widthXS: null,
                            widthSM: null,
                            widthMD: null,
                            widthLG: null,
                            widthXL: null,
                            additionalClasses: [],
                            additionalStyles: []
                        }
                    ]
                }
            ]
        },
        blackBoard: null,
        selectionTranslators: null,
        version: "4.7.0.qualifier",
        projectRelativePageIDSuffix: null
    },
    webNodes: {},
    version: "4.7.0.qualifier",
    nodeViews: {
        ROOT: {}
    }
}, hUe = {
    wizardPageContent: fUe
};
const pUe = {
    components: {
        PageBuilder: q9
    },
    emits: ["stateChange"],
    data() {
        return {
            isReady: !1
        }
    },
    computed: {
        ...ut("application", {
            projectId: "activeProjectId"
        }),
        ...ut("workflow", {
            workflowId: e => e.activeWorkflow.info.containerId
        }),
        ...zt("selection", {
            selectedNode: "singleSelectedNode"
        }),
        hasView() {
            return Boolean(this.selectedNode?.hasView)
        }
    },
    watch: {
        selectedNode: {
            handler(e) {
                e?.hasView && this.loadContent(e.id)
            }
        }
    },
    async created() {
        try {
            this.$emit("stateChange", {
                state: "loading",
                message: "Loading view"
            }),
            await this.loadContent(),
            this.isReady = !0,
            this.$emit("stateChange", {
                state: "ready"
            })
        } catch (e) {
            this.$emit("stateChange", {
                state: "error",
                message: e
            })
        }
    },
    methods: {
        async loadContent() {
            try {
                if (!this.selectedNode)
                    return;
                const e = await Oe.node.getNodeView({
                    projectId: this.projectId,
                    workflowId: this.workflowId,
                    nodeId: this.selectedNode.id
                }),
                t = JSON.parse(JSON.stringify(hUe));
                return t.wizardPageContent.nodeViews.ROOT = e,
                this.$store.dispatch("pagebuilder/setPage", {
                    page: t
                })
            } catch (e) {
                throw consola.log("Error loading view content", e),
                e
            }
        }
    }
};
function mUe(e, t, n, r, o, i) {
    const s = B("PageBuilder");
    return o.isReady ? (_(), H(s, {
            key: 0,
            class: "page-builder"
        })) : J("", !0)
}
const gUe = te(pUe, [["render", mUe], ["__scopeId", "data-v-c50b5331"]]), vUe = ({
    selectedNode: e,
    portTypes: t
}) => {
    const r = wI(O7, $7)({
        selectedNode: e,
        portTypes: t
    })();
    return Object.freeze(r)
}, yUe = {
    components: {
        NodeViewLoader: gUe
    },
    props: {
        projectId: {
            type: String,
            required: !0
        },
        workflowId: {
            type: String,
            required: !0
        },
        selectedNode: {
            type: Object,
            required: !0
        },
        availablePortTypes: {
            type: Object,
            required: !0
        }
    },
    emits: ["outputStateChange"],
    data() {
        return {
            nodeViewState: null
        }
    },
    computed: {
        nodeErrors() {
            const {
                error: e
            } = vUe({
                selectedNode: this.selectedNode,
                portTypes: this.availablePortTypes
            });
            return e
        }
    },
    watch: {
        nodeErrors: {
            immediate: !0,
            handler() {
                this.nodeErrors && this.$emit("outputStateChange", {
                    loading: this.nodeErrors.code === "NODE_BUSY",
                    message: this.nodeErrors.message,
                    error: this.nodeErrors
                })
            }
        }
    },
    methods: {
        onNodeViewStateChange(e) {
            switch (this.nodeViewState = e, this.nodeViewState?.state) {
            case "loading": {
                    this.$emit("outputStateChange", {
                        message: "Loading data",
                        loading: !0
                    });
                    return
                }
            case "error": {
                    this.$emit("outputStateChange", {
                        message: this.nodeViewState.message
                    });
                    return
                }
            default:
                this.$emit("outputStateChange", null)
            }
        }
    }
};
function wUe(e, t, n, r, o, i) {
    const s = B("NodeViewLoader");
    return i.nodeErrors ? J("", !0) : (_(), H(s, {
            key: 0,
            kind: "node-view",
            onStateChange: i.onNodeViewStateChange
        }, null, 8, ["onStateChange"]))
}
const bUe = te(yUe, [["render", wUe]]), _Ue = ({
    selectedNodes: e,
    isDragging: t
}) => {
    const r = wI(H1e, U1e)({
        selectedNodes: e,
        isDragging: t
    })();
    return Object.freeze(r)
}, kUe = Fe({
    components: {
        PortTabs: h1e,
        ReloadIcon: cg,
        PortViewTabOutput: _we,
        NodeViewTabOutput: bUe,
        Button: Pr,
        PlayIcon: b7
    },
    data() {
        return {
            selectedTab: null,
            outputState: null
        }
    },
    computed: {
        ...ut("application", {
            projectId: e => e.activeProjectId,
            availablePortTypes: e => e.availablePortTypes
        }),
        ...ut("workflow", {
            workflowId: e => e.activeWorkflow.info.containerId,
            isDragging: e => e.isDragging
        }),
        ...zt("selection", ["selectedNodes", "singleSelectedNode"]),
        canSelectTabs() {
            return !this.outputState?.error || this.outputState?.error?.code !== "NO_SUPPORTED_PORTS" && this.outputState?.error?.code !== "NODE_DRAGGING"
        },
        isViewTabSelected() {
            return this.selectedTab === "view"
        },
        selectedPortIndex() {
            return this.isViewTabSelected ? null : Number(this.selectedTab)
        },
        validationErrors() {
            const {
                error: e
            } = _Ue({
                selectedNodes: this.selectedNodes,
                isDragging: this.isDragging
            });
            return e
        },
        canExecute() {
            return x7(this.singleSelectedNode, this.selectedPortIndex)
        },
        isExecuted() {
            return S7(this.singleSelectedNode, this.selectedPortIndex) === "EXECUTED"
        }
    },
    watch: {
        validationErrors: {
            handler(e) {
                e ? this.outputState = {
                    message: this.validationErrors.message,
                    error: e
                }
                 : this.selectPort()
            },
            immediate: !0,
            deep: !0
        }
    },
    methods: {
        selectPort() {
            let {
                outPorts: e,
                kind: t
            } = this.singleSelectedNode;
            if (this.singleSelectedNode.hasView && this.$features.shouldDisplayEmbeddedViews()) {
                this.selectedTab = "view";
                return
            }
            if (t === "metanode") {
                this.selectedTab = "0";
                return
            }
            this.selectedTab = e.length > 1 ? "1" : "0"
        },
        openLegacyPortView(e = !1) {
            this.$store.dispatch("workflow/openLegacyPortView", {
                nodeId: this.singleSelectedNode.id,
                portIndex: this.selectedPortIndex,
                executeNode: e
            })
        }
    }
});
const xUe = {
    id: "node-output",
    class: "output-container"
}, SUe = {
    key: 1,
    "data-testid": "execute-open-legacy-view-action"
};
function CUe(e, t, n, r, o, i) {
    const s = B("PortTabs"),
    a = B("ReloadIcon"),
    l = B("PlayIcon"),
    c = B("Button"),
    u = B("NodeViewTabOutput"),
    f = B("PortViewTabOutput");
    return _(),
    O("div", xUe, [e.singleSelectedNode && e.singleSelectedNode.outPorts.length ? (_(), H(s, {
                    key: 0,
                    modelValue: e.selectedTab,
                    "onUpdate:modelValue": t[0] || (t[0] = p => e.selectedTab = p),
                    "has-view-tab": e.singleSelectedNode.hasView,
                    node: e.singleSelectedNode,
                    disabled: !e.canSelectTabs
                }, null, 8, ["modelValue", "has-view-tab", "node", "disabled"])) : J("", !0), e.outputState ? (_(), O("div", {
                    key: 1,
                    class: he(["placeholder", {
                                "is-viewer-loading": e.outputState.loading
                            }
                        ])
                }, [P("span", null, [e.outputState.loading ? (_(), H(a, {
                                        key: 0,
                                        class: "loading-icon"
                                    })) : J("", !0), mt(" " + Re(e.outputState.message) + " ", 1), e.outputState?.error?.code === "NO_SUPPORTED_VIEW" ? (_(), O("div", SUe, [e.isExecuted ? J("", !0) : (_(), H(c, {
                                                    key: 0,
                                                    class: "action-button action-execute",
                                                    primary: "",
                                                    disabled: !e.canExecute,
                                                    compact: "",
                                                    onClick: t[1] || (t[1] = p => e.openLegacyPortView(!0))
                                                }, {
                                                default:
                                                    oe(() => [z(l), mt(" Execute and open legacy port view ")]),
                                                    _: 1
                                                }, 8, ["disabled"])), z(c, {
                                                "with-border": !e.isExecuted,
                                                class: he(["action-button", {
                                                            "dim-border": !e.isExecuted
                                                        }
                                                    ]),
                                                primary: e.isExecuted,
                                                compact: "",
                                                onClick: t[2] || (t[2] = p => e.openLegacyPortView(!1))
                                            }, {
                                            default:
                                                oe(() => [mt(" Open legacy port view ")]),
                                                _: 1
                                            }, 8, ["with-border", "class", "primary"])])) : J("", !0)])], 2)) : J("", !0), e.validationErrors ? J("", !0) : (_(), O(Le, {
                    key: 2
                }, [e.isViewTabSelected && e.$features.shouldDisplayEmbeddedViews() ? (_(), H(u, {
                                key: 0,
                                "project-id": e.projectId,
                                "workflow-id": e.workflowId,
                                "selected-node": e.singleSelectedNode,
                                "available-port-types": e.availablePortTypes,
                                class: "output",
                                onOutputStateChange: t[3] || (t[3] = p => e.outputState = p)
                            }, null, 8, ["project-id", "workflow-id", "selected-node", "available-port-types"])) : J("", !0), e.isViewTabSelected ? J("", !0) : (_(), H(f, {
                                key: 1,
                                "project-id": e.projectId,
                                "workflow-id": e.workflowId,
                                "selected-node": e.singleSelectedNode,
                                "selected-port-index": e.selectedPortIndex,
                                "available-port-types": e.availablePortTypes,
                                class: "output",
                                onOutputStateChange: t[4] || (t[4] = p => e.outputState = p),
                                onExecuteNode: t[5] || (t[5] = p => e.$store.dispatch("workflow/executeNodes", [e.singleSelectedNode.id]))
                            }, null, 8, ["project-id", "workflow-id", "selected-node", "selected-port-index", "available-port-types"]))], 64))])
}
const IUe = te(kUe, [["render", CUe], ["__scopeId", "data-v-6543108e"]]), TUe = ["error", "warning", "default"], MUe = ["bottom", "top"], tT = Fe({
    props: {
        text: {
            type: [String, Number],
        default:
            null
        },
        title: {
            type: String,
        default:
            null
        },
        issue: {
            type: String,
        default:
            null
        },
        resolutions: {
            type: Array,
        default:
            () => []
        },
        x: {
            type: Number,
        default:
            0
        },
        y: {
            type: Number,
        default:
            0
        },
        type: {
            type: String,
        default:
            "default",
            validator: e => TUe.includes(e)
        },
        orientation: {
            type: String,
        default:
            "bottom",
            validator: e => MUe.includes(e)
        },
        gap: {
            type: Number,
        default:
            0
        },
        hoverable: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        expandedGap() {
            return this.gap + this.$shapes.tooltipArrowSize * Math.SQRT1_2
        }
    }
}), nN = () => {
    to(e => ({
            d6e04ac4: e.$colors.warning,
            dafc54ec: e.$colors.error
        }))
}, rN = tT.setup;
tT.setup = rN ? (e, t) => (nN(), rN(e, t)) : nN;
const PUe = {
    class: "wrap-arrow"
}, EUe = {
    key: 0,
    class: "title"
}, OUe = {
    key: 1,
    class: "text"
}, $Ue = ["textContent"], AUe = {
    key: 3,
    class: "resolutions"
};
function DUe(e, t, n, r, o, i) {
    return _(),
    O("div", {
        class: he(["tooltip", e.orientation, e.type, {
                    hoverable: e.hoverable
                }
            ]),
        style: Yt({
            "--arrow-size": `${e.$shapes.tooltipArrowSize}px`,
            "--gap-size": `${e.expandedGap}px`,
            top: `${e.y}px`,
            left: `${e.x}px`,
            maxWidth: `${e.$shapes.tooltipMaxWidth}px`
        })
    }, [P("div", PUe, [P("div", {
                        class: "scroller",
                        style: Yt({
                            maxHeight: `${e.$shapes.tooltipMaxHeight}px`
                        })
                    }, [e.title ? (_(), O("div", EUe, Re(e.title), 1)) : J("", !0), e.text ? (_(), O("p", OUe, Re(e.text), 1)) : J("", !0), e.issue ? (_(), O("div", {
                                    key: 2,
                                    class: "issue",
                                    textContent: Re(e.issue)
                                }, null, 8, $Ue)) : J("", !0), e.resolutions.length ? (_(), O("div", AUe, [mt(" Potential resolutions: "), P("ul", null, [(_(!0), O(Le, null, $t(e.resolutions, s => (_(), O("li", {
                                                                    key: s
                                                                }, Re(s), 1))), 128))])])) : J("", !0)], 4)])], 6)
}
const NUe = te(tT, [["render", DUe], ["__scopeId", "data-v-d6e7955c"]]);
const RUe = {
    components: {
        Tooltip: NUe
    },
    data: () => ({
        position: null
    }),
    computed: {
        ...ut("workflow", ["tooltip"]),
        ...ut("canvas", ["zoomFactor"]),
        ...zt("canvas", ["screenFromCanvasCoordinates"]),
        zoomedGap() {
            return Math.sqrt(this.zoomFactor) * (this.tooltip.gap || 0)
        }
    },
    watch: {
        tooltip(e, t) {
            t ? e || this.closeTooltip() : (this.setPosition(), this.openTooltip())
        }
    },
    beforeUnmount() {
        this.closeTooltip()
    },
    methods: {
        setPosition() {
            if (!this.tooltip) {
                this.position = null;
                return
            }
            let {
                anchorPoint: e = {
                    x: 0,
                    y: 0
                },
                position: t
            } = this.tooltip;
            this.position = this.screenFromCanvasCoordinates({
                x: e.x + t.x,
                y: e.y + t.y
            })
        },
        openTooltip() {
            consola.trace("add kanvas scroll listener for tooltips"),
            document.getElementById("kanvas").addEventListener("scroll", this.onCanvasScroll)
        },
        closeTooltip() {
            consola.trace("remove kanvas scroll listener for tooltips"),
            document.getElementById("kanvas")?.removeEventListener("scroll", this.onCanvasScroll)
        },
        onMouseLeave() {
            this.$store.commit("workflow/setTooltip", null)
        },
        onCanvasScroll() {
            consola.trace("scrolling canvas while tooltip is open"),
            this.setPosition()
        }
    }
}, LUe = {
    class: "tooltip-container"
};
function BUe(e, t, n, r, o, i) {
    const s = B("Tooltip");
    return _(),
    O("div", LUe, [z(ho, {
                name: "tooltip"
            }, {
            default:
                oe(() => [e.tooltip ? (_(), H(s, {
                                key: 0,
                                x: e.position.x,
                                y: e.position.y,
                                gap: i.zoomedGap,
                                text: e.tooltip.text,
                                title: e.tooltip.title,
                                issue: e.tooltip.issue,
                                resolutions: e.tooltip.resolutions,
                                orientation: e.tooltip.orientation,
                                hoverable: e.tooltip.hoverable,
                                type: e.tooltip.type,
                                onMouseleave: i.onMouseLeave,
                                onWheel: t[0] || (t[0] = ve(() => {}, ["ctrl", "prevent"]))
                            }, null, 8, ["x", "y", "gap", "text", "title", "issue", "resolutions", "orientation", "hoverable", "type", "onMouseleave"])) : J("", !0)]),
                _: 1
            })])
}
const VUe = te(RUe, [["render", BUe], ["__scopeId", "data-v-98cb3a3d"]]), FUe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, jUe = P("path", {
    d: "M16 12.31V2.18M12.78 5.4 16 2.18l3.22 3.22m.47 10.6h10.13m-3.22-3.22L29.82 16l-3.22 3.22m-10.6.47v10.13m3.22-3.22L16 29.82l-3.22-3.22M12.31 16H2.18m3.22 3.22L2.18 16l3.22-3.22"
}, null, -1), WUe = [jUe];
function zUe(e, t) {
    return _(),
    O("svg", FUe, WUe)
}
const Y9 = {
    render: zUe
}, Fv = e => {
    e.preventDefault(),
    e.stopPropagation(),
    e.stopImmediatePropagation()
}, HUe = ({
    getNextElement: e,
    getFirstElement: t,
    getLastElement: n,
    close: r,
    disableSpaceToClick: o
}) => {
    const i = De(null),
    s = () => {};
    let a = s;
    const l = () => {
        i.value = null,
        a = s
    },
    c = m => {
        i.value = m.index,
        a = m.onClick
    },
    u = m => {
        c(e(i.value, m))
    },
    f = () => {
        l(),
        r()
    };
    return {
        onKeydown: m => {
            switch (m.code) {
            case "ArrowDown":
                Fv(m),
                u(1);
                break;
            case "ArrowUp":
                Fv(m),
                u(-1);
                break;
            case "Enter":
            case "Space": {
                    const v = m.code === "Enter",
                    y = m.code === "Space";
                    i.value !== null && (v || y && !o) && (Fv(m), a());
                    break
                }
            case "Home":
                t && c(t());
                break;
            case "End":
                n && c(n());
                break;
            case "Escape":
                Fv(m),
                f();
                break;
            case "Tab":
                f();
                break
            }
        },
        currentIndex: i,
        resetNavigation: l
    }
}, UUe = (e, t) => (e % t + t) % t;
var Go = "top", ss = "bottom", as = "right", Xo = "left", nT = "auto", _g = [Go, ss, as, Xo], Nf = "start", Nm = "end", qUe = "clippingParents", K9 = "viewport", tp = "popper", YUe = "reference", oN = _g.reduce(function (e, t) {
    return e.concat([t + "-" + Nf, t + "-" + Nm])
}, []), G9 = [].concat(_g, [nT]).reduce(function (e, t) {
    return e.concat([t, t + "-" + Nf, t + "-" + Nm])
}, []), KUe = "beforeRead", GUe = "read", XUe = "afterRead", JUe = "beforeMain", ZUe = "main", QUe = "afterMain", eqe = "beforeWrite", tqe = "write", nqe = "afterWrite", rqe = [KUe, GUe, XUe, JUe, ZUe, QUe, eqe, tqe, nqe];
function ma(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function hs(e) {
    if (e == null)
        return window;
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t && t.defaultView || window
    }
    return e
}
function Du(e) {
    var t = hs(e).Element;
    return e instanceof t || e instanceof Element
}
function Zi(e) {
    var t = hs(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}
function rT(e) {
    if (typeof ShadowRoot > "u")
        return !1;
    var t = hs(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}
function oqe(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function (n) {
        var r = t.styles[n] || {},
        o = t.attributes[n] || {},
        i = t.elements[n];
        !Zi(i) || !ma(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function (s) {
                var a = o[s];
                a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a)
            }))
    })
}
function iqe(e) {
    var t = e.state,
    n = {
        popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(t.elements.popper.style, n.popper),
    t.styles = n,
    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
    function () {
        Object.keys(t.elements).forEach(function (r) {
            var o = t.elements[r],
            i = t.attributes[r] || {},
            s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]),
            a = s.reduce(function (l, c) {
                return l[c] = "",
                l
            }, {});
            !Zi(o) || !ma(o) || (Object.assign(o.style, a), Object.keys(i).forEach(function (l) {
                    o.removeAttribute(l)
                }))
        })
    }
}
const sqe = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: oqe,
    effect: iqe,
    requires: ["computeStyles"]
};
function aa(e) {
    return e.split("-")[0]
}
var fu = Math.max, qy = Math.min, Rf = Math.round;
function Yx() {
    var e = navigator.userAgentData;
    return e != null && e.brands ? e.brands.map(function (t) {
        return t.brand + "/" + t.version
    }).join(" ") : navigator.userAgent
}
function X9() {
    return !/^((?!chrome|android).)*safari/i.test(Yx())
}
function Lf(e, t, n) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !1);
    var r = e.getBoundingClientRect(),
    o = 1,
    i = 1;
    t && Zi(e) && (o = e.offsetWidth > 0 && Rf(r.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && Rf(r.height) / e.offsetHeight || 1);
    var s = Du(e) ? hs(e) : window,
    a = s.visualViewport,
    l = !X9() && n,
    c = (r.left + (l && a ? a.offsetLeft : 0)) / o,
    u = (r.top + (l && a ? a.offsetTop : 0)) / i,
    f = r.width / o,
    p = r.height / i;
    return {
        width: f,
        height: p,
        top: u,
        right: c + f,
        bottom: u + p,
        left: c,
        x: c,
        y: u
    }
}
function oT(e) {
    var t = Lf(e),
    n = e.offsetWidth,
    r = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width),
    Math.abs(t.height - r) <= 1 && (r = t.height), {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: n,
        height: r
    }
}
function J9(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t))
        return !0;
    if (n && rT(n)) {
        var r = t;
        do {
            if (r && e.isSameNode(r))
                return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}
function Qa(e) {
    return hs(e).getComputedStyle(e)
}
function aqe(e) {
    return ["table", "td", "th"].indexOf(ma(e)) >= 0
}
function vc(e) {
    return ((Du(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function Uw(e) {
    return ma(e) === "html" ? e : e.assignedSlot || e.parentNode || (rT(e) ? e.host : null) || vc(e)
}
function iN(e) {
    return !Zi(e) || Qa(e).position === "fixed" ? null : e.offsetParent
}
function lqe(e) {
    var t = /firefox/i.test(Yx()),
    n = /Trident/i.test(Yx());
    if (n && Zi(e)) {
        var r = Qa(e);
        if (r.position === "fixed")
            return null
    }
    var o = Uw(e);
    for (rT(o) && (o = o.host); Zi(o) && ["html", "body"].indexOf(ma(o)) < 0; ) {
        var i = Qa(o);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || t && i.willChange === "filter" || t && i.filter && i.filter !== "none")
            return o;
        o = o.parentNode
    }
    return null
}
function kg(e) {
    for (var t = hs(e), n = iN(e); n && aqe(n) && Qa(n).position === "static"; )
        n = iN(n);
    return n && (ma(n) === "html" || ma(n) === "body" && Qa(n).position === "static") ? t : n || lqe(e) || t
}
function iT(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function Fp(e, t, n) {
    return fu(e, qy(t, n))
}
function cqe(e, t, n) {
    var r = Fp(e, t, n);
    return r > n ? n : r
}
function Z9() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function Q9(e) {
    return Object.assign({}, Z9(), e)
}
function eF(e, t) {
    return t.reduce(function (n, r) {
        return n[r] = e,
        n
    }, {})
}
var uqe = function (t, n) {
    return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
                placement: n.placement
            })) : t,
    Q9(typeof t != "number" ? t : eF(t, _g))
};
function dqe(e) {
    var t,
    n = e.state,
    r = e.name,
    o = e.options,
    i = n.elements.arrow,
    s = n.modifiersData.popperOffsets,
    a = aa(n.placement),
    l = iT(a),
    c = [Xo, as].indexOf(a) >= 0,
    u = c ? "height" : "width";
    if (!(!i || !s)) {
        var f = uqe(o.padding, n),
        p = oT(i),
        m = l === "y" ? Go : Xo,
        v = l === "y" ? ss : as,
        y = n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u],
        b = s[l] - n.rects.reference[l],
        w = kg(i),
        k = w ? l === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0,
        C = y / 2 - b / 2,
        x = f[m],
        S = k - p[u] - f[v],
        T = k / 2 - p[u] / 2 + C,
        E = Fp(x, T, S),
        M = l;
        n.modifiersData[r] = (t = {}, t[M] = E, t.centerOffset = E - T, t)
    }
}
function fqe(e) {
    var t = e.state,
    n = e.options,
    r = n.element,
    o = r === void 0 ? "[data-popper-arrow]" : r;
    o != null && (typeof o == "string" && (o = t.elements.popper.querySelector(o), !o) || J9(t.elements.popper, o) && (t.elements.arrow = o))
}
const hqe = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: dqe,
    effect: fqe,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function Bf(e) {
    return e.split("-")[1]
}
var pqe = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function mqe(e) {
    var t = e.x,
    n = e.y,
    r = window,
    o = r.devicePixelRatio || 1;
    return {
        x: Rf(t * o) / o || 0,
        y: Rf(n * o) / o || 0
    }
}
function sN(e) {
    var t,
    n = e.popper,
    r = e.popperRect,
    o = e.placement,
    i = e.variation,
    s = e.offsets,
    a = e.position,
    l = e.gpuAcceleration,
    c = e.adaptive,
    u = e.roundOffsets,
    f = e.isFixed,
    p = s.x,
    m = p === void 0 ? 0 : p,
    v = s.y,
    y = v === void 0 ? 0 : v,
    b = typeof u == "function" ? u({
        x: m,
        y
    }) : {
        x: m,
        y
    };
    m = b.x,
    y = b.y;
    var w = s.hasOwnProperty("x"),
    k = s.hasOwnProperty("y"),
    C = Xo,
    x = Go,
    S = window;
    if (c) {
        var T = kg(n),
        E = "clientHeight",
        M = "clientWidth";
        if (T === hs(n) && (T = vc(n), Qa(T).position !== "static" && a === "absolute" && (E = "scrollHeight", M = "scrollWidth")), T = T, o === Go || (o === Xo || o === as) && i === Nm) {
            x = ss;
            var N = f && T === S && S.visualViewport ? S.visualViewport.height : T[E];
            y -= N - r.height,
            y *= l ? 1 : -1
        }
        if (o === Xo || (o === Go || o === ss) && i === Nm) {
            C = as;
            var F = f && T === S && S.visualViewport ? S.visualViewport.width : T[M];
            m -= F - r.width,
            m *= l ? 1 : -1
        }
    }
    var K = Object.assign({
        position: a
    }, c && pqe),
    j = u === !0 ? mqe({
        x: m,
        y
    }) : {
        x: m,
        y
    };
    if (m = j.x, y = j.y, l) {
        var G;
        return Object.assign({}, K, (G = {}, G[x] = k ? "0" : "", G[C] = w ? "0" : "", G.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + y + "px)" : "translate3d(" + m + "px, " + y + "px, 0)", G))
    }
    return Object.assign({}, K, (t = {}, t[x] = k ? y + "px" : "", t[C] = w ? m + "px" : "", t.transform = "", t))
}
function gqe(e) {
    var t = e.state,
    n = e.options,
    r = n.gpuAcceleration,
    o = r === void 0 ? !0 : r,
    i = n.adaptive,
    s = i === void 0 ? !0 : i,
    a = n.roundOffsets,
    l = a === void 0 ? !0 : a,
    c = {
        placement: aa(t.placement),
        variation: Bf(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: o,
        isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, sN(Object.assign({}, c, {
                        offsets: t.modifiersData.popperOffsets,
                        position: t.options.strategy,
                        adaptive: s,
                        roundOffsets: l
                    })))),
    t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, sN(Object.assign({}, c, {
                        offsets: t.modifiersData.arrow,
                        position: "absolute",
                        adaptive: !1,
                        roundOffsets: l
                    })))),
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
const vqe = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: gqe,
    data: {}
};
var jv = {
    passive: !0
};
function yqe(e) {
    var t = e.state,
    n = e.instance,
    r = e.options,
    o = r.scroll,
    i = o === void 0 ? !0 : o,
    s = r.resize,
    a = s === void 0 ? !0 : s,
    l = hs(t.elements.popper),
    c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return i && c.forEach(function (u) {
        u.addEventListener("scroll", n.update, jv)
    }),
    a && l.addEventListener("resize", n.update, jv),
    function () {
        i && c.forEach(function (u) {
            u.removeEventListener("scroll", n.update, jv)
        }),
        a && l.removeEventListener("resize", n.update, jv)
    }
}
const wqe = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: yqe,
    data: {}
};
var bqe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function y0(e) {
    return e.replace(/left|right|bottom|top/g, function (t) {
        return bqe[t]
    })
}
var _qe = {
    start: "end",
    end: "start"
};
function aN(e) {
    return e.replace(/start|end/g, function (t) {
        return _qe[t]
    })
}
function sT(e) {
    var t = hs(e),
    n = t.pageXOffset,
    r = t.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}
function aT(e) {
    return Lf(vc(e)).left + sT(e).scrollLeft
}
function kqe(e, t) {
    var n = hs(e),
    r = vc(e),
    o = n.visualViewport,
    i = r.clientWidth,
    s = r.clientHeight,
    a = 0,
    l = 0;
    if (o) {
        i = o.width,
        s = o.height;
        var c = X9();
        (c || !c && t === "fixed") && (a = o.offsetLeft, l = o.offsetTop)
    }
    return {
        width: i,
        height: s,
        x: a + aT(e),
        y: l
    }
}
function xqe(e) {
    var t,
    n = vc(e),
    r = sT(e),
    o = (t = e.ownerDocument) == null ? void 0 : t.body,
    i = fu(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0),
    s = fu(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0),
    a = -r.scrollLeft + aT(e),
    l = -r.scrollTop;
    return Qa(o || n).direction === "rtl" && (a += fu(n.clientWidth, o ? o.clientWidth : 0) - i), {
        width: i,
        height: s,
        x: a,
        y: l
    }
}
function lT(e) {
    var t = Qa(e),
    n = t.overflow,
    r = t.overflowX,
    o = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + o + r)
}
function tF(e) {
    return ["html", "body", "#document"].indexOf(ma(e)) >= 0 ? e.ownerDocument.body : Zi(e) && lT(e) ? e : tF(Uw(e))
}
function jp(e, t) {
    var n;
    t === void 0 && (t = []);
    var r = tF(e),
    o = r === ((n = e.ownerDocument) == null ? void 0 : n.body),
    i = hs(r),
    s = o ? [i].concat(i.visualViewport || [], lT(r) ? r : []) : r,
    a = t.concat(s);
    return o ? a : a.concat(jp(Uw(s)))
}
function Kx(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}
function Sqe(e, t) {
    var n = Lf(e, !1, t === "fixed");
    return n.top = n.top + e.clientTop,
    n.left = n.left + e.clientLeft,
    n.bottom = n.top + e.clientHeight,
    n.right = n.left + e.clientWidth,
    n.width = e.clientWidth,
    n.height = e.clientHeight,
    n.x = n.left,
    n.y = n.top,
    n
}
function lN(e, t, n) {
    return t === K9 ? Kx(kqe(e, n)) : Du(t) ? Sqe(t, n) : Kx(xqe(vc(e)))
}
function Cqe(e) {
    var t = jp(Uw(e)),
    n = ["absolute", "fixed"].indexOf(Qa(e).position) >= 0,
    r = n && Zi(e) ? kg(e) : e;
    return Du(r) ? t.filter(function (o) {
        return Du(o) && J9(o, r) && ma(o) !== "body"
    }) : []
}
function Iqe(e, t, n, r) {
    var o = t === "clippingParents" ? Cqe(e) : [].concat(t),
    i = [].concat(o, [n]),
    s = i[0],
    a = i.reduce(function (l, c) {
        var u = lN(e, c, r);
        return l.top = fu(u.top, l.top),
        l.right = qy(u.right, l.right),
        l.bottom = qy(u.bottom, l.bottom),
        l.left = fu(u.left, l.left),
        l
    }, lN(e, s, r));
    return a.width = a.right - a.left,
    a.height = a.bottom - a.top,
    a.x = a.left,
    a.y = a.top,
    a
}
function nF(e) {
    var t = e.reference,
    n = e.element,
    r = e.placement,
    o = r ? aa(r) : null,
    i = r ? Bf(r) : null,
    s = t.x + t.width / 2 - n.width / 2,
    a = t.y + t.height / 2 - n.height / 2,
    l;
    switch (o) {
    case Go:
        l = {
            x: s,
            y: t.y - n.height
        };
        break;
    case ss:
        l = {
            x: s,
            y: t.y + t.height
        };
        break;
    case as:
        l = {
            x: t.x + t.width,
            y: a
        };
        break;
    case Xo:
        l = {
            x: t.x - n.width,
            y: a
        };
        break;
    default:
        l = {
            x: t.x,
            y: t.y
        }
    }
    var c = o ? iT(o) : null;
    if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (i) {
        case Nf:
            l[c] = l[c] - (t[u] / 2 - n[u] / 2);
            break;
        case Nm:
            l[c] = l[c] + (t[u] / 2 - n[u] / 2);
            break
        }
    }
    return l
}
function Rm(e, t) {
    t === void 0 && (t = {});
    var n = t,
    r = n.placement,
    o = r === void 0 ? e.placement : r,
    i = n.strategy,
    s = i === void 0 ? e.strategy : i,
    a = n.boundary,
    l = a === void 0 ? qUe : a,
    c = n.rootBoundary,
    u = c === void 0 ? K9 : c,
    f = n.elementContext,
    p = f === void 0 ? tp : f,
    m = n.altBoundary,
    v = m === void 0 ? !1 : m,
    y = n.padding,
    b = y === void 0 ? 0 : y,
    w = Q9(typeof b != "number" ? b : eF(b, _g)),
    k = p === tp ? YUe : tp,
    C = e.rects.popper,
    x = e.elements[v ? k : p],
    S = Iqe(Du(x) ? x : x.contextElement || vc(e.elements.popper), l, u, s),
    T = Lf(e.elements.reference),
    E = nF({
        reference: T,
        element: C,
        strategy: "absolute",
        placement: o
    }),
    M = Kx(Object.assign({}, C, E)),
    N = p === tp ? M : T,
    F = {
        top: S.top - N.top + w.top,
        bottom: N.bottom - S.bottom + w.bottom,
        left: S.left - N.left + w.left,
        right: N.right - S.right + w.right
    },
    K = e.modifiersData.offset;
    if (p === tp && K) {
        var j = K[o];
        Object.keys(F).forEach(function (G) {
            var Y = [as, ss].indexOf(G) >= 0 ? 1 : -1,
            ue = [Go, ss].indexOf(G) >= 0 ? "y" : "x";
            F[G] += j[ue] * Y
        })
    }
    return F
}
function Tqe(e, t) {
    t === void 0 && (t = {});
    var n = t,
    r = n.placement,
    o = n.boundary,
    i = n.rootBoundary,
    s = n.padding,
    a = n.flipVariations,
    l = n.allowedAutoPlacements,
    c = l === void 0 ? G9 : l,
    u = Bf(r),
    f = u ? a ? oN : oN.filter(function (v) {
        return Bf(v) === u
    }) : _g,
    p = f.filter(function (v) {
        return c.indexOf(v) >= 0
    });
    p.length === 0 && (p = f);
    var m = p.reduce(function (v, y) {
        return v[y] = Rm(e, {
            placement: y,
            boundary: o,
            rootBoundary: i,
            padding: s
        })[aa(y)],
        v
    }, {});
    return Object.keys(m).sort(function (v, y) {
        return m[v] - m[y]
    })
}
function Mqe(e) {
    if (aa(e) === nT)
        return [];
    var t = y0(e);
    return [aN(e), t, aN(t)]
}
function Pqe(e) {
    var t = e.state,
    n = e.options,
    r = e.name;
    if (!t.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, f = n.rootBoundary, p = n.altBoundary, m = n.flipVariations, v = m === void 0 ? !0 : m, y = n.allowedAutoPlacements, b = t.options.placement, w = aa(b), k = w === b, C = l || (k || !v ? [y0(b)] : Mqe(b)), x = [b].concat(C).reduce(function (at, le) {
                return at.concat(aa(le) === nT ? Tqe(t, {
                        placement: le,
                        boundary: u,
                        rootBoundary: f,
                        padding: c,
                        flipVariations: v,
                        allowedAutoPlacements: y
                    }) : le)
            }, []), S = t.rects.reference, T = t.rects.popper, E = new Map, M = !0, N = x[0], F = 0; F < x.length; F++) {
            var K = x[F],
            j = aa(K),
            G = Bf(K) === Nf,
            Y = [Go, ss].indexOf(j) >= 0,
            ue = Y ? "width" : "height",
            re = Rm(t, {
                placement: K,
                boundary: u,
                rootBoundary: f,
                altBoundary: p,
                padding: c
            }),
            de = Y ? G ? as : Xo : G ? ss : Go;
            S[ue] > T[ue] && (de = y0(de));
            var Se = y0(de),
            Pe = [];
            if (i && Pe.push(re[j] <= 0), a && Pe.push(re[de] <= 0, re[Se] <= 0), Pe.every(function (at) {
                    return at
                })) {
                N = K,
                M = !1;
                break
            }
            E.set(K, Pe)
        }
        if (M)
            for (var je = v ? 3 : 1, Ke = function (le) {
                var ye = x.find(function (ge) {
                    var pe = E.get(ge);
                    if (pe)
                        return pe.slice(0, le)
                            .every(function (xe) {
                                return xe
                            })
                    });
                if (ye)
                    return N = ye, "break"
            }, Ue = je; Ue > 0; Ue--) {
                var yt = Ke(Ue);
                if (yt === "break")
                    break
            }
    t.placement !== N && (t.modifiersData[r]._skip = !0, t.placement = N, t.reset = !0)
}
}
const Eqe = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: Pqe,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function cN(e, t, n) {
    return n === void 0 && (n = {
            x: 0,
            y: 0
        }), {
        top: e.top - t.height - n.y,
        right: e.right - t.width + n.x,
        bottom: e.bottom - t.height + n.y,
        left: e.left - t.width - n.x
    }
}
function uN(e) {
    return [Go, as, ss, Xo].some(function (t) {
        return e[t] >= 0
    })
}
function Oqe(e) {
    var t = e.state,
    n = e.name,
    r = t.rects.reference,
    o = t.rects.popper,
    i = t.modifiersData.preventOverflow,
    s = Rm(t, {
        elementContext: "reference"
    }),
    a = Rm(t, {
        altBoundary: !0
    }),
    l = cN(s, r),
    c = cN(a, o, i),
    u = uN(l),
    f = uN(c);
    t.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: f
    },
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": f
    })
}
const $qe = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: Oqe
};
function Aqe(e, t, n) {
    var r = aa(e),
    o = [Xo, Go].indexOf(r) >= 0 ? -1 : 1,
    i = typeof n == "function" ? n(Object.assign({}, t, {
                placement: e
            })) : n,
    s = i[0],
    a = i[1];
    return s = s || 0,
    a = (a || 0) * o,
    [Xo, as].indexOf(r) >= 0 ? {
        x: a,
        y: s
    }
     : {
        x: s,
        y: a
    }
}
function Dqe(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.offset,
    i = o === void 0 ? [0, 0] : o,
    s = G9.reduce(function (u, f) {
        return u[f] = Aqe(f, t.rects, i),
        u
    }, {}),
    a = s[t.placement],
    l = a.x,
    c = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c),
    t.modifiersData[r] = s
}
const Nqe = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: Dqe
};
function Rqe(e) {
    var t = e.state,
    n = e.name;
    t.modifiersData[n] = nF({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
    })
}
const Lqe = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: Rqe,
    data: {}
};
function Bqe(e) {
    return e === "x" ? "y" : "x"
}
function Vqe(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.mainAxis,
    i = o === void 0 ? !0 : o,
    s = n.altAxis,
    a = s === void 0 ? !1 : s,
    l = n.boundary,
    c = n.rootBoundary,
    u = n.altBoundary,
    f = n.padding,
    p = n.tether,
    m = p === void 0 ? !0 : p,
    v = n.tetherOffset,
    y = v === void 0 ? 0 : v,
    b = Rm(t, {
        boundary: l,
        rootBoundary: c,
        padding: f,
        altBoundary: u
    }),
    w = aa(t.placement),
    k = Bf(t.placement),
    C = !k,
    x = iT(w),
    S = Bqe(x),
    T = t.modifiersData.popperOffsets,
    E = t.rects.reference,
    M = t.rects.popper,
    N = typeof y == "function" ? y(Object.assign({}, t.rects, {
                placement: t.placement
            })) : y,
    F = typeof N == "number" ? {
        mainAxis: N,
        altAxis: N
    }
     : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, N),
    K = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
    j = {
        x: 0,
        y: 0
    };
    if (T) {
        if (i) {
            var G,
            Y = x === "y" ? Go : Xo,
            ue = x === "y" ? ss : as,
            re = x === "y" ? "height" : "width",
            de = T[x],
            Se = de + b[Y],
            Pe = de - b[ue],
            je = m ? -M[re] / 2 : 0,
            Ke = k === Nf ? E[re] : M[re],
            Ue = k === Nf ? -M[re] : -E[re],
            yt = t.elements.arrow,
            at = m && yt ? oT(yt) : {
                width: 0,
                height: 0
            },
            le = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Z9(),
            ye = le[Y],
            ge = le[ue],
            pe = Fp(0, E[re], at[re]),
            xe = C ? E[re] / 2 - je - pe - ye - F.mainAxis : Ke - pe - ye - F.mainAxis,
            et = C ? -E[re] / 2 + je + pe + ge + F.mainAxis : Ue + pe + ge + F.mainAxis,
            Xe = t.elements.arrow && kg(t.elements.arrow),
            W = Xe ? x === "y" ? Xe.clientTop || 0 : Xe.clientLeft || 0 : 0,
            R = (G = K?.[x]) != null ? G : 0,
            X = de + xe - R - W,
            Q = de + et - R,
            Z = Fp(m ? qy(Se, X) : Se, de, m ? fu(Pe, Q) : Pe);
            T[x] = Z,
            j[x] = Z - de
        }
        if (a) {
            var fe,
            be = x === "x" ? Go : Xo,
            Ee = x === "x" ? ss : as,
            Me = T[S],
            we = S === "y" ? "height" : "width",
            He = Me + b[be],
            We = Me - b[Ee],
            Je = [Go, Xo].indexOf(w) !== -1,
            qe = (fe = K?.[S]) != null ? fe : 0,
            wt = Je ? He : Me - E[we] - M[we] - qe + F.altAxis,
            Et = Je ? Me + E[we] + M[we] - qe - F.altAxis : We,
            bt = m && Je ? cqe(wt, Me, Et) : Fp(m ? wt : He, Me, m ? Et : We);
            T[S] = bt,
            j[S] = bt - Me
        }
        t.modifiersData[r] = j
    }
}
const Fqe = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: Vqe,
    requiresIfExists: ["offset"]
};
function jqe(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}
function Wqe(e) {
    return e === hs(e) || !Zi(e) ? sT(e) : jqe(e)
}
function zqe(e) {
    var t = e.getBoundingClientRect(),
    n = Rf(t.width) / e.offsetWidth || 1,
    r = Rf(t.height) / e.offsetHeight || 1;
    return n !== 1 || r !== 1
}
function Hqe(e, t, n) {
    n === void 0 && (n = !1);
    var r = Zi(t),
    o = Zi(t) && zqe(t),
    i = vc(t),
    s = Lf(e, o, n),
    a = {
        scrollLeft: 0,
        scrollTop: 0
    },
    l = {
        x: 0,
        y: 0
    };
    return (r || !r && !n) && ((ma(t) !== "body" || lT(i)) && (a = Wqe(t)), Zi(t) ? (l = Lf(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : i && (l.x = aT(i))), {
        x: s.left + a.scrollLeft - l.x,
        y: s.top + a.scrollTop - l.y,
        width: s.width,
        height: s.height
    }
}
function Uqe(e) {
    var t = new Map,
    n = new Set,
    r = [];
    e.forEach(function (i) {
        t.set(i.name, i)
    });
    function o(i) {
        n.add(i.name);
        var s = [].concat(i.requires || [], i.requiresIfExists || []);
        s.forEach(function (a) {
            if (!n.has(a)) {
                var l = t.get(a);
                l && o(l)
            }
        }),
        r.push(i)
    }
    return e.forEach(function (i) {
        n.has(i.name) || o(i)
    }),
    r
}
function qqe(e) {
    var t = Uqe(e);
    return rqe.reduce(function (n, r) {
        return n.concat(t.filter(function (o) {
                return o.phase === r
            }))
    }, [])
}
function Yqe(e) {
    var t;
    return function () {
        return t || (t = new Promise(function (n) {
                Promise.resolve().then(function () {
                    t = void 0,
                    n(e())
                })
            })),
        t
    }
}
function Kqe(e) {
    var t = e.reduce(function (n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, r, {
            options: Object.assign({}, o.options, r.options),
            data: Object.assign({}, o.data, r.data)
        }) : r,
        n
    }, {});
    return Object.keys(t).map(function (n) {
        return t[n]
    })
}
var dN = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function fN() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return !t.some(function (r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}
function Gqe(e) {
    e === void 0 && (e = {});
    var t = e,
    n = t.defaultModifiers,
    r = n === void 0 ? [] : n,
    o = t.defaultOptions,
    i = o === void 0 ? dN : o;
    return function (a, l, c) {
        c === void 0 && (c = i);
        var u = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, dN, i),
            modifiersData: {},
            elements: {
                reference: a,
                popper: l
            },
            attributes: {},
            styles: {}
        },
        f = [],
        p = !1,
        m = {
            state: u,
            setOptions: function (w) {
                var k = typeof w == "function" ? w(u.options) : w;
                y(),
                u.options = Object.assign({}, i, u.options, k),
                u.scrollParents = {
                    reference: Du(a) ? jp(a) : a.contextElement ? jp(a.contextElement) : [],
                    popper: jp(l)
                };
                var C = qqe(Kqe([].concat(r, u.options.modifiers)));
                return u.orderedModifiers = C.filter(function (x) {
                    return x.enabled
                }),
                v(),
                m.update()
            },
            forceUpdate: function () {
                if (!p) {
                    var w = u.elements,
                    k = w.reference,
                    C = w.popper;
                    if (fN(k, C)) {
                        u.rects = {
                            reference: Hqe(k, kg(C), u.options.strategy === "fixed"),
                            popper: oT(C)
                        },
                        u.reset = !1,
                        u.placement = u.options.placement,
                        u.orderedModifiers.forEach(function (F) {
                            return u.modifiersData[F.name] = Object.assign({}, F.data)
                        });
                        for (var x = 0; x < u.orderedModifiers.length; x++) {
                            if (u.reset === !0) {
                                u.reset = !1,
                                x = -1;
                                continue
                            }
                            var S = u.orderedModifiers[x],
                            T = S.fn,
                            E = S.options,
                            M = E === void 0 ? {}
                             : E,
                            N = S.name;
                            typeof T == "function" && (u = T({
                                    state: u,
                                    options: M,
                                    name: N,
                                    instance: m
                                }) || u)
                        }
                    }
                }
            },
            update: Yqe(function () {
                return new Promise(function (b) {
                    m.forceUpdate(),
                    b(u)
                })
            }),
            destroy: function () {
                y(),
                p = !0
            }
        };
        if (!fN(a, l))
            return m;
        m.setOptions(c).then(function (b) {
            !p && c.onFirstUpdate && c.onFirstUpdate(b)
        });
        function v() {
            u.orderedModifiers.forEach(function (b) {
                var w = b.name,
                k = b.options,
                C = k === void 0 ? {}
                 : k,
                x = b.effect;
                if (typeof x == "function") {
                    var S = x({
                        state: u,
                        name: w,
                        instance: m,
                        options: C
                    }),
                    T = function () {};
                    f.push(S || T)
                }
            })
        }
        function y() {
            f.forEach(function (b) {
                return b()
            }),
            f = []
        }
        return m
    }
}
var Xqe = [wqe, Lqe, vqe, sqe, Nqe, Eqe, Fqe, hqe, $qe], Jqe = Gqe({
    defaultModifiers: Xqe
});
const rF = ({
    popperTarget: e,
    referenceEl: t
}, n) => {
    const r = De(null);
    return Ur(() => {
        t.value !== null && e.value !== null && (r.value = Jqe(t.value, e.value, ke(n)))
    }),
    cc(() => {
        r.value && r.value.destroy()
    }), {
        popperInstance: r,
        updatePopper: () => {
            r.value && r.value.update().catch(a => {
                throw Error(`Unable to update popper instance; ${a}`)
            })
        }
    }
}, Zqe = {
    key: 0,
    class: "hotkey"
}, hN = Fe({
    __name: "BaseMenuItemText",
    props: {
        text: {},
        hotkeyText: {},
        useMaxMenuWidth: {
            type: Boolean
        }
    },
    setup(e) {
        return (t, n) => (_(), O(Le, null, [P("span", {
                        class: he(["text", {
                                    truncate: t.useMaxMenuWidth
                                }
                            ])
                    }, Re(t.text), 3), t.hotkeyText ? (_(), O("span", Zqe, Re(t.hotkeyText), 1)) : J("", !0)], 64))
    }
});
const Qqe = {
    class: "label"
}, eYe = {
    class: "text-and-hotkey"
}, tYe = {
    key: 0,
    class: "description"
}, nYe = Fe({
    __name: "BaseMenuItem",
    props: {
        item: {},
        index: {},
        hasFocus: {
            type: Boolean
        },
        useMaxMenuWidth: {
            type: Boolean
        }
    },
    setup(e) {
        const t = r => r.to ? "nuxt-link" : r.href ? "a" : "button",
        n = r => r.href && r.download ? {
            download: typeof r.download == "boolean" ? "" : r.download
        }
         : null;
        return (r, o) => (_(), H(Kt(t(r.item)), Bt({
                    ref: "listItemComponent",
                    tabindex: "-1",
                    class: ["list-item", r.item.sectionHeadline ? "section-headline" : "clickable-item", {
                            disabled: r.item.disabled,
                            selected: r.item.selected,
                            focused: r.hasFocus
                        }
                    ],
                    to: r.item.to || null,
                    href: r.item.href || null
                }, n(r.item)), {
            default:
                oe(() => [r.item.icon ? (_(), H(Kt(r.item.icon), {
                                key: 0,
                                class: "item-icon"
                            })) : J("", !0), P("div", Qqe, [P("div", eYe, [r.item.checkbox ? (_(), H(Tw, {
                                                key: 0,
                                                "model-value": r.item.checkbox.checked,
                                                class: "checkbox"
                                            }, {
                                            default:
                                                oe(() => [z(hN, {
                                                            text: r.item.text,
                                                            "use-max-menu-width": r.useMaxMenuWidth,
                                                            "hotkey-text": r.item.hotkeyText
                                                        }, null, 8, ["text", "use-max-menu-width", "hotkey-text"])]),
                                                _: 1
                                            }, 8, ["model-value"])) : (_(), O(Le, {
                                                key: 1
                                            }, [z(hN, {
                                                        text: r.item.text,
                                                        "use-max-menu-width": r.useMaxMenuWidth,
                                                        "hotkey-text": r.item.hotkeyText
                                                    }, null, 8, ["text", "use-max-menu-width", "hotkey-text"]), Ye(r.$slots, "submenu", {
                                                        itemElement: r.$refs.listItemComponent
                                                    }, void 0, !0)], 64))]), r.item.description ? (_(), O("div", tYe, Re(r.item.description), 1)) : J("", !0)])]),
                _: 3
            }, 16, ["class", "to", "href"]))
    }
});
const oF = te(nYe, [["__scopeId", "data-v-20688faf"]]);
function rYe(e) {
    return !("$el" in e)
}
const oYe = {
    components: {
        BaseMenuItem: oF
    },
    props: {
        items: {
            type: Array,
            required: !0
        },
        focusedItemIndex: {
            required: !1,
            type: Number,
        default:
            null
        },
        menuAriaLabel: {
            type: String,
            required: !0
        },
        id: {
        default:
            () => `__BaseMenuItems-${V0()}__`,
            type: String
        },
        maxMenuWidth: {
            type: Number,
        default:
            null
        },
        positionRelativeToElement: {
            type: HTMLElement,
        default:
            null
        }
    },
    emits: ["item-click", "item-focused", "item-hovered"],
    setup(e) {
        const t = De([]),
        n = ca(e, "positionRelativeToElement"),
        r = De(null);
        return ZS(() => {
            t.value = []
        }),
        rF({
            popperTarget: r,
            referenceEl: n
        }, {
            strategy: "fixed",
            placement: "right-start",
            modifiers: []
        }), {
            listContainer: r,
            listItems: t
        }
    },
    computed: {
        useMaxMenuWidth() {
            return Boolean(this.maxMenuWidth)
        },
        enabledItemsIndices() {
            return this.items.map((e, t) => ({
                    item: e,
                    index: t
                })).filter(({
                    item: e
                }) => !e.disabled).map(({
                    index: e
                }) => e)
        }
    },
    watch: {
        focusedItemIndex: {
            immediate: !0,
            handler() {
                this.emitItemFocused()
            }
        },
        items: {
            deep: !0,
            handler() {
                this.emitItemFocused()
            }
        }
    },
    expose: ["getEnabledListItems", "scrollTo"],
    methods: {
        updateItem(e, t) {
            this.listItems[t] = e
        },
        getEnabledListItems() {
            return this.listItems.map((t, n) => {
                const r = t.children[0];
                return {
                    element: t,
                    index: n,
                    onClick: rYe(r) ? () => r.click() : () => r.$el.click()
                }
            }).filter(({
                    index: t
                }) => this.enabledItemsIndices.includes(t))
        },
        scrollTo(e) {
            const t = this.$refs.listContainer;
            if (t && t.scrollHeight > t.clientHeight) {
                const n = t.clientHeight + t.scrollTop,
                r = e.offsetTop + e.offsetHeight;
                r > n ? t.scrollTop = r - t.clientHeight : e.offsetTop < t.scrollTop && (t.scrollTop = e.offsetTop)
            }
        },
        menuItemId(e) {
            return `menu-item-${this.id}-${e}`
        },
        onPointerEnter(e, t, n) {
            this.$emit("item-hovered", t.disabled || t.sectionHeadline ? null : t, this.id, n)
        },
        onItemClick(e, t, n) {
            if (t.disabled || t.sectionHeadline || t.children?.length)
                return;
            if (!(t.href || t.to) && (e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation()), t.checkbox) {
                const o = !t.checkbox.checked;
                t.checkbox.setBoolean(o);
                return
            }
            this.$emit("item-click", e, t, n)
        },
        emitItemFocused() {
            if (this.focusedItemIndex === null) {
                this.$emit("item-focused", null, null);
                return
            }
            const e = this.focusedItemIndex;
            this.$emit("item-focused", this.menuItemId(e), this.items[e])
        }
    }
};
const iYe = ["aria-label"], sYe = ["data-index", "title", "onClick", "onPointerenter"];
function aYe(e, t, n, r, o, i) {
    const s = B("BaseMenuItem");
    return _(),
    O("ul", {
        ref: "listContainer",
        "aria-label": n.menuAriaLabel,
        class: "base-menu-items",
        role: "menu",
        tabindex: "-1",
        onPointerleave: t[0] || (t[0] = a => e.$emit("item-hovered", null, n.id))
    }, [(_(!0), O(Le, null, $t(n.items, (a, l) => (_(), O("li", {
                                key: l,
                                ref_for: !0,
                                ref: c => i.updateItem(c, l),
                                "data-index": l,
                                class: he([{
                                            separator: a.separator
                                        }
                                    ]),
                                style: Yt(i.useMaxMenuWidth ? {
                                    "max-width": `${n.maxMenuWidth}px`
                                }
                                     : {}),
                                title: a.title,
                                onClick: c => i.onItemClick(c, a, n.id),
                                onPointerenter: c => i.onPointerEnter(c, a, l)
                            }, [Ye(e.$slots, "item", {
                                        item: a,
                                        index: l,
                                        menuId: n.id,
                                        menuItemId: i.menuItemId,
                                        maxMenuWidth: n.maxMenuWidth,
                                        focusedItemIndex: n.focusedItemIndex
                                    }, () => [z(s, {
                                                id: i.menuItemId(l),
                                                item: a,
                                                index: l,
                                                "use-max-menu-width": Boolean(n.maxMenuWidth),
                                                "has-focus": l === n.focusedItemIndex
                                            }, null, 8, ["id", "item", "index", "use-max-menu-width", "has-focus"])], !0)], 46, sYe))), 128))], 40, iYe)
}
const lYe = te(oYe, [["render", aYe], ["__scopeId", "data-v-c70359b3"]]), cT = Fe({
    __name: "MenuItems",
    props: {
        items: {},
        menuAriaLabel: {},
        disableSpaceToClick: {
            type: Boolean,
        default:
            !1
        },
        registerKeydown: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["close", "item-click", "item-focused", "item-hovered", "close-submenu"],
    setup(e, {
        expose: t,
        emit: n
    }) {
        const r = e,
        o = De(null),
        i = De(-1),
        s = De(null),
        a = (w, k) => {
            if (!o.value)
                return {
                    onClick: () => {},
                    index: -1
                };
            const C = o.value.getEnabledListItems();
            let x = C.map(({
                        index: N
                    }) => N).indexOf(w);
            x === -1 && k === -1 && (x = 0);
            const S = UUe(x + k, C.length), {
                element: T,
                index: E,
                onClick: M
            } = C[S];
            return o.value.scrollTo(T), {
                index: E,
                onClick: M
            }
        }, {
            currentIndex: l,
            onKeydown: c,
            resetNavigation: u
        } = HUe({
            disableSpaceToClick: r.disableSpaceToClick,
            getNextElement: a,
            close: () => n("close")
        }),
        f = (w = 0) => {
            l.value = w
        },
        p = w => {
            const k = r.items[w],
            C = k && !k.disabled && k.children?.length;
            i.value = C ? w : -1
        },
        m = w => {
            switch (w.code) {
            case "ArrowLeft":
                n("close-submenu");
                break;
            case "ArrowRight":
                p(l.value ?? 0),
                Ci(() => {
                    s.value?.focusIndex()
                });
                break
            }
            c(w)
        },
        v = (w, k, C) => {
            w !== null && p(C),
            n("item-hovered", w, k, C)
        },
        y = w => {
            i.value !== -1 ? s.value?.onKeydown(w) : m(w)
        };
        t({
            onKeydown: y,
            resetNavigation: u,
            focusIndex: f
        });
        const b = w => !w.children || w.children.length === 0 ? !1 : Boolean(w.children.find(({
                        selected: k
                    }) => k));
        return (w, k) => {
            const C = B("MenuItems", !0);
            return _(),
            H(lYe, Bt({
                    ref_key: "baseMenuItems",
                    ref: o
                }, w.$attrs, {
                    items: r.items,
                    "menu-aria-label": r.menuAriaLabel,
                    "focused-item-index": ke(l),
                    onKeydown: k[4] || (k[4] = x => r.registerKeydown && y(x)),
                    onItemClick: k[5] || (k[5] = (x, S, T) => w.$emit("item-click", x, S, T)),
                    onItemHovered: k[6] || (k[6] = (x, S, T) => v(x, S, T)),
                    onItemFocused: k[7] || (k[7] = (x, S) => w.$emit("item-focused", x, S))
                }), {
                item: oe(({
                        item: x,
                        menuId: S,
                        menuItemId: T,
                        index: E,
                        maxMenuWidth: M,
                        focusedItemIndex: N
                    }) => [z(oF, {
                            id: T(E),
                            item: x,
                            index: E,
                            "use-max-menu-width": Boolean(M),
                            "has-focus": E === N,
                            class: "base-item"
                        }, {
                            submenu: oe(({
                                    itemElement: F
                                }) => [x.children && x.children.length ? (_(), O("span", {
                                            key: 0,
                                            class: he(["sub-menu-indicator", {
                                                        highlight: b(x)
                                                    }
                                                ])
                                        }, [z(ke(Ww), {
                                                    class: "icon"
                                                }), i.value === E ? (_(), H(C, {
                                                        key: 0,
                                                        id: `${S}__sub${E}`,
                                                        ref_key: "subLevelItems",
                                                        ref: s,
                                                        class: "menu-items-sub-level",
                                                        "menu-aria-label": `${x.text} sub menu`,
                                                        items: x.children,
                                                        "max-menu-width": M,
                                                        "position-relative-to-element": F,
                                                        "register-keydown": "",
                                                        onCloseSubmenu: k[0] || (k[0] = K => i.value = -1),
                                                        onItemClick: k[1] || (k[1] = (...K) => w.$emit("item-click", ...K)),
                                                        onItemHovered: k[2] || (k[2] = (...K) => w.$emit("item-hovered", ...K)),
                                                        onItemFocused: k[3] || (k[3] = (...K) => w.$emit("item-focused", ...K))
                                                    }, null, 8, ["id", "menu-aria-label", "items", "max-menu-width", "position-relative-to-element"])) : J("", !0)], 2)) : J("", !0)]),
                            _: 2
                        }, 1032, ["id", "item", "index", "use-max-menu-width", "has-focus"])]),
                _: 1
            }, 16, ["items", "menu-aria-label", "focused-item-index"])
        }
    }
});
const cYe = ({
    targets: e,
    callback: t
}, n) => {
    let r;
    const o = () => {
        r = SQ(e[0], t, {
            ignore: e
        })
    },
    i = () => {
        typeof r < "u" && r()
    };
    Ht(() => ke(n), s => {
        s ? o() : i()
    }, {
        immediate: !0
    }),
    cc(i)
}, uYe = ["right", "top", "left"], pN = {
    right: "bottom-end",
    top: "top-end",
    left: "bottom-start"
}, dYe = {
    components: {
        FunctionButton: ti,
        MenuItems: cT
    },
    props: {
        items: {
            type: Array,
            required: !0
        },
        id: {
            type: String,
        default:
            ""
        },
        buttonTitle: {
            type: String,
        default:
            ""
        },
        orientation: {
            type: String,
        default:
            "right",
            validator(e = "right") {
                return uYe.includes(e)
            }
        },
        disabled: {
            type: Boolean,
        default:
            !1
        },
        maxMenuWidth: {
            type: Number,
        default:
            null
        },
        allowOverflowMainAxis: {
            type: Boolean,
        default:
            !1
        },
        teleportToBody: {
            type: Boolean,
        default:
            !0
        },
        positioningStrategy: {
            type: String,
        default:
            "fixed",
            validator: e => ["fixed", "absolute"].includes(e)
        }
    },
    emits: ["item-click", "toggle", "open", "close"],
    setup(e) {
        const {
            orientation: t
        } = nl(e),
        n = De(null),
        r = De(null),
        o = De(null),
        i = De(!1),
        s = () => {
            i.value = !1
        };
        cYe({
            targets: [n, r],
            callback: s
        }, i);
        const {
            popperInstance: a,
            updatePopper: l
        } = rF({
            popperTarget: o,
            referenceEl: n
        }, ne(() => ({
                        placement: pN[e.orientation],
                        strategy: e.positioningStrategy,
                        modifiers: [{
                                name: "preventOverflow",
                                options: {
                                    mainAxis: e.allowOverflowMainAxis
                                }
                            }
                        ]
                    })));
        return Ht(t, c => {
            const u = ke(a);
            u && u.setOptions({
                placement: pN[c]
            })
        }), {
            menuItems: r,
            submenu: n,
            menuWrapper: o,
            expanded: i,
            updatePopper: l,
            closeMenu: s
        }
    },
    data() {
        return {
            activeDescendant: void 0
        }
    },
    methods: {
        toggleMenu(e) {
            if (this.disabled)
                return;
            this.expanded = !this.expanded;
            const t = this.expanded ? () => {
                this.expanded = !1
            }
             : () => {};
            this.$emit("toggle", e, t);
            const n = this.expanded ? "open" : "close";
            this.$emit(n),
            this.updatePopper()
        },
        onItemClick(e, t) {
            if (this.$emit("item-click", e, t, this.id), t.checkbox) {
                t.checkbox.setBoolean(!t.checkbox.checked);
                return
            }
            this.toggleMenu(e)
        },
        onKeydown(e) {
            this.getMenuItems()?.onKeydown(e)
        },
        getMenuItems() {
            return this.$refs.menuItems
        },
        setActiveDescendant(e) {
            e === null ? this.activeDescendant = void 0 : this.activeDescendant = e
        }
    }
};
const fYe = ["aria-owns", "aria-activedescendant"];
function hYe(e, t, n, r, o, i) {
    const s = B("FunctionButton"),
    a = B("MenuItems");
    return _(),
    O("div", {
        ref: "submenu",
        class: he(["submenu", {
                    expanded: r.expanded
                }, {
                    disabled: n.disabled
                }
            ]),
        "aria-owns": e.activeDescendant,
        "aria-activedescendant": e.activeDescendant,
        onKeydown: t[0] || (t[0] = (...l) => i.onKeydown && i.onKeydown(...l))
    }, [z(s, {
                ref: "submenu-toggle",
                "aria-haspopup": "true",
                type: "button",
                title: n.buttonTitle,
                class: he(["submenu-toggle", {
                            expanded: r.expanded
                        }
                    ]),
                "aria-expanded": String(r.expanded),
                disabled: n.disabled,
                active: r.expanded,
                onClick: ve(i.toggleMenu, ["stop"])
            }, {
            default:
                oe(() => [Ye(e.$slots, "default", {
                            expanded: r.expanded
                        }, void 0, !0)]),
                _: 3
            }, 8, ["title", "class", "aria-expanded", "disabled", "active", "onClick"]), (_(), H(H1, {
                    to: "body",
                    disabled: !n.teleportToBody
                }, [Cn(P("div", {
                                ref: "menuWrapper",
                                class: he(["menu-wrapper", {
                                            disabled: n.disabled
                                        }
                                    ])
                            }, [r.expanded ? (_(), H(a, {
                                            key: 0,
                                            id: n.id,
                                            ref: "menuItems",
                                            class: he(["menu-items", `orient-${n.orientation}`]),
                                            items: n.items,
                                            "max-menu-width": n.maxMenuWidth,
                                            "menu-aria-label": "sub menu",
                                            onItemClick: i.onItemClick,
                                            onClose: r.closeMenu,
                                            onItemFocused: i.setActiveDescendant
                                        }, null, 8, ["id", "class", "items", "max-menu-width", "onItemClick", "onClose", "onItemFocused"])) : J("", !0)], 2), [[Kn, r.expanded]])], 8, ["disabled"]))], 42, fYe)
}
const Vf = te(dYe, [["render", hYe], ["__scopeId", "data-v-4e0a86d8"]]), pYe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, mYe = P("path", {
    "stroke-linejoin": "round",
    d: "m26.188 27.225-6.51-10.07 8.646-1.83L6 1l3.708 26.08 5.4-6.876 6.51 10.07 4.57-3.049Z"
}, null, -1), gYe = [mYe];
function vYe(e, t) {
    return _(),
    O("svg", pYe, gYe)
}
const iF = {
    render: vYe
}, yYe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, wYe = P("path", {
    d: "M9 30h14M16 2v28M5 7V2h22v5"
}, null, -1), bYe = [wYe];
function _Ye(e, t) {
    return _(),
    O("svg", yYe, bYe)
}
const sF = {
    render: _Ye
};
const kYe = {
    components: {
        ArrowNext: Ww
    },
    props: {
        items: {
            type: Array,
        default:
            () => []
        },
        greyStyle: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["click-item"],
    computed: {
        linkComponent() {
            return hC()
        }
    }
}, xYe = ["role", "title", "onClick"];
function SYe(e, t, n, r, o, i) {
    const s = B("ArrowNext");
    return n.items && n.items.length ? (_(), O("nav", {
            key: 0,
            class: he(["breadcrumb", {
                        "grey-style": n.greyStyle
                    }
                ])
        }, [P("ul", null, [(_(!0), O(Le, null, $t(n.items, (a, l) => (_(), O("li", {
                                            key: l
                                        }, [a.href ? (_(), H(Kt(i.linkComponent), {
                                                        key: 0,
                                                        to: a.href
                                                    }, {
                                                    default:
                                                        oe(() => [a.icon ? (_(), H(Kt(a.icon), {
                                                                        key: 0,
                                                                        class: "breadcrumb-icon"
                                                                    })) : J("", !0), mt(" " + Re(a.text), 1)]),
                                                        _: 2
                                                    }, 1032, ["to"])) : (_(), O("span", {
                                                        key: 1,
                                                        class: he({
                                                            clickable: a.clickable
                                                        }),
                                                        role: a.clickable ? "button" : null,
                                                        title: a.title,
                                                        onClick: c => a.clickable && e.$emit("click-item", a)
                                                    }, [a.icon ? (_(), H(Kt(a.icon), {
                                                                    key: 0,
                                                                    class: "breadcrumb-icon"
                                                                })) : J("", !0), mt(" " + Re(a.text), 1)], 10, xYe)), l !== n.items.length - 1 ? (_(), H(s, {
                                                        key: 2,
                                                        class: "arrow"
                                                    })) : J("", !0)]))), 128))])], 2)) : J("", !0)
}
const CYe = te(kYe, [["render", SYe], ["__scopeId", "data-v-a919fbe4"]]), IYe = {
    components: {
        Breadcrumb: CYe
    },
    props: {
        items: {
            type: Array,
        default:
            () => []
        }
    },
    emits: ["click"],
    computed: {
        breadcrumbItems() {
            return this.items.map(({
                    text: e,
                    icon: t,
                    id: n
                }) => {
                let r = {
                    text: e,
                    icon: t || null
                };
                return n && (r.href = `#${encodeURIComponent(n)}`),
                r
            })
        }
    },
    methods: {
        onClick({
            target: e
        }) {
            if (!e || !e.href)
                return;
            let {
                hash: t
            } = new URL(e.href, "file://dummy/"),
            n = decodeURIComponent(t.replace(/^#/, ""));
            this.$emit("click", {
                id: n,
                target: e
            })
        }
    }
};
function TYe(e, t, n, r, o, i) {
    const s = B("Breadcrumb");
    return _(),
    H(s, Bt(e.$attrs, {
            items: i.breadcrumbItems,
            onClickCapture: ve(i.onClick, ["prevent", "stop"])
        }), null, 16, ["items", "onClickCapture"])
}
const MYe = te(IYe, [["render", TYe]]), PYe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, EYe = P("path", {
    d: "M19.24 12.361V4.415c0-1.1-.9-1.999-1.999-1.999H5.243A2.008 2.008 0 0 0 3.24 4.419v12c0 1.098.899 1.997 1.997 1.997h3.688M3.828 3.004l11.194 11.194m13.009-1.134h-3.405a.732.732 0 0 0-.73.73v3.405c0 .401.328.73.73.73H28.031c.401 0 .73-.328.73-.73v-3.405a.733.733 0 0 0-.73-.73zm-11.447 5.827h-3.405a.732.732 0 0 0-.73.73v3.405c0 .401.328.73.73.73h3.405c.401 0 .73-.328.73-.73V19.62a.732.732 0 0 0-.73-.729zm11.422 5.829h-3.405a.732.732 0 0 0-.73.73v3.405c0 .401.328.73.73.73h3.405c.401 0 .73-.328.73-.73V25.45a.733.733 0 0 0-.73-.73zM17.314 21.4h3.137v-5.297c0-.335.271-.606.606-.606h2.839m-.025 11.655h-2.815a.605.605 0 0 1-.605-.605V21.4h-3.137"
}, null, -1), OYe = [EYe];
function $Ye(e, t) {
    return _(),
    O("svg", PYe, OYe)
}
const AYe = {
    render: $Ye
}, DYe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#3E3A39",
    viewBox: "0 0 32 32"
}, NYe = P("path", {
    d: "M12.5 3h7m2 0h6C29 3 29 4.5 29 4.5v6m0 2v7m0 2v6c0 1.5-1.5 1.5-1.5 1.5h-6m-2 0h-7m-2 0h-6C3 29 3 27.5 3 27.5v-6m0-2v-7m0-2v-6C3 3 4.5 3 4.5 3h6"
}, null, -1), RYe = [NYe];
function LYe(e, t) {
    return _(),
    O("svg", DYe, RYe)
}
const BYe = {
    render: LYe
}, VYe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, FYe = P("path", {
    d: "M19.24 12.361V4.415c0-1.1-.9-1.999-1.999-1.999H5.243A2.008 2.008 0 0 0 3.24 4.419v12c0 1.098.9 1.997 1.997 1.997h3.688m8.39 2.984h3.136m0 0v-5.297c0-.335.271-.606.606-.606h2.84M20.45 21.4v5.147a.605.605 0 0 0 .605.605h2.815m4.16-14.088h-3.405a.732.732 0 0 0-.73.73v3.405c0 .401.328.73.73.73h3.405c.401 0 .73-.328.73-.73v-3.405a.733.733 0 0 0-.73-.73Zm-11.447 5.827H13.18a.732.732 0 0 0-.73.73v3.405c0 .401.328.73.73.73h3.405c.401 0 .73-.328.73-.73V19.62a.732.732 0 0 0-.73-.729Zm11.422 5.829h-3.405a.732.732 0 0 0-.73.73v3.405c0 .401.328.73.73.73h3.405c.401 0 .73-.328.73-.73V25.45a.733.733 0 0 0-.73-.73ZM7.1 14.4 15.5 6m-5.4 0h5.4v5.4"
}, null, -1), jYe = [FYe];
function WYe(e, t) {
    return _(),
    O("svg", VYe, jYe)
}
const zYe = {
    render: WYe
}, HYe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, UYe = P("path", {
    d: "M12.5 3h7m2 0h6C29 3 29 4.5 29 4.5v6m0 2v7m0 2v6c0 1.5-1.5 1.5-1.5 1.5h-6m-2 0h-7m-2 0h-6C3 29 3 27.5 3 27.5v-6m0-2v-7m0-2v-6C3 3 4.5 3 4.5 3h6M5.596 26.4l8.4-8.4M8.596 18h5.4v5.4"
}, null, -1), qYe = [UYe];
function YYe(e, t) {
    return _(),
    O("svg", HYe, qYe)
}
const KYe = {
    render: YYe
};
const GYe = {
    components: {
        ActionBreadcrumb: MYe
    },
    computed: {
        ...ut("workflow", {
            workflow: "activeWorkflow"
        }),
        items() {
            let t = (this.workflow.parents || []).map(({
                    containerType: o,
                    name: i,
                    containerId: s = "root",
                    linked: a
                }) => ({
                    icon: this.getIcon(o, a),
                    text: i,
                    id: s
                }));
            const {
                containerType: n,
                linked: r
            } = this.workflow.info;
            return t.push({
                text: this.workflow.info.name,
                icon: this.getIcon(n, r)
            }),
            t
        }
    },
    methods: {
        getIcon(e, t) {
            return t && e === "component" ? zYe : t && e === "metanode" ? KYe : e === "component" ? AYe : e === "metanode" ? BYe : null
        },
        onClick({
            id: e
        }) {
            this.$router.push({
                name: zo.WorkflowPage,
                params: {
                    projectId: this.workflow.projectId,
                    workflowId: e
                },
                force: !0,
                replace: !0
            })
        }
    }
};
function XYe(e, t, n, r, o, i) {
    const s = B("ActionBreadcrumb");
    return _(),
    H(s, {
        items: i.items,
        onClick: i.onClick
    }, null, 8, ["items", "onClick"])
}
const JYe = te(GYe, [["render", XYe], ["__scopeId", "data-v-0036e617"]]);
const ZYe = {
    components: {
        DropdownIcon: al,
        SubMenu: Vf
    },
    props: {
        disabled: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        ...ut("canvas", ["zoomFactor"]),
        zoomInputValue() {
            return `${Math.round(this.zoomFactor * 100)}%`
        },
        zoomMenuItems() {
            return ["fillScreen", "fitToScreen", "zoomIn", "zoomOut", "zoomTo75", "zoomTo100", "zoomTo125", "zoomTo150"].map(e => this.$shortcuts.get(e))
        }
    },
    methods: {
        onZoomInputEnter(e) {
            let t = parseInt(e.target.value, 10) / 100;
            isNaN(t) || this.$store.dispatch("canvas/zoomCentered", {
                factor: t
            }),
            e.target.blur(),
            e.target.value = this.zoomInputValue
        },
        onZoomInputClick(e) {
            e.target.focus(),
            e.target.select()
        },
        onZoomInputFocusOut(e) {
            e.target.blur(),
            e.target.value = this.zoomInputValue
        },
        onZoomItemClick(e, t) {
            this.$shortcuts.dispatch(t.name),
            this.$refs.zoomInput.blur()
        },
        onWheel(e) {
            const t = e.deltaY < 0 ? 1 : -1;
            this.$store.dispatch("canvas/zoomCentered", {
                delta: t
            })
        }
    }
}, QYe = ["value"];
function eKe(e, t, n, r, o, i) {
    const s = B("DropdownIcon"),
    a = B("SubMenu");
    return _(),
    H(a, {
        ref: "subMenu",
        class: "zoom",
        "teleport-to-body": !1,
        items: i.zoomMenuItems,
        disabled: n.disabled,
        onItemClick: i.onZoomItemClick
    }, {
    default:
        oe(() => [P("input", {
                    ref: "zoomInput",
                    type: "text",
                    value: i.zoomInputValue,
                    class: "zoom-input",
                    onClick: t[0] || (t[0] = ve((...l) => i.onZoomInputClick && i.onZoomInputClick(...l), ["stop"])),
                    onKeydown: t[1] || (t[1] = Rt(ve((...l) => i.onZoomInputEnter && i.onZoomInputEnter(...l), ["stop", "prevent"]), ["enter"])),
                    onWheel: t[2] || (t[2] = ve((...l) => i.onWheel && i.onWheel(...l), ["prevent"])),
                    onFocusout: t[3] || (t[3] = ve((...l) => i.onZoomInputFocusOut && i.onZoomInputFocusOut(...l), ["stop"]))
                }, null, 40, QYe), z(s)]),
        _: 1
    }, 8, ["items", "disabled", "onItemClick"])
}
const tKe = te(ZYe, [["render", eKe], ["__scopeId", "data-v-826c2cd5"]]), Nu = () => navigator?.userAgent?.toLowerCase()?.includes("mac"), ga = () => Nu() ? "metaKey" : "ctrlKey", nKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, rKe = P("path", {
    d: "m26.44 21.205-8.198-8.2a7.54 7.54 0 0 0-10.664 0c-1.845 1.845-2.455 4.337-1.705 8.09"
}, null, -1), oKe = P("path", {
    "stroke-linejoin": "round",
    d: "M17.73 21.205h8.71v-8.713"
}, null, -1), iKe = [rKe, oKe];
function sKe(e, t) {
    return _(),
    O("svg", nKe, iKe)
}
const aKe = {
    render: sKe
}, lKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, cKe = P("path", {
    d: "m5.56 21.203 8.198-8.197a7.54 7.54 0 0 1 10.663 0c1.845 1.844 2.455 4.335 1.705 8.087"
}, null, -1), uKe = P("path", {
    "stroke-linejoin": "round",
    d: "M14.27 21.203H5.56v-8.71"
}, null, -1), dKe = [cKe, uKe];
function fKe(e, t) {
    return _(),
    O("svg", lKe, dKe)
}
const hKe = {
    render: fKe
}, pKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, mKe = P("path", {
    d: "M14 11.333V9h4v2.333m3 0L19.5 23h-7L11 11.333h10Zm-11 0h12-12Z"
}, null, -1), gKe = [mKe];
function vKe(e, t) {
    return _(),
    O("svg", pKe, gKe)
}
const aF = {
    render: vKe
}, yKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, wKe = P("path", {
    d: "M16 18.904a2.904 2.904 0 1 0 0-5.808 2.904 2.904 0 0 0 0 5.808Zm5.511-6.4L22.52 11.2 20.74 9.481l-1.304 1.008-2.015-.83L17.244 8h-2.488l-.238 1.66-2.014.829L11.2 9.48 9.481 11.2l1.008 1.304-.83 2.014L8 14.756v2.488l1.66.178.829 2.015L9.48 20.8l1.719 1.718 1.363-1.007 2.015.83.178 1.659h2.488l.238-1.66 1.955-.829L20.8 22.52l1.718-1.778-1.007-1.304.83-2.015L24 17.244v-2.488l-1.66-.238-.829-2.014Z"
}, null, -1), bKe = [wKe];
function _Ke(e, t) {
    return _(),
    O("svg", yKe, bKe)
}
const lF = {
    render: _Ke
}, kKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, xKe = P("path", {
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    d: "M4 27.52V4h23.52v19.404l-4.115 4.116H4Z"
}, null, -1), SKe = P("path", {
    "stroke-linejoin": "round",
    d: "M21.64 19.68H7.92v7.84h13.72v-7.84Zm-3.92 5.88v-3.92M23.6 4H7.92v11.76H23.6V4Z"
}, null, -1), CKe = [xKe, SKe];
function IKe(e, t) {
    return _(),
    O("svg", kKe, CKe)
}
const TKe = {
    render: IKe
}, MKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, PKe = P("path", {
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    d: "M8.563 2.5 14 7.937l-5.437 5.437"
}, null, -1), EKe = P("path", {
    "stroke-linejoin": "round",
    d: "M14 7.937H2M4 11.5v16.02h19.405l4.115-4.116V4H15.76"
}, null, -1), OKe = P("path", {
    "stroke-linejoin": "round",
    d: "M21.64 19.68H7.92v7.84h13.72v-7.84Zm-3.92 5.88v-3.92M15.76 4h7.84v11.76H11.84"
}, null, -1), $Ke = [PKe, EKe, OKe];
function AKe(e, t) {
    return _(),
    O("svg", MKe, $Ke)
}
const DKe = {
    render: AKe
}, Yy = (e, t, n, r) => {
    const o = r ? fr + _i / 2 : -_i / 2;
    if (n && (e++, t++), e === 0)
        return [o + (r ? -1 : 1) * _i / 2, -_i / 2];
    const i = fr / 2;
    if (t === 2)
        return [o, i];
    const s = 2,
    a = 1.5;
    t === 3 && e === 2 && (e = 3);
    const l = i + (e - s) * (_i + a);
    return [o, l]
}, mN = ({
    portCount: e,
    isOutport: t = !1,
    isMetanode: n = !1
}) => {
    const r = Number(n);
    switch (e) {
    case 1 - r:
        return Yy(e, e + 1, n, t);
    default:
        return Yy(Math.max(4 - r, e), Math.max(4 - r, e) + 1, n, t)
    }
}, Ky = ({
    portCount: e,
    isMetanode: t = !1,
    isOutports: n = !1
}) => [...Array(e).keys()].map(r => Yy(r, e, t, n)), NKe = {
    save: {
        title: "Save workflow",
        text: "保存",
        hotkey: ["Ctrl", "S"],
        icon: TKe,
        execute: ({
            $store: e
        }) => {
            e.getters["application/activeProjectOrigin"] ? e.dispatch("workflow/saveWorkflow") : e.dispatch("workflow/saveWorkflowAs")
        },
        condition: ({
            $store: e
        }) => qk() && (e.getters["application/isDirtyActiveProject"] || !e.getters["application/activeProjectOrigin"])
    },
    saveAs: {
        title: "另存为",
        text: "另存为…",
        icon: DKe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/saveWorkflowAs"),
        condition: () => qk()
    },
    undo: {
        title: "撤销",
        hotkey: ["Ctrl", "Z"],
        icon: hKe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/undo"),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.allowedActions.canUndo
    },
    redo: {
        title: "重做",
        hotkey: ["Ctrl", "Shift", "Z"],
        icon: aKe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/redo"),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.allowedActions.canRedo
    },
    configureNode: {
        text: "配置",
        hotkey: ["F6"],
        icon: lF,
        execute: ({
            $store: e,
            payload: t = null
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/openNodeConfiguration", n)
        },
        condition: ({
            $store: e
        }) => {
            const t = e.getters["selection/singleSelectedNode"];
            if (t) {
                const {
                    canOpenDialog: n
                } = t.allowedActions;
                return n && EC(t.kind) && e.state.application.permissions.canConfigureNodes
            }
            return !1
        }
    },
    configureFlowVariables: {
        text: "配置流变量",
        hotkey: ["Shift", "F6"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/openFlowVariableConfiguration", e.getters["selection/singleSelectedNode"].id),
        condition: ({
            $store: e
        }) => {
            const t = e.getters["selection/singleSelectedNode"];
            if (t) {
                const {
                    canOpenLegacyFlowVariableDialog: n
                } = t.allowedActions;
                return n && B6() && e.state.application.permissions.canConfigureNodes
            }
            return !1
        }
    },
    editName: {
        text: ({
            $store: e
        }) => `重命名 ${e.getters["selection/singleSelectedNode"]?.kind}`,
        hotkey: ["Shift", "F2"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/openNameEditor", e.getters["selection/singleSelectedNode"].id),
        condition: ({
            $store: e
        }) => ["metanode", "component"].includes(e.getters["selection/singleSelectedNode"]?.kind) && !e.getters["selection/singleSelectedNode"]?.link && e.getters["workflow/isWritable"]
    },
    editNodeComment: {
        text: "编辑节点注释",
        hotkey: ["F2"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/openLabelEditor", e.getters["selection/singleSelectedNode"].id),
        condition: ({
            $store: e
        }) => e.getters["selection/singleSelectedNode"] !== null && e.getters["workflow/isWritable"]
    },
    deleteSelected: {
        text: "删除",
        title: "删除所选内容",
        hotkey: ["Delete"],
        icon: aF,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/deleteSelectedObjects"),
        condition({
            $store: e
        }) {
            if (!e.getters["workflow/isWritable"])
                return !1;
            const t = e.getters["selection/selectedNodes"],
            n = e.getters["selection/selectedConnections"],
            r = e.getters["selection/selectedAnnotations"],
            o = e.getters["selection/selectedBendpointIds"];
            return t.length === 0 && n.length === 0 && r.length === 0 && o.length === 0 ? !1 : t.every(s => s.allowedActions.canDelete) && n.every(s => s.allowedActions.canDelete)
        }
    },
    copy: {
        text: "复制",
        title: "复制选择",
        hotkey: ["Ctrl", "C"],
        allowEventDefault: !0,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/copyOrCutWorkflowParts", {
            command: "copy"
        }),
        condition: ({
            $store: e
        }) => {
            const t = document.querySelector("#node-output");
            if (t && t.contains(document.activeElement))
                return !1;
            const n = Object.keys(e.getters["selection/selectedNodes"]),
            r = e.getters["selection/selectedAnnotations"],
            o = e.state.canvas.getScrollContainerElement(),
            i = document.activeElement === o,
            s = window?.getSelection().toString() === "";
            return (n.length !== 0 || r.length !== 0) && e.state.application.hasClipboardSupport && (s || i)
        }
    },
    cut: {
        text: "剪切",
        title: "剪切所选",
        hotkey: ["Ctrl", "X"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/copyOrCutWorkflowParts", {
            command: "cut"
        }),
        condition: ({
            $store: e
        }) => {
            const t = Object.keys(e.getters["selection/selectedNodes"]),
            n = e.getters["selection/selectedAnnotations"];
            return (t.length !== 0 || n.length !== 0) && e.getters["workflow/isWritable"] && e.state.application.hasClipboardSupport
        }
    },
    paste: {
        text: "黏贴",
        title: "从剪切板黏贴",
        hotkey: ["Ctrl", "V"],
        execute: ({
            $store: e,
            payload: t
        }) => e.dispatch("workflow/pasteWorkflowParts", {
            position: t?.metadata?.position
        }),
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"] && e.state.application.hasClipboardSupport
    },
    switchToPanMode: {
        hotkey: ["P"],
        text: "平移模式",
        icon: Y9,
        execute: ({
            $store: e
        }) => {
            e.dispatch("application/switchCanvasMode", "pan")
        },
        condition: ({
            $store: e
        }) => !e.getters["workflow/isWorkflowEmpty"]
    },
    switchToSelectionMode: {
        hotkey: ["V"],
        text: "选择模式",
        icon: iF,
        execute: ({
            $store: e
        }) => {
            e.dispatch("application/switchCanvasMode", "selection")
        }
    },
    quickAddNode: {
        text: "快速添加节点",
        title: "添加新节点",
        hotkey: ["Ctrl", "."],
        execute: ({
            $store: e
        }) => {
            const {
                isOpen: t,
                props: n
            } = e.state.workflow.quickAddNodeMenu, {
                nodeId: r,
                port: {
                    index: o
                } = {
                    index: -1
                },
                position: i
            } = n ?? {},
            s = t ? e.getters["workflow/getNodeById"](r) : e.getters["selection/singleSelectedNode"];
            if (s === null) {
                const y = br.findFreeSpaceAroundCenterWithFallback({
                    visibleFrame: e.getters["canvas/getVisibleFrame"](),
                    nodes: e.state.workflow.activeWorkflow.nodes
                });
                e.dispatch("workflow/openQuickAddNodeMenu", {
                    props: {
                        position: y
                    }
                });
                return
            }
            const a = s.id,
            l = s.outPorts.length,
            c = l === 1 ? 0 : 1,
            u = (o + 1) % l,
            f = r === a ? u : c,
            p = (y, b, w, k) => {
                const C = Ky({
                    portCount: w,
                    isMetanode: rh(y),
                    isOutports: !0
                }),
                x = fr * 3,
                S = {
                    x: y.position.x + C[b][0] + x,
                    y: y.position.y + C[b][1]
                };
                return br.findFreeSpaceAroundPointWithFallback({
                    startPoint: S,
                    visibleFrame: k.getters["canvas/getVisibleFrame"](),
                    nodes: k.state.workflow.activeWorkflow.nodes
                })
            },
            m = s.outPorts[f],
            v = t ? i : p(s, f, l, e);
            e.dispatch("workflow/openQuickAddNodeMenu", {
                props: {
                    nodeId: a,
                    port: m,
                    position: v
                }
            })
        },
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"]
    }
}, RKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, LKe = P("path", {
    d: "M5.078 5v22l9.467-7.303V27l14.877-11L14.545 5v7.303L5.078 5Z"
}, null, -1), BKe = [LKe];
function VKe(e, t) {
    return _(),
    O("svg", RKe, BKe)
}
const FKe = {
    render: VKe
}, jKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, WKe = P("path", {
    d: "M4.9 5.183 27 26.917M26.817 5 5.083 27.1"
}, null, -1), zKe = [WKe];
function HKe(e, t) {
    return _(),
    O("svg", jKe, zKe)
}
const UKe = {
    render: HKe
}, qKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, YKe = P("path", {
    "stroke-linejoin": "round",
    d: "M19.582 5.121 8.704 16l10.878 10.878"
}, null, -1), KKe = P("path", {
    d: "M1.995 5v22M8.704 16h22.3"
}, null, -1), GKe = [YKe, KKe];
function XKe(e, t) {
    return _(),
    O("svg", qKe, GKe)
}
const JKe = {
    render: XKe
}, ZKe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, QKe = P("path", {
    d: "M15 19a5 5 0 1 0 0-10 5 5 0 0 0 0 10Zm3-1 5 5"
}, null, -1), eGe = [QKe];
function tGe(e, t) {
    return _(),
    O("svg", ZKe, eGe)
}
const cF = {
    render: tGe
}, nGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, rGe = P("path", {
    "stroke-linejoin": "round",
    d: "M6.42 18.281V5.85l10.7 6.216-10.7 6.215Z"
}, null, -1), oGe = P("path", {
    d: "M21.287 9.02h4.358c.844 0 1.528.684 1.528 1.528v14.603c0 .844-.684 1.529-1.528 1.529H11.042a1.529 1.529 0 0 1-1.529-1.529v-2.886"
}, null, -1), iGe = [rGe, oGe];
function sGe(e, t) {
    return _(),
    O("svg", nGe, iGe)
}
const aGe = {
    render: sGe
}, lGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, cGe = P("path", {
    "stroke-linejoin": "round",
    d: "m4 5.432 11.601 11.41M15.506 5.336 4.096 16.938"
}, null, -1), uGe = P("path", {
    d: "M18.345 9.007h7.36c.81 0 1.468.657 1.468 1.468v14.72c0 .811-.657 1.469-1.468 1.469h-14.72a1.469 1.469 0 0 1-1.468-1.469v-7.36"
}, null, -1), dGe = [cGe, uGe];
function fGe(e, t) {
    return _(),
    O("svg", lGe, dGe)
}
const hGe = {
    render: fGe
}, pGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, mGe = P("path", {
    "stroke-linejoin": "round",
    d: "M11.205 5.162 7.419 8.948l3.786 3.785M5.085 5.12v7.655M7.42 8.948h7.76"
}, null, -1), gGe = P("path", {
    d: "M19.796 8.948h5.996c.752 0 1.362.61 1.362 1.363v14.934c0 .753-.61 1.363-1.362 1.363H10.857c-.753 0-1.363-.61-1.363-1.363v-8.939"
}, null, -1), vGe = [mGe, gGe];
function yGe(e, t) {
    return _(),
    O("svg", pGe, vGe)
}
const wGe = {
    render: yGe
}, bGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, _Ge = P("path", {
    d: "M14 22.1V9.9L24.5 16 14 22.1ZM11 10v12"
}, null, -1), kGe = [_Ge];
function xGe(e, t) {
    return _(),
    O("svg", bGe, kGe)
}
const uF = {
    render: xGe
}, SGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, CGe = P("path", {
    d: "M13.931 9.933v12.134m4.138 0V9.933"
}, null, -1), IGe = [CGe];
function TGe(e, t) {
    return _(),
    O("svg", SGe, IGe)
}
const dF = {
    render: TGe
}, MGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, PGe = P("path", {
    d: "M10.893 21 9 22.1V9.9l7 4.067M23 23V13h-4v3h-3v3h-3v4"
}, null, -1), EGe = [PGe];
function OGe(e, t) {
    return _(),
    O("svg", MGe, EGe)
}
const fF = {
    render: OGe
}, gN = ({
    $store: e,
    payload: t = {}
}) => {
    const {
        nodeId: n
    } = t.metadata || {},
    r = n || e.getters["selection/singleSelectedNode"].id;
    e.dispatch("workflow/executeNodeAndOpenView", r)
}, vN = ({
    $store: e
}) => e.getters["selection/singleSelectedNode"] && (e.getters["selection/singleSelectedNode"].allowedActions.canExecute || e.getters["selection/singleSelectedNode"].allowedActions.canOpenView), $Ge = {
    executeAll: {
        text: "执行全部",
        title: "执行全部",
        hotkey: ["Shift", "F7"],
        icon: FKe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/executeNodes", "all"),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.allowedActions.canExecute
    },
    cancelAll: {
        text: "取消全部",
        title: "取消工作流执行",
        hotkey: ["Shift", "F9"],
        icon: UKe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/cancelNodeExecution", "all"),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.allowedActions.canCancel
    },
    resetAll: {
        text: "重置全部",
        title: "重置已执行的节点",
        hotkey: ["Shift", "F8"],
        icon: JKe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/resetNodes", "all"),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.allowedActions.canReset
    },
    executeSelected: {
        text: "执行",
        title: "执行选定的节点",
        hotkey: ["F7"],
        icon: aGe,
        execute: ({
            $store: e,
            payload: t = {}
        }) => {
            const n = t?.metadata?.nodeId ? [t?.metadata?.nodeId] : "selected";
            e.dispatch("workflow/executeNodes", n)
        },
        condition: ({
            $store: e
        }) => e.getters["selection/selectedNodes"].some(t => t.allowedActions.canExecute)
    },
    executeAndOpenView: {
        text: ({
            $store: e
        }) => e.getters["selection/singleSelectedNode"].allowedActions.canExecute ? "Execute and open view" : "Open view",
        hotkey: ["F10"],
        icon: cF,
        execute: gN,
        condition: vN
    },
    executeAndOpenViewShortcutAlternative: {
        hotkey: ["Shift", "F10"],
        execute: gN,
        condition: vN
    },
    cancelSelected: {
        text: "取消",
        title: "取消选定的节点",
        hotkey: ["F9"],
        icon: hGe,
        execute: ({
            $store: e,
            payload: t = {}
        }) => {
            const n = t?.metadata?.nodeId ? [t?.metadata?.nodeId] : "selected";
            e.dispatch("workflow/cancelNodeExecution", n)
        },
        condition: ({
            $store: e
        }) => e.getters["selection/selectedNodes"].some(t => t.allowedActions.canCancel)
    },
    resetSelected: {
        text: "重置",
        title: "重置所选节点",
        hotkey: ["F8"],
        icon: wGe,
        execute: ({
            $store: e,
            payload: t = {}
        }) => {
            const n = t?.metadata?.nodeId ? [t?.metadata?.nodeId] : "selected";
            e.dispatch("workflow/resetNodes", n)
        },
        condition: ({
            $store: e
        }) => e.getters["selection/selectedNodes"].some(t => t.allowedActions.canReset)
    },
    resumeLoopExecution: {
        text: "恢复循环",
        title: "恢复循环执行",
        hotkey: ["Ctrl", "Alt", "F8"],
        icon: uF,
        execute: ({
            $store: e,
            payload: t = {}
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/resumeLoopExecution", n)
        },
        condition: ({
            $store: e
        }) => e.getters["selection/singleSelectedNode"]?.loopInfo?.allowedActions?.canResume
    },
    pauseLoopExecution: {
        text: "暂停循环",
        title: "暂停循环执行",
        hotkey: ["Ctrl", "Alt", "F7"],
        icon: dF,
        execute: ({
            $store: e,
            payload: t = {}
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/pauseLoopExecution", n)
        },
        condition: ({
            $store: e
        }) => e.getters["selection/singleSelectedNode"]?.loopInfo?.allowedActions?.canPause
    },
    stepLoopExecution: {
        text: "步进循环",
        title: "执行一个循环步骤",
        hotkey: ["Ctrl", "Alt", "F6"],
        icon: fF,
        execute: ({
            $store: e,
            payload: t = {}
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/stepLoopExecution", n)
        },
        condition: ({
            $store: e
        }) => e.getters["selection/singleSelectedNode"]?.loopInfo?.allowedActions?.canStep
    }
};
var AGe = function (t) {
    var n = null,
    r,
    o = function (a) {
        return function () {
            n = null,
            t.apply(a, r)
        }
    },
    i = function () {
        for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
            l[c] = arguments[c];
        r = l,
        n === null && (n = requestAnimationFrame(o(this)))
    };
    return i.cancel = function () {
        cancelAnimationFrame(n),
        n = null
    },
    i
}, Ds = AGe;
const yN = Ds(({
            $store: e
        }) => {
        e.dispatch("canvas/zoomCentered", {
            delta: 1
        })
    }), DGe = {
    fitToScreen: {
        text: "适合屏幕",
        hotkey: ["Ctrl", "2"],
        execute: ({
            $store: e
        }) => e.dispatch("canvas/fitToScreen")
    },
    fillScreen: {
        text: "填满整个屏幕",
        hotkey: ["Ctrl", "1"],
        execute: ({
            $store: e
        }) => e.dispatch("canvas/fillScreen")
    },
    zoomIn: {
        text: "放大",
        hotkey: ["Ctrl", "+"],
        execute: yN
    },
    zoomInAlternative: {
        hotkey: ["Shift", "Ctrl", "="],
        execute: yN
    },
    zoomOut: {
        text: "缩小",
        hotkey: ["Ctrl", "-"],
        execute: Ds(({
                $store: e
            }) => {
            e.dispatch("canvas/zoomCentered", {
                delta: -1
            })
        })
    },
    zoomTo75: {
        text: "缩放至 75%",
        execute: ({
            $store: e
        }) => e.dispatch("canvas/zoomCentered", {
            factor: .75
        })
    },
    zoomTo100: {
        text: "缩放至 100%",
        hotkey: ["Ctrl", "0"],
        execute: ({
            $store: e
        }) => e.dispatch("canvas/zoomCentered", {
            factor: 1
        })
    },
    zoomTo125: {
        text: "缩放至 125%",
        execute: ({
            $store: e
        }) => e.dispatch("canvas/zoomCentered", {
            factor: 1.25
        })
    },
    zoomTo150: {
        text: "缩放至 150%",
        execute: ({
            $store: e
        }) => e.dispatch("canvas/zoomCentered", {
            factor: 1.5
        })
    }
}, NGe = {
    closeWorkflow: {
        text: "关闭工作流",
        hotkey: ["Ctrl", "W"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/closeWorkflow", e.state.workflow.activeWorkflow?.projectId),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.projectId !== null
    },
    createWorkflow: {
        text: "创建工作流",
        hotkey: ["Ctrl", "N"],
        execute: ({
            $store: e
        }) => {
            const {
                activeProjectId: t
            } = e.state.application, {
                projectPath: n
            } = e.state.spaces,
            r = n[wm] && wm,
            o = n[bm] && bm,
            s = e.getters["application/isUnknownProject"] ? o : t ?? r ?? o;
            e.commit("spaces/setCreateWorkflowModalConfig", {
                isOpen: !0,
                projectId: s
            })
        },
        condition: ({
            $store: e
        }) => !e.state.spaces.isLoadingContent
    }
}, RGe = {
    switchToAnnotationMode: {
        hotkey: ["T"],
        text: "注释模式",
        icon: sF,
        execute: ({
            $store: e
        }) => {
            e.dispatch("application/switchCanvasMode", "annotation")
        },
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"]
    },
    addWorkflowAnnotation: {
        text: "新的工作流注释",
        execute: ({
            $store: e,
            payload: t
        }) => {
            const {
                metadata: n
            } = t;
            n?.position && e.dispatch("workflow/addWorkflowAnnotation", {
                bounds: {
                    x: n.position.x,
                    y: n.position.y,
                    width: n.width || 80,
                    height: n.height || 80
                }
            })
        },
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"]
    },
    bringAnnotationToFront: {
        text: "移到最前",
        hotkey: ["Ctrl", "Shift", "ArrowUp"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/reorderWorkflowAnnotation", {
            action: Vd.ActionEnum.BringToFront
        }),
        condition: ({
            $store: e
        }) => e.getters["selection/selectedAnnotations"].length > 0 && e.getters["workflow/isWritable"]
    },
    bringAnnotationForward: {
        hotkey: ["Ctrl", "ArrowUp"],
        text: "向前",
        execute: ({
            $store: e
        }) => e.dispatch("workflow/reorderWorkflowAnnotation", {
            action: Vd.ActionEnum.BringForward
        }),
        condition: ({
            $store: e
        }) => e.getters["selection/selectedAnnotations"].length > 0 && e.getters["workflow/isWritable"]
    },
    sendAnnotationBackward: {
        hotkey: ["Ctrl", "ArrowDown"],
        text: "后移一层",
        execute: ({
            $store: e
        }) => e.dispatch("workflow/reorderWorkflowAnnotation", {
            action: Vd.ActionEnum.SendBackward
        }),
        condition: ({
            $store: e
        }) => e.getters["selection/selectedAnnotations"].length > 0 && e.getters["workflow/isWritable"]
    },
    sendAnnotationToBack: {
        hotkey: ["Ctrl", "Shift", "ArrowDown"],
        text: "移动最后",
        execute: ({
            $store: e
        }) => e.dispatch("workflow/reorderWorkflowAnnotation", {
            action: Vd.ActionEnum.SendToBack
        }),
        condition: ({
            $store: e
        }) => e.getters["selection/selectedAnnotations"].length > 0 && e.getters["workflow/isWritable"]
    }
}, LGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, BGe = P("path", {
    d: "M13.371 5.485h5.258m2.629 0h4.044c1.213 0 1.213 1.213 1.213 1.213v4.044m0 2.427v5.662m0 2.427v4.044c0 1.213-1.213 1.213-1.213 1.213h-4.044m-2.63 0h-5.257m-2.629 0H6.698c-1.213 0-1.213-1.213-1.213-1.213v-4.044m0-2.427V13.17m0-2.427V6.698c0-1.213 1.213-1.213 1.213-1.213h3.1M16 11.619v8.762M11.619 16h8.762"
}, null, -1), VGe = [BGe];
function FGe(e, t) {
    return _(),
    O("svg", LGe, VGe)
}
const jGe = {
    render: FGe
}, WGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, zGe = P("path", {
    d: "M19.048 14.05V6.83c0-.804-.65-1.46-1.444-1.46H7.524c-.383 0-.75.155-1.021.429a1.475 1.475 0 0 0-.425 1.033v10.182c0 .802.65 1.459 1.442 1.459h4.08m6.057 2.18h2.265m0 0v-3.87a.44.44 0 0 1 .438-.442h2.05m-2.488 4.311v3.76c0 .117.046.23.128.312.082.083.193.13.309.13h2.032m3.004-10.29h-2.459a.526.526 0 0 0-.372.156.538.538 0 0 0-.155.377v2.487c0 .293.237.533.527.533h2.459c.29 0 .527-.24.527-.533v-2.487a.538.538 0 0 0-.155-.376.526.526 0 0 0-.372-.157ZM17.13 18.82h-2.458a.525.525 0 0 0-.373.157.538.538 0 0 0-.154.376v2.487c0 .293.236.533.527.533h2.458c.29 0 .527-.24.527-.533v-2.488a.538.538 0 0 0-.155-.376.526.526 0 0 0-.372-.156Zm8.247 4.257h-2.459a.525.525 0 0 0-.372.157.538.538 0 0 0-.155.376v2.488c0 .292.237.533.527.533h2.459c.29 0 .527-.24.527-.534V23.61a.539.539 0 0 0-.155-.376.527.527 0 0 0-.372-.157ZM12.456 8.204v7.087M8.913 11.748H16"
}, null, -1), HGe = [zGe];
function UGe(e, t) {
    return _(),
    O("svg", WGe, HGe)
}
const qGe = {
    render: UGe
}, YGe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, KGe = P("path", {
    "stroke-linejoin": "round",
    d: "M5.49 5.59h21.02v6.005H5.49V5.59ZM5.49 15.9h6.006v10.51H5.49V15.9ZM15.802 15.9H26.31v10.51h-10.51V15.9Z"
}, null, -1), GGe = [KGe];
function XGe(e, t) {
    return _(),
    O("svg", YGe, GGe)
}
const wN = {
    render: XGe
}, bN = e => ({
    $store: t
}) => {
    const n = t.getters["selection/singleSelectedNode"];
    return !t.getters["workflow/isWritable"] || n?.link || n?.isLocked ? !1 : n?.kind === e && n?.allowedActions.canExpand !== "false"
}, _N = e => ({
    $store: t
}) => {
    const n = t.getters["selection/singleSelectedNode"];
    return n?.kind === e && !n?.isLocked
}, JGe = {
    createMetanode: {
        text: "创建元点",
        title: "Create metanode",
        hotkey: ["Ctrl", "G"],
        icon: jGe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/collapseToContainer", {
            containerType: "metanode"
        }),
        condition({
            $store: e
        }) {
            return !e.getters["workflow/isWritable"] || !e.getters["selection/selectedNodes"].length ? !1 : e.getters["selection/selectedNodes"].every(t => t.allowedActions.canCollapse !== "false")
        }
    },
    createComponent: {
        text: "创建组件",
        title: "Create component",
        hotkey: ["Ctrl", "J"],
        icon: qGe,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/collapseToContainer", {
            containerType: "component"
        }),
        condition({
            $store: e
        }) {
            return !e.getters["workflow/isWritable"] || !e.getters["selection/selectedNodes"].length ? !1 : e.getters["selection/selectedNodes"].every(t => t.allowedActions.canCollapse !== "false")
        }
    },
    openComponentOrMetanode: {
        text: ({
            $store: e
        }) => `打开${e.getters["selection/singleSelectedNode"]?.kind}`,
        hotkey: ["Ctrl", "Alt", "Enter"],
        execute: ({
            $store: e,
            $router: t
        }) => {
            const n = e.state.application.activeProjectId,
            r = e.getters["selection/singleSelectedNode"].id;
            t.push({
                name: zo.WorkflowPage,
                params: {
                    projectId: n,
                    workflowId: r
                }
            })
        },
        condition: ({
            $store: e
        }) => _N("component")({
            $store: e
        }) || _N("metanode")({
            $store: e
        })
    },
    openParentWorkflow: {
        hotkey: ["Ctrl", "Alt", "Shift", "Enter"],
        execute: ({
            $store: e,
            $router: t
        }) => {
            const n = e.state.application.activeProjectId,
            o = e.state.workflow.activeWorkflow.parents.at(-1).containerId;
            t.push({
                name: zo.WorkflowPage,
                params: {
                    projectId: n,
                    workflowId: o
                },
                force: !0,
                replace: !0
            })
        },
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow.parents?.length > 0
    },
    expandMetanode: {
        text: "拆分元节点",
        title: "Expand metanode",
        hotkey: ["Ctrl", "Shift", "G"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/expandContainerNode"),
        condition: bN("metanode")
    },
    expandComponent: {
        text: "拆分组件",
        title: "Expand component",
        hotkey: ["Ctrl", "Shift", "J"],
        execute: ({
            $store: e
        }) => e.dispatch("workflow/expandContainerNode"),
        condition: bN("component")
    },
    linkComponent: {
        text: "共享",
        title: "Share component",
        execute: ({
            $store: e,
            payload: t = null
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/linkComponent", {
                nodeId: n
            })
        },
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"]
    },
    updateComponent: {
        text: "更新组件",
        title: "Update component",
        execute: ({
            $store: e,
            payload: t = null
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/updateComponents", {
                nodeIds: [n]
            })
        },
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"]
    },
    unlinkComponent: {
        text: "断开链接",
        title: "Unlink component",
        execute: ({
            $store: e,
            payload: t = null
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/unlinkComponent", {
                nodeId: n
            })
        },
        condition: ({
            $store: e
        }) => e.getters["workflow/isWritable"]
    },
    changeHubItemVersion: {
        text: "更改Hub项目版本",
        title: "Change KNIME Hub item version",
        execute: ({
            $store: e,
            payload: t = null
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/changeHubItemVersion", {
                nodeId: n
            })
        },
        condition: ({
            $store: e
        }) => {
            const t = e.getters["workflow/isWritable"],
            n = e.getters["selection/singleSelectedNode"].link?.isHubItemVersionChangeable;
            return t && n
        }
    },
    changeComponentLinkType: {
        text: "更改链接类型",
        title: "Change component link type",
        execute: ({
            $store: e,
            payload: t = null
        }) => {
            const n = t?.metadata?.nodeId || e.getters["selection/singleSelectedNode"].id;
            e.dispatch("workflow/changeComponentLinkType", {
                nodeId: n
            })
        },
        condition: ({
            $store: e
        }) => {
            const t = e.getters["workflow/isWritable"],
            n = e.getters["selection/singleSelectedNode"].link?.isLinkTypeChangeable;
            return t && n
        }
    },
    openLayoutEditor: {
        text: "打开布局编辑器",
        title: "Open layout editor",
        hotkey: ["Ctrl", "D"],
        icon: wN,
        execute: ({
            $store: e
        }) => e.dispatch("workflow/openLayoutEditor"),
        condition: ({
            $store: e
        }) => e.state.workflow.activeWorkflow?.info.containerType === "component" && e.getters["workflow/isWritable"]
    },
    openLayoutEditorByNodeId: {
        text: "打开布局编辑器",
        title: "Open layout editor",
        hotkey: ["Ctrl", "Shift", "D"],
        icon: wN,
        execute: ({
            $store: e
        }) => {
            const t = e.getters["selection/singleSelectedNode"]?.id;
            e.dispatch("workflow/openLayoutEditorByNodeId", {
                nodeId: t
            })
        },
        condition: ({
            $store: e
        }) => {
            const t = e.getters["selection/singleSelectedNode"];
            return t?.kind === "component" && !t?.isLocked && !t?.link && yf()
        }
    },
    checkForComponentUpdates: {
        text: "检查链接的组件更新",
        title: "Check for linked component updates",
        execute: ({
            $store: e
        }) => {
            e.dispatch("workflow/checkForLinkedComponentUpdates")
        },
        condition: ({
            $store: e
        }) => {
            const {
                containsLinkedComponents: t
            } = e.state.workflow.activeWorkflow.info,
            n = e.getters["workflow/isWritable"];
            return t && n
        }
    }
}, ZGe = {
    selectAll: {
        hotkey: ["Ctrl", "A"],
        execute: ({
            $store: e
        }) => e.dispatch("selection/selectAllObjects")
    },
    deselectAll: {
        hotkey: ["Ctrl", "Shift", "A"],
        execute: ({
            $store: e
        }) => e.dispatch("selection/deselectAllObjects")
    }
}, QGe = {
    toggleSidePanel: {
        hotkey: ["Ctrl", "P"],
        execute: ({
            $store: e
        }) => e.commit("panel/toggleExpanded")
    }
}, Wv = (e, t) => (e && Object.values(t).forEach(n => {
        const r = n.condition;
        r ? n.condition = (...o) => e(...o) && r(...o) : n.condition = e
    }), t), Uc = {
    ...NGe,
    ...Wv(({
            $store: e
        }) => Boolean(e.state.workflow.activeWorkflow), {
        ...NKe,
        ...RGe,
        ...JGe,
        ...Wv(({
                $store: e
            }) => e.state.application.permissions.canEditWorkflow, $Ge),
        ...Wv(({
                $store: e
            }) => Boolean(e.state.canvas.interactionsEnabled), ZGe),
        ...Wv(({
                $store: e
            }) => Boolean(e.state.canvas.interactionsEnabled && !e.getters["workflow/isWorkflowEmpty"]), DGe)
    }),
    ...QGe
}, pp = e => {
    const t = {
        ArrowUp: "↑",
        ArrowDown: "↓"
    },
    n = {
        Shift: "⇧",
        Delete: "⌫",
        Ctrl: "⌘",
        Alt: "⌥"
    },
    r = i => s => i[s] || s,
    o = i => i;
    return e.map(r(t)).map(Nu() ? r(n) : o).join(" ")
};
Object.entries(Uc).forEach(([e, t]) => {
    t.name = e,
    t.hotkey && (t.hotkeyText = pp(t.hotkey))
});
Object.freeze(Uc);
const hF = ({
    $store: e,
    $router: t,
    $toast: n
}) => ({
    isEnabled: c => {
        const u = Uc[c];
        if (!u)
            throw new Error(`Shortcut ${c} doesn't exist`);
        return u.condition ? u.condition({
            $store: e
        }) : !0
    },
    dispatch: (c, u = {}) => {
        const f = Uc[c];
        if (!f)
            throw new Error(`Shortcut ${c} doesn't exist`);
        f.execute({
            $store: e,
            $router: t,
            $toast: n,
            payload: u
        })
    },
    preventDefault: c => {
        const u = Uc[c];
        if (!u)
            throw new Error(`Shortcut ${c} doesn't exist`);
        return !u.allowEventDefault
    },
    findByHotkey: ({
        key: c,
        metaKey: u,
        ctrlKey: f,
        shiftKey: p,
        altKey: m
    }) => {
        for (const [v, {
                    hotkey: y
                }
            ] of Object.entries(Uc)) {
            if (!y)
                continue;
            const b = [...y],
            w = b.pop(),
            k = b.includes("Ctrl") === (Nu() ? u : f),
            C = Boolean(p) === b.includes("Shift"),
            x = Boolean(m) === b.includes("Alt"),
            S = c.toUpperCase() === w.toUpperCase() || Nu() && w === "Delete" && c === "Backspace";
            if (k && C && x && S)
                return consola.trace("Shortcut", y, v), v
        }
        return null
    },
    get: c => ({
        ...Uc[c]
    })
}), pF = () => {
    const e = wa(),
    t = g0e(),
    n = w6();
    return hF({
        $store: e,
        $router: t,
        $toast: n
    })
}, eXe = ({
    app: e,
    $store: t,
    $router: n,
    $toast: r
}) => {
    const o = hF({
        $store: t,
        $router: n,
        $toast: r
    });
    e.config.globalProperties.$shortcuts = o
};
const tXe = {
    props: {
        withText: {
            type: Boolean,
        default:
            !1
        },
        primary: {
            type: Boolean,
        default:
            !1
        }
    }
};
function nXe(e, t, n, r, o, i) {
    return _(),
    O("button", {
        class: he(["button", {
                    "with-text": n.withText,
                    primary: n.primary
                }
            ]),
        tabindex: "1"
    }, [Ye(e.$slots, "default")], 2)
}
const rXe = te(tXe, [["render", nXe], ["__scopeId", "data-v-d3e65094"]]), oXe = Fe({
    __name: "ToolbarShortcutButton",
    props: {
        name: {},
        withText: {
            type: Boolean,
        default:
            !0
        },
        dropdown: {
        default:
            () => []
        }
    },
    setup(e) {
        const t = e,
        n = pF(),
        r = ne(() => {
            if (!t.dropdown || t.dropdown.length === 0)
                return [];
            const l = c => {
                const u = n.get(c), {
                    hotkeyText: f,
                    icon: p,
                    title: m
                } = u,
                v = u.text,
                y = !n.isEnabled(c);
                return {
                    name: c,
                    text: v,
                    title: m,
                    disabled: y,
                    hotkeyText: f,
                    icon: p
                }
            };
            return t.dropdown.map(l)
        }),
        o = ne(() => r.value.length > 0),
        i = ne(() => n.get(t.name)),
        s = ne(() => {
            const {
                title: l,
                hotkeyText: c
            } = i.value;
            return [l, c].filter(Boolean).join(" – ")
        }),
        a = ne(() => n.isEnabled(t.name));
        return (l, c) => (_(), O("div", {
                class: he({
                    "split-button": o.value
                })
            }, [z(rXe, {
                        class: "toolbar-button",
                        "with-text": l.withText && Boolean(i.value.text),
                        disabled: !a.value,
                        title: s.value,
                        onClick: c[0] || (c[0] = u => ke(n).dispatch(l.name))
                    }, {
                    default:
                        oe(() => [i.value.icon ? (_(), H(Kt(i.value.icon), {
                                        key: 0
                                    })) : J("", !0), mt(" " + Re(l.withText ? i.value.text : ""), 1)]),
                        _: 1
                    }, 8, ["with-text", "disabled", "title"]), o.value ? (_(), H(Vf, {
                            key: 0,
                            ref: "submenu",
                            "teleport-to-body": !1,
                            items: r.value,
                            tabindex: "1",
                            orientation: "left",
                            onItemClick: c[1] || (c[1] = (u, f) => ke(n).dispatch(f.name)),
                            onKeydown: c[2] || (c[2] = Rt(ve(u => l.$refs.submenu.toggleMenu(u), ["stop", "prevent"]), ["enter"]))
                        }, {
                        default:
                            oe(() => [z(ke(al))]),
                            _: 1
                        }, 8, ["items"])) : J("", !0)], 2))
    }
});
const iXe = te(oXe, [["__scopeId", "data-v-007bbbf6"]]), sXe = {
    components: {
        WorkflowBreadcrumb: JYe,
        ZoomMenu: tKe,
        ToolbarShortcutButton: iXe,
        SubMenu: Vf,
        SelectionModeIcon: iF,
        ArrowMoveIcon: Y9,
        AnnotationModeIcon: sF
    },
    computed: {
        ...ut("workflow", {
            workflow: "activeWorkflow"
        }),
        ...ut("application", ["permissions"]),
        ...zt("workflow", ["isWorkflowEmpty"]),
        ...zt("selection", ["selectedNodes"]),
        ...zt("application", ["hasAnnotationModeEnabled", "hasSelectionModeEnabled", "hasPanModeEnabled", "isUnknownProject"]),
        canvasModes() {
            return [{
                    id: "selection",
                    shortcutName: "switchToSelectionMode"
                }, {
                    id: "annotation",
                    shortcutName: "switchToAnnotationMode"
                }, {
                    id: "pan",
                    shortcutName: "switchToPanMode"
                }
            ].map(({
                    id: t,
                    shortcutName: n
                }) => {
                const r = this.$shortcuts.get(n);
                return r ? {
                    text: typeof r.text == "function" ? r.text({
                        $store: this.$store
                    }) : r.text,
                    hotkeyText: r.hotkeyText,
                    disabled: !this.$shortcuts.isEnabled(n),
                    metadata: {
                        id: t
                    }
                }
                 : null
            }).filter(Boolean)
        },
        hasBreadcrumb() {
            return this.workflow?.parents?.length > 0
        },
        hideText() {
            return {
                save: !0,
                saveAs: !0,
                undo: !0,
                redo: !0
            }
        },
        toolbarDropdowns() {
            return this.isUnknownProject ? {}
             : {
                save: ["save", "saveAs"]
            }
        },
        toolbarButtons() {
            const e = this.workflow?.info.containerType === "component";
            if (!this.workflow)
                return [];
            if (!this.workflow || !this.permissions.canEditWorkflow)
                return [];
            const t = {
                save: !this.isUnknownProject && Es,
                saveAs: this.isUnknownProject && Es,
                undo: !0,
                redo: !0,
                executeAll: !this.selectedNodes.length,
                cancelAll: !this.selectedNodes.length,
                resetAll: !this.selectedNodes.length,
                executeSelected: this.selectedNodes.length,
                cancelSelected: this.selectedNodes.length,
                resetSelected: this.selectedNodes.length,
                createMetanode: this.selectedNodes.length,
                createComponent: this.selectedNodes.length && yf(),
                openLayoutEditor: e && yf()
            };
            return Object.entries(t).filter(([n, r]) => r).map(([n]) => n)
        }
    },
    methods: {
        onCanvasModeUpdate(e, {
            metadata: {
                id: t
            }
        }) {
            this.$store.dispatch("application/switchCanvasMode", t)
        }
    }
};
const aXe = {
    class: "toolbar"
}, lXe = {
    class: "control-list"
};
function cXe(e, t, n, r, o, i) {
    const s = B("ToolbarShortcutButton"),
    a = B("WorkflowBreadcrumb"),
    l = B("SelectionModeIcon"),
    c = B("AnnotationModeIcon"),
    u = B("ArrowMoveIcon"),
    f = B("SubMenu"),
    p = B("ZoomMenu");
    return _(),
    O("div", aXe, [z(Qm, {
                tag: "div",
                name: "button-list"
            }, {
            default:
                oe(() => [(_(), O("div", {
                                key: i.toolbarButtons.join(),
                                class: "button-list"
                            }, [(_(!0), O(Le, null, $t(i.toolbarButtons, m => (_(), H(s, {
                                                        key: m,
                                                        name: m,
                                                        "with-text": !i.hideText[m],
                                                        dropdown: i.toolbarDropdowns[m] ?? []
                                                    }, null, 8, ["name", "with-text", "dropdown"]))), 128))]))]),
                _: 1
            }), i.hasBreadcrumb ? (_(), H(a, {
                    key: 0,
                    class: "breadcrumb"
                })) : J("", !0), P("div", lXe, [z(f, {
                        class: "control",
                        items: i.canvasModes,
                        orientation: "left",
                        onItemClick: i.onCanvasModeUpdate
                    }, {
                    default:
                        oe(() => [e.hasSelectionModeEnabled ? (_(), H(l, {
                                        key: 0
                                    })) : e.hasAnnotationModeEnabled ? (_(), H(c, {
                                        key: 1
                                    })) : e.hasPanModeEnabled ? (_(), H(u, {
                                        key: 2
                                    })) : J("", !0)]),
                        _: 1
                    }, 8, ["items", "onItemClick"]), e.workflow ? (_(), H(p, {
                            key: 0,
                            disabled: e.isWorkflowEmpty
                        }, null, 8, ["disabled"])) : J("", !0)])])
}
const uXe = te(sXe, [["render", cXe], ["__scopeId", "data-v-faa15c13"]]);
const dXe = {
    mixins: [XI, H6({
            onEscape() {
                this.$emit("menuClose")
            }
        })],
    props: {
        preventOverflow: {
            type: Boolean,
        default:
            !1
        },
        canvasPosition: {
            type: Object,
            required: !0
        },
        anchor: {
            type: String,
        default:
            "top-left",
            validator: e => ["top-left", "top-right"].includes(e)
        },
        disableInteractions: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["menuClose"],
    data: () => ({
        absolutePosition: {
            left: 0,
            top: 0
        }
    }),
    computed: {
        ...zt("canvas", ["screenFromCanvasCoordinates"]),
        ...ut("canvas", ["zoomFactor"]),
        ...ut("nodeRepository", {
            isDraggingNodeFromRepository: "isDraggingNode"
        }),
        ...ut("workflow", {
            isDraggingNodeInCanvas: "isDragging"
        })
    },
    watch: {
        canvasPosition() {
            this.setAbsolutePosition()
        },
        zoomFactor() {
            this.setAbsolutePosition()
        },
        isDraggingNodeInCanvas() {
            this.isDraggingNodeInCanvas && this.$emit("menuClose")
        },
        isDraggingNodeFromRepository: {
            immediate: !0,
            handler() {
                this.isDraggingNodeFromRepository && this.$emit("menuClose")
            }
        }
    },
    mounted() {
        this.setAbsolutePosition(),
        this.disableInteractions && this.setInteractionsEnabled(!1),
        document.getElementById("kanvas").addEventListener("scroll", this.onCanvasScroll),
        this.resizeObserver = new ResizeObserver(() => {
            this.setAbsolutePosition(),
            consola.trace("floating menu: resize detected")
        }),
        this.stopResizeObserver = () => {
            this.resizeObserver?.disconnect()
        },
        this.resizeObserver.observe(this.$el)
    },
    beforeUnmount() {
        this.setInteractionsEnabled(!0),
        document.getElementById("kanvas")?.removeEventListener("scroll", this.onCanvasScroll),
        this.stopResizeObserver()
    },
    methods: {
        ...eg("canvas", ["setInteractionsEnabled"]),
        distanceToCanvas({
            left: e,
            top: t
        }) {
            let n = document.getElementById("kanvas"), {
                y: r,
                x: o,
                width: i,
                height: s
            } = n.getBoundingClientRect(),
            a = o - e,
            l = e - o - i,
            c = r - t,
            u = t - r - s,
            f = Math.max(Math.max(a, l), 0),
            p = Math.max(Math.max(c, u), 0);
            return Math.max(f, p)
        },
        setAbsolutePosition() {
            let {
                x: e,
                y: t
            } = this.screenFromCanvasCoordinates(this.canvasPosition),
            n = this.distanceToCanvas({
                left: e,
                top: t
            });
            const r = 50;
            let o = Math.max(0, r - n) / r;
            if (this.$el.style.opacity = o, n > r) {
                this.$emit("menuClose");
                return
            }
            const i = this.$el.offsetWidth,
            s = this.$el.offsetHeight;
            this.anchor === "top-right" && (e -= i),
            this.preventOverflow && (window.innerWidth - e < i ? e = window.innerWidth - i : e < 0 && (e = 0), window.innerHeight - t < s ? t = window.innerHeight - s : t < 0 && (t = 0)),
            this.absolutePosition = {
                left: e,
                top: t
            }
        },
        onFocusOut(e) {
            e.relatedTarget && !this.$el.contains(e.relatedTarget) && this.$emit("menuClose")
        },
        onCanvasScroll: Ds(function () {
            this.setAbsolutePosition()
        })
    }
};
function fXe(e, t, n, r, o, i) {
    const s = W1("click-away");
    return Cn((_(), O("div", {
                class: "floating-menu",
                style: Yt({
                    left: `${e.absolutePosition.left}px`,
                    top: `${e.absolutePosition.top}px`
                }),
                onFocusout: t[0] || (t[0] = ve((...a) => i.onFocusOut && i.onFocusOut(...a), ["stop"])),
                onKeydown: t[1] || (t[1] = Rt(ve(() => {}, ["stop", "prevent"]), ["tab"]))
            }, [Ye(e.$slots, "default", {}, void 0, !0)], 36)), [[s, () => e.$emit("menuClose")]])
}
const qw = te(dXe, [["render", fXe], ["__scopeId", "data-v-1c3b2b21"]]), hXe = function () {
    let e = [];
    const t = r => !r.disabled,
    n = r => r.filter(t).map(o => o.children ? {
        ...o,
        children: n(o.children)
    }
             : o).filter(o => o.children ? o.children.length > 0 : !0);
    return {
        append(r) {
            const o = n(r);
            return e.length !== 0 && o.length > 0 && (e.at(-1).separator = !0),
            e = e.concat(o),
            this
        },
        value: () => e
    }
}, zv = (e, t) => t ? [e] : [], kN = (e, t) => t > 0 ? `${t}: ${e}` : e, pXe = () => dt(_7, {
    style: {
        width: "14px",
        marginTop: "-1px",
        marginRight: " 4px",
        marginLeft: "-2px"
    }
}), mXe = (e, t, n) => rh(e) ? oa(km(t, _i)) : oa(n === 0 ? pXe() : km(t, _i)), gXe = Fe({
    components: {
        FloatingMenu: qw,
        MenuItems: cT
    },
    props: {
        position: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        }
    },
    emits: ["menuClose"],
    data: () => ({
        visibleItems: [],
        activeDescendant: null
    }),
    computed: {
        ...zt("selection", ["selectedNodes", "selectedAnnotations", "selectedConnections", "selectedBendpointIds", "singleSelectedNode", "isSelectionEmpty"]),
        ...ut("application", {
            projectId: e => e.activeProjectId,
            availablePortTypes: e => e.availablePortTypes
        })
    },
    watch: {
        position: {
            immediate: !0,
            handler() {
                this.setMenuItems(),
                this.$nextTick(() => {
                    this.$refs.menuItems.$el.focus()
                })
            }
        }
    },
    beforeMount() {
        window?.getSelection().removeAllRanges()
    },
    methods: {
        mapToShortcut(e) {
            const t = n => {
                if (!n.isVisible)
                    return [];
                const r = this.$shortcuts.get(n.name);
                return [{
                        text: typeof r.text == "function" ? r.text({
                            $store: this.$store
                        }) : r.text,
                        hotkeyText: r.hotkeyText,
                        disabled: !this.$shortcuts.isEnabled(n.name),
                        metadata: {
                            shortcutName: n.name
                        }
                    }
                ]
            };
            return Array.isArray(e) ? e.flatMap(t) : t(e)
        },
        onItemClick(e, t) {
            if (this.$emit("menuClose"), typeof t.metadata.handler == "function") {
                t.metadata.handler();
                return
            }
            const n = t.metadata?.shortcutName;
            n && this.$shortcuts.dispatch(n, {
                event: e,
                metadata: {
                    position: this.position
                }
            })
        },
        setActiveDescendant(e) {
            this.activeDescendant = e
        },
        portViews() {
            const e = this.singleSelectedNode;
            if (!e)
                return [];
            const t = e.id;
            return e.outPorts.map(r => ri(this.availablePortTypes)(r)).flatMap((r, o) => {
                if (S7(e, o) !== "EXECUTED")
                    return [];
                if (!r.views)
                    return [{
                            text: kN(r.name, o),
                            icon: oa(km(r, this.$shapes.portSize)),
                            sectionHeadline: !0,
                            separator: !0
                        }, {
                            text: "Open legacy port view",
                            metadata: {
                                handler: () => {
                                    this.$store.dispatch("workflow/openLegacyPortView", {
                                        nodeId: t,
                                        portIndex: o
                                    })
                                }
                            }
                        }
                    ];
                let s = D7(r.views, e, o).map(l => ({
                            text: l.text,
                            disabled: l.disabled,
                            metadata: {
                                handler: () => {
                                    Oe.desktop.openPortView({
                                        projectId: this.projectId,
                                        nodeId: t,
                                        portIndex: o,
                                        viewIndex: Number(l.id)
                                    })
                                }
                            }
                        }));
                return [{
                        text: kN(r.name, o),
                        icon: mXe(e, r, o),
                        sectionHeadline: !0,
                        separator: !0
                    }, ...s]
            })
        },
        setMenuItems() {
            const e = this.selectedNodes.length > 0,
            t = this.selectedAnnotations.length > 0,
            n = Boolean(this.singleSelectedNode?.loopInfo?.allowedActions),
            r = this.singleSelectedNode && "canOpenView" in this.singleSelectedNode.allowedActions,
            o = this.singleSelectedNode && "canOpenLegacyFlowVariableDialog" in this.singleSelectedNode.allowedActions,
            i = this.singleSelectedNode?.kind === "metanode",
            s = this.singleSelectedNode?.kind === "component",
            a = this.singleSelectedNode?.link,
            l = this.portViews(),
            c = [...this.mapToShortcut([{
                            name: "configureNode",
                            isVisible: this.singleSelectedNode
                        }, {
                            name: "configureFlowVariables",
                            isVisible: o
                        }, {
                            name: "executeSelected",
                            isVisible: this.selectedNodes.length
                        }, {
                            name: "executeAndOpenView",
                            isVisible: r
                        }
                    ]), ...zv({
                    text: "打开输出端口",
                    children: l
                }, l.length > 0 && V6()), ...this.mapToShortcut([{
                            name: "resumeLoopExecution",
                            isVisible: n
                        }, {
                            name: "pauseLoopExecution",
                            isVisible: n
                        }, {
                            name: "stepLoopExecution",
                            isVisible: n
                        }, {
                            name: "cancelSelected",
                            isVisible: this.selectedNodes.length
                        }, {
                            name: "resetSelected",
                            isVisible: this.selectedNodes.length
                        }
                    ])],
            u = [...this.mapToShortcut([{
                            name: "executeAll",
                            isVisible: this.isSelectionEmpty
                        }, {
                            name: "cancelAll",
                            isVisible: this.isSelectionEmpty
                        }, {
                            name: "resetAll",
                            isVisible: this.isSelectionEmpty
                        }, {
                            name: "checkForComponentUpdates",
                            isVisible: this.isSelectionEmpty
                        }
                    ])],
            f = [...this.mapToShortcut([{
                            name: "cut",
                            isVisible: e || t
                        }, {
                            name: "copy",
                            isVisible: e || t
                        }, {
                            name: "paste",
                            isVisible: this.isSelectionEmpty
                        }, {
                            name: "deleteSelected",
                            isVisible: !this.isSelectionEmpty
                        }
                    ])],
            p = [...this.mapToShortcut({
                    name: "addWorkflowAnnotation",
                    isVisible: this.isSelectionEmpty
                }), ...zv({
                    text: "排列批注",
                    children: this.mapToShortcut([{
                                name: "bringAnnotationToFront",
                                isVisible: t
                            }, {
                                name: "bringAnnotationForward",
                                isVisible: t
                            }, {
                                name: "sendAnnotationBackward",
                                isVisible: t
                            }, {
                                name: "sendAnnotationToBack",
                                isVisible: t
                            }
                        ])
                }, t)],
            m = [...this.mapToShortcut([{
                            name: "createMetanode",
                            isVisible: this.selectedNodes.length
                        }, {
                            name: "createComponent",
                            isVisible: this.selectedNodes.length && yf()
                        }
                    ]), ...zv({
                    text: "元点",
                    children: this.mapToShortcut([{
                                name: "openComponentOrMetanode",
                                isVisible: !0
                            }, {
                                name: "editName",
                                isVisible: !0
                            }, {
                                name: "expandMetanode",
                                isVisible: !0
                            }
                        ])
                }, i), ...zv({
                    text: "组件",
                    children: this.mapToShortcut([{
                                name: "openComponentOrMetanode",
                                isVisible: !0
                            }, {
                                name: "editName",
                                isVisible: !0
                            }, {
                                name: "expandComponent",
                                isVisible: !0
                            }, {
                                name: "openLayoutEditorByNodeId",
                                isVisible: !a
                            }, {
                                name: "linkComponent",
                                isVisible: !a
                            }, {
                                name: "updateComponent",
                                isVisible: a
                            }, {
                                name: "changeComponentLinkType",
                                isVisible: a
                            }, {
                                name: "changeHubItemVersion",
                                isVisible: a
                            }, {
                                name: "unlinkComponent",
                                isVisible: a
                            }
                        ])
                }, s && yf())];
            this.visibleItems = hXe().append(c).append(this.mapToShortcut({
                        name: "editNodeComment",
                        isVisible: this.singleSelectedNode
                    })).append(u).append(f).append(p).append(m).value()
        }
    }
});
function vXe(e, t, n, r, o, i) {
    const s = B("MenuItems"),
    a = B("FloatingMenu");
    return _(),
    H(a, {
        "canvas-position": e.position,
        "disable-interactions": !0,
        class: "context-menu",
        "aria-label": "Context Menu",
        "aria-activedescendant": e.activeDescendant,
        "prevent-overflow": "",
        onMenuClose: t[0] || (t[0] = l => e.$emit("menuClose"))
    }, {
    default:
        oe(() => [z(s, {
                    id: "context-menu-items",
                    ref: "menuItems",
                    class: "menu-items",
                    "register-keydown": "",
                    items: e.visibleItems,
                    "menu-aria-label": "Context Menu",
                    onItemClick: e.onItemClick,
                    onItemFocused: e.setActiveDescendant
                }, null, 8, ["items", "onItemClick", "onItemFocused"])]),
        _: 1
    }, 8, ["canvas-position", "aria-activedescendant"])
}
const yXe = te(gXe, [["render", vXe], ["__scopeId", "data-v-d157eefe"]]);
const wXe = (() => {
    let e = 0,
    t = 0;
    const n = 6;
    return `M ${e} ${t}
            m -${n}, 0
            a ${n},${n} 0 1,1 ${n * 2},0
            a ${n},${n} 0 1,1 -${n * 2},0`
})(), bXe = {
    components: {
        Port: hg
    },
    inject: ["anchorPoint"],
    props: {
        position: {
            type: Array,
            required: !0
        },
        side: {
            type: String,
            required: !0,
            validator: e => ["input", "output"].includes(e)
        },
        nodeId: {
            type: String,
            required: !0
        },
        portGroups: {
            type: Object,
        default:
            null
        },
        targeted: {
            type: Boolean,
        default:
            !1
        },
        targetPort: {
            type: Object,
        default:
            null
        }
    },
    emits: ["addPort"],
    data: () => ({
        transitionEnabled: !0,
        closeTimeout: null
    }),
    computed: {
        ...ut("workflow", ["portTypeMenu"]),
        addPortPlaceholderPath: () => wXe,
        validPortGroups() {
            return this.portGroups ? Object.entries(this.portGroups).filter(([e, t]) => t.canAddInPort || t.canAddOutPort).reduce((e, [t, n]) => ({
                    ...e,
                    [t]: n
                }), {}) : null
        },
        isMenuOpen() {
            return this.portTypeMenu.isOpen && this.portTypeMenu.nodeId === this.nodeId && this.portTypeMenu.props?.side === this.side
        },
        previewPort() {
            return this.targeted ? this.targetPort : this.isMenuOpen ? this.selectedPort : null
        },
        selectedPort: {
            get() {
                return this.portTypeMenu.previewPort
            },
            set(e) {
                this.setPortTypeMenuPreviewPort(e)
            }
        }
    },
    watch: {
        isMenuOpen(e) {
            e ? (this.$el.style.opacity = "1", clearTimeout(this.closeTimeout)) : this.closeTimeout = setTimeout(() => {
                this.$el.style.opacity = null
            }, 1e3)
        }
    },
    methods: {
        ...Er("workflow", ["openPortTypeMenu", "closePortTypeMenu"]),
        ...eg("workflow", ["setPortTypeMenuPreviewPort"]),
        openMenu() {
            let e = {
                x: this.anchorPoint.x + this.position[0],
                y: this.anchorPoint.y + this.position[1]
            };
            this.openPortTypeMenu({
                nodeId: this.nodeId,
                props: {
                    side: this.side,
                    position: e,
                    portGroups: this.validPortGroups
                },
                events: {
                    itemActive: this.onItemActive,
                    itemClick: this.onItemClick,
                    menuClose: this.onRequestClose
                }
            })
        },
        closeMenu() {
            this.closePortTypeMenu()
        },
        onClick() {
            if (this.isMenuOpen) {
                this.closeMenu();
                return
            }
            const e = Object.values(this.validPortGroups || {});
            if (e.length === 1) {
                const {
                    supportedPortTypeIds: t
                } = e[0];
                if (t.length === 1) {
                    let [n] = t;
                    this.$emit("addPort", {
                        typeId: n,
                        portGroup: Object.keys(this.validPortGroups)[0]
                    });
                    return
                }
            }
            this.openMenu()
        },
        onRequestClose(e) {
            e || (this.selectedPort = null),
            this.closeMenu()
        },
        onItemActive(e) {
            this.selectedPort = e?.port
        },
        onItemClick({
            typeId: e,
            portGroup: t
        }) {
            this.transitionEnabled = !1,
            this.selectedPort = null,
            this.$emit("addPort", {
                typeId: e,
                portGroup: t
            }),
            this.$nextTick(() => {
                this.transitionEnabled = !0
            })
        }
    }
}, uT = e => (ir("data-v-25065727"), e = e(), sr(), e), _Xe = ["transform"], kXe = uT(() => P("circle", {
            r: "6.5",
            fill: "white",
            stroke: "none"
        }, null, -1)), xXe = ["d"], SXe = uT(() => P("line", {
            y1: "0",
            y2: "0",
            x1: "-3.5",
            x2: "3.5",
            stroke: "#000",
            "stroke-width": "1"
        }, null, -1)), CXe = uT(() => P("line", {
            x1: "0",
            x2: "0",
            y1: "-3.5",
            y2: "3.5",
            stroke: "#000",
            "stroke-width": "1"
        }, null, -1));
function IXe(e, t, n, r, o, i) {
    const s = B("Port");
    return _(),
    O("g", {
        transform: `translate(${n.position})`
    }, [z(ho, {
                name: e.transitionEnabled ? "port-fade" : "none"
            }, {
            default:
                oe(() => [i.previewPort && i.previewPort.typeId ? (_(), H(s, {
                                key: i.previewPort.typeId,
                                port: i.previewPort
                            }, null, 8, ["port"])) : (_(), O("g", {
                                key: 1,
                                class: he(["add-port-icon", {
                                            active: i.isMenuOpen
                                        }
                                    ]),
                                onClick: t[0] || (t[0] = (...a) => i.onClick && i.onClick(...a))
                            }, [kXe, P("path", {
                                        d: i.addPortPlaceholderPath,
                                        "stroke-width": "1",
                                        stroke: "#000",
                                        fill: "none",
                                        "stroke-dasharray": "1"
                                    }, null, 8, xXe), SXe, CXe], 2))]),
                _: 1
            }, 8, ["name"])], 8, _Xe)
}
const TXe = te(bXe, [["render", IXe], ["__scopeId", "data-v-25065727"]]), MXe = 750, PXe = e => {
    const t = De(null),
    n = wa();
    let r,
    o = null;
    n.watch(l => l.workflow.tooltip, l => {
        l === null && r?.()
    });
    const i = () => {
        const l = Ht(e.tooltip, c => {
            n.commit("workflow/setTooltip", c)
        }, {
            immediate: !0
        });
        r = () => {
            l(),
            r = null
        }
    },
    s = () => {
        if (r?.(), !e.tooltip) {
            consola.error("Tooltip cannot be used without providing a tooltip property");
            return
        }
        o = setTimeout(i, MXe)
    },
    a = l => {
        const c = l.target;
        if (consola.trace("mouse left to:", c?.tagName, c?.id, c?.classList), !r) {
            clearTimeout(o);
            return
        }
        if (e.tooltip?.value.hoverable) {
            const u = document.getElementById("tooltip-container");
            if (u && u.contains(c))
                return
        }
        n.commit("workflow/setTooltip", null)
    };
    return Ur(() => {
        t.value.addEventListener("mouseenter", s),
        t.value.addEventListener("mouseleave", a)
    }),
    Rs(() => {
        t.value.removeEventListener("mouseenter", s),
        t.value.removeEventListener("mouseleave", a),
        r && n.commit("workflow/setTooltip", null)
    }), {
        elemRef: t
    }
}, EXe = 750, OXe = {
    mounted() {
        this.$el.addEventListener("mouseenter", this.onTooltipMouseEnter),
        this.$el.addEventListener("mouseleave", this.onTooltipMouseLeave)
    },
    beforeUnmount() {
        this.$el.removeEventListener("mouseenter", this.onTooltipMouseEnter),
        this.$el.removeEventListener("mouseleave", this.onTooltipMouseLeave),
        this.removeTooltipWatcher && this.$store.commit("workflow/setTooltip", null)
    },
    watch: {
        "$store.state.workflow.tooltip"(e) {
            e === null && this.removeTooltipWatcher?.()
        }
    },
    methods: {
        onTooltipMouseEnter() {
            if (this.removeTooltipWatcher?.(), this.tooltip === void 0) {
                consola.error("Tooltip mixin is used without providing a tooltip property");
                return
            }
            this.tooltipTimeout = setTimeout(this.showTooltip, EXe)
        },
        showTooltip() {
            let e = this.$watch("tooltip", t => this.$store.commit("workflow/setTooltip", t), {
                immediate: !0
            });
            this.removeTooltipWatcher = () => {
                e(),
                this.removeTooltipWatcher = null
            }
        },
        onTooltipMouseLeave({
            relatedTarget: e
        }) {
            if (consola.trace("mouse left to:", e?.tagName, e?.id, e?.classList), !this.removeTooltipWatcher) {
                clearTimeout(this.tooltipTimeout);
                return
            }
            if (this.tooltip?.hoverable) {
                let t = document.getElementById("tooltip-container");
                if (t && t.contains(e))
                    return
            }
            this.$store.commit("workflow/setTooltip", null)
        }
    }
}, Ff = "application/vnd.knime.ap.noderepo+json", $Xe = e => e.dataTransfer.types.includes(Ff), AXe = {
    computed: {
        ...zt("canvas", ["screenToCanvasCoordinates"]),
        ...zt("workflow", ["isWritable"])
    },
    methods: {
        ...Er("workflow", ["addNode"]),
        ...Er("selection", ["selectNode", "deselectAllObjects"]),
        async onDrop(e) {
            if (this.isWritable) {
                const t = e.dataTransfer.getData(Ff);
                if (!t)
                    return;
                const n = JSON.parse(t),
                [r, o] = this.screenToCanvasCoordinates([e.clientX - this.$shapes.nodeSize / 2, e.clientY - this.$shapes.nodeSize / 2]);
                try {
                    await this.addNode({
                        position: {
                            x: r,
                            y: o
                        },
                        nodeFactory: n
                    })
                } catch (i) {
                    throw consola.error({
                        message: "Error adding node to workflow",
                        error: i
                    }),
                    i
                }
            }
            e.preventDefault()
        },
        onDragOver(e) {
            this.isWritable && $Xe(e) && (e.dataTransfer.dropEffect = "copy")
        }
    }
}, DXe = {
    render() {
        const e = this.$slots.default();
        return dt(e[0].children[0])
    }
};
const NXe = {
    components: {
        NestedSvg: DXe
    },
    props: {
        x: {
            type: [Number, String],
        default:
            0
        },
        disabled: {
            type: Boolean,
        default:
            !1
        },
        title: {
            type: String,
        default:
            null
        },
        primary: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["click"],
    methods: {
        onClick(e) {
            this.disabled || this.$emit("click", e)
        }
    }
}, RXe = ["cx"], LXe = ["x"], BXe = {
    key: 0
};
function VXe(e, t, n, r, o, i) {
    const s = B("NestedSvg");
    return _(),
    O("g", {
        class: he(["action-button", {
                    disabled: n.disabled
                }
            ]),
        onClick: t[0] || (t[0] = ve((...a) => i.onClick && i.onClick(...a), ["left", "stop"])),
        onPointerdown: t[1] || (t[1] = ve(() => {}, ["stop"]))
    }, [P("circle", {
                r: "9.5",
                cx: n.x,
                filter: "url(#node-action-button-shadow)",
                class: he({
                    primary: n.primary
                })
            }, null, 10, RXe), P("rect", {
                width: "24",
                height: "24",
                x: n.x - 12,
                y: "-12",
                opacity: "0"
            }, null, 8, LXe), n.title ? (_(), O("title", BXe, Re(n.title), 1)) : J("", !0), z(s, {
                width: "20",
                height: "20",
                x: n.x - 10,
                y: "-10"
            }, {
            default:
                oe(() => [Ye(e.$slots, "default", {}, void 0, !0)]),
                _: 3
            }, 8, ["x"])], 34)
}
const mF = te(NXe, [["render", VXe], ["__scopeId", "data-v-103e78a7"]]), Sd = 20, FXe = 5, jXe = {
    components: {
        Port: hg,
        ActionButton: mF,
        DeleteIcon: aF
    },
    mixins: [H6({
            onEscape() {
                this.$emit("close")
            }
        })],
    props: {
        port: {
            type: Object,
            required: !0
        },
        direction: {
            type: String,
            required: !0,
            validator: e => ["in", "out"].includes(e)
        },
        relativePosition: {
            type: Array,
        default:
            () => [0, 0],
            validator: e => Array.isArray(e) && e.length === 2
        },
        anchorPoint: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        }
    },
    emits: ["close", "action:remove"],
    computed: {
        actions() {
            return [{
                    id: "remove",
                    title: "Remove port",
                    isDisabled: !this.port.canRemove,
                    eventName: "action:remove"
                }
            ]
        },
        selectedPortPosition() {
            const [e, t] = this.relativePosition;
            return [this.anchorPoint.x + e, this.anchorPoint.y + t]
        },
        hoverArea() {
            const e = this.actions.length,
            t = this.direction === "in" ? Sd * e : 0;
            return {
                x:  - (Sd / 2) - t,
                y:  - (Sd / 2),
                width: Sd * (e + 1),
                height: Sd
            }
        }
    },
    methods: {
        buttonX(e) {
            const t = this.direction === "in" ? -1 : 1;
            return (Sd + FXe) * e * t
        }
    }
}, WXe = ["transform"];
function zXe(e, t, n, r, o, i) {
    const s = B("Port"),
    a = B("DeleteIcon"),
    l = B("ActionButton");
    return _(),
    O("g", {
        transform: `translate(${i.selectedPortPosition})`
    }, [P("rect", Bt(i.hoverArea, {
                    fill: "transparent",
                    onMouseenter: t[0] || (t[0] = ve(() => {}, ["stop"])),
                    onMouseleave: t[1] || (t[1] = ve(() => {}, ["stop"])),
                    onClick: t[2] || (t[2] = ve(() => {}, ["stop"]))
                }), null, 16), z(s, {
                port: n.port,
                class: "selected-port",
                "is-selected": ""
            }, null, 8, ["port"]), (_(!0), O(Le, null, $t(i.actions, (c, u) => (_(), H(l, {
                                id: c.id,
                                key: c.id,
                                x: i.buttonX(u + 1),
                                disabled: c.isDisabled,
                                title: c.title,
                                onClick: f => e.$emit(c.eventName)
                            }, {
                            default:
                                oe(() => [z(a)]),
                                _: 2
                            }, 1032, ["id", "x", "disabled", "title", "onClick"]))), 128))], 8, WXe)
}
const HXe = te(jXe, [["render", zXe]]), Hv = {
    useGridSnapping: !0,
    onMoveStartCallback: () => {},
    onMoveCallback: () => {},
    onMoveEndCallback: () => Promise.resolve(!0)
}, Yw = e => {
    const t = po(),
    n = ne(() => t.state.workflow.hasAbortedDrag),
    r = ne(() => t.getters["workflow/isWritable"]),
    o = ne(() => t.state.canvas.zoomFactor),
    i = ne(() => t.state.canvas.isMoveLocked),
    s = ne(() => t.getters["canvas/screenToCanvasCoordinates"]),
    a = e.onMoveStartCallback || Hv.onMoveStartCallback,
    l = e.onMoveCallback || Hv.onMoveCallback,
    c = e.onMoveEndCallback || Hv.onMoveEndCallback,
    u = e.useGridSnapping ?? Hv.useGridSnapping,
    f = v => {
        const y = e.objectElement.value.getBoundingClientRect();
        return v.clientX > y.left && v.clientX < y.right && v.clientY > y.top && v.clientY < y.bottom
    },
    p = (v, y) => {
        const w = Math.abs(y.x - v.x),
        k = Math.abs(y.y - v.y);
        return w >= 5 || k >= 5
    };
    return {
        createPointerDownHandler: v => y => {
            if (y.stopPropagation(), !r.value || i.value)
                return;
            const b = y.currentTarget;
            a(y);
            let w = !1,
            k = !1;
            if (e.objectElement && !f(y))
                return;
            const C = e.objectElement?.value ? e.objectElement.value.getBoundingClientRect() : {
                left: y.clientX,
                top: y.clientY
            },
            x = {
                x: Math.floor(y.clientX - C.left) / o.value,
                y: Math.floor(y.clientY - C.top) / o.value
            },
            S = u ? {
                x: br.utils.snapToGrid(v.value.x),
                y: br.utils.snapToGrid(v.value.y)
            }
             : v.value,
            T = {
                ...S,
                positionDelta: {
                    x: S.x - v.value.x,
                    y: S.y - v.value.y
                }
            },
            E = Ds(F => {
                if (!k) {
                    k = !0;
                    return
                }
                if (F.buttons !== 1 || (b.setPointerCapture(y.pointerId), n.value || w))
                    return;
                const K = F.altKey ? 1 : BC.x,
                [j, G] = s.value([F.clientX, F.clientY]);
                if (!p({
                        x: y.clientX,
                        y: y.clientY
                    }, {
                        x: F.clientX,
                        y: F.clientY
                    }))
                    return;
                l(F);
                const Y = u ? br.utils.snapToGrid : de => de,
                ue = Y(j - T.x - x.x, K),
                re = Y(G - T.y - x.y, K);
                t.commit("workflow/setIsDragging", !0),
                t.commit("workflow/setMovePreview", {
                    deltaX: ue + T.positionDelta.x,
                    deltaY: re + T.positionDelta.y
                })
            }),
            M = F => {
                (async() => {
                    w = !0;
                    const j = await c(F);
                    try {
                        j && !n.value && await t.dispatch("workflow/moveObjects")
                    } catch (G) {
                        consola.error("Error moving objects", G),
                        await t.dispatch("workflow/resetDragState")
                    }
                    n.value && await t.dispatch("workflow/resetAbortDrag"),
                    b.releasePointerCapture(y.pointerId),
                    document.removeEventListener("pointermove", E),
                    document.removeEventListener("pointerup", M),
                    b.removeEventListener("pointerup", M),
                    b.removeEventListener("lostpointercapture", N)
                })()
            };
            function N(F) {
                w || M(F)
            }
            document.addEventListener("pointermove", E),
            document.addEventListener("pointerup", M),
            b.addEventListener("pointerup", M),
            b.addEventListener("lostpointercapture", N)
        }
    }
}, gF = e => {
    const t = po(),
    n = ne(() => t.state.workflow.activeWorkflow.nodes[e.sourceNode.value]),
    r = ne(() => t.state.workflow.activeWorkflow.nodes[e.destNode.value]);
    return {
        sourceNodeObject: n,
        destNodeObject: r
    }
}, UXe = ({
    startNode: e,
    downstreamConnection: t,
    workflow: {
        nodes: n,
        connections: r,
        info: o
    }
}) => {
    const i = new Set(Object.keys(n));
    if (o.containerType === "metanode" && o.containerId === e)
        return i;
    const s = t ? "inPorts" : "outPorts",
    a = t ? "sourceNode" : "destNode",
    l = [e];
    for (; l.length; ) {
        const c = l.shift();
        n[c][s].forEach(u => {
            u.connectedVia.forEach(f => {
                const p = r[f][a];
                i.has(p) && l.push(p)
            })
        }),
        i.delete(c)
    }
    return i
}, qXe = ({
    toPort: e,
    connections: t,
    targetPortDirection: n
}) => {
    if (n === "in") {
        if (e.connectedVia.length === 0)
            return !0;
        const [o] = e.connectedVia;
        return t[o].allowedActions.canDelete
    }
    return !0
}, Lm = ({
    fromPort: e,
    toPort: t,
    availablePortTypes: n
}) => {
    const r = ri(n)(e),
    o = ri(n)(t), {
        compatibleTypes: i
    } = o, {
        kind: s
    } = r, {
        kind: a
    } = o;
    return s === "generic" && a === "table" || s === "table" && a === "generic" ? !1 : s === "generic" || a === "generic" || i && i.includes(e.typeId) ? !0 : e.typeId === t.typeId
}, YXe = ({
    targetPortGroups: e,
    availablePortTypes: t,
    targetPortDirection: n
}) => {
    if (!e)
        return [[null, Object.keys(t)]];
    const r = Object.entries(e),
    o = n === "in" ? "canAddInPort" : "canAddOutPort";
    return r.filter(([s, a]) => a[o]).map(([s, a]) => [s, a.supportedPortTypeIds])
}, xN = (e, t) => {
    const n = e.map(([r, o]) => ({
                [r]: {
                    [t]: !0,
                    supportedPortTypeIds: o
                }
            }));
    return Object.assign({}, ...n)
}, KXe = ({
    fromPort: e,
    toPort: t,
    availablePortTypes: n,
    targetPortDirection: r,
    connections: o
}) => {
    const i = qXe({
        toPort: t,
        connections: o,
        targetPortDirection: r
    }),
    s = Lm({
        fromPort: e,
        toPort: t,
        availablePortTypes: n
    });
    return i && s
}, GXe = ({
    fromPort: e,
    availablePortTypes: t,
    targetPortGroups: n,
    targetPortDirection: r
}) => {
    const o = YXe({
        availablePortTypes: t,
        targetPortGroups: n,
        targetPortDirection: r
    }),
    i = o.flatMap(([l, c]) => c.includes(e.typeId) ? [[l || "default", [e.typeId]]] : []),
    s = r === "in" ? "canAddInPort" : "canAddOutPort";
    if (i.length > 0)
        return xN(i, s);
    const a = o.flatMap(([l, c]) => {
        const u = c.filter(f => Lm({
                    fromPort: e,
                    toPort: {
                        typeId: f
                    },
                    availablePortTypes: t
                }));
        return u.length > 0 ? [[l, u]] : []
    });
    return a.length > 0 ? xN(a, s) : null
}, XXe = e => {
    const t = De(!1),
    n = po(),
    r = ne(() => n.state.nodeRepository.draggedNodeData),
    o = ne(() => n.getters["workflow/isWritable"]),
    i = ne(() => n.getters["canvas/screenToCanvasCoordinates"]), {
        sourceNodeObject: s,
        destNodeObject: a
    } = gF({
        sourceNode: e.sourceNode,
        destNode: e.destNode
    }),
    l = ne(() => n.state.application.availablePortTypes),
    c = (y, b) => {
        const w = s.value && y.some(C => Lm({
                    fromPort: s.value.outPorts[e.sourcePort.value],
                    toPort: C,
                    availablePortTypes: l.value
                })),
        k = a.value && b.some(C => Lm({
                    fromPort: C,
                    toPort: a.value.inPorts[e.destPort.value],
                    availablePortTypes: l.value
                }));
        return w || k
    },
    u = ({
        clientX: y,
        clientY: b,
        event: w,
        nodeId: k = null,
        nodeFactory: C = null
    }) => {
        if (!o.value)
            return;
        const [x, S] = i.value([y - fr / 2, b - fr / 2]);
        e.allowedActions.canDelete ? n.dispatch("workflow/insertNode", {
            connectionId: e.id.value,
            position: {
                x,
                y: S
            },
            nodeFactory: C,
            nodeId: k
        }) : (window.alert("Cannot delete connection at this point. Insert node operation aborted."), w.detail.onError()),
        t.value = !1
    };
    return {
        isDraggedOver: t,
        onRepositoryNodeDragEnter: y => {
            if (o.value && [...y.dataTransfer.types].includes(Ff)) {
                const {
                    inPorts: b,
                    outPorts: w
                } = r.value;
                c(b, w) && (t.value = !0)
            }
        },
        onRepositoryNodeDrop: y => {
            const b = JSON.parse(y.dataTransfer.getData(Ff));
            u({
                clientX: y.clientX,
                clientY: y.clientY,
                nodeFactory: b,
                event: y
            })
        },
        onWorkflowNodeDragEnter: y => {
            const {
                isNodeConnected: b,
                inPorts: w,
                outPorts: k
            } = y.detail;
            c(w, k) && (b || (y.preventDefault(), t.value = !0))
        },
        onWorkflowNodeDragLeave: y => {
            u({
                clientX: y.detail.clientX,
                clientY: y.detail.clientY,
                nodeId: y.detail.id,
                event: y
            })
        }
    }
}, JXe = _i / 2 - .5, ZXe = _i / 2 - .5, SN = (e, t, n, r, o = !1, i = !1) => {
    e += JXe,
    n -= ZXe;
    const s = Math.abs(e - n),
    a = Math.abs(t - r),
    l = s / 4,
    c = a / 4,
    u = o ? 4 : 0,
    f = i ? 4 : 0;
    return `M${e - u},${t} C${e + l + c},${t} ${n - l - c},${r} ${n + f},${r}`
}, QXe = ["transform"], eJe = ["width", "height"], tJe = ["width", "height"], nJe = Fe({
    __name: "ConnectorBendpoint",
    props: {
        position: {},
        connectionId: {},
        index: {},
        isFlowVariableConnection: {
            type: Boolean
        },
        isSelected: {
            type: Boolean
        },
        isDragging: {
            type: Boolean
        },
        interactive: {
            type: Boolean,
        default:
            !0
        },
        virtual: {
            type: Boolean,
        default:
            !1
        },
        isVisible: {
            type: Boolean,
        default:
            !1
        }
    },
    setup(e) {
        const t = e;
        to(a => ({
                "4cf4197a": s.value
            }));
        const n = ne(() => t.virtual ? 4 : 6),
        r = ne(() => t.position.x - n.value / 2),
        o = ne(() => t.position.y - n.value / 2),
        i = ne(() => `translate(${r.value}, ${o.value})`),
        s = ne(() => `${n.value / 2}px ${n.value / 2}px`);
        return (a, l) => (_(), O("g", {
                transform: i.value
            }, [a.interactive ? (_(), O("rect", {
                            key: 0,
                            width: n.value,
                            height: n.value,
                            class: he(["hover-area", {
                                        dragging: a.isDragging,
                                        virtual: a.virtual,
                                        visible: a.isVisible
                                    }
                                ]),
                            "data-hide-in-workflow-preview": ""
                        }, null, 10, eJe)) : J("", !0), P("rect", {
                        class: he(["bendpoint", {
                                    selected: a.isSelected,
                                    "flow-variable": a.isFlowVariableConnection,
                                    virtual: a.virtual,
                                    visible: a.isVisible
                                }
                            ]),
                        width: n.value,
                        height: n.value,
                        "data-hide-in-workflow-preview": ""
                    }, null, 10, tJe)], 8, QXe))
    }
});
const vF = te(nJe, [["__scopeId", "data-v-f0d80598"]]), rJe = ["d"], oJe = ["d"], iJe = Fe({
    __name: "ConnectorPathSegment",
    props: {
        connectionId: {},
        segment: {},
        isFlowvariableConnection: {
            type: Boolean
        },
        isHighlighted: {
            type: Boolean
        },
        isDraggedOver: {
            type: Boolean
        },
        suggestDelete: {
            type: Boolean
        },
        isConnectionHovered: {
            type: Boolean
        },
        index: {},
        isLastSegment: {
            type: Boolean
        },
        isReadonly: {
            type: Boolean,
        default:
            !1
        },
        isSelected: {
            type: Boolean,
        default:
            !1
        },
        interactive: {
            type: Boolean,
        default:
            !0
        },
        streaming: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["addVirtualBendpoint"],
    setup(e, {
        emit: t
    }) {
        const n = e;
        to(a => ({
                "5da23c64": a.$shapes.connectorWidth,
                c33e9642: a.$shapes.selectedConnectorWidth,
                "5922b0e1": a.$shapes.highlightedConnectorWidth
            }));
        const r = ne(() => {
            const a = n.segment.start.x,
            l = n.segment.start.y,
            c = n.segment.end.x,
            u = n.segment.end.y,
            f = n.index !== 0,
            p = !n.isLastSegment;
            return SN(a, l, c, u, f, p)
        }),
        o = ne(() => br.utils.getCenterPoint(n.segment.start, n.segment.end)),
        i = De(null);
        Ht(ca(n, "suggestDelete"), (a, l) => {
            if (!i.value)
                return;
            const c = -12,
            u = -6,
            f = n.segment.start.x,
            p = n.segment.start.y,
            m = n.segment.end.x,
            v = n.segment.end.y,
            y = a && !l ? SN(f, p, m + c, v + u) : r.value;
            nI.to(i.value, {
                attr: {
                    d: y
                },
                duration: .2,
                ease: "power2.out"
            })
        });
        const s = De(!1);
        return (a, l) => (_(), O(Le, null, [a.interactive ? (_(), O("path", Bt({
                                key: 0,
                                d: r.value,
                                class: ["hover-area", {
                                        hovered: a.isConnectionHovered
                                    }
                                ],
                                "data-hide-in-workflow-preview": ""
                            }, a.$attrs, {
                                onMouseenter: l[0] || (l[0] = c => s.value = !0),
                                onMouseleave: l[1] || (l[1] = c => s.value = !1)
                            }), null, 16, rJe)) : J("", !0), P("path", Bt(a.$attrs, {
                            ref_key: "visiblePath",
                            ref: i,
                            d: r.value,
                            class: {
                                "flow-variable": a.isFlowvariableConnection,
                                "read-only": a.isReadonly,
                                highlighted: a.isHighlighted,
                                dashed: a.streaming,
                                selected: a.isSelected,
                                "is-dragged-over": a.isDraggedOver
                            },
                            fill: "none"
                        }), null, 16, oJe), a.isReadonly ? J("", !0) : Cn((_(), H(vF, {
                                key: 1,
                                "connection-id": a.connectionId,
                                "is-flow-variable-connection": !1,
                                "is-selected": !1,
                                "is-dragging": !1,
                                index: -1,
                                position: o.value,
                                virtual: "",
                                onMouseenter: l[2] || (l[2] = c => s.value = !0),
                                onMouseleave: l[3] || (l[3] = c => s.value = !1),
                                onPointerdown: l[4] || (l[4] = ve(c => t("addVirtualBendpoint", {
                                                position: o.value,
                                                event: c
                                            }), ["left"]))
                            }, null, 8, ["connection-id", "position"])), [[Kn, s.value]])], 64))
    }
});
const sJe = te(iJe, [["__scopeId", "data-v-e10926ae"]]), dT = () => {
    const e = po(),
    t = ne(() => e.state.workflow.activeWorkflow),
    n = ne(() => e.state.workflow.calculatedMetanodePortBarBounds),
    r = u => u ? t.value.metaOutPorts.ports : t.value.metaInPorts.ports,
    o = u => u ? dx(t.value.metaOutPorts?.bounds || null, n.value.out) : dx(t.value.metaInPorts?.bounds || null, n.value.in),
    i = u => o(u).x,
    s = u => o(u).y,
    a = u => o(u).height;
    return {
        portBarWidth: u => o(u).width,
        portBarHeight: a,
        portBarYPos: s,
        portBarXPos: i,
        getBounds: o,
        getPortBarPortYPosition: (u, f, p) => {
            const m = r(f),
            v = a(f),
            y = m.length;
            return v * (u + 1) / (y + 1) + (p ? s(f) : 0)
        }
    }
}, aJe = e => {
    const {
        portBarXPos: t,
        getPortBarPortYPosition: n
    } = dT(),
    r = gF({
        sourceNode: e.sourceNode,
        destNode: e.destNode
    }),
    o = (c, u, f) => {
        const p = u === "source" ? f.outPorts : f.inPorts,
        [m, v] = Yy(c, p.length, f.kind === "metanode", u === "source"), {
            x: y,
            y: b
        } = f.position;
        return {
            x: y + m,
            y: b + v
        }
    },
    i = (c, u) => {
        let f = t(u === "dest");
        const p = _i / 2;
        f += u === "source" ? p : -p;
        const m = n(c, u === "dest", !0);
        return {
            x: f,
            y: m
        }
    },
    s = (c = "dest") => {
        const u = e[`${c}Port`],
        f = r[`${c}NodeObject`];
        return f.value ? o(u.value, c, f.value) : i(u.value, c)
    },
    a = ne(() => e.sourceNode.value && s("source") || {
        x: e.absolutePoint.value.at(0),
        y: e.absolutePoint.value.at(1)
    }),
    l = ne(() => e.destNode.value && s("dest") || {
        x: e.absolutePoint.value.at(0),
        y: e.absolutePoint.value.at(1)
    });
    return {
        start: a,
        end: l,
        ...r
    }
}, yF = e => {
    const t = po(),
    n = ne(() => t.state.workflow.isDragging),
    r = ne(() => t.state.workflow.virtualBendpoints[e.id] ?? {}),
    o = ne(() => Object.keys(r.value).length),
    i = ne(() => o.value > 0),
    s = ne(() => t.state.workflow.movePreviewDelta),
    a = ne(() => t.getters["selection/isMetaNodePortBarSelected"]),
    l = (b, w) => b && b.length > 0 && b.find(k => k.connectedVia.includes(w)),
    c = ne(() => l(t.state.workflow.activeWorkflow.metaInPorts?.ports, e.id)),
    u = ne(() => l(t.state.workflow.activeWorkflow.metaOutPorts?.ports, e.id)),
    f = ne(() => t.getters["selection/isNodeSelected"]),
    p = ne(() => t.getters["selection/isBendpointSelected"]), {
        start: m,
        end: v
    } = aJe(e);
    return {
        pathSegments: ne(() => {
            let b = m.value.x,
            w = m.value.y,
            k = v.value.x,
            C = v.value.y;
            if (n.value && ((f.value(e.sourceNode.value) || c.value && a.value("in")) && (b += s.value.x, w += s.value.y), (f.value(e.destNode.value) || u.value && a.value("out")) && (k += s.value.x, C += s.value.y)), e.bendpoints.value.length === 0 && !i.value || e.absolutePoint.value)
                return [{
                        isStart: !0,
                        isEnd: !0,
                        start: {
                            x: b,
                            y: w
                        },
                        end: {
                            x: k,
                            y: C
                        }
                    }
                ];
            const x = [{
                    x: b,
                    y: w
                }, ...Array(e.bendpoints.value.length + o.value).fill(null).flatMap((E, M) => {
                    const N = e.bendpoints.value.at(M),
                    F = r.value[M];
                    return F ? [F.currentBendpointCount === e.bendpoints.value.length ? {
                            ...F,
                            virtual: !0
                        }
                         : null, N] : [N]
                }).filter(Boolean), {
                    x: k,
                    y: C
                }
            ],
            S = (E, M, N) => {
                const F = $d(e.id, E),
                K = p.value(F) || M;
                return !N && K
            },
            T = [];
            for (let E = 0; E < x.length - 1; E++) {
                const M = E === 0,
                N = E + 1 === x.length - 1,
                F = x[E],
                K = x[E + 1],
                j = S(E - 1, F.virtual, M) ? {
                    x: F.x + s.value.x,
                    y: F.y + s.value.y
                }
                 : F,
                G = S(E, K.virtual, N) ? {
                    x: K.x + s.value.x,
                    y: K.y + s.value.y
                }
                 : K;
                T.push({
                    start: j,
                    end: G,
                    isStart: M,
                    isEnd: N
                })
            }
            return T
        }),
        startSegmentPosition: m,
        endSegmentPosition: v
    }
}, lJe = ["data-connector-id"], wF = Fe({
    inheritAttrs: !1,
    __name: "Connector",
    props: {
        sourceNode: {
        default:
            null
        },
        sourcePort: {
        default:
            null
        },
        destNode: {
        default:
            null
        },
        destPort: {
        default:
            null
        },
        absolutePoint: {
        default:
            null
        },
        interactive: {
            type: Boolean,
        default:
            !0
        },
        id: {},
        flowVariableConnection: {
            type: Boolean
        },
        streaming: {
            type: Boolean
        },
        label: {},
        allowedActions: {},
        bendpoints: {
        default:
            () => []
        }
    },
    setup(e) {
        const t = e,
        n = po(),
        r = De(!1),
        o = De(!1),
        i = ne(() => n.state.workflow.isDragging),
        s = ne(() => n.getters["selection/isNodeSelected"]),
        a = ne(() => n.getters["selection/isConnectionSelected"]),
        l = ne(() => n.getters["selection/isBendpointSelected"]), {
            sourceNode: c,
            sourcePort: u,
            destNode: f,
            destPort: p,
            id: m,
            absolutePoint: v,
            bendpoints: y
        } = nl(t), {
            pathSegments: b
        } = yF({
            id: t.id,
            sourceNode: c,
            destNode: f,
            sourcePort: u,
            destPort: p,
            absolutePoint: v,
            bendpoints: y
        }),
        w = ne(() => n.getters["workflow/isWritable"]),
        k = ne(() => s.value(c.value) && s.value(f.value));
        Ht(k, ye => {
            if (ye) {
                const ge = Array(b.value.length - 1).fill(null).map((pe, xe) => $d(t.id, xe));
                ge.every(pe => !l.value(pe)) && n.dispatch("selection/selectBendpoints", ge)
            }
        });
        const C = ne(() => n.getters["selection/singleSelectedNode"]),
        x = ne(() => n.getters["selection/selectedConnections"]),
        S = ne(() => n.getters["canvas/screenToCanvasCoordinates"]),
        T = ne(() => Boolean(C.value) && x.value.length === 0 && (s.value(t.sourceNode) || s.value(t.destNode))), {
            isDraggedOver: E,
            onRepositoryNodeDragEnter: M,
            onRepositoryNodeDrop: N,
            onWorkflowNodeDragEnter: F,
            onWorkflowNodeDragLeave: K
        } = XXe({
            id: m,
            sourceNode: c,
            sourcePort: u,
            destNode: f,
            destPort: p,
            allowedActions: t.allowedActions
        }),
        j = ye => ye.shiftKey || ye[ga()],
        G = ye => {
            j(ye) || n.dispatch("selection/deselectAllObjects");
            const ge = a.value(t.id) ? "deselectConnection" : "selectConnection";
            n.dispatch(`selection/${ge}`, t.id)
        },
        Y = ye => {
            G(ye),
            n.dispatch("application/toggleContextMenu", {
                event: ye
            })
        },
        ue = () => {
            E.value = !1
        },
        re = De(null),
        de = De([]),
        Se = async({
            position: ye,
            index: ge,
            event: pe
        }) => {
            await n.dispatch("workflow/addVirtualBendpoint", {
                position: ye,
                connectionId: t.id,
                index: ge
            });
            const [xe, et] = S.value([pe.clientX, pe.clientY]);
            re.value = {
                index: ge,
                position: {
                    x: xe,
                    y: et
                }
            },
            pe.stopPropagation();
            const Xe = new PointerEvent("pointerdown", {
                clientX: pe.clientX,
                clientY: pe.clientY,
                pointerId: pe.pointerId
            });
            de.value[ge].$el.dispatchEvent(Xe)
        }, {
            createPointerDownHandler: Pe
        } = Yw({
            useGridSnapping: !1,
            onMoveEndCallback: () => re.value ? (n.dispatch("workflow/addBendpoint", {
                    connectionId: t.id,
                    position: re.value.position,
                    index: re.value.index
                }), re.value = null, Promise.resolve(!1)) : Promise.resolve(!0)
        }),
        je = (ye, ge, pe) => {
            if (j(ye))
                return;
            const xe = $d(t.id, ge - 1);
            l.value(xe, t.sourceNode, t.destNode) || n.dispatch("selection/deselectAllObjects"),
            n.dispatch("selection/selectBendpoint", xe),
            Pe(ne(() => pe))(ye)
        };
        Ht(ca(t, "bendpoints"), () => {
            i.value && n.dispatch("workflow/resetDragState")
        }, {
            deep: !0
        });
        const Ke = (ye, ge) => {
            if (i.value)
                return;
            const pe = $d(t.id, ge - 1);
            if (j(ye)) {
                const xe = l.value(pe, t.sourceNode, t.destNode) ? "deselect" : "select";
                n.dispatch(`selection/${xe}Bendpoint`, pe)
            } else
                n.dispatch("selection/deselectAllObjects"), n.dispatch("selection/selectBendpoint", pe)
        },
        Ue = De(null),
        yt = ne(() => a.value(t.id) || T.value || o.value),
        at = (ye, ge) => {
            Ue.value = ye ? ge : null
        },
        le = (ye, ge) => {
            const pe = $d(t.id, ge - 1);
            Ue.value = ge - 1,
            n.dispatch("selection/selectBendpoint", pe),
            n.dispatch("application/toggleContextMenu", {
                event: ye
            })
        };
        return (ye, ge) => (_(), O("g", {
                "data-connector-id": ke(m),
                onIndicateReplacement: ge[2] || (ge[2] = ve(pe => r.value = pe.detail.state, ["stop"]))
            }, [(_(!0), O(Le, null, $t(ke(b), (pe, xe) => (_(), O(Le, {
                                        key: xe
                                    }, [z(sJe, {
                                                "connection-id": ke(m),
                                                segment: pe,
                                                index: xe,
                                                "is-flowvariable-connection": ye.flowVariableConnection,
                                                "is-highlighted": T.value,
                                                "is-dragged-over": ke(E),
                                                "is-readonly": !w.value,
                                                "is-last-segment": xe === ke(b).length - 1,
                                                "is-selected": a.value(ke(m)) && !i.value,
                                                interactive: ye.interactive,
                                                streaming: ye.streaming,
                                                "suggest-delete": pe.isEnd && r.value,
                                                "is-connection-hovered": o.value,
                                                onMouseenter: ge[0] || (ge[0] = et => o.value = !0),
                                                onMouseleave: ge[1] || (ge[1] = et => o.value = !1),
                                                onClick: ve(G, ["left"]),
                                                onPointerdown: ve(Y, ["right"]),
                                                onDragenter: ke(M),
                                                onDragleave: ue,
                                                onDrop: ve(ke(N), ["stop"]),
                                                onNodeDraggingEnter: ke(F),
                                                onNodeDraggingLeave: ve(ue, ["prevent"]),
                                                onNodeDraggingEnd: ve(ke(K), ["prevent"]),
                                                onAddVirtualBendpoint: et => Se({
                                                    ...et,
                                                    index: xe
                                                })
                                            }, null, 8, ["connection-id", "segment", "index", "is-flowvariable-connection", "is-highlighted", "is-dragged-over", "is-readonly", "is-last-segment", "is-selected", "interactive", "streaming", "suggest-delete", "is-connection-hovered", "onClick", "onPointerdown", "onDragenter", "onDrop", "onNodeDraggingEnter", "onNodeDraggingLeave", "onNodeDraggingEnd", "onAddVirtualBendpoint"]), xe !== 0 ? (_(), H(vF, {
                                                    key: 0,
                                                    ref_for: !0,
                                                    ref_key: "itemRefs",
                                                    ref: de,
                                                    "is-selected": l.value(ke($d)(ke(m), xe - 1), ke(c), ke(f)),
                                                    "is-dragging": i.value,
                                                    "is-flow-variable-connection": ye.flowVariableConnection,
                                                    position: ke(b)[xe].start,
                                                    index: xe - 1,
                                                    "connection-id": ke(m),
                                                    interactive: ye.interactive && w.value,
                                                    "is-visible": yt.value || Ue.value === xe - 1,
                                                    onMouseenter: et => at(!0, xe - 1),
                                                    onMouseleave: et => at(!1, xe - 1),
                                                    onPointerdown: [ve(et => je(et, xe, ke(b)[xe].start), ["left"]), ve(et => le(et, xe), ["right"])],
                                                    onClick: et => Ke(et, xe)
                                                }, null, 8, ["is-selected", "is-dragging", "is-flow-variable-connection", "position", "index", "connection-id", "interactive", "is-visible", "onMouseenter", "onMouseleave", "onPointerdown", "onClick"])) : J("", !0)], 64))), 128))], 40, lJe))
    }
}), cJe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#3E3A39",
    viewBox: "0 0 32 32"
}, uJe = P("path", {
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    d: "M8.417 16h15.166M16 8.417v15.166"
}, null, -1), dJe = [uJe];
function fJe(e, t) {
    return _(),
    O("svg", cJe, dJe)
}
const hJe = {
    render: fJe
};
const pJe = {
    components: {
        PlusIcon: hJe
    },
    props: {
        position: {
            type: Array,
            required: !0
        }
    },
    computed: {
        size() {
            return this.$shapes.addNodeGhostSize
        },
        iconSize() {
            return this.size * .9
        },
        portSize() {
            return this.$shapes.portSize
        },
        transformToCenter() {
            return [this.portSize / 2, -this.size / 2]
        }
    }
}, mJe = ["transform"], gJe = ["transform"], vJe = ["width", "height"];
function yJe(e, t, n, r, o, i) {
    const s = B("PlusIcon");
    return _(),
    O("g", {
        transform: `translate(${n.position})`
    }, [P("g", {
                transform: `translate(${i.transformToCenter})`
            }, [P("rect", {
                        width: i.size,
                        height: i.size,
                        rx: "1",
                        ry: "1"
                    }, null, 8, vJe), z(s, {
                        width: i.iconSize,
                        height: i.iconSize,
                        x: i.size / 2 - i.iconSize / 2,
                        y: i.size / 2 - i.iconSize / 2
                    }, null, 8, ["width", "height", "x", "y"])], 8, gJe)], 8, mJe)
}
const wJe = te(pJe, [["render", yJe], ["__scopeId", "data-v-6d5861ef"]]), bJe = Fe({
    __name: "NodePortActiveConnector",
    props: {
        port: {},
        dragConnector: {},
        direction: {},
        targeted: {
            type: Boolean
        },
        didDragToCompatibleTarget: {
            type: Boolean
        },
        disableQuickNodeAdd: {
            type: Boolean
        }
    },
    setup(e) {
        const t = e,
        n = ne(() => t.direction === "out" && !t.didDragToCompatibleTarget && !t.disableQuickNodeAdd),
        r = ne(() => {
            const o = t.port?.connectedVia.length > 0;
            return t.direction === "in" && o && (t.targeted || Boolean(t.dragConnector))
        });
        return Ht(r, o => {
            if (!t.port)
                return;
            const [i] = t.port.connectedVia;
            document.querySelector(`[data-connector-id="${i}"]`).dispatchEvent(new CustomEvent("indicate-replacement", {
                    detail: {
                        state: o
                    }
                }))
        }),
        (o, i) => {
            const s = B("Portal");
            return o.dragConnector ? (_(), H(s, {
                    key: 0,
                    to: "drag-connector"
                }, {
                default:
                    oe(() => [o.port ? (_(), H(wF, Bt({
                                        key: 0
                                    }, o.dragConnector, {
                                        class: "non-interactive",
                                        interactive: !1
                                    }), null, 16)) : J("", !0), o.port ? (_(), H(hg, {
                                    key: 1,
                                    class: "non-interactive",
                                    "data-test-id": "drag-connector-port",
                                    port: o.port,
                                    transform: `translate(${o.dragConnector.absolutePoint})`
                                }, null, 8, ["port", "transform"])) : J("", !0), n.value ? (_(), H(wJe, {
                                    key: 2,
                                    class: "non-interactive",
                                    position: o.dragConnector.absolutePoint
                                }, null, 8, ["position"])) : J("", !0)]),
                    _: 1
                })) : J("", !0)
        }
    }
});
const bF = te(bJe, [["__scopeId", "data-v-22ff3293"]]), _Je = e => e.isPlaceHolderPort, kJe = () => {
    const e = wa(),
    t = ne(() => e.state.workflow.activeWorkflow.connections),
    n = ne(() => e.state.application.availablePortTypes);
    return {
        shouldPortSnap: ({
            sourcePort: o,
            targetPort: i,
            targetPortDirection: s,
            targetPortGroups: a
        }) => {
            let l = !1,
            c = null;
            return _Je(i) ? (c = GXe({
                    fromPort: o,
                    availablePortTypes: n.value,
                    targetPortDirection: s,
                    targetPortGroups: a
                }), l = c !== null) : l = KXe({
                    fromPort: o,
                    toPort: i,
                    availablePortTypes: n.value,
                    targetPortDirection: s,
                    connections: t.value
                }), {
                isCompatible: l,
                validPortGroups: c
            }
        }
    }
}, xJe = (e, t) => {
    const n = e.direction === "out" ? "sourceNode" : "destNode",
    r = e.direction === "out" ? "sourcePort" : "destPort";
    return {
        id: "drag-connector",
        allowedActions: {
            canDelete: !1
        },
        flowVariableConnection: e.isFlowVariable,
        absolutePoint: t,
        [n]: e.nodeId,
        [r]: e.port.index
    }
}, CN = Math.ceil(_i / 2), SJe = (e, t) => {
    const n = Math.abs(t.x - e.x),
    r = Math.abs(t.y - e.y);
    return n >= CN || r >= CN
}, CJe = e => {
    const t = wa();
    let n = null;
    const r = De(null),
    o = De(!1),
    i = De(!1),
    s = De(!1),
    a = De(!1);
    lg({
        group: "PORT_DRAG",
        alwaysActive: !0,
        onEscape: () => {
            if (r.value) {
                const {
                    removeConnector: w
                } = e.onEscPressed?.() || {
                    removeConnector: !0
                };
                w && (r.value = null, a.value = !0)
            }
        }
    });
    const {
        shouldPortSnap: l
    } = kJe(),
    c = ne(() => t.getters["canvas/screenToCanvasCoordinates"]),
    u = ne(() => t.getters["workflow/isWritable"]);
    let f = null;
    const p = w => {
        !u.value || w.button !== 0 || w.shiftKey || w.ctrlKey || (w.stopPropagation(), i.value = !0, w.target.setPointerCapture(w.pointerId), f = {
                x: w.clientX,
                y: w.clientY
            })
    },
    m = w => {
        if (!SJe(f, {
                x: w.clientX,
                y: w.clientY
            }))
            return;
        o.value = !0,
        r.value = xJe(e, c.value([w.x, w.y]));
        const k = UXe({
            downstreamConnection: e.direction === "out",
            startNode: e.nodeId,
            workflow: t.state.workflow.activeWorkflow
        });
        Ir.emit("connector-start", {
            validConnectionTargets: k,
            startNodeId: e.nodeId,
            startPort: e.port
        })
    },
    v = Ds(w => {
        if (i.value && !o.value && m(w), !r.value || !i.value)
            return;
        const k = document.elementFromPoint(w.x, w.y),
        [C, x] = c.value([w.x, w.y]),
        S = (N, F) => {
            r.value.absolutePoint = [N, F]
        };
        S(C, x);
        const T = e.direction === "out" ? "in" : "out",
        E = new CustomEvent("connector-move", {
            detail: {
                x: C,
                y: x,
                targetPortDirection: T,
                onSnapCallback: ({
                    snapPosition: N,
                    targetPort: F,
                    targetPortGroups: K
                }) => {
                    const [j, G] = N, {
                        isCompatible: Y,
                        validPortGroups: ue
                    } = l({
                        sourcePort: e.port,
                        targetPort: F,
                        targetPortDirection: T,
                        targetPortGroups: K
                    });
                    return s.value = Y,
                    Y && S(j, G), {
                        didSnap: Y,
                        ...ue && {
                            createPortFromPlaceholder: {
                                validPortGroups: ue
                            }
                        }
                    }
                }
            },
            bubbles: !0
        }),
        M = k && n?.element === k;
        if (M && !n.allowsDrop)
            s.value = !1;
        else if (M)
            k.dispatchEvent(E);
        else if (n && n.allowsDrop && n.element.dispatchEvent(new CustomEvent("connector-leave", {
                    detail: {
                        relatedTarget: k
                    },
                    bubbles: !0
                })), k) {
            const F = !k.dispatchEvent(new CustomEvent("connector-enter", {
                        bubbles: !0,
                        cancelable: !0
                    }));
            F && k.dispatchEvent(E),
            n = {
                element: k,
                allowsDrop: F
            }
        } else
            n = null;
        n && (n = {
                ...n,
                isCompatible: s.value
            })
    });
    return {
        didMove: o,
        didDragToCompatibleTarget: s,
        dragConnector: r,
        onPointerDown: p,
        onPointerMove: v,
        onPointerUp: w => {
            i.value = !1,
            r.value && (w.stopPropagation(), w.target.releasePointerCapture(w.pointerId), n && n.allowsDrop && n.element.dispatchEvent(new CustomEvent("connector-drop", {
                        detail: {
                            startNode: e.nodeId,
                            startPort: e.port.index,
                            isCompatible: n.isCompatible
                        },
                        bubbles: !0,
                        cancelable: !0
                    })) && Ir.emit("connector-dropped"))
        },
        onLostPointerCapture: () => {
            if (i.value = !1, o.value = !1, a.value) {
                Ir.emit("connector-end"),
                a.value = !1;
                return
            }
            const w = !s.value && e.direction === "out", {
                removeConnector: k
            } = w && r.value ? e.onCanvasDrop(r.value) : {
                removeConnector: !0
            };
            k && (r.value = null),
            n && n.allowsDrop && n.element.dispatchEvent(new CustomEvent("connector-leave", {
                    bubbles: !0
                })),
            Ir.emit("connector-end")
        }
    }
}, IJe = ["transform"], TJe = Fe({
    __name: "NodePort",
    props: {
        direction: {},
        nodeId: {},
        relativePosition: {
        default:
            () => [0, 0]
        },
        port: {},
        targeted: {
            type: Boolean,
        default:
            !1
        },
        selected: {
            type: Boolean,
        default:
            !1
        },
        disableQuickNodeAdd: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["click", "deselect", "remove"],
    setup(e, {
        emit: t
    }) {
        const n = e,
        r = wa(),
        o = Mo("anchorPoint"),
        i = ne(() => r.state.application.availablePortTypes),
        s = ne(() => {
            const S = ri(i.value)(n.port.typeId);
            if (!S)
                throw new Error(`port template ${n.port.typeId} not available in application`);
            return S
        }),
        a = ne(() => s.value.kind === "flowVariable"),
        l = ne(() => {
            const S = s.value.kind === "table" ? 6 : 8, {
                portSize: T
            } = dw;
            return {
                position: {
                    x: n.relativePosition[0],
                    y: n.relativePosition[1] - T / 2
                },
                gap: S,
                anchorPoint: o,
                title: n.port.name,
                text: n.port.info,
                orientation: "top",
                hoverable: !1
            }
        }),
        c = S => {
            r.dispatch("workflow/openQuickAddNodeMenu", S)
        },
        u = ne(() => r.getters["workflow/isWritable"]), {
            elemRef: f
        } = PXe({
            tooltip: l
        }), {
            didMove: p,
            didDragToCompatibleTarget: m,
            dragConnector: v,
            onPointerDown: y,
            onPointerMove: b,
            onPointerUp: w,
            onLostPointerCapture: k
        } = CJe({
            direction: n.direction,
            isFlowVariable: a.value,
            nodeId: n.nodeId,
            port: n.port,
            onCanvasDrop: () => {
                if (n.disableQuickNodeAdd)
                    return {
                        removeConnector: !0
                    };
                const [S, T] = v.value.absolutePoint;
                return c({
                    props: {
                        position: {
                            x: S,
                            y: T
                        },
                        port: n.port,
                        nodeId: n.nodeId
                    }
                }), {
                    removeConnector: !0
                }
            }
        }),
        C = () => {
            p.value || t("click")
        },
        x = () => {
            n.selected && t("deselect")
        };
        return (S, T) => {
            const E = B("Portal");
            return Cn((_(), O("g", {
                        ref_key: "tooltipRef",
                        ref: f,
                        transform: `translate(${S.relativePosition})`,
                        class: he({
                            targeted: S.targeted
                        }),
                        onPointerdown: T[1] || (T[1] = (...M) => ke(y) && ke(y)(...M)),
                        onPointerup: T[2] || (T[2] = (...M) => ke(w) && ke(w)(...M)),
                        onPointermove: T[3] || (T[3] = ve((...M) => ke(b) && ke(b)(...M), ["stop"])),
                        onLostpointercapture: T[4] || (T[4] = ve((...M) => ke(k) && ke(k)(...M), ["stop"]))
                    }, [z(hg, {
                                port: S.port,
                                class: he({
                                    "hoverable-port": !S.selected && u.value
                                }),
                                onClick: C
                            }, null, 8, ["port", "class"]), z(E, {
                                to: "selected-port"
                            }, {
                            default:
                                oe(() => [z(ho, {
                                            name: "fade"
                                        }, {
                                        default:
                                            oe(() => [S.selected ? (_(), H(HXe, {
                                                            key: `${S.nodeId}-${S.port.index}-${S.direction}`,
                                                            port: S.port,
                                                            "anchor-point": ke(o),
                                                            "relative-position": S.relativePosition,
                                                            direction: S.direction,
                                                            "onAction:remove": T[0] || (T[0] = M => S.$emit("remove")),
                                                            onClose: x
                                                        }, null, 8, ["port", "anchor-point", "relative-position", "direction"])) : J("", !0)]),
                                            _: 1
                                        })]),
                                _: 1
                            }), z(bF, {
                                port: S.port,
                                targeted: S.targeted,
                                direction: S.direction,
                                "drag-connector": ke(v),
                                "did-drag-to-compatible-target": ke(m),
                                "disable-quick-node-add": S.disableQuickNodeAdd
                            }, null, 8, ["port", "targeted", "direction", "drag-connector", "did-drag-to-compatible-target", "disable-quick-node-add"])], 42, IJe)), [[ke(x9), () => x()]])
        }
    }
});
const _F = te(TJe, [["__scopeId", "data-v-289e51f2"]]);
const MJe = {
    components: {
        NodePort: _F,
        AddPortPlaceholder: TXe
    },
    props: {
        nodeId: {
            type: String,
            required: !0
        },
        nodeKind: {
            type: String,
            required: !0,
            validator: e => ["node", "metanode", "component"].includes(e)
        },
        inPorts: {
            type: Array,
            required: !0
        },
        outPorts: {
            type: Array,
            required: !0
        },
        portGroups: {
            type: Object,
        default:
            null
        },
        targetPort: {
            type: Object,
        default:
            null
        },
        isEditable: {
            type: Boolean,
        default:
            !1
        },
        hover: {
            type: Boolean,
        default:
            !1
        },
        connectorHover: {
            type: Boolean,
        default:
            !1
        },
        isSingleSelected: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["updatePortPositions"],
    data: () => ({
        selectedPort: null
    }),
    computed: {
        ...ut("workflow", ["isDragging", "quickAddNodeMenu"]),
        ...zt("workflow", ["isWritable"]),
        isMetanode() {
            return this.nodeKind === "metanode"
        },
        isComponent() {
            return this.nodeKind === "component"
        },
        portPositions() {
            const e = {
                in: Ky({
                    portCount: this.inPorts.length,
                    isMetanode: this.isMetanode
                }),
                out: Ky({
                    portCount: this.outPorts.length,
                    isMetanode: this.isMetanode,
                    isOutports: !0
                })
            };
            return this.canAddPort.input && e.in.push(mN({
                    portCount: this.inPorts.length,
                    isMetanode: this.isMetanode
                })),
            this.canAddPort.output && e.out.push(mN({
                    portCount: this.outPorts.length,
                    isMetanode: this.isMetanode,
                    isOutport: !0
                })),
            e
        },
        addPortPlaceholderPositions() {
            return {
                input: this.portPositions.in[this.portPositions.in.length - 1],
                output: this.portPositions.out[this.portPositions.out.length - 1]
            }
        },
        canAddPort() {
            if (!this.isEditable)
                return {
                    input: !1,
                    output: !1
                };
            if (this.isComponent || this.isMetanode)
                return {
                    input: !0,
                    output: !0
                };
            if (this.portGroups) {
                let e = Object.values(this.portGroups);
                return {
                    input: e.some(t => t.canAddInPort),
                    output: e.some(t => t.canAddOutPort)
                }
            }
            return {
                input: !1,
                output: !1
            }
        }
    },
    watch: {
        isDragging(e, t) {
            e && !t && (this.selectedPort = null)
        },
        portPositions() {
            this.$emit("updatePortPositions", this.portPositions)
        }
    },
    mounted() {
        this.$emit("updatePortPositions", this.portPositions)
    },
    methods: {
        ...Er("workflow", ["addNodePort", "removeNodePort"]),
        isShowingQuickAddNodeMenu(e, t) {
            return this.quickAddNodeMenu.isOpen && t === "out" && this.quickAddNodeMenu.props.nodeId === this.nodeId && this.quickAddNodeMenu.props.port.index === e
        },
        onPortClick({
            index: e,
            portGroupId: t
        }, n) {
            if (!this.isEditable)
                return;
            let r = () => {
                this.selectedPort = `${n}-${e}`
            };
            if (this.nodeKind === "component" && e !== 0)
                r();
            else if (this.nodeKind === "metanode")
                r();
            else if (t) {
                let o = this.portGroups[t],
                [, i] = o[`${n}Range`];
                this.selectedPort = `${n}-${i}`
            }
        },
        onDeselectPort() {
            this.selectedPort = null
        },
        isMickeyMousePort(e) {
            return !this.isMetanode && e.index === 0
        },
        portAnimationClasses(e, t) {
            if (!this.isMickeyMousePort(e))
                return {};
            const n = this.isShowingQuickAddNodeMenu(e.index, t);
            return {
                "mickey-mouse": !0,
                "connector-hover": this.connectorHover,
                connected: n || e.connectedVia.length,
                "read-only": !this.isWritable,
                "node-hover": this.hover
            }
        },
        isPortTargeted({
            index: e
        }, t) {
            return this.targetPort?.side === t && this.targetPort.index === e
        },
        isPlaceholderPortTargeted(e) {
            return e === "input" ? this.isPortTargeted({
                index: this.inPorts.length
            }, "in") : this.isPortTargeted({
                index: this.outPorts.length
            }, "out")
        },
        addPort({
            side: e,
            typeId: t,
            portGroup: n
        }) {
            this.addNodePort({
                nodeId: this.nodeId,
                side: e,
                typeId: t,
                portGroup: n
            })
        },
        removePort({
            portGroupId: e,
            index: t
        }, n) {
            this.removeNodePort({
                nodeId: this.nodeId,
                side: n,
                index: t,
                portGroup: e
            }),
            this.selectedPort = null
        }
    }
};
function PJe(e, t, n, r, o, i) {
    const s = B("NodePort"),
    a = B("AddPortPlaceholder");
    return _(),
    O("g", null, [(_(!0), O(Le, null, $t(n.inPorts, l => (_(), H(s, {
                                key: `input-${l.index}`,
                                class: he(["port", i.portAnimationClasses(l, "in")]),
                                direction: "in",
                                "node-id": n.nodeId,
                                "node-kind": n.nodeKind,
                                port: l,
                                "relative-position": i.portPositions.in[l.index],
                                selected: e.selectedPort === `input-${l.index}`,
                                targeted: i.isPortTargeted(l, "in"),
                                "data-hide-in-workflow-preview": i.isMickeyMousePort(l) && !l.connectedVia.length || null,
                                onClick: c => i.onPortClick(l, "input"),
                                onRemove: c => i.removePort(l, "input"),
                                onDeselect: i.onDeselectPort
                            }, null, 8, ["class", "node-id", "node-kind", "port", "relative-position", "selected", "targeted", "data-hide-in-workflow-preview", "onClick", "onRemove", "onDeselect"]))), 128)), (_(!0), O(Le, null, $t(n.outPorts, l => (_(), H(s, {
                                key: `output-${l.index}`,
                                class: he(["port", i.portAnimationClasses(l, "out")]),
                                direction: "out",
                                "node-id": n.nodeId,
                                "node-kind": n.nodeKind,
                                port: l,
                                "relative-position": i.portPositions.out[l.index],
                                selected: e.selectedPort === `output-${l.index}`,
                                targeted: i.isPortTargeted(l, "out"),
                                "data-hide-in-workflow-preview": i.isMickeyMousePort(l) && !l.connectedVia.length || null,
                                onClick: c => i.onPortClick(l, "output"),
                                onRemove: c => i.removePort(l, "output"),
                                onDeselect: i.onDeselectPort
                            }, null, 8, ["class", "node-id", "node-kind", "port", "relative-position", "selected", "targeted", "data-hide-in-workflow-preview", "onClick", "onRemove", "onDeselect"]))), 128)), (_(), O(Le, null, $t(["input", "output"], l => (_(), O(Le, null, [i.canAddPort[l] ? (_(), H(a, {
                                            key: l,
                                            side: l,
                                            targeted: i.isPlaceholderPortTargeted(l),
                                            "target-port": n.targetPort,
                                            "node-id": n.nodeId,
                                            position: i.addPortPlaceholderPositions[l],
                                            "port-groups": n.portGroups,
                                            class: he(["add-port", {
                                                        "node-hover": n.hover,
                                                        "connector-hover": n.connectorHover,
                                                        "node-selected": n.isSingleSelected
                                                    }
                                                ]),
                                            "data-hide-in-workflow-preview": "",
                                            onAddPort: c => i.addPort({
                                                side: l,
                                                typeId: c.typeId,
                                                portGroup: c.portGroup
                                            })
                                        }, null, 8, ["side", "targeted", "target-port", "node-id", "position", "port-groups", "class", "onAddPort"])) : J("", !0)], 64))), 64))])
}
const EJe = te(MJe, [["render", PJe], ["__scopeId", "data-v-8f184099"]]), kF = {
    props: {
        id: {
            type: [String, null],
            required: !0
        },
        disableValidTargetCheck: {
            type: Boolean,
        default:
            !1
        },
        disableHoverBoundaryCheck: {
            type: Boolean,
        default:
            !1
        },
        position: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        },
        portPositions: {
            type: Object,
            required: !0,
            validator: e => Array.isArray(e.in) && Array.isArray(e.out)
        },
        portGroups: {
            type: Object,
        default:
            null
        }
    },
    data: () => ({
        connectorHover: !1,
        targetPort: null,
        isConnectionSource: !1,
        connectionForbidden: !1,
        validConnectionTargets: null
    }),
    computed: {
        ...ut("workflow", ["portTypeMenu"]),
        snapPartitions() {
            const e = n => {
                if (!n.length)
                    return null;
                let r = [];
                for (let o = 0; o < n.length - 1; o++)
                    r.push((n[o] + n[o + 1]) / 2);
                return r
            };
            let t = {};
            return this.portPositions.in && (t.in = e(this.portPositions.in.map(([, n]) => n))),
            this.portPositions.out && (t.out = e(this.portPositions.out.map(([, n]) => n))),
            t
        }
    },
    mounted() {
        this.$bus.on("connector-start", this.onConnectorStart),
        this.$bus.on("connector-end", this.onConnectorEnd)
    },
    methods: {
        ...Er("workflow", ["connectNodes", "addNodePort", "openPortTypeMenu", "closePortTypeMenu"]),
        ...eg("workflow", ["setPortTypeMenuPreviewPort"]),
        onConnectorStart({
            validConnectionTargets: e,
            startNodeId: t
        }) {
            this.disableValidTargetCheck || (this.validConnectionTargets = e, this.connectionForbidden = !e.has(this.id), this.isConnectionSource = this.id === t)
        },
        onConnectorEnd() {
            this.connectionForbidden = !1,
            this.isConnectionSource = !1,
            this.connectorHover = !1,
            this.targetPort = null,
            this.validConnectionTargets = null
        },
        onConnectorEnter(e) {
            consola.trace("connector-enter"),
            !this.connectionForbidden && (this.connectorHover = !0, e.preventDefault())
        },
        onConnectorLeave() {
            consola.trace("connector-leave"),
            this.connectorHover = !1,
            this.targetPort = null
        },
        onConnectorMove(e, t) {
            consola.trace("connector-move");
            let {
                y: n,
                x: r,
                targetPortDirection: o
            } = e.detail;
            const i = r - this.position.x,
            s = n - this.position.y;
            if (!this.disableHoverBoundaryCheck && this.isOutsideConnectorHoverRegion(i, s, o)) {
                this.targetPort = null;
                return
            }
            const a = this.snapPartitions[o],
            l = this.portPositions[o];
            if (!a)
                return;
            const c = a.findIndex(k => s <= k);
            let u;
            a.length === 0 ? u = 0 : c === -1 ? u = l.length - 1 : u = c;
            const [f, p] = l[u],
            m = [f + this.position.x, p + this.position.y],
            v = t[`${o}Ports`];
            let y;
            u < v.length ? y = v[u] : y = {
                isPlaceHolderPort: !0
            };
            const {
                didSnap: b,
                createPortFromPlaceholder: w
            } = e.detail.onSnapCallback({
                targetPort: y,
                targetPortGroups: this.portGroups,
                snapPosition: m
            });
            b && this.targetPort?.index !== u && (this.targetPort = {
                    side: o,
                    index: u
                }, w && (this.targetPort = {
                        ...this.targetPort,
                        ...w,
                        isPlaceHolderPort: !0,
                        snapPosition: m
                    }))
        },
        addPort({
            side: e,
            typeId: t,
            portGroup: n
        }) {
            return this.addNodePort({
                nodeId: this.id,
                side: e === "in" ? "input" : "output",
                typeId: t,
                portGroup: n
            })
        },
        async addPortAndConnectIt({
            typeId: e,
            portGroup: t,
            side: n,
            startNode: r,
            startPort: o
        }) {
            const {
                newPortIdx: i
            } = await this.addPort({
                side: n,
                typeId: e,
                portGroup: t
            });
            this.connectNodes(this.createConnectorObject({
                    startNode: r,
                    startPort: o,
                    targetPort: i,
                    targetNode: this.id,
                    side: n
                }))
        },
        createConnectorObject({
            startNode: e,
            startPort: t,
            targetNode: n,
            targetPort: r,
            side: o
        }) {
            return o === "in" ? {
                sourceNode: e,
                sourcePort: t,
                destNode: n,
                destPort: r
            }
             : {
                sourceNode: n,
                sourcePort: r,
                destNode: e,
                destPort: t
            }
        },
        onConnectorDrop(e) {
            let t = {
                ...this.targetPort
            };
            const {
                detail: {
                    startNode: n,
                    startPort: r,
                    isCompatible: o
                }
            } = e;
            if (isNaN(t?.index)) {
                e.preventDefault();
                return
            }
            if (!o) {
                e.preventDefault();
                return
            }
            if (!t.isPlaceHolderPort) {
                this.connectNodes(this.createConnectorObject({
                        startNode: n,
                        startPort: r,
                        targetPort: t.index,
                        targetNode: this.id,
                        side: t.side
                    }));
                return
            }
            const i = Object.keys(t.validPortGroups),
            [s] = i;
            if (i.length === 1 && t.validPortGroups[s].supportedPortTypeIds.length === 1) {
                const [c] = t.validPortGroups[s].supportedPortTypeIds,
                u = t.side;
                this.addPortAndConnectIt({
                    typeId: c,
                    portGroup: s === "default" ? null : s,
                    side: u,
                    startNode: n,
                    startPort: r
                });
                return
            }
            const [a, l] = t.snapPosition;
            this.openPortTypeMenu({
                nodeId: this.id,
                startNodeId: n,
                props: {
                    side: t.side === "in" ? "input" : "output",
                    position: {
                        x: a,
                        y: l
                    },
                    portGroups: t.validPortGroups
                },
                events: {
                    itemActive: c => {
                        this.setPortTypeMenuPreviewPort(c?.port)
                    },
                    itemClick: ({
                        typeId: c,
                        portGroup: u
                    }) => {
                        u = u === "default" ? null : u;
                        const f = t.side;
                        this.addPortAndConnectIt({
                            typeId: c,
                            portGroup: u,
                            side: f,
                            startNode: n,
                            startPort: r
                        })
                    },
                    menuClose: this.closePortTypeMenu
                }
            })
        },
        isOutsideConnectorHoverRegion(e, t, n) {
            return t < -20 || n === "in" && e > this.$shapes.nodeSize || n === "out" && e < 0
        }
    },
    render() {
        return this.$slots.default({
            targetPort: this.targetPort,
            connectorHover: this.connectorHover,
            connectionForbidden: this.connectionForbidden,
            isConnectionSource: this.isConnectionSource,
            on: {
                onConnectorStart: this.onConnectorStart,
                onConnectorEnd: this.onConnectorEnd,
                onConnectorEnter: this.onConnectorEnter,
                onConnectorLeave: this.onConnectorLeave,
                onConnectorMove: this.onConnectorMove,
                onConnectorDrop: this.onConnectorDrop
            }
        })
    }
}, OJe = 32, IN = {
default:
    "M0,29.2L0,2.8C0,1.3,1.3,0,2.8,0l26.3,0C30.7,0,32,1.3,32,2.8v26.3c0,1.6-1.3,2.8-2.8,2.8H2.8C1.3,32,0,30.7,0,29.2z",
    LoopEnd: "M32,2.8v26.3c0,1.6-1.3,2.8-2.8,2.8H4L0,16.1L4,0l25.2,0C30.7,0,32,1.3,32,2.8z",
    LoopStart: "M0,29.2L0,2.8C0,1.3,1.3,0,2.8,0L32,0l-4,15.9L32,32H2.8C1.3,32,0,30.7,0,29.2z",
    ScopeEnd: "M32,2.8v26.3c0,1.6-1.3,2.8-2.8,2.8H4L0,16.1L4,0l25.2,0C30.7,0,32,1.3,32,2.8z",
    ScopeStart: "M0,29.2L0,2.8C0,1.3,1.3,0,2.8,0L32,0l-4,15.9L32,32H2.8C1.3,32,0,30.7,0,29.2z",
    VirtualIn: "M32,2.8v26.3c0,1.6-1.3,2.8-2.8,2.8H6.5L0,25.9l5.2-10L0.7,7.2L6.5,0l22.7,0C30.7,0,32,1.3,32,2.8z",
    VirtualOut: "M0,29.2L0,2.8C0,1.3,1.3,0,2.8,0L32,0l-5.8,7.2l4.5,8.7l-5.2,10L32,32H2.8C1.3,32,0,30.7,0,29.2z"
}, $Je = .75, AJe = {
    props: {
        type: {
            type: String,
        default:
            null
        },
        isComponent: {
            type: Boolean,
        default:
            !1
        },
        icon: {
            type: String,
        default:
            null,
            validator: e => e.startsWith("data:image/")
        }
    },
    computed: {
        backgroundPath() {
            return IN[this.type] || IN.default
        },
        backgroundColor() {
            return r7[this.type] || lI
        },
        componentColor() {
            return n7
        },
        componentBackgroundTransformation() {
            let e = OJe / 2;
            return `translate(${e}, ${e}) scale(${$Je}) translate(-${e}, -${e})`
        }
    }
}, DJe = ["d", "fill"], NJe = ["d", "fill", "transform"], RJe = ["xlink:href"];
function LJe(e, t, n, r, o, i) {
    return _(),
    O("g", null, [P("path", {
                class: "bg",
                d: i.backgroundPath,
                fill: n.isComponent ? i.componentColor : i.backgroundColor
            }, null, 8, DJe), n.isComponent && n.type ? (_(), O("path", {
                    key: 0,
                    class: "bg",
                    d: i.backgroundPath,
                    fill: i.backgroundColor,
                    transform: i.componentBackgroundTransformation
                }, null, 8, NJe)) : J("", !0), n.icon ? (_(), O("image", {
                    key: 1,
                    "xlink:href": n.icon,
                    x: "8",
                    y: "8",
                    width: "16",
                    height: "16",
                    "pointer-events": "none"
                }, null, 8, RJe)) : J("", !0)])
}
const xF = te(AJe, [["render", LJe]]), BJe = {}, VJe = {
    fill: "none"
}, FJe = P("rect", {
    width: "32",
    height: "32",
    rx: "2",
    fill: "white"
}, null, -1), jJe = P("path", {
    d: `M32 5.3V4.3H27.9V0H26.9V4.3H22.3V0H21.3V4.3H16.7V0H15.7V4.3H11.1V0H10.1V4.3H5.5V0H4.5V4.3H0V5.3H4.5V9.9H0V10.9H
      4.5V15.5H0V16.5H4.5V21.1H0V22.1H4.5V26.7H0V27.7H4.5V32H5.5V27.7H10.1V32H11.1V27.7H15.7V32H16.7V27.7H21.3V32H22.3V
      27.7H26.9V32H27.9V27.7H32V26.7H27.9V22.1H32V21.1H27.9V16.5H32V15.5H27.9V10.9H32V9.9H27.9V5.3H32ZM21.3 5.3V9.9H16.7
      V5.3H21.3ZM15.7 16.5V21.1H11.1V16.5H15.7ZM11.1 15.5V10.9H15.7V15.5H11.1ZM16.7 16.5H21.3V21.1H16.7V16.5ZM16.7 15.5V
      10.9H21.3V15.5H16.7ZM15.7 5.3V9.9H11.1V5.3H15.7ZM5.5 5.3H10.1V9.9H5.5V5.3ZM5.5 10.9H10.1V15.5H5.5V10.9ZM5.5 16.5H
      10.1V21.1H5.5V16.5ZM5.5 26.7V22.1H10.1V26.7H5.5ZM11.1 26.7V22.1H15.7V26.7H11.1ZM16.7 26.7V22.1H21.3V26.7H16.7ZM
      26.9 26.7H22.3V22.1H26.9V26.7ZM26.9 21.1H22.3V16.5H26.9V21.1ZM26.9 15.5H22.3V10.9H26.9V15.5ZM26.9 9.9H22.3V5.3H
      26.9V9.9Z`,
    fill: "#D30D52"
}, null, -1), WJe = P("circle", {
    cx: "16",
    cy: "16",
    r: "8.5",
    fill: "white",
    stroke: "white"
}, null, -1), zJe = P("circle", {
    cx: "16",
    cy: "16",
    r: "7.5",
    fill: "white",
    stroke: "#D30D52"
}, null, -1), HJe = P("path", {
    d: `M16 18C16 18 15.8667 16.8 17.2 15.7333C17.8 15.2667 18 14.7333 18 14.0667C18 12.9333 17.1333 12 16 12C14.8667
       12 14 12.8667 14 14`,
    stroke: "#3E3A39",
    "stroke-miterlimit": "10",
    "stroke-linejoin": "round"
}, null, -1), UJe = P("path", {
    d: `M16.0002 20.4666C15.9335 20.4666 15.8002 20.4666 15.7335 20.3999C15.6668 20.3332 15.6002 20.3332 15.5335
      20.2666C15.4002 20.1332 15.3335 19.9999 15.3335 19.7999C15.3335 19.5999 15.4002 19.4666 15.5335 19.3332C15.6002
      19.2666 15.6668 19.1999 15.7335 19.1999C15.9335 19.1332 16.0668 19.1332 16.2668 19.1999C16.3335 19.2666 16.4002
      19.2666 16.4668 19.3332C16.6002 19.4666 16.6668 19.6666 16.6668 19.7999C16.6668 19.9999 16.6002 20.1332 16.4668
      20.2666C16.4002 20.3332 16.3335 20.3999 16.2668 20.3999C16.2002 20.4666 16.0668 20.4666 16.0002 20.4666Z`,
    fill: "#3E3A39"
}, null, -1), qJe = P("rect", {
    x: "0.5",
    y: "0.5",
    width: "31",
    height: "31",
    rx: "1.5",
    stroke: "#A90A42"
}, null, -1), YJe = [FJe, jJe, WJe, zJe, HJe, UJe, qJe];
function KJe(e, t) {
    return _(),
    O("g", VJe, YJe)
}
const GJe = te(BJe, [["render", KJe]]), XJe = {}, JJe = {
    fill: "none"
}, ZJe = P("rect", {
    width: "32",
    height: "32",
    rx: "2",
    fill: "white"
}, null, -1), QJe = P("path", {
    d: `M32 5.3V4.3H27.9V0H26.9V4.3H22.3V0H21.3V4.3H16.7V0H15.7V4.3H11.1V0H10.1V4.3H5.5V0H4.5V4.3H0V5.3H4.5V9.9H0V10.9H
      4.5V15.5H0V16.5H4.5V21.1H0V22.1H4.5V26.7H0V27.7H4.5V32H5.5V27.7H10.1V32H11.1V27.7H15.7V32H16.7V27.7H21.3V32H22.3V
      27.7H26.9V32H27.9V27.7H32V26.7H27.9V22.1H32V21.1H27.9V16.5H32V15.5H27.9V10.9H32V9.9H27.9V5.3H32ZM21.3 5.3V9.9H16.7
      V5.3H21.3ZM15.7 16.5V21.1H11.1V16.5H15.7ZM11.1 15.5V10.9H15.7V15.5H11.1ZM16.7 16.5H21.3V21.1H16.7V16.5ZM16.7 15.5V
      10.9H21.3V15.5H16.7ZM15.7 5.3V9.9H11.1V5.3H15.7ZM5.5 5.3H10.1V9.9H5.5V5.3ZM5.5 10.9H10.1V15.5H5.5V10.9ZM5.5 16.5H
      10.1V21.1H5.5V16.5ZM5.5 26.7V22.1H10.1V26.7H5.5ZM11.1 26.7V22.1H15.7V26.7H11.1ZM16.7 26.7V22.1H21.3V26.7H16.7ZM
      26.9 26.7H22.3V22.1H26.9V26.7ZM26.9 21.1H22.3V16.5H26.9V21.1ZM26.9 15.5H22.3V10.9H26.9V15.5ZM26.9 9.9H22.3V5.3H
      26.9V9.9Z`,
    fill: "#FFD800"
}, null, -1), eZe = P("path", {
    d: `M16.6495 9.12501C16.5156 8.89295 16.268 8.75 16 8.75C15.732 8.75 15.4844 8.89295 15.3505 9.12501L8.35048
      21.2498C8.21651 21.4818 8.21651 21.7677 8.35048 21.9998C8.48446 22.2318 8.73205 22.3748 9 22.3748H23C23.2679
      22.3748 23.5155 22.2318 23.6495 21.9998C23.7835 21.7677 23.7835 21.4818 23.6495 21.2498L16.6495 9.12501Z`,
    fill: "#FFD800",
    stroke: "white",
    "stroke-width": "1.5"
}, null, -1), tZe = P("path", {
    d: "M16 9.5L9 21.6248H23L16 9.5Z",
    fill: "#FFD800",
    stroke: "#3E3A39"
}, null, -1), nZe = P("path", {
    d: "M15.9997 13.25L15.9993 17.2365",
    stroke: "#3E3A39"
}, null, -1), rZe = P("path", {
    d: `M16.0064 20.0318C15.9177 20.0318 15.8423 20.0063 15.753 19.9814C15.6776 19.9431 15.6131 19.9054 15.5506
      19.8416C15.4369 19.7273 15.3616 19.5626 15.3616 19.3979C15.3616 19.2326 15.4369 19.0679 15.5506 18.9415C15.6138
      18.891 15.6776 18.8399 15.753 18.8023C15.9171 18.7391 16.0818 18.7391 16.2459 18.8023C16.3225 18.8399 16.3857
      18.891 16.4483 18.9415C16.5619 19.0685 16.6385 19.2326 16.6385 19.3979C16.6385 19.5626 16.5619 19.7273 16.4483
      19.841C16.3851 19.9048 16.3225 19.9425 16.2459 19.9808C16.1705 20.0063 16.0818 20.0318 16.0064 20.0318Z`,
    fill: "#3E3A39"
}, null, -1), oZe = P("rect", {
    x: "0.5",
    y: "0.5",
    width: "31",
    height: "31",
    rx: "1.5",
    stroke: "#AB9100"
}, null, -1), iZe = [ZJe, QJe, eZe, tZe, nZe, rZe, oZe];
function sZe(e, t) {
    return _(),
    O("g", JJe, iZe)
}
const aZe = te(XJe, [["render", sZe]]), lZe = {
    props: {
        executionState: {
            type: String,
        default:
            null,
            validator: e => ["EXECUTED", "EXECUTING", "IDLE"].includes(e)
        }
    }
}, cZe = ["fill"], uZe = ["fill", "data-test-metanodeState"], dZe = P("path", {
    d: `M0 2C0 0.895431 0.895431 0 2 0H8V2H2.75C2.33579 2 2 2.33579 2 2.75V8H0V2Z
        M2 24H0V30C0 31.1046 0.895431 32 2 32H8V30H2.75C2.33579 30 2 29.6642 2 29.25V24Z
        M24 30V32H30C31.1046 32 32 31.1046 32 30V24H30V29.25C30 29.6642 29.6642 30 29.25 30H24Z
        M30 8H32V2C32 0.895431 31.1046 0 30 0H24V2H29.25C29.6642 2 30 2.33579 30 2.75V8Z`
}, null, -1), fZe = P("rect", {
    x: "13",
    width: "6",
    height: "2"
}, null, -1), hZe = P("rect", {
    x: "13",
    y: "30",
    width: "6",
    height: "2"
}, null, -1), pZe = P("rect", {
    y: "13",
    width: "2",
    height: "6"
}, null, -1), mZe = P("rect", {
    x: "30",
    y: "13",
    width: "2",
    height: "6"
}, null, -1), gZe = ["stroke"], vZe = ["stroke"];
function yZe(e, t, n, r, o, i) {
    return _(),
    O("g", {
        fill: e.$colors.nodeBackgroundColors.MetanodeSecondary
    }, [P("rect", {
                width: "32",
                height: "32",
                rx: "2",
                fill: e.$colors.nodeBackgroundColors.Metanode,
                "data-test-metanodeState": n.executionState
            }, null, 8, uZe), dZe, fZe, hZe, pZe, mZe, n.executionState === "EXECUTING" ? (_(), O("polygon", {
                    key: 0,
                    stroke: e.$colors.metanodeState,
                    points: "11,11  11,21  14.75,18.5  14.75,21  22.25,16  14.75,11  14.75,13.5",
                    fill: "transparent",
                    "stroke-width": "2"
                }, null, 8, gZe)) : n.executionState === "EXECUTED" ? (_(), O("polyline", {
                    key: 1,
                    stroke: e.$colors.metanodeState,
                    points: "8,16  14,21.5  24,10.5",
                    fill: "transparent",
                    "stroke-width": "2",
                    "stroke-linejoin": "round"
                }, null, 8, vZe)) : J("", !0)], 8, cZe)
}
const wZe = te(lZe, [["render", yZe]]), bZe = {
    props: {
        isDraggedOver: {
            type: Boolean,
        default:
            !1
        }
    }
}, _Ze = ["opacity"], kZe = P("path", {
    class: "bg",
    d: "M0,29.2L0,2.8C0,1.3,1.3,0,2.8,0l26.3,0C30.7,0,32,1.3,32,2.8v26.3c0,1.6-1.3,2.8-2.8,2.8H2.8C1.3,32,0,30.7,0,29.2z",
    fill: "var(--knime-silver-sand)",
    stroke: "none"
}, null, -1), xZe = P("path", {
    d: "M27.6509 3.23401H20.6509C19.8259 3.23401 19.1509 3.90901 19.1509 4.73401V11.734C19.1509 12.559 19.8259 13.234 20.6509 13.234H27.6509C28.4759 13.234 29.1509 12.559 29.1509 11.734V4.73401C29.1509 3.90901 28.4759 3.23401 27.6509 3.23401Z",
    "stroke-linejoin": "round"
}, null, -1), SZe = P("path", {
    d: "M11.6509 18.806H4.65088C3.82588 18.806 3.15088 19.481 3.15088 20.306V27.306C3.15088 28.131 3.82588 28.806 4.65088 28.806H11.6509C12.4759 28.806 13.1509 28.131 13.1509 27.306V20.306C13.1509 19.481 12.4759 18.806 11.6509 18.806Z",
    "stroke-linejoin": "round"
}, null, -1), CZe = P("path", {
    d: "M3.59186 19.247L12.7099 28.365",
    "stroke-linejoin": "round"
}, null, -1), IZe = P("path", {
    d: "M19.5919 3.67502L28.7099 12.793",
    "stroke-linejoin": "round"
}, null, -1), TZe = P("path", {
    d: "M24.1509 16.52V18.745C24.1509 21.52 21.8959 23.77 19.1209 23.77H16.1509",
    "stroke-linejoin": "round"
}, null, -1), MZe = P("path", {
    d: "M21.7809 18.4L24.1609 16.02L26.5409 18.4",
    "stroke-linejoin": "round"
}, null, -1), PZe = [kZe, xZe, SZe, CZe, IZe, TZe, MZe];
function EZe(e, t, n, r, o, i) {
    return _(),
    O("g", {
        opacity: [n.isDraggedOver ? "1" : "0"],
        fill: "none",
        stroke: "#000"
    }, PZe, 8, _Ze)
}
const OZe = te(bZe, [["render", EZe]]), $Ze = {
    components: {
        NodeTorsoMissing: GJe,
        NodeTorsoMetanode: wZe,
        NodeTorsoUnknown: aZe,
        NodeTorsoNormal: xF,
        NodeTorsoReplace: OZe
    },
    props: {
        type: {
            type: String,
        default:
            null
        },
        kind: {
            type: String,
            required: !0,
            validator: e => ["node", "metanode", "component"].includes(e)
        },
        icon: {
            type: String,
        default:
            null,
            validator: e => e.startsWith("data:image/")
        },
        executionState: {
            type: String,
        default:
            null
        },
        isDraggedOver: {
            type: Boolean,
            defaut: !1
        }
    },
    computed: {
        ...zt("workflow", ["isWritable"]),
        isKnownNode() {
            return this.kind === "component" ? !this.type || Reflect.has(this.$colors.nodeBackgroundColors, this.type) : this.kind === "metanode" || Reflect.has(this.$colors.nodeBackgroundColors, this.type)
        }
    }
};
function AZe(e, t, n, r, o, i) {
    const s = B("NodeTorsoMissing"),
    a = B("NodeTorsoMetanode"),
    l = B("NodeTorsoNormal"),
    c = B("NodeTorsoUnknown"),
    u = B("NodeTorsoReplace");
    return _(),
    O("g", null, [n.type === "Missing" ? (_(), H(s, {
                    key: 0
                })) : n.kind === "metanode" ? (_(), H(a, {
                    key: 1,
                    "execution-state": n.executionState
                }, null, 8, ["execution-state"])) : i.isKnownNode ? (_(), H(l, {
                    key: 2,
                    "is-component": n.kind === "component",
                    icon: n.icon,
                    type: n.type
                }, null, 8, ["is-component", "icon", "type"])) : (_(), H(c, {
                    key: 3
                })), z(u, {
                "is-dragged-over": n.isDraggedOver
            }, null, 8, ["is-dragged-over"])])
}
const DZe = te($Ze, [["render", AZe]]);
const NZe = {
    props: {
        backgroundType: {
            type: String,
        default:
            null
        },
        updateStatus: {
            type: String,
        default:
            null
        }
    },
    computed: {
        backgroundColor() {
            return this.$colors.nodeBackgroundColors[this.backgroundType]
        }
    }
}, RZe = ["fill"], LZe = ["stroke"], BZe = ["stroke"], VZe = {
    key: 3
}, FZe = ["stroke"], jZe = ["stroke"];
function WZe(e, t, n, r, o, i) {
    return _(),
    O("g", null, [i.backgroundColor ? (_(), O("rect", {
                    key: 0,
                    width: "6",
                    height: "6",
                    x: "5",
                    rx: "1",
                    ry: "1",
                    fill: i.backgroundColor
                }, null, 8, RZe)) : J("", !0), !n.updateStatus || n.updateStatus === "UP_TO_DATE" ? (_(), O("path", {
                    key: 1,
                    d: "M2.43 8.57L9.5 1.5M5 1.5L9.5 1.5L9.5 6",
                    fill: "none",
                    "stroke-linejoin": "round",
                    stroke: e.$colors.linkDecorator,
                    "data-testid": "arrow"
                }, null, 8, LZe)) : J("", !0), n.updateStatus === "HAS_UPDATE" ? (_(), O("path", {
                    key: 2,
                    d: "M2.43 8.57L9.5 1.5M5 1.5L9.5 1.5L9.5 6",
                    fill: "none",
                    "stroke-linejoin": "round",
                    stroke: e.$colors.linkDecorator,
                    "stroke-dasharray": "1 1",
                    "data-testid": "dotted-arrow"
                }, null, 8, BZe)) : n.updateStatus === "ERROR" ? (_(), O("g", VZe, [P("path", {
                            d: "M2.4304 8.56863L9.50146 1.49756",
                            stroke: e.$colors.linkDecorator,
                            "data-testid": "cross"
                        }, null, 8, FZe), P("path", {
                            d: "M9.50124 8.56863L2.43018 1.49756",
                            stroke: e.$colors.linkDecorator,
                            "data-testid": "cross"
                        }, null, 8, jZe)])) : J("", !0)])
}
const zZe = te(NZe, [["render", WZe], ["__scopeId", "data-v-51a2d6f4"]]), HZe = {
    props: {
        backgroundType: {
            type: String,
        default:
            null
        },
        isLocked: {
            type: Boolean,
            required: !0
        }
    },
    computed: {
        backgroundColor() {
            return this.$colors.nodeBackgroundColors[this.backgroundType]
        }
    }
};
const xg = e => (ir("data-v-9ecc7262"), e = e(), sr(), e), UZe = ["fill"], qZe = {
    key: 1
}, YZe = xg(() => P("path", {
            d: "M7.43753 3.99902H1.5625V8.12524H7.43753V3.99902Z"
        }, null, -1)), KZe = xg(() => P("path", {
            d: "M4.5 6.89504V5.71436"
        }, null, -1)), GZe = xg(() => P("path", {
            d: "M2.53125 3.99892V2.84326C2.53125 1.75651 3.41297 0.874512 4.5 0.874512C5.58759 0.874512 6.46875 1.75651 6.46875 2.84326V3.99892"
        }, null, -1)), XZe = xg(() => P("path", {
            d: "M3.97705 5.71436H5.0233"
        }, null, -1)), JZe = [YZe, KZe, GZe, XZe], ZZe = {
    key: 2
}, QZe = xg(() => P("g", null, [P("path", {
                    d: "M8.43753 3.99902H2.5625V8.12524H8.43753V3.99902Z"
                }), P("path", {
                    d: "M5.5 6.89504V5.71436"
                }), P("path", {
                    d: "M0.53125 3.99892V2.84326C0.53125 1.75651 1.41297 0.874512 2.5 0.874512C3.58759 0.874512 4.46875 1.75651 4.46875 2.84326V3.99892"
                }), P("path", {
                    d: "M4.97705 5.71436H6.0233"
                })], -1)), eQe = [QZe];
function tQe(e, t, n, r, o, i) {
    return _(),
    O("g", null, [i.backgroundColor ? (_(), O("rect", {
                    key: 0,
                    width: "6",
                    height: "6",
                    x: "0",
                    y: "5",
                    rx: "1",
                    ry: "1",
                    fill: i.backgroundColor
                }, null, 8, UZe)) : J("", !0), n.isLocked ? (_(), O("g", qZe, JZe)) : (_(), O("g", ZZe, eQe))])
}
const nQe = te(HZe, [["render", tQe], ["__scopeId", "data-v-9ecc7262"]]);
const rQe = {
    props: {
        executionInfo: {
            type: Object,
            required: !0
        },
        backgroundType: {
            type: String,
        default:
            null
        }
    },
    computed: {
        backgroundColor() {
            return this.$colors.nodeBackgroundColors[this.backgroundType]
        },
        streamable() {
            let {
                streamable: e,
                jobManager: t
            } = this.executionInfo;
            return e || t?.type === "streaming"
        }
    }
}, oQe = e => (ir("data-v-bf6e4819"), e = e(), sr(), e), iQe = {
    key: 0,
    class: "streamable",
    d: "M0.5,5.5 h1 m2,0 h1 m2,0 h1 M5.80957 2.40625L8.90332 5.5L5.80957 8.59375"
}, sQe = {
    key: 1
}, aQe = ["fill"], lQe = oQe(() => P("path", {
            class: "not-streamable",
            d: "M2.40625 8.59375L8.59375 2.40625 M2.40625 2.40625L8.59375 8.59375"
        }, null, -1));
function cQe(e, t, n, r, o, i) {
    return i.streamable ? (_(), O("path", iQe)) : (_(), O("g", sQe, [i.backgroundColor ? (_(), O("rect", {
                        key: 0,
                        width: "4",
                        height: "4",
                        x: "1",
                        y: "1",
                        rx: "1",
                        ry: "1",
                        fill: i.backgroundColor
                    }, null, 8, aQe)) : J("", !0), lQe]))
}
const uQe = te(rQe, [["render", cQe], ["__scopeId", "data-v-bf6e4819"]]);
const dQe = {
    props: {
        loopStatus: {
            type: String,
        default:
            null
        }
    },
    computed: {
        backgroundColor() {
            return this.$colors.nodeBackgroundColors.Loop
        }
    }
}, Kw = e => (ir("data-v-a7fc5beb"), e = e(), sr(), e), fQe = {
    key: 0,
    class: "pause"
}, hQe = ["fill"], pQe = ["fill"], mQe = Kw(() => P("path", {
            d: "M4.04102 3.104V6.89588",
            stroke: "#3E3A39",
            "stroke-linejoin": "round"
        }, null, -1)), gQe = Kw(() => P("path", {
            d: "M5.95898 6.89588V3.104",
            stroke: "#3E3A39",
            "stroke-linejoin": "round"
        }, null, -1)), vQe = {
    key: 1,
    class: "running"
}, yQe = ["fill"], wQe = Kw(() => P("path", {
            d: "M6.28125 6.96875L5.4375 8.34375L6.84375 9.21875",
            stroke: "#3E3A39",
            "stroke-linejoin": "round"
        }, null, -1)), bQe = ["fill"], _Qe = Kw(() => P("path", {
            d: "M3.75 3.03125L4.5625 1.65625L3.15625 0.78125",
            stroke: "#3E3A39",
            "stroke-linejoin": "round"
        }, null, -1)), kQe = ["fill"];
function xQe(e, t, n, r, o, i) {
    return n.loopStatus === "PAUSED" ? (_(), O("g", fQe, [P("path", {
                    "fill-rule": "evenodd",
                    d: `M0.441293 0.440316C0.722598 0.159012 1.10413 0.000976478 1.50195 0.000976562L6.99728 0.000977039L6.99728
        3.00098L7.00418 6.9963L0.00195312 6.9963L0.00195338 1.50098C0.00195338 1.10315 0.159989 0.721621 0.441293
        0.440316Z`,
                    fill: i.backgroundColor
                }, null, 8, hQe), P("path", {
                    d: `M5 9.0625C7.24366 9.0625 9.0625 7.24366 9.0625 5C9.0625 2.75634 7.24366 0.9375 5 0.9375C2.75634 0.9375
        0.9375 2.75634 0.9375 5C0.9375 7.24366 2.75634 9.0625 5 9.0625Z`,
                    stroke: "#3E3A39",
                    "stroke-linejoin": "round",
                    fill: i.backgroundColor
                }, null, 8, pQe), mQe, gQe])) : n.loopStatus === "RUNNING" ? (_(), O("g", vQe, [P("path", {
                    "fill-rule": "evenodd",
                    d: `M0.441293 0.440316C0.722598 0.159012 1.10413 0.000976478 1.50195 0.000976562L6.99728 0.000977039L6.99728
        3.00098L7.00418 6.9963L0.00195312 6.9963L0.00195338 1.50098C0.00195338 1.10315 0.159989 0.721621 0.441293
        0.440316Z`,
                    fill: i.backgroundColor
                }, null, 8, yQe), wQe, P("path", {
                    d: "M5.4375 8.34375C7.1875 8.125 8.53125 6.78125 8.53125 5C8.53125 3.40625 7.46875 2.0625 6 1.625",
                    stroke: "#3E3A39",
                    "stroke-linejoin": "round",
                    fill: i.backgroundColor
                }, null, 8, bQe), _Qe, P("path", {
                    d: "M4.5625 1.65625C2.8125 1.875 1.46875 3.21875 1.46875 5C1.46875 6.59375 2.53125 7.9375 4 8.375",
                    stroke: "#3E3A39",
                    "stroke-linejoin": "round",
                    fill: i.backgroundColor
                }, null, 8, kQe)])) : J("", !0)
}
const SQe = te(dQe, [["render", xQe], ["__scopeId", "data-v-a7fc5beb"]]);
const CQe = {
    props: {
        backgroundType: {
            type: String,
        default:
            null
        }
    },
    computed: {
        backgroundColor() {
            return this.$colors.nodeBackgroundColors[this.backgroundType]
        }
    }
}, Gw = e => (ir("data-v-04993555"), e = e(), sr(), e), IQe = ["fill"], TQe = Gw(() => P("path", {
            d: "M7.5 3H9.5V8H6.5"
        }, null, -1)), MQe = Gw(() => P("path", {
            d: "M4 8H2V3H5"
        }, null, -1)), PQe = Gw(() => P("path", {
            d: "M4 1.5L5.5 3L4 4.5"
        }, null, -1)), EQe = Gw(() => P("path", {
            d: "M7.5 9.5L6 8L7.5 6.5"
        }, null, -1));
function OQe(e, t, n, r, o, i) {
    return _(),
    O("g", null, [i.backgroundColor ? (_(), O("rect", {
                    key: 0,
                    width: "4",
                    height: "4",
                    x: "1",
                    y: "5",
                    rx: "1",
                    ry: "1",
                    fill: i.backgroundColor
                }, null, 8, IQe)) : J("", !0), TQe, MQe, PQe, EQe])
}
const $Qe = te(CQe, [["render", OQe], ["__scopeId", "data-v-04993555"]]), AQe = {
    components: {
        LinkDecorator: zZe,
        StreamingDecorator: uQe,
        LoopDecorator: SQe,
        ReexecutionDecorator: $Qe,
        LockDecorator: nQe
    },
    inheritAttrs: !1,
    props: {
        type: {
            type: String,
        default:
            null
        },
        link: {
            type: Object,
        default:
            null
        },
        kind: {
            type: String,
            required: !0,
            validator: e => ["node", "metanode", "component"].includes(e)
        },
        executionInfo: {
            type: Object,
        default:
            null
        },
        loopInfo: {
            type: Object,
        default:
            () => ({
                allowedActions: {}
            })
        },
        isReexecutable: {
            type: Boolean,
        default:
            !1
        },
        isLocked: {
            type: Boolean,
        default:
            null
        }
    },
    computed: {
        decoratorBackgroundType() {
            return this.type || this.kind[0].toUpperCase() + this.kind.substring(1)
        }
    }
};
function DQe(e, t, n, r, o, i) {
    const s = B("LinkDecorator"),
    a = B("StreamingDecorator"),
    l = B("ReexecutionDecorator"),
    c = B("LoopDecorator"),
    u = B("LockDecorator");
    return _(),
    O("g", null, [n.link?.url ? (_(), H(s, {
                    key: 0,
                    "background-type": i.decoratorBackgroundType,
                    "update-status": n.link.updateStatus,
                    transform: "translate(0, 21)"
                }, null, 8, ["background-type", "update-status"])) : J("", !0), n.executionInfo ? (_(), H(a, {
                    key: 1,
                    "background-type": i.decoratorBackgroundType,
                    "execution-info": n.executionInfo,
                    transform: "translate(21, 21)"
                }, null, 8, ["background-type", "execution-info"])) : J("", !0), n.isReexecutable ? (_(), H(l, {
                    key: 2,
                    "background-type": i.decoratorBackgroundType,
                    transform: "translate(20, 0)"
                }, null, 8, ["background-type"])) : J("", !0), n.type === "LoopStart" || n.type === "LoopEnd" ? (_(), H(c, {
                    key: 3,
                    "loop-status": n.loopInfo.status,
                    transform: "translate(20, 20)"
                }, null, 8, ["loop-status"])) : J("", !0), n.isLocked !== null ? (_(), H(u, {
                    key: 4,
                    "is-locked": n.isLocked,
                    "background-type": i.decoratorBackgroundType,
                    transform: "translate(22, 1)"
                }, null, 8, ["is-locked", "background-type"])) : J("", !0)])
}
const NQe = te(AQe, [["render", DQe]]), RQe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, LQe = P("path", {
    d: "M8 16.396 14.313 22 24 11"
}, null, -1), BQe = [LQe];
function VQe(e, t) {
    return _(),
    O("svg", RQe, BQe)
}
const fT = {
    render: VQe
}, FQe = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, jQe = P("path", {
    d: "M9.9 10.1 22 22m-.1-12L10 22.1"
}, null, -1), WQe = [jQe];
function zQe(e, t) {
    return _(),
    O("svg", FQe, WQe)
}
const Xw = {
    render: zQe
}, HQe = {
    components: {
        SaveIcon: fT,
        CancelIcon: Xw,
        ActionButton: mF
    },
    props: {
        actions: {
            type: Array,
            required: !0
        },
        preventContextMenu: {
            type: Boolean,
        default:
            !1
        }
    },
    computed: {
        positions() {
            const {
                nodeActionBarButtonSpread: e
            } = this.$shapes;
            let t = this.actions.length;
            return this.actions.map((n, r) => (r + (1 - t) / 2) * e)
        }
    },
    methods: {
        getTitle(e) {
            const {
                title: t
            } = e;
            return t ? typeof t == "string" ? t : typeof t == "function" ? t(e) : null : null
        },
        onContextMenu(e) {
            this.preventContextMenu && (e.preventDefault(), e.stopPropagation())
        }
    }
};
function UQe(e, t, n, r, o, i) {
    const s = B("ActionButton");
    return _(),
    O("g", null, [(_(!0), O(Le, null, $t(n.actions, (a, l) => (_(), H(s, {
                                key: a.name,
                                x: i.positions[l],
                                primary: a.primary,
                                disabled: a.disabled,
                                title: i.getTitle(a),
                                onClick: a.onClick
                            }, {
                            default:
                                oe(() => [(_(), H(Kt(a.icon)))]),
                                _: 2
                            }, 1032, ["x", "primary", "disabled", "title", "onClick"]))), 128))])
}
const hT = te(HQe, [["render", UQe]]), qQe = ["width", "height", "x", "y"], YQe = Fe({
    __name: "AutoSizeForeignObject",
    props: {
        value: {
        default:
            ""
        },
        maxWidth: {
        default:
            1e3
        },
        yOffset: {
        default:
            0
        },
        offsetByHeight: {
            type: Boolean,
        default:
            !1
        },
        parentWidth: {
        default:
            null
        }
    },
    emits: ["widthChange", "heightChange"],
    setup(e, {
        emit: t
    }) {
        const n = e, {
            maxWidth: r,
            parentWidth: o,
            offsetByHeight: i,
            yOffset: s
        } = nl(n),
        a = De(0),
        l = De(1),
        c = De(0),
        u = De(null);
        let f = null;
        const p = ne(() => i.value ? -l.value + s.value : s.value);
        Ht(r, () => {
            a.value = r.value
        }, {
            immediate: !0
        });
        const m = () => {
            o.value !== null && (c.value = (o.value - a.value) / 2)
        },
        v = () => {
            t("widthChange", a.value),
            t("heightChange", l.value)
        };
        return Ur(async() => {
            m(),
            await Ci(),
            f = new ResizeObserver(y => {
                for (const b of y) {
                    const {
                        contentRect: w
                    } = b;
                    a.value = w.width,
                    l.value = w.height,
                    m(),
                    v()
                }
            }),
            f.observe(u.value)
        }),
        Rs(() => {
            f?.disconnect()
        }),
        (y, b) => (_(), O("foreignObject", {
                class: "autosize-container",
                width: a.value,
                height: l.value,
                x: c.value,
                y: p.value
            }, [P("div", {
                        ref_key: "wrapper",
                        ref: u,
                        class: "wrapper"
                    }, [Ye(y.$slots, "default", {}, void 0, !0)], 512)], 8, qQe))
    }
});
const SF = te(YQe, [["__scopeId", "data-v-f325ceb2"]]), pT = Fe({
    components: {
        AutoSizeForeignObject: SF
    },
    props: {
        editable: {
            type: Boolean,
        default:
            !1
        },
        value: {
            type: String,
        default:
            ""
        },
        showOverflow: {
            type: Boolean,
        default:
            !1
        },
        startWidth: {
            type: Number,
        default:
            null
        },
        startHeight: {
            type: Number,
        default:
            null
        }
    },
    emits: ["widthChange", "heightChange", "click", "requestEdit", "mouseenter", "mouseleave"]
}), TN = () => {
    to(e => ({
            "2e91aebb": e.$shapes.nodeNameFontSize,
            "300985c6": e.$shapes.nodeNameMaxLines,
            "6f0a6e34": e.$shapes.nodeNamePadding,
            "3707a574": e.$shapes.nodeNameLineHeight
        }))
}, MN = pT.setup;
pT.setup = MN ? (e, t) => (TN(), MN(e, t)) : TN;
const KQe = ["title"];
function GQe(e, t, n, r, o, i) {
    const s = B("AutoSizeForeignObject");
    return _(),
    H(s, {
        value: e.value,
        "start-width": e.startWidth,
        "start-height": e.startHeight,
        class: he(["node-name-text-container", {
                    editable: e.editable,
                    "text-ellipsis": !e.showOverflow
                }
            ]),
        "max-width": e.$shapes.maxNodeNameWidth,
        "y-offset": -e.$shapes.nodeNameMargin,
        "parent-width": e.$shapes.nodeSize,
        "offset-by-height": "",
        onWidthChange: t[4] || (t[4] = a => e.$emit("widthChange", a)),
        onHeightChange: t[5] || (t[5] = a => e.$emit("heightChange", a))
    }, {
    default:
        oe(() => [P("div", {
                    class: "node-name",
                    onClick: t[0] || (t[0] = ve(a => e.$emit("click", a), ["prevent"])),
                    onDblclick: t[1] || (t[1] = ve(a => e.editable ? e.$emit("requestEdit") : null, ["left", "prevent", "stop"])),
                    onMouseleave: t[2] || (t[2] = a => e.$emit("mouseleave", a)),
                    onMouseenter: t[3] || (t[3] = a => e.$emit("mouseenter", a))
                }, [P("span", {
                            style: Yt({
                                "max-width": `${e.$shapes.maxNodeNameWidth}px`
                            }),
                            title: e.showOverflow ? null : e.value,
                            class: "text"
                        }, [Ye(e.$slots, "default", {}, () => [mt(Re(e.value), 1)], !0)], 12, KQe)], 32)]),
        _: 3
    }, 8, ["value", "start-width", "start-height", "class", "max-width", "y-offset", "parent-width"])
}
const CF = te(pT, [["render", GQe], ["__scopeId", "data-v-8971ac2e"]]);
const XQe = {
    components: {
        NodeNameText: CF
    },
    props: {
        modelValue: {
            type: String,
        default:
            ""
        },
        startWidth: {
            type: Number,
        default:
            null
        },
        startHeight: {
            type: Number,
        default:
            null
        },
        invalidCharacters: {
            type: RegExp,
        default:
            null
        }
    },
    emits: ["update:modelValue", "save", "cancel", "widthChange", "heightChange", "invalidInput"],
    mounted() {
        this.$nextTick(() => {
            this.resizeTextarea(),
            this.$refs.textarea && (this.$refs.textarea.focus(), this.$refs.textarea.select())
        })
    },
    methods: {
        onInput(e) {
            let t = e.target.value;
            t = t.replace(/(\r\n|\n|\r)/gm, ""),
            this.invalidCharacters && this.invalidCharacters.test(t) && (this.$emit("invalidInput"), t = t.replace(this.invalidCharacters, "")),
            this.$refs.textarea.value = t,
            this.$refs.ghost.innerText = t,
            this.resizeTextarea(),
            this.$emit("update:modelValue", t)
        },
        onKeyDown(e) {
            this.invalidCharacters && this.invalidCharacters.test(e.key) && (this.$emit("invalidInput"), e.preventDefault())
        },
        onEnter(e) {
            e.preventDefault(),
            this.$emit("save")
        },
        onEscape(e) {
            e.preventDefault(),
            this.$emit("cancel")
        },
        resizeTextarea() {
            const e = this.$refs.textarea;
            if (!e)
                return;
            const t = Math.min(Math.max(this.$refs.ghost.scrollWidth + 2, this.$shapes.nodeNameEditorMinWidth), this.$shapes.maxNodeNameWidth);
            e.style.width = `${t}px`,
            e.style.height = "auto",
            e.style.height = `${e.scrollHeight}px`
        }
    }
}, JQe = ["value"];
function ZQe(e, t, n, r, o, i) {
    const s = B("NodeNameText");
    return _(),
    H(s, {
        "show-overflow": "",
        class: "editor",
        "start-width": n.startWidth,
        "start-height": n.startHeight,
        onWidthChange: t[5] || (t[5] = a => e.$emit("widthChange", a)),
        onHeightChange: t[6] || (t[6] = a => e.$emit("heightChange", a))
    }, {
    default:
        oe(() => [P("span", {
                    ref: "ghost",
                    class: "ghost",
                    "aria-hidden": "true"
                }, Re(n.modelValue), 513), P("textarea", {
                    ref: "textarea",
                    rows: "1",
                    class: "name-textarea native-context-menu",
                    value: n.modelValue,
                    onPointerdown: t[0] || (t[0] = ve(() => {}, ["stop"])),
                    onInput: t[1] || (t[1] = (...a) => i.onInput && i.onInput(...a)),
                    onKeydown: [t[2] || (t[2] = (...a) => i.onKeyDown && i.onKeyDown(...a)), t[3] || (t[3] = Rt(ve((...a) => i.onEnter && i.onEnter(...a), ["exact"]), ["enter"])), t[4] || (t[4] = Rt((...a) => i.onEscape && i.onEscape(...a), ["esc"]))]
                }, null, 40, JQe)]),
        _: 1
    }, 8, ["start-width", "start-height"])
}
const QQe = te(XQe, [["render", ZQe], ["__scopeId", "data-v-85300b07"]]), eet = 4e3, mT = Fe({
    components: {
        ActionBar: hT,
        NodeNameTextarea: QQe
    },
    props: {
        value: {
            type: String,
        default:
            ""
        },
        nodeId: {
            type: String,
            required: !0
        },
        nodePosition: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        },
        startWidth: {
            type: Number,
        default:
            null
        },
        startHeight: {
            type: Number,
        default:
            null
        }
    },
    emits: ["save", "cancel", "widthChange", "heightChange"],
    data() {
        return {
            hideInvalidCharsTimeoutId: null,
            currentName: this.value,
            latestDimensions: {
                width: null,
                height: null
            }
        }
    },
    computed: {
        ...zt("canvas", ["viewBox"]),
        overlayStyles() {
            const {
                left: e,
                top: t
            } = this.viewBox;
            return {
                width: "100%",
                height: "100%",
                x: e,
                y: t
            }
        },
        invalidCharacters() {
            return /[*?#:"<>%~|/\\]/g
        },
        actions() {
            return [{
                    name: "save",
                    icon: fT,
                    onClick: this.onSave,
                    primary: !0
                }, {
                    name: "cancel",
                    icon: Xw,
                    onClick: this.onCancel
                }
            ]
        },
        actionBarPosition() {
            return [this.nodePosition.x + this.$shapes.nodeSize / 2, this.nodePosition.y - this.$shapes.nodeSelectionPadding[0] - this.latestDimensions.height]
        },
        errorMessagePosition() {
            const e = this.$shapes.nodeSize / 2,
            t = Math.max(this.latestDimensions.width, this.$shapes.nodeWidthWithPadding);
            return {
                x: this.nodePosition.x + e - t / 2,
                y: this.nodePosition.y
            }
        }
    },
    watch: {
        value(e) {
            this.currentName = e
        }
    },
    methods: {
        handleDimensionChange(e, t) {
            this.latestDimensions = {
                ...this.latestDimensions,
                [e]: t
            },
            this.$emit(`${e}Change`, t)
        },
        onSave() {
            if (this.currentName.trim() === "") {
                this.currentName = this.value,
                this.$emit("cancel");
                return
            }
            this.currentName === this.value ? this.onCancel() : this.$emit("save", {
                dimensionsOnClose: this.latestDimensions,
                newName: this.currentName.trim()
            })
        },
        onCancel() {
            this.currentName = this.value,
            this.$emit("cancel")
        },
        onInvalidInput() {
            this.hideInvalidCharsTimeoutId && clearTimeout(this.hideInvalidCharsTimeoutId),
            this.hideInvalidCharsTimeoutId = setTimeout(() => {
                this.hideInvalidCharsTimeoutId = null
            }, eet)
        }
    }
}), PN = () => {
    to(e => ({
            "10d5b3e6": e.$shapes.selectedItemBorderRadius,
            "0a635a36": e.$colors.error
        }))
}, EN = mT.setup;
mT.setup = EN ? (e, t) => (PN(), EN(e, t)) : PN;
const tet = ["width", "x", "y"], net = {
    class: "invalid-chars-error"
}, ret = {
    class: "chars"
};
function oet(e, t, n, r, o, i) {
    const s = B("ActionBar"),
    a = B("NodeNameTextarea");
    return _(),
    O("g", null, [P("rect", Bt(e.overlayStyles, {
                    fill: "transparent",
                    onPointerdown: t[0] || (t[0] = ve(() => {}, ["stop", "prevent"])),
                    onClick: t[1] || (t[1] = ve((...l) => e.onSave && e.onSave(...l), ["stop", "prevent"])),
                    onContextmenu: t[2] || (t[2] = ve(() => {}, ["stop", "prevent"]))
                }), null, 16), z(s, {
                transform: `translate(${e.actionBarPosition})`,
                actions: e.actions,
                "prevent-context-menu": ""
            }, null, 8, ["transform", "actions"]), z(a, {
                modelValue: e.currentName,
                "onUpdate:modelValue": t[3] || (t[3] = l => e.currentName = l),
                transform: `translate(${e.nodePosition.x}, ${e.nodePosition.y})`,
                "start-width": e.startWidth,
                "start-height": e.startHeight,
                "invalid-characters": e.invalidCharacters,
                onWidthChange: t[4] || (t[4] = l => e.handleDimensionChange("width", l)),
                onHeightChange: t[5] || (t[5] = l => e.handleDimensionChange("height", l)),
                onSave: e.onSave,
                onCancel: e.onCancel,
                onInvalidInput: e.onInvalidInput
            }, null, 8, ["modelValue", "transform", "start-width", "start-height", "invalid-characters", "onSave", "onCancel", "onInvalidInput"]), Boolean(e.hideInvalidCharsTimeoutId) ? (_(), O("foreignObject", {
                    key: 0,
                    width: Math.max(e.latestDimensions.width, e.$shapes.nodeWidthWithPadding),
                    height: 70,
                    x: e.errorMessagePosition.x,
                    y: e.errorMessagePosition.y
                }, [P("div", net, [mt(" Characters "), P("span", ret, Re(e.invalidCharacters.source), 1), mt(" are not allowed and have been removed. ")])], 8, tet)) : J("", !0)])
}
const iet = te(mT, [["render", oet], ["__scopeId", "data-v-b499cd11"]]), set = {
    components: {
        NodeNameEditor: iet,
        NodeNameText: CF
    },
    props: {
        nodeId: {
            type: String,
            required: !0
        },
        nodePosition: {
            type: Object,
            required: !0
        },
        editable: {
            type: Boolean,
        default:
            !1
        },
        value: {
            type: String,
        default:
            ""
        }
    },
    emits: ["editStart", "widthChange", "heightChange", "mouseleave", "mouseenter"],
    data() {
        return {
            editorInitialDimensions: {
                width: null,
                height: null
            }
        }
    },
    computed: {
        ...ut("workflow", ["nameEditorNodeId"]),
        isEditing() {
            return this.nodeId === this.nameEditorNodeId
        }
    },
    watch: {
        isEditing(e) {
            e && this.$emit("editStart")
        }
    },
    methods: {
        ...Er("workflow", ["renameContainerNode", "openNameEditor", "closeNameEditor"]),
        onRequestEdit() {
            this.openNameEditor(this.nodeId)
        },
        onSave({
            dimensionsOnClose: e,
            newName: t
        }) {
            this.renameContainerNode({
                nodeId: this.nodeId,
                name: t
            }),
            this.editorInitialDimensions = e,
            setTimeout(() => {
                this.closeNameEditor()
            }, 100)
        },
        onCancel() {
            this.closeNameEditor()
        }
    }
};
function aet(e, t, n, r, o, i) {
    const s = B("NodeNameEditor"),
    a = B("Portal"),
    l = B("NodeNameText");
    return _(),
    O("g", null, [i.isEditing ? (_(), H(a, {
                    key: 0,
                    to: "node-text-editor"
                }, {
                default:
                    oe(() => [z(s, {
                                "node-id": n.nodeId,
                                "node-position": n.nodePosition,
                                value: n.value,
                                "start-width": o.editorInitialDimensions.width,
                                "start-height": o.editorInitialDimensions.height,
                                onWidthChange: t[0] || (t[0] = c => e.$emit("widthChange", c)),
                                onHeightChange: t[1] || (t[1] = c => e.$emit("heightChange", c)),
                                onSave: i.onSave,
                                onCancel: i.onCancel
                            }, null, 8, ["node-id", "node-position", "value", "start-width", "start-height", "onSave", "onCancel"])]),
                    _: 1
                })) : (_(), H(l, {
                    key: 1,
                    editable: n.editable,
                    value: n.value,
                    onWidthChange: t[2] || (t[2] = c => e.$emit("widthChange", c)),
                    onHeightChange: t[3] || (t[3] = c => e.$emit("heightChange", c)),
                    onRequestEdit: i.onRequestEdit,
                    onMouseleave: t[4] || (t[4] = c => e.$emit("mouseleave", c)),
                    onMouseenter: t[5] || (t[5] = c => e.$emit("mouseenter", c))
                }, null, 8, ["editable", "value", "onRequestEdit"]))])
}
const cet = te(set, [["render", aet]]), uet = (e, t) => {
    const n = () => [{
            start: 0,
            length: t.length
        }
    ];
    let r = JSON.parse(JSON.stringify(e));
    if (r.sort(({
                start: s
            }, {
                start: a
            }) => s - a), !t)
        return {
            normalized: [],
            isValid: r.length === 0
        };
    if (r.length === 0)
        return {
            normalized: n(),
            isValid: !0
        };
    for (let s = 0; s < r.length; s++) {
        let a = r[s],
        l = r[s + 1];
        if (typeof a.length != "number" || typeof a.start != "number" || a.start < 0 || a.start + a.length > t.length || l && a.start + a.length > l.start)
            return {
                normalized: n(),
                isValid: !1
            }
    }
    r[0].start !== 0 && r.unshift({
        start: 0,
        length: r[0].start
    }),
    r = r.reduce((s, a) => {
        let l = s[s.length - 1];
        if (l) {
            let c = l.start + l.length;
            c < a.start && s.push({
                start: c,
                length: a.start - c
            })
        }
        return s.push(a),
        s
    }, []);
    let o = r[r.length - 1],
    i = o.start + o.length;
    return i < t.length && r.push({
        start: i,
        length: t.length - i
    }), {
        normalized: r,
        isValid: !0
    }
}, IF = (e, t) => {
    let {
        normalized: n,
        isValid: r
    } = uet(e, t),
    o = n.map(i => ({
                ...i,
                text: t.substr(i.start, i.length)
            }));
    return o.forEach(i => {
        delete i.start,
        delete i.length
    }), {
        textRanges: o,
        isValid: r
    }
}, gT = Fe({
    components: {
        AutoSizeForeignObject: SF
    },
    props: {
        value: {
            type: String,
        default:
            "Node label"
        },
        editable: {
            type: Boolean,
        default:
            !1
        },
        isSelected: {
            type: Boolean,
        default:
            !1
        },
        kind: {
            type: String,
        default:
            ""
        },
        nodeId: {
            type: String,
        default:
            ""
        },
        annotation: {
            type: Object,
            required: !1,
        default:
            () => ({
                textAlign: "center",
                backgroundColor: "transparent",
                styleRanges: []
            })
        },
        portOffset: {
            type: Number,
            required: !1,
        default:
            0
        }
    },
    emits: ["requestEdit"],
    data() {
        return {
            textAlign: this.annotation?.textAlign,
            backgroundColor: this.annotation?.backgroundColor === "#FFFFFF" ? "transparent" : this.annotation?.backgroundColor
        }
    },
    computed: {
        isMetanode() {
            return this.kind === vf.KindEnum.Metanode
        },
        styledText() {
            const e = this.annotation ? this.annotation.styleRanges : [];
            let {
                textRanges: t,
                isValid: n
            } = IF(e, this.value);
            return n || consola.warn(`Invalid styleRanges:
                ${JSON.stringify(this.annotation.styleRanges)}. Using default style.`),
            t
        },
        yOffset() {
            return (this.isMetanode ? this.$shapes.metanodeLabelOffsetY : this.$shapes.nodeLabelOffsetY) + this.portOffset
        }
    },
    methods: {
        getTextStyles(e) {
            return {
                fontSize: e.fontSize ? `${e.fontSize * this.$shapes.annotationsFontSizePointToPixelFactor}px` : null,
                color: e.color,
                fontWeight: e.bold ? "bold" : null,
                fontStyle: e.italic ? "italic" : null,
                lineHeight: e.fontSize ? 1.1 : null
            }
        }
    }
}), ON = () => {
    to(e => ({
            "2da84d38": e.$shapes.nodeNamePadding,
            "41aa6408": e.$shapes.nodeNameLineHeight,
            "2402adfd": e.$shapes.nodeNameFontSize
        }))
}, $N = gT.setup;
gT.setup = $N ? (e, t) => (ON(), $N(e, t)) : ON;
const det = {
    key: 0,
    class: "text placeholder",
    "data-hide-in-workflow-preview": ""
};
function fet(e, t, n, r, o, i) {
    const s = B("AutoSizeForeignObject");
    return e.value || e.isSelected ? (_(), H(s, {
            key: 0,
            class: "node-label-text-container",
            "y-offset": e.yOffset,
            "parent-width": e.$shapes.nodeSize,
            style: Yt({
                backgroundColor: e.backgroundColor
            })
        }, {
        default:
            oe(() => [P("div", {
                        class: "node-label",
                        style: Yt({
                            textAlign: e.textAlign
                        }),
                        onDblclick: t[0] || (t[0] = ve(a => e.editable ? e.$emit("requestEdit") : null, ["left"]))
                    }, [(_(!0), O(Le, null, $t(e.styledText, (a, l) => (_(), O("span", {
                                                key: l,
                                                class: "text",
                                                style: Yt(e.getTextStyles(a))
                                            }, [Ye(e.$slots, "default", {}, () => [mt(Re(a.text), 1)], !0)], 4))), 128)), !e.value && e.editable ? (_(), O("span", det, [Ye(e.$slots, "default", {}, () => [mt("Add comment")], !0)])) : J("", !0)], 36)]),
            _: 3
        }, 8, ["y-offset", "parent-width", "style"])) : J("", !0)
}
const TF = te(gT, [["render", fet], ["__scopeId", "data-v-9131c35a"]]);
const het = {
    components: {
        NodeLabelText: TF
    },
    props: {
        modelValue: {
            type: String,
        default:
            ""
        },
        kind: {
            type: String,
        default:
            ""
        },
        portOffset: {
            type: Number,
            required: !1,
        default:
            0
        }
    },
    emits: ["update:modelValue", "save", "cancel", "invalidInput"],
    mounted() {
        this.$nextTick(() => {
            this.resizeTextarea(),
            this.$refs.textarea && (this.$refs.textarea.focus(), this.$refs.textarea.select())
        })
    },
    methods: {
        onInput(e) {
            const t = e.target.value;
            this.$refs.textarea.value = t,
            this.$refs.ghost.innerText = t,
            this.resizeTextarea(),
            this.$emit("update:modelValue", t)
        },
        resizeTextarea() {
            const e = this.$refs.textarea,
            t = this.$refs.ghost.scrollWidth + 6;
            e.style.width = `${t}px`,
            e.style.height = "auto",
            e.style.height = `${e.scrollHeight}px`
        },
        onSave(e) {
            const t = ga();
            e[t] && this.$emit("save")
        }
    }
}, pet = ["value"];
function met(e, t, n, r, o, i) {
    const s = B("NodeLabelText");
    return _(),
    H(s, {
        class: "editor",
        kind: n.kind,
        "port-offset": n.portOffset
    }, {
    default:
        oe(() => [P("span", {
                    ref: "ghost",
                    class: "ghost",
                    "aria-hidden": "true"
                }, Re(n.modelValue), 513), P("textarea", {
                    ref: "textarea",
                    rows: "1",
                    class: "label-textarea native-context-menu",
                    value: n.modelValue,
                    onPointerdown: t[0] || (t[0] = ve(() => {}, ["stop"])),
                    onInput: t[1] || (t[1] = (...a) => i.onInput && i.onInput(...a)),
                    onKeydown: [t[2] || (t[2] = Rt((...a) => i.onSave && i.onSave(...a), ["enter"])), t[3] || (t[3] = Rt(ve(a => e.$emit("cancel"), ["prevent"]), ["esc"]))]
                }, null, 40, pet)]),
        _: 1
    }, 8, ["kind", "port-offset"])
}
const get = te(het, [["render", met], ["__scopeId", "data-v-8f3bb002"]]), vet = {
    components: {
        NodeLabelTextArea: get,
        ActionBar: hT
    },
    props: {
        value: {
            type: String,
        default:
            ""
        },
        nodeId: {
            type: String,
            required: !0
        },
        kind: {
            type: String,
        default:
            ""
        },
        nodePosition: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        },
        portOffset: {
            type: Number,
            required: !1,
        default:
            0
        }
    },
    emits: ["save", "cancel"],
    data() {
        return {
            currentLabel: this.value
        }
    },
    computed: {
        ...zt("canvas", ["viewBox"]),
        overlayStyles() {
            const {
                left: e,
                top: t
            } = this.viewBox;
            return {
                width: "100%",
                height: "100%",
                x: e,
                y: t
            }
        },
        actions() {
            return [{
                    name: "save",
                    icon: fT,
                    onClick: this.onSave,
                    primary: !0
                }, {
                    name: "cancel",
                    icon: Xw,
                    onClick: this.onCancel
                }
            ]
        },
        actionBarPosition() {
            return [this.nodePosition.x + this.$shapes.nodeSize / 2, this.nodePosition.y + this.yOffset]
        },
        yOffset() {
            return (this.kind === "metanode" ? this.$shapes.metanodeLabelActionBarOffset : this.$shapes.nodeLabelActionBarOffset) + this.portOffset
        }
    },
    watch: {
        value(e) {
            this.currentLabel = e
        }
    },
    methods: {
        onSave() {
            this.currentLabel === this.value ? this.onCancel() : this.$emit("save", {
                newLabel: this.currentLabel.trim()
            })
        },
        onCancel() {
            this.currentLabel = this.value,
            this.$emit("cancel")
        }
    }
};
function yet(e, t, n, r, o, i) {
    const s = B("ActionBar"),
    a = B("NodeLabelTextArea");
    return _(),
    O("g", null, [P("rect", Bt(i.overlayStyles, {
                    fill: "transparent",
                    onPointerdown: t[0] || (t[0] = ve(() => {}, ["stop", "prevent"])),
                    onClick: t[1] || (t[1] = ve((...l) => i.onSave && i.onSave(...l), ["stop", "prevent"])),
                    onContextmenu: t[2] || (t[2] = ve(() => {}, ["stop", "prevent"]))
                }), null, 16), z(s, {
                actions: i.actions,
                transform: `translate(${i.actionBarPosition})`,
                "prevent-context-menu": ""
            }, null, 8, ["actions", "transform"]), z(a, {
                modelValue: o.currentLabel,
                "onUpdate:modelValue": t[3] || (t[3] = l => o.currentLabel = l),
                transform: `translate(${n.nodePosition.x}, ${n.nodePosition.y})`,
                kind: n.kind,
                "parent-width": e.$shapes.nodeSize,
                "port-offset": n.portOffset,
                onSave: i.onSave,
                onCancel: i.onCancel
            }, null, 8, ["modelValue", "transform", "kind", "parent-width", "port-offset", "onSave", "onCancel"])])
}
const wet = te(vet, [["render", yet]]), bet = {
    components: {
        NodeLabelText: TF,
        NodeLabelEditor: wet
    },
    props: {
        nodeId: {
            type: String,
            required: !0
        },
        value: {
            type: String,
        default:
            ""
        },
        kind: {
            type: String,
        default:
            ""
        },
        nodePosition: {
            type: Object,
            required: !0
        },
        editable: {
            type: Boolean,
        default:
            !1
        },
        annotation: {
            type: Object,
            required: !1,
        default:
            () => {}
        },
        numberOfPorts: {
            type: Number,
            required: !1,
        default:
            0
        }
    },
    emits: ["editStart", "widthChange", "heightChange", "mouseleave", "mouseenter"],
    computed: {
        ...ut("workflow", ["labelEditorNodeId"]),
        ...zt("selection", ["singleSelectedNode"]),
        isEditing() {
            return this.nodeId === this.labelEditorNodeId
        },
        isSelected() {
            return this.nodeId === this.singleSelectedNode?.id
        },
        portOffset() {
            const n = this.kind === "metanode" ? 2 : 5;
            return Math.max(this.numberOfPorts - n, 0) * this.$shapes.portSize
        }
    },
    methods: {
        ...Er("workflow", ["renameNodeLabel", "openLabelEditor", "closeLabelEditor"]),
        onRequestEdit() {
            this.openLabelEditor(this.nodeId)
        },
        onSave({
            newLabel: e
        }) {
            this.renameNodeLabel({
                nodeId: this.nodeId,
                label: e
            }),
            setTimeout(() => {
                this.closeLabelEditor()
            }, 100)
        },
        onCancel() {
            this.closeLabelEditor()
        }
    }
};
function _et(e, t, n, r, o, i) {
    const s = B("NodeLabelEditor"),
    a = B("portal"),
    l = B("NodeLabelText");
    return _(),
    O("g", null, [i.isEditing ? (_(), H(a, {
                    key: 0,
                    to: "node-text-editor"
                }, {
                default:
                    oe(() => [z(s, {
                                "node-id": n.nodeId,
                                value: n.value,
                                kind: n.kind,
                                "node-position": n.nodePosition,
                                "port-offset": i.portOffset,
                                onSave: i.onSave,
                                onCancel: i.onCancel
                            }, null, 8, ["node-id", "value", "kind", "node-position", "port-offset", "onSave", "onCancel"])]),
                    _: 1
                })) : (_(), H(l, {
                    key: 1,
                    "node-id": n.nodeId,
                    value: n.value,
                    kind: n.kind,
                    annotation: n.annotation,
                    editable: n.editable,
                    "is-selected": i.isSelected,
                    "port-offset": i.portOffset,
                    onRequestEdit: i.onRequestEdit
                }, null, 8, ["node-id", "value", "kind", "annotation", "editable", "is-selected", "port-offset", "onRequestEdit"]))])
}
const ket = te(bet, [["render", _et]]), xet = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Cet = P("path", {
    d: "M12 22.1V9.9L22.5 16 12 22.1Z"
}, null, -1), Iet = [Cet];
function Tet(e, t) {
    return _(),
    O("svg", xet, Iet)
}
const Met = {
    render: Tet
}, Pet = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Eet = P("path", {
    d: "M12.2 16h12.3m-6.3-6-6 6 6 6M8.5 9.933v12.134"
}, null, -1), Oet = [Eet];
function $et(e, t) {
    return _(),
    O("svg", Pet, Oet)
}
const Aet = {
    render: $et
}, Det = Fe({
    components: {
        ActionBar: hT
    },
    props: {
        nodeId: {
            type: String,
        default:
            "NODE ID MISSING"
        },
        nodeKind: {
            type: String,
            required: !0
        },
        isNodeSelected: {
            type: Boolean,
        default:
            !1
        },
        canExecute: {
            type: Boolean,
        default:
            !1
        },
        canCancel: {
            type: Boolean,
        default:
            !1
        },
        canReset: {
            type: Boolean,
        default:
            !1
        },
        canStep: {
            type: Boolean,
        default:
            null
        },
        canPause: {
            type: Boolean,
        default:
            null
        },
        canResume: {
            type: Boolean,
        default:
            null
        },
        canOpenView: {
            type: Boolean,
        default:
            null
        },
        canOpenDialog: {
            type: Boolean,
        default:
            null
        }
    },
    computed: {
        ...ut("application", ["permissions"]),
        actions() {
            return {
                configureNode: {
                    title: () => this.hoverTitle("Configure", this.$shortcuts.get("configureNode").hotkeyText),
                    disabled: !this.canOpenDialog,
                    icon: lF,
                    onClick: () => this.dispatchShortcut("configureNode")
                },
                pauseLoopExecution: {
                    title: () => this.hoverTitle("Pause", this.$shortcuts.get("pauseLoopExecution").hotkeyText),
                    disabled: !1,
                    icon: dF,
                    onClick: () => this.dispatchShortcut("pauseLoopExecution")
                },
                resumeLoopExecution: {
                    title: () => this.hoverTitle("Resume", this.$shortcuts.get("resumeLoopExecution").hotkeyText),
                    disabled: !1,
                    icon: uF,
                    onClick: () => this.dispatchShortcut("resumeLoopExecution")
                },
                execute: {
                    title: () => this.hoverTitle("Execute", this.$shortcuts.get("executeSelected").hotkeyText),
                    disabled: !this.canExecute,
                    icon: Met,
                    onClick: () => this.dispatchShortcut("executeSelected")
                },
                stepLoopExecution: {
                    title: () => this.hoverTitle("Step", this.$shortcuts.get("stepLoopExecution").hotkeyText),
                    disabled: !this.canStep,
                    icon: fF,
                    onClick: () => this.dispatchShortcut("stepLoopExecution")
                },
                cancelExecution: {
                    title: () => this.hoverTitle("Cancel", this.$shortcuts.get("cancelSelected").hotkeyText),
                    disabled: !this.canCancel,
                    icon: Xw,
                    onClick: () => this.dispatchShortcut("cancelSelected")
                },
                reset: {
                    title: () => this.hoverTitle("Reset22", this.$shortcuts.get("resetSelected").hotkeyText),
                    disabled: !this.canReset,
                    icon: Aet,
                    onClick: () => this.dispatchShortcut("resetSelected")
                },
                openView: {
                    title: () => this.hoverTitle(this.canExecute ? "Execute and open view" : "Open view", this.$shortcuts.get("executeAndOpenView").hotkeyText),
                    disabled: !this.canOpenView && !this.canExecute,
                    icon: cF,
                    onClick: () => this.dispatchShortcut("executeAndOpenView")
                }
            }
        },
        visibleActions() {
            if (!this.permissions.canEditWorkflow)
                return [];
            const e = {
                configureNode: this.canOpenDialog !== null && this.permissions.canConfigureNodes && EC(this.nodeKind),
                execute: !this.canPause && !this.canResume,
                pauseLoopExecution: this.canPause,
                resumeLoopExecution: !this.canPause && this.canResume,
                stepLoopExecution: this.canStep !== null,
                cancelExecution: !0,
                reset: !0,
                openView: this.canOpenView !== null
            };
            return Object.entries(e).filter(([t, n]) => n).map(([t, n]) => this.actions[t])
        }
    },
    methods: {
        hoverTitle(e, t) {
            return this.isNodeSelected && t ? `${e} - ${t}` : e
        },
        dispatchShortcut(e, t = {}) {
            this.$shortcuts.dispatch(e, {
                metadata: {
                    nodeId: this.nodeId,
                    ...t
                }
            })
        }
    }
});
const Net = ["y"];
function Ret(e, t, n, r, o, i) {
    const s = B("ActionBar");
    return _(),
    O("g", null, [z(s, {
                actions: e.visibleActions
            }, null, 8, ["actions"]), P("text", {
                class: "node-id",
                "text-anchor": "middle",
                y: -e.$shapes.nodeIdMargin
            }, Re(e.nodeId), 9, Net)])
}
const Let = te(Det, [["render", Ret], ["__scopeId", "data-v-034180d3"]]);
const Bet = {
    mixins: [OXe],
    inject: ["anchorPoint"],
    props: {
        executionState: {
            type: String,
        default:
            "null",
            validator: e => ["null", "CONFIGURED", "EXECUTED", "EXECUTING", "HALTED", "IDLE", "QUEUED"].includes(e)
        },
        progress: {
            type: Number,
        default:
            null
        },
        progressMessages: {
            type: Array,
        default:
            () => []
        },
        error: {
            type: String,
        default:
            null
        },
        warning: {
            type: String,
        default:
            null
        },
        issue: {
            type: String,
        default:
            null
        },
        resolutions: {
            type: Array,
        default:
            () => []
        },
        loopStatus: {
            type: String,
        default:
            null
        }
    },
    computed: {
        trafficLight() {
            return {
                IDLE: [!0, !1, !1],
                CONFIGURED: [!1, !0, !1],
                EXECUTED: [!1, !1, !0],
                HALTED: [!1, !1, !0],
                null: [!1, !1, !1]
            }
            [this.executionState]
        },
        progressBarWidth() {
            let e = this.$shapes.nodeSize * this.clippedProgress;
            return e && e < 1 ? 1 : e
        },
        percentageClipPath() {
            return `polygon(0 0, ${100 * this.clippedProgress}% 0, ${100 * this.clippedProgress}% 100%, 0 100%)`
        },
        tooltip() {
            const {
                nodeSize: e,
                nodeStatusHeight: t,
                nodeStatusMarginTop: n
            } = this.$shapes;
            let r = {
                position: {
                    x: e / 2,
                    y: e + n + t
                },
                anchorPoint: this.anchorPoint,
                gap: 10,
                hoverable: !0,
                issue: this.issue,
                resolutions: this.resolutions
            };
            return this.error ? {
                ...r,
                text: this.error,
                type: "error"
            }
             : this.warning ? {
                ...r,
                text: this.warning,
                type: "warning"
            }
             : this.progressMessages.length ? {
                ...r,
                text: this.progressMessages.join(" – ")
            }
             : null
        },
        clippedProgress() {
            return Math.min(Math.max(this.progress, 0), 1)
        },
        progressDisplayPercentage() {
            return Math.floor(100 * this.clippedProgress)
        }
    }
}, MF = e => (ir("data-v-81baf334"), e = e(), sr(), e), Vet = ["width", "height", "fill", "stroke"], Fet = {
    key: 0
}, jet = ["cx", "fill"], Wet = ["cx", "stroke"], zet = ["x", "fill"], Het = ["cy", "fill"], Uet = ["fill", "x"], qet = ["height", "width", "fill"], Yet = ["clip-path"], Ket = ["height", "width"], Get = ["x"], Xet = ["transform"], Jet = ["fill"], Zet = MF(() => P("line", {
            x1: "-2.25",
            y1: "-2.25",
            x2: "2.25",
            y2: "2.25",
            stroke: "white"
        }, null, -1)), Qet = MF(() => P("line", {
            x1: "2.25",
            y1: "-2.25",
            x2: "-2.25",
            y2: "2.25",
            stroke: "white"
        }, null, -1)), ett = ["transform"], ttt = ["fill", "stroke"], ntt = ["stroke"], rtt = ["fill"];
function ott(e, t, n, r, o, i) {
    return _(),
    O("g", null, [P("rect", {
                width: e.$shapes.nodeSize,
                height: e.$shapes.nodeStatusHeight,
                fill: e.$colors.trafficLight.background,
                stroke: e.$colors.darkeningMask,
                "stroke-width": ".3",
                rx: "1"
            }, null, 8, Vet), i.trafficLight ? (_(), O("g", Fet, [(_(!0), O(Le, null, $t(i.trafficLight, (s, a) => (_(), O(Le, {
                                            key: a
                                        }, [P("circle", {
                                                    cx: 6 + 10 * a,
                                                    cy: "6",
                                                    r: "4",
                                                    class: he(s ? `traffic-light-${["red", "yellow", "green"][a]}` : null),
                                                    fill: s ? e.$colors.trafficLight[["red", "yellow", "green"][a]] : e.$colors.trafficLight.inactive
                                                }, null, 10, jet), P("circle", {
                                                    cx: 6 + 10 * a,
                                                    cy: "6",
                                                    r: "3.5",
                                                    fill: "none",
                                                    stroke: s ? e.$colors.darkeningMask : e.$colors.trafficLight.inactiveBorder
                                                }, null, 8, Wet)], 64))), 128))])) : n.executionState === "QUEUED" ? (_(), O("text", {
                    key: 1,
                    class: "progress-text",
                    x: e.$shapes.nodeSize / 2,
                    fill: e.$colors.text.default,
                    "text-anchor": "middle",
                    y: "8.5"
                }, Re(n.loopStatus && n.loopStatus === "PAUSED" ? "paused" : "queued"), 9, zet)) : n.executionState === "EXECUTING" ? (_(), O(Le, {
                    key: 2
                }, [n.progress ? (_(), O(Le, {
                                key: 1
                            }, [P("text", {
                                        class: "progress-text progress-bar",
                                        fill: e.$colors.text.default,
                                        x: e.$shapes.nodeSize / 2,
                                        "text-anchor": "middle",
                                        y: "8.5"
                                    }, Re(i.progressDisplayPercentage) + "% ", 9, Uet), P("rect", {
                                        height: e.$shapes.nodeStatusHeight,
                                        width: i.progressBarWidth,
                                        fill: e.$colors.nodeProgressBar,
                                        rx: "1"
                                    }, null, 8, qet), P("g", {
                                        "clip-path": i.percentageClipPath
                                    }, [P("rect", {
                                                height: e.$shapes.nodeStatusHeight,
                                                width: e.$shapes.nodeSize,
                                                fill: "none"
                                            }, null, 8, Ket), P("text", {
                                                class: "progress-text",
                                                x: e.$shapes.nodeSize / 2,
                                                y: "8.5",
                                                fill: "white",
                                                "text-anchor": "middle"
                                            }, Re(i.progressDisplayPercentage) + "% ", 9, Get)], 8, Yet)], 64)) : (_(), O("circle", {
                                key: 0,
                                class: "progress-circle",
                                r: "4",
                                cy: e.$shapes.nodeStatusHeight / 2,
                                fill: e.$colors.nodeProgressBar
                            }, null, 8, Het))], 64)) : J("", !0), n.error ? (_(), O("g", {
                    key: 3,
                    class: "error",
                    transform: `translate(${e.$shapes.nodeSize / 2}, ${e.$shapes.nodeStatusHeight})`
                }, [P("circle", {
                            r: "5",
                            fill: e.$colors.error
                        }, null, 8, Jet), Zet, Qet], 8, Xet)) : n.warning ? (_(), O("g", {
                    key: 4,
                    class: "warning",
                    transform: `translate(${e.$shapes.nodeSize / 2 - 6}, 5.5)`
                }, [P("path", {
                            d: "M6,1.25 L0.5,10.75 H11.5 Z",
                            fill: e.$colors.warning,
                            stroke: e.$colors.Masala,
                            "stroke-linejoin": "round"
                        }, null, 8, ttt), P("line", {
                            x1: "6",
                            x2: "6",
                            stroke: e.$colors.Masala,
                            y1: "4.2",
                            y2: "7.3"
                        }, null, 8, ntt), P("circle", {
                            r: "0.5",
                            cy: "8.75",
                            cx: "6",
                            fill: e.$colors.Masala
                        }, null, 8, rtt)], 8, ett)) : J("", !0)])
}
const itt = te(Bet, [["render", ott], ["__scopeId", "data-v-81baf334"]]), stt = {
    props: {
        position: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        },
        extraHeight: {
            type: Number,
        default:
            20
        },
        width: {
            type: Number,
        default:
            0
        },
        kind: {
            type: String,
            required: !0,
            validator: e => ["node", "metanode", "component"].includes(e)
        }
    },
    computed: {
        nodeSelectionMeasures() {
            const {
                nodeStatusHeight: e,
                nodeStatusMarginTop: t,
                nodeSize: n,
                nodeSelectionPadding: [r, o, i, s]
            } = this.$shapes,
            a = this.kind !== "metanode",
            l = r + n + i + (a ? e + t : 0) + this.extraHeight,
            c = s + o + n,
            u = this.width > c ? this.width : c;
            return {
                y:  - (r + this.extraHeight),
                x:  - ((u - n) / 2),
                height: l,
                width: u
            }
        }
    }
}, att = ["transform"], ltt = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "rx"];
function ctt(e, t, n, r, o, i) {
    return _(),
    O("g", {
        transform: `translate(${n.position.x}, ${n.position.y})`
    }, [P("rect", {
                x: i.nodeSelectionMeasures.x,
                y: i.nodeSelectionMeasures.y,
                width: i.nodeSelectionMeasures.width,
                height: i.nodeSelectionMeasures.height,
                fill: e.$colors.selection.activeBackground,
                stroke: e.$colors.selection.activeBorder,
                "stroke-width": e.$shapes.selectedNodeStrokeWidth,
                rx: e.$shapes.selectedItemBorderRadius
            }, null, 8, ltt)], 8, att)
}
const utt = te(stt, [["render", ctt]]), dtt = {
    props: {
        isHovering: {
            type: Boolean,
        default:
            !1
        },
        nodeNameDimensions: {
            type: Object,
            required: !0
        },
        portPositions: {
            type: Object,
            required: !0
        },
        isConnectorHovering: {
            type: Boolean,
        default:
            !1
        },
        allowedActions: {
            type: Object,
        default:
            () => ({})
        }
    },
    computed: {
        portBarBottom() {
            const e = this.portPositions,
            t = e.in[e.in.length - 1],
            n = e.out[e.out.length - 1],
            r = t?.[1] || 0,
            o = n?.[1] || 0;
            return Math.max(r, o) + this.$shapes.portSize / 2
        },
        hoverSize() {
            let e = {
                top: -this.$shapes.nodeHoverMargin[0],
                left: -this.$shapes.nodeHoverMargin[1],
                bottom: this.$shapes.nodeSize + this.$shapes.nodeHoverMargin[2],
                right: this.$shapes.nodeSize + this.$shapes.nodeHoverMargin[3]
            };
            if (e.top -= this.nodeNameDimensions.height, this.isHovering) {
                let t = 0;
                "canOpenDialog" in this.allowedActions && (t += this.$shapes.nodeActionBarButtonSpread),
                "canOpenView" in this.allowedActions && (t += this.$shapes.nodeActionBarButtonSpread),
                e.left -= t / 2,
                e.right += t / 2
            }
            if (this.isConnectorHovering || this.isHovering) {
                const t = this.$shapes.nodeHoverPortBottomMargin;
                e.bottom = Math.max(this.portBarBottom + t, e.bottom)
            }
            return {
                y: e.top,
                x: e.left,
                width: e.right - e.left,
                height: e.bottom - e.top
            }
        }
    }
};
function ftt(e, t, n, r, o, i) {
    return _(),
    O("g", null, [Ye(e.$slots, "default", {
                hoverSize: i.hoverSize
            })])
}
const htt = te(dtt, [["render", ftt]]);
const ptt = {
    components: {
        NodeActionBar: Let,
        NodeTorso: DZe,
        NodeState: itt,
        NodeName: cet,
        NodeLabel: ket,
        NodePorts: EJe,
        NodeSelectionPlane: utt,
        NodeDecorators: NQe,
        ConnectorSnappingProvider: kF,
        NodeHoverSizeProvider: htt
    },
    provide() {
        return {
            anchorPoint: this.position
        }
    },
    props: {
        id: {
            type: String,
            required: !0
        },
        kind: {
            type: String,
            required: !0,
            validator: e => ["node", "metanode", "component"].includes(e)
        },
        inPorts: {
            type: Array,
            required: !0
        },
        outPorts: {
            type: Array,
            required: !0
        },
        position: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        },
        annotation: {
            type: Object,
        default:
            null
        },
        name: {
            type: String,
        default:
            null
        },
        type: {
            type: String,
        default:
            null
        },
        icon: {
            type: String,
        default:
            null,
            validator: e => e.startsWith("data:image/")
        },
        link: {
            type: Object,
        default:
            null
        },
        state: {
            type: Object,
            validator(e) {
                return Reflect.has(e, "executionState") || Object.keys(e).length === 0
            },
        default:
            null
        },
        allowedActions: {
            type: Object,
        default:
            () => ({})
        },
        executionInfo: {
            type: Object,
            validator(e) {
                return !e || Reflect.has(e, "streamable") || e.jobManager || e.icon
            },
        default:
            null
        },
        loopInfo: {
            type: Object,
        default:
            () => ({
                allowedActions: {}
            })
        },
        portGroups: {
            type: Object,
        default:
            null
        },
        isReexecutable: {
            type: Boolean,
        default:
            !1
        },
        isLocked: {
            type: Boolean,
        default:
            null
        }
    },
    data() {
        return {
            isHovering: !1,
            selectionPreview: null,
            nameDimensions: {
                width: 0,
                height: 20
            },
            portPositions: {
                in: [],
                out: []
            },
            isDraggedOver: !1,
            dragTarget: null,
            latestTap: 0
        }
    },
    computed: {
        ...ut("application", {
            projectId: "activeProjectId",
            permissions: "permissions"
        }),
        ...ut("workflow", ["isDragging"]),
        ...zt("selection", ["isNodeSelected", "singleSelectedNode"]),
        ...zt("workflow", ["isWritable"]),
        ...zt("application", ["hasAnnotationModeEnabled"]),
        selectionWidth() {
            return this.nameDimensions.width + this.$shapes.nodeNameHorizontalMargin * 2
        },
        insideStreamingComponent() {
            return typeof this.executionInfo?.streamable < "u"
        },
        allNodeActions() {
            return {
                ...this.allowedActions,
                ...this.loopInfo.allowedActions
            }
        },
        isSelected() {
            return this.isNodeSelected(this.id)
        },
        isSingleSelected() {
            return this.singleSelectedNode?.id === this.id
        },
        showSelectionPlane() {
            return this.selectionPreview === null ? this.isSelected && !this.isDragging : this.isSelected && this.selectionPreview === "hide" ? !1 : this.selectionPreview === "show" || this.isSelected
        },
        isExecuting() {
            return this.state?.executionState === "EXECUTING"
        },
        isEditable() {
            return this.isWritable && !this.link
        },
        isContainerNode() {
            return ["metanode", "component"].includes(this.kind)
        },
        actionBarPosition() {
            return {
                x: this.position.x + this.$shapes.nodeSize / 2,
                y: this.position.y - this.$shapes.nodeSelectionPadding[0] - this.nameDimensions.height
            }
        }
    },
    methods: {
        ...Er("workflow", ["openNodeConfiguration", "replaceNode", "resetDragState"]),
        ...Er("selection", ["selectNode", "deselectAllObjects", "deselectNode"]),
        ...eg("workflow", ["setIsDragging"]),
        onLeaveHoverArea(e) {
            const t = this.$refs.actionbar?.$el;
            if (t?.contains(e.relatedTarget))
                return;
            const n = this.$refs.hoverContainer?.$el,
            r = document.elementFromPoint(e.clientX, e.clientY);
            n?.contains(r) || t?.contains(r) || (this.isHovering = !1)
        },
        onLeftDoubleClick(e) {
            this.kind === "metanode" || this.kind === "component" && (e.ctrlKey || e.metaKey) ? this.isLocked ? consola.trace(`${this.kind} cannot be opened because it's locked`) : this.$router.push({
                name: zo.WorkflowPage,
                params: {
                    projectId: this.projectId,
                    workflowId: this.id
                }
            }) : this.allowedActions?.canOpenDialog && this.permissions.canConfigureNodes && this.openNodeConfiguration(this.id)
        },
        onLeftMouseClick(e) {
            if (this.isDragging)
                return;
            const t = ga();
            e.shiftKey || e[t] ? this.isNodeSelected(this.id) ? this.deselectNode(this.id) : this.selectNode(this.id) : (this.deselectAllObjects(), this.selectNode(this.id))
        },
        onContextMenu(e) {
            if (this.isDragging)
                return;
            const t = ga();
            e.shiftKey || e[t] ? this.selectNode(this.id) : this.isNodeSelected(this.id) || (this.deselectAllObjects(), this.selectNode(this.id)),
            this.$store.dispatch("application/toggleContextMenu", {
                event: e
            })
        },
        onTorsoDragEnter(e) {
            this.isWritable && [...e.dataTransfer.types].includes(Ff) && (this.isDraggedOver = !0, this.dragTarget = e.target)
        },
        onTorsoDragLeave(e) {
            this.dragTarget === e.target && (this.isDraggedOver = !1, this.dragTarget = null)
        },
        onTorsoDragDrop(e) {
            if (!this.isWritable)
                return;
            const t = JSON.parse(e.dataTransfer.getData(Ff));
            this.replaceNode({
                targetNodeId: this.id,
                nodeFactory: t
            }),
            this.isDraggedOver = !1,
            this.dragTarget = null
        },
        onNodeDragggingEnter(e) {
            e.detail.isNodeConnected || (e.preventDefault(), this.isDraggedOver = !0)
        },
        onNodeDragggingLeave() {
            this.isDraggedOver = !1
        },
        async onNodeDragggingEnd(e) {
            this.id !== e.detail.id && await this.replaceNode({
                targetNodeId: this.id,
                replacementNodeId: e.detail.id
            }),
            this.isDraggedOver = !1,
            this.resetDragState()
        },
        setSelectionPreview(e) {
            this.selectionPreview = e === "clear" ? null : e
        }
    }
}, mtt = ["onConnectorEnter", "onConnectorLeave", "onConnectorMove", "onConnectorDrop"], gtt = ["width", "height", "x", "y"], vtt = ["width", "height"];
function ytt(e, t, n, r, o, i) {
    const s = B("NodeActionBar"),
    a = B("Portal"),
    l = B("NodeSelectionPlane"),
    c = B("NodeLabel"),
    u = B("NodeTorso"),
    f = B("NodeDecorators"),
    p = B("NodeState"),
    m = B("NodePorts"),
    v = B("NodeName"),
    y = B("NodeHoverSizeProvider"),
    b = B("ConnectorSnappingProvider");
    return _(),
    H(b, {
        id: n.id,
        position: n.position,
        "port-groups": n.portGroups,
        "port-positions": o.portPositions
    }, {
    default:
        oe(({
                connectionForbidden: w,
                isConnectionSource: k,
                targetPort: C,
                connectorHover: x,
                on: {
                    onConnectorEnter: S,
                    onConnectorLeave: T,
                    onConnectorMove: E,
                    onConnectorDrop: M
                }
            }) => [P("g", Bt(e.$attrs, {
                        class: {
                            "connection-forbidden": w && !k
                        }
                    }), [z(a, {
                            to: "node-actions"
                        }, {
                        default:
                            oe(() => [!i.insideStreamingComponent && o.isHovering && !e.isDragging ? (_(), H(s, Bt({
                                                key: 0,
                                                ref: "actionbar"
                                            }, i.allNodeActions, {
                                                transform: `translate(${i.actionBarPosition.x}, ${i.actionBarPosition.y})`,
                                                "node-id": n.id,
                                                "is-node-selected": i.isSelected,
                                                "node-kind": n.kind,
                                                onMouseleave: i.onLeaveHoverArea
                                            }), null, 16, ["transform", "node-id", "is-node-selected", "node-kind", "onMouseleave"])) : J("", !0)]),
                            _: 1
                        }), z(a, {
                            to: "node-select"
                        }, {
                        default:
                            oe(() => [Cn(z(l, {
                                            position: n.position,
                                            width: i.selectionWidth,
                                            "extra-height": o.nameDimensions.height,
                                            kind: n.kind
                                        }, null, 8, ["position", "width", "extra-height", "kind"]), [[Kn, i.showSelectionPlane && !e.hasAnnotationModeEnabled]])]),
                            _: 1
                        }), z(c, {
                            value: n.annotation ? n.annotation.text.value : "",
                            annotation: n.annotation,
                            editable: e.isWritable,
                            kind: n.kind,
                            "node-id": n.id,
                            "node-position": n.position,
                            "number-of-ports": Math.max(n.inPorts.length, n.outPorts.length),
                            onContextmenu: ve(i.onContextMenu, ["prevent"])
                        }, null, 8, ["value", "annotation", "editable", "kind", "node-id", "node-position", "number-of-ports", "onContextmenu"]), P("g", {
                            ref: "hoverContainer",
                            class: "hover-container",
                            onPointerdown: t[5] || (t[5] = ve((...N) => i.onContextMenu && i.onContextMenu(...N), ["right"])),
                            onConnectorEnter: S,
                            onConnectorLeave: T,
                            onConnectorMove: N => E(N, {
                                inPorts: n.inPorts,
                                outPorts: n.outPorts
                            }),
                            onConnectorDrop: M,
                            onMouseenter: t[6] || (t[6] = N => o.isHovering = !0),
                            onMouseleave: t[7] || (t[7] = (...N) => i.onLeaveHoverArea && i.onLeaveHoverArea(...N))
                        }, [z(y, {
                                    "is-hovering": o.isHovering,
                                    "node-name-dimensions": o.nameDimensions,
                                    "is-connector-hovering": x,
                                    "allowed-actions": n.allowedActions,
                                    "port-positions": o.portPositions
                                }, {
                                default:
                                    oe(({
                                            hoverSize: N
                                        }) => [P("g", {
                                                class: "mouse-clickable",
                                                onClick: t[0] || (t[0] = ve((...F) => i.onLeftMouseClick && i.onLeftMouseClick(...F), ["left"]))
                                            }, [P("rect", {
                                                        class: he(["hover-area", {
                                                                    "is-dragging": e.isDragging
                                                                }
                                                            ]),
                                                        width: N.width,
                                                        height: N.height,
                                                        x: N.x,
                                                        y: N.y,
                                                        "data-hide-in-workflow-preview": ""
                                                    }, null, 10, gtt), P("g", {
                                                        class: he(["node-torso-wrapper", {
                                                                    grabbable: e.isWritable,
                                                                    "is-dragging": e.isDragging
                                                                }
                                                            ])
                                                    }, [P("rect", {
                                                                class: he({
                                                                    grabbable: e.isWritable,
                                                                    "is-dragging": e.isDragging
                                                                }),
                                                                width: e.$shapes.nodeSize,
                                                                height: n.kind === "metanode" ? e.$shapes.nodeSize : e.$shapes.nodeSize + 20,
                                                                x: 0,
                                                                y: 0,
                                                                "data-hide-in-workflow-preview": "",
                                                                fill: "transparent"
                                                            }, null, 10, vtt), z(u, {
                                                                type: n.type,
                                                                kind: n.kind,
                                                                icon: n.icon,
                                                                "is-dragged-over": o.isDraggedOver,
                                                                "execution-state": n.state && n.state.executionState,
                                                                class: he(["node-torso", {
                                                                            hover: o.isHovering
                                                                        }
                                                                    ]),
                                                                filter: o.isHovering && "url(#node-torso-shadow)",
                                                                onDblclick: ve(i.onLeftDoubleClick, ["left"]),
                                                                onDragenter: i.onTorsoDragEnter,
                                                                onDragleave: i.onTorsoDragLeave,
                                                                onDrop: ve(i.onTorsoDragDrop, ["stop"]),
                                                                onNodeDraggingEnter: i.onNodeDragggingEnter,
                                                                onNodeDraggingLeave: ve(i.onNodeDragggingLeave, ["prevent"]),
                                                                onNodeDraggingEnd: ve(i.onNodeDragggingEnd, ["prevent"])
                                                            }, null, 8, ["type", "kind", "icon", "is-dragged-over", "execution-state", "class", "filter", "onDblclick", "onDragenter", "onDragleave", "onDrop", "onNodeDraggingEnter", "onNodeDraggingLeave", "onNodeDraggingEnd"]), z(f, wu(tc(e.$props)), null, 16), n.kind !== "metanode" ? (_(), H(p, Bt({
                                                                        key: 0
                                                                    }, n.state, {
                                                                        class: ["node-state", {
                                                                                hover: o.isHovering
                                                                            }
                                                                        ],
                                                                        "loop-status": n.loopInfo.status,
                                                                        transform: `translate(0, ${e.$shapes.nodeSize + e.$shapes.nodeStatusMarginTop})`
                                                                    }), null, 16, ["class", "loop-status", "transform"])) : J("", !0)], 2)]), z(m, {
                                                "node-id": n.id,
                                                "node-kind": n.kind,
                                                "in-ports": n.inPorts,
                                                "out-ports": n.outPorts,
                                                "target-port": C,
                                                "is-editable": i.isEditable && !i.isExecuting,
                                                "port-groups": n.portGroups,
                                                hover: o.isHovering,
                                                "connector-hover": x,
                                                "is-single-selected": i.isSingleSelected,
                                                onUpdatePortPositions: t[1] || (t[1] = F => o.portPositions = F)
                                            }, null, 8, ["node-id", "node-kind", "in-ports", "out-ports", "target-port", "is-editable", "port-groups", "hover", "connector-hover", "is-single-selected"]), z(v, {
                                                "node-id": n.id,
                                                "node-position": n.position,
                                                value: n.name,
                                                editable: i.isEditable && i.isContainerNode,
                                                onClick: ve(i.onLeftMouseClick, ["left"]),
                                                onPointerdown: ve(i.onContextMenu, ["right"]),
                                                onWidthChange: t[2] || (t[2] = F => o.nameDimensions.width = F),
                                                onHeightChange: t[3] || (t[3] = F => o.nameDimensions.height = F),
                                                onEditStart: t[4] || (t[4] = F => o.isHovering = !1),
                                                onConnectorEnter: ve(S, ["stop"]),
                                                onConnectorLeave: ve(T, ["stop"])
                                            }, null, 8, ["node-id", "node-position", "value", "editable", "onClick", "onPointerdown", "onConnectorEnter", "onConnectorLeave"])]),
                                    _: 2
                                }, 1032, ["is-hovering", "node-name-dimensions", "is-connector-hovering", "allowed-actions", "port-positions"])], 40, mtt)], 16)]),
        _: 1
    }, 8, ["id", "position", "port-groups", "port-positions"])
}
const wtt = te(ptt, [["render", ytt], ["__scopeId", "data-v-38421aad"]]), btt = ["transform", "data-node-id"], _tt = ".node-torso-wrapper", ktt = Fe({
    __name: "MoveableNodeContainer",
    props: {
        id: {},
        position: {}
    },
    setup(e) {
        const t = e;
        let n = null;
        const r = po(),
        o = ne(() => r.state.workflow.movePreviewDelta),
        i = ne(() => r.state.workflow.hasAbortedDrag),
        s = ne(() => r.state.workflow.isDragging),
        a = ne(() => r.getters["workflow/isNodeConnected"]),
        l = ne(() => r.getters["workflow/getNodeById"]),
        c = ne(() => r.getters["selection/isNodeSelected"]),
        u = De(null),
        f = ne(() => ({
                    x: t.position.x + o.value.x,
                    y: t.position.y + o.value.y
                })),
        p = ne(() => c.value(t.id) ? f.value : t.position);
        Ht(ca(t, "position"), () => {
            s.value && r.dispatch("workflow/resetDragState")
        }, {
            deep: !0
        });
        const m = ne(() => u.value.querySelector(_tt)),
        v = () => {
            r.dispatch("workflow/moveObjects")
        },
        y = (C, x) => {
            const S = document.elementFromPoint(C, x);
            if (S && m.value.contains(S))
                return;
            const T = S && n === S;
            if (!T && n && n.dispatchEvent(new CustomEvent("node-dragging-leave", {
                        bubbles: !0,
                        cancelable: !0
                    })), !T && S) {
                const {
                    inPorts: E = [],
                    outPorts: M = []
                } = l.value(t.id);
                n = S.dispatchEvent(new CustomEvent("node-dragging-enter", {
                            bubbles: !0,
                            cancelable: !0,
                            detail: {
                                isNodeConnected: a.value(t.id),
                                inPorts: E,
                                outPorts: M
                            }
                        })) ? null : S
            }
        },
        b = ca(t, "position"), {
            createPointerDownHandler: w
        } = Yw({
            objectElement: m,
            onMoveStartCallback: () => {
                c.value(t.id) || r.dispatch("selection/deselectAllObjects"),
                r.dispatch("selection/selectNode", t.id)
            },
            onMoveCallback: C => {
                y(C.clientX, C.clientY)
            },
            onMoveEndCallback: C => i.value && n ? (n.dispatchEvent(new CustomEvent("node-dragging-leave", {
                        bubbles: !0,
                        cancelable: !0
                    })), n = null, Promise.resolve(!1)) : n ? (n.dispatchEvent(new CustomEvent("node-dragging-end", {
                        bubbles: !0,
                        cancelable: !0,
                        detail: {
                            id: t.id,
                            clientX: C.clientX,
                            clientY: C.clientY,
                            onError: v
                        }
                    })), n = null, Promise.resolve(!1)) : Promise.resolve(!0)
        }),
        k = w(b);
        return lg({
            group: "OBJECT_DRAG",
            alwaysActive: !0,
            onEscape: () => {
                s.value && r.dispatch("workflow/abortDrag")
            }
        }),
        (C, x) => (_(), O("g", {
                ref_key: "container",
                ref: u,
                transform: `translate(${p.value.x}, ${p.value.y})`,
                "data-node-id": C.id,
                class: he([{
                            dragging: s.value && c.value(C.id)
                        }
                    ]),
                onPointerdown: x[0] || (x[0] = ve((...S) => ke(k) && ke(k)(...S), ["left"]))
            }, [Ye(C.$slots, "default", {
                        position: p.value
                    }, void 0, !0)], 42, btt))
    }
});
const xtt = te(ktt, [["__scopeId", "data-v-d297ce39"]]), Stt = e => e.replaceAll(/(\r\n|\r|\n)/g, "<br />"), Ctt = ["nw", "n", "ne", "w", "e", "sw", "s", "se"], PF = {
    width: 0,
    height: 0
}, Da = e => e > PF.height, Na = e => e > PF.width, Cd = ({
    startX: e,
    moveX: t,
    origWidth: n
}, r = !1) => r ? t - (e + n) : t - e, Id = ({
    startY: e,
    moveY: t,
    origHeight: n
}, r = !1) => r ? t - (e + n) : t - e, Itt = {
    nw: (e, {
        startX: t,
        startY: n,
        moveX: r,
        moveY: o,
        origWidth: i,
        origHeight: s
    }) => {
        const a = Cd({
            startX: t,
            moveX: r,
            origWidth: i
        }),
        l = Id({
            startY: n,
            moveY: o,
            origHeight: s
        }),
        c = i + a * -1,
        u = s + l * -1;
        return {
            ...e,
            x: Na(c) ? r : e.x,
            width: Na(c) ? c : e.width,
            y: Da(u) ? o : e.y,
            height: Da(u) ? u : e.height
        }
    },
    n: (e, {
        moveY: t,
        origHeight: n,
        startY: r
    }) => {
        const o = Id({
            startY: r,
            moveY: t,
            origHeight: n
        }),
        i = n + o * -1;
        return {
            ...e,
            y: Da(i) ? t : e.y,
            height: Da(i) ? i : e.height
        }
    },
    ne: (e, {
        startX: t,
        startY: n,
        moveX: r,
        moveY: o,
        origHeight: i,
        origWidth: s
    }) => {
        const a = Cd({
            startX: t,
            moveX: r,
            origWidth: s
        }, !0),
        l = Id({
            startY: n,
            moveY: o,
            origHeight: i
        }),
        c = s + a,
        u = i + l * -1;
        return {
            ...e,
            width: Na(c) ? c : e.width,
            y: Da(u) ? o : e.y,
            height: Da(u) ? u : e.height
        }
    },
    e: (e, {
        startX: t,
        moveX: n,
        origWidth: r
    }) => {
        const o = Cd({
            startX: t,
            moveX: n,
            origWidth: r
        }, !0),
        i = r + o;
        return {
            ...e,
            width: Na(i) ? i : e.width
        }
    },
    se: (e, {
        startX: t,
        startY: n,
        origWidth: r,
        origHeight: o,
        moveX: i,
        moveY: s
    }) => {
        const a = Cd({
            startX: t,
            moveX: i,
            origWidth: r
        }, !0),
        l = Id({
            startY: n,
            moveY: s,
            origHeight: o
        }, !0),
        c = r + a,
        u = o + l;
        return {
            ...e,
            width: Na(c) ? c : e.width,
            height: Da(u) ? u : e.height
        }
    },
    s: (e, {
        startY: t,
        origHeight: n,
        moveY: r
    }) => {
        const o = Id({
            startY: t,
            moveY: r,
            origHeight: n
        }, !0),
        i = n + o;
        return {
            ...e,
            height: Da(i) ? i : e.height
        }
    },
    sw: (e, {
        startX: t,
        startY: n,
        moveX: r,
        moveY: o,
        origWidth: i,
        origHeight: s
    }) => {
        const a = Cd({
            startX: t,
            moveX: r,
            origWidth: i
        }),
        l = Id({
            startY: n,
            moveY: o,
            origHeight: s
        }, !0),
        c = i + a * -1,
        u = s + l;
        return {
            ...e,
            x: Na(c) ? r : e.x,
            width: Na(c) ? c : e.width,
            height: Da(u) ? u : e.height
        }
    },
    w: (e, {
        startX: t,
        moveX: n,
        origWidth: r
    }) => {
        const o = Cd({
            startX: t,
            moveX: n,
            origWidth: r
        }),
        i = r + o * -1;
        return {
            ...e,
            x: Na(i) ? n : e.x,
            width: Na(i) ? i : e.width
        }
    }
}, Gx = e => ({
    x: br.utils.snapToGrid(e.x),
    y: br.utils.snapToGrid(e.y),
    width: br.utils.snapToGrid(e.width),
    height: br.utils.snapToGrid(e.height)
}), Ttt = (e, {
    startX: t,
    startY: n,
    moveX: r,
    moveY: o,
    origWidth: i,
    origHeight: s,
    direction: a
}) => {
    const l = () => e,
    u = (Itt[a] || l)(e, {
        moveX: r,
        moveY: o,
        startX: t,
        startY: n,
        origWidth: i,
        origHeight: s
    });
    return Gx(u)
}, Mtt = e => {
    const {
        bounds: t,
        direction: n
    } = e,
    r = e.controlSize / 2, {
        x: o,
        y: i,
        width: s,
        height: a
    } = t,
    l = (v, y = 1) => v - r * y,
    c = () => l(o + s / 2),
    u = () => l(i + a / 2),
    f = () => l(o + s - e.controlSize, -1),
    p = () => l(i + a - e.controlSize, -1);
    return {
        nw: {
            x: l(o),
            y: l(i)
        },
        n: {
            x: c(),
            y: l(i)
        },
        ne: {
            x: f(),
            y: l(i)
        },
        e: {
            x: f(),
            y: u()
        },
        se: {
            x: f(),
            y: p()
        },
        s: {
            x: c(),
            y: p()
        },
        sw: {
            x: l(o),
            y: p()
        },
        w: {
            x: l(o),
            y: u()
        }
    }
    [n] || {
        x: o,
        y: i
    }
}, Uv = 1, Ptt = Fe({
    props: {
        showTransformControls: {
            type: Boolean,
        default:
            !1
        },
        initialValue: {
            type: Object,
        default:
            () => ({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            })
        },
        showSelection: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: {
        transformEnd: e => !0
    },
    data() {
        return {
            directions: Ctt,
            innerValue: Gx(this.initialValue)
        }
    },
    computed: {
        ...zt("canvas", ["screenToCanvasCoordinates"]),
        ...ut("canvas", ["zoomFactor"]),
        controlSize() {
            return Math.max(6 / 1.4, 6 / this.zoomFactor)
        },
        transformRectStrokeWidth() {
            return Math.max(this.$shapes.selectedAnnotationStrokeWidth / 2, this.$shapes.selectedAnnotationStrokeWidth / this.zoomFactor)
        },
        valueWithOffset() {
            return {
                width: this.innerValue.width + Uv * 2,
                height: this.innerValue.height + Uv * 2,
                x: this.innerValue.x - Uv,
                y: this.innerValue.y - Uv
            }
        }
    },
    watch: {
        initialValue: {
            handler() {
                this.innerValue = Gx(this.initialValue)
            },
            immediate: !0,
            deep: !0
        }
    },
    methods: {
        onStart({
            direction: e,
            event: t
        }) {
            const n = this.innerValue.x,
            r = this.innerValue.y,
            o = this.innerValue.width,
            i = this.innerValue.height;
            t.target.setPointerCapture(t.pointerId);
            const s = l => {
                l.stopPropagation(),
                l.preventDefault();
                const {
                    clientX: c,
                    clientY: u
                } = l,
                [f, p] = this.screenToCanvasCoordinates([c, u]);
                this.innerValue = Ttt(this.innerValue, {
                    startX: n,
                    startY: r,
                    origWidth: o,
                    origHeight: i,
                    moveX: f,
                    moveY: p,
                    direction: e
                })
            },
            a = () => {
                window.removeEventListener("mousemove", s),
                window.removeEventListener("mouseup", a)
            };
            window.addEventListener("mousemove", s),
            window.addEventListener("mouseup", a)
        },
        onStop(e) {
            e.target.releasePointerCapture(e.pointerId),
            this.$emit("transformEnd", {
                bounds: this.innerValue
            })
        },
        getControlPosition(e) {
            return Mtt({
                bounds: this.valueWithOffset,
                direction: e,
                controlSize: this.controlSize
            })
        },
        getCursorStyle(e) {
            return {
                cursor: `${e}-resize`
            }
        }
    }
});
const Ett = {
    class: "transform"
}, Ott = ["width", "height", "x", "y", "stroke", "stroke-width", "rx"], $tt = ["x", "y", "width", "height", "onPointerdown"];
function Att(e, t, n, r, o, i) {
    const s = B("Portal");
    return _(),
    O("g", Ett, [Ye(e.$slots, "default", {
                transformedBounds: e.innerValue
            }, void 0, !0), z(s, {
                to: "annotation-transform"
            }, {
            default:
                oe(() => [e.showSelection ? (_(), O("rect", {
                                key: 0,
                                width: e.valueWithOffset.width,
                                height: e.valueWithOffset.height,
                                x: e.valueWithOffset.x,
                                y: e.valueWithOffset.y,
                                class: "transform-box",
                                stroke: e.$colors.selection.activeBorder,
                                "stroke-width": e.transformRectStrokeWidth,
                                rx: e.$shapes.selectedItemBorderRadius
                            }, null, 8, Ott)) : J("", !0), e.showTransformControls ? (_(!0), O(Le, {
                                key: 1
                            }, $t(e.directions, a => (_(), O("rect", {
                                            key: a,
                                            x: e.getControlPosition(a).x,
                                            y: e.getControlPosition(a).y,
                                            width: e.controlSize,
                                            height: e.controlSize,
                                            class: he(["transform-control", `transform-control-${a}`]),
                                            style: Yt(e.getCursorStyle(a)),
                                            onClick: t[0] || (t[0] = ve(() => {}, ["stop"])),
                                            onPointerdown: ve(l => e.onStart({
                                                    event: l,
                                                    direction: a
                                                }), ["self", "stop"]),
                                            onPointerup: t[1] || (t[1] = ve((...l) => e.onStop && e.onStop(...l), ["self", "stop"]))
                                        }, null, 46, $tt))), 128)) : J("", !0)]),
                _: 1
            })])
}
const Dtt = te(Ptt, [["render", Att], ["__scopeId", "data-v-1dc9112b"]]), Ntt = Fe({
    props: {
        annotation: {
            type: Object,
            required: !0
        }
    },
    emits: ["editStart"],
    computed: {
        styledText() {
            const {
                styleRanges: e,
                text: t
            } = this.annotation, {
                textRanges: n,
                isValid: r
            } = IF(e, t.value || "");
            return r || consola.warn(`Invalid styleRanges: ${JSON.stringify(e)}. Using default style.`),
            n
        },
        annotationWrapperStyle() {
            const {
                backgroundColor: e,
                borderColor: t,
                defaultFontSize: n = 12,
                borderWidth: r = 2,
                textAlign: o = "left"
            } = this.annotation;
            return {
                fontSize: `${n * this.$shapes.annotationsFontSizePointToPixelFactor}px`,
                border: `${r}px solid ${t}`,
                background: e,
                textAlign: o,
                padding: `${this.$shapes.workflowAnnotationPadding}px`,
                width: "100%",
                height: "100%"
            }
        }
    },
    methods: {
        getFontSize(e) {
            return e.fontSize ? `${e.fontSize * this.$shapes.annotationsFontSizePointToPixelFactor}px` : null
        }
    }
});
function Rtt(e, t, n, r, o, i) {
    return _(),
    O("div", {
        style: Yt(e.annotationWrapperStyle),
        onDblclick: t[0] || (t[0] = s => e.$emit("editStart"))
    }, [(_(!0), O(Le, null, $t(e.styledText, (s, a) => (_(), O("span", {
                                key: `text-${a}`,
                                style: Yt({
                                    fontSize: e.getFontSize(s),
                                    color: s.color,
                                    fontWeight: s.bold ? "bold" : null,
                                    fontStyle: s.italic ? "italic" : null
                                })
                            }, Re(s.text), 5))), 128))], 36)
}
const Ltt = te(Ntt, [["render", Rtt], ["__scopeId", "data-v-a15383eb"]]);
function Kr(e) {
    this.content = e
}
Kr.prototype = {
    constructor: Kr,
    find: function (e) {
        for (var t = 0; t < this.content.length; t += 2)
            if (this.content[t] === e)
                return t;
        return -1
    },
    get: function (e) {
        var t = this.find(e);
        return t == -1 ? void 0 : this.content[t + 1]
    },
    update: function (e, t, n) {
        var r = n && n != e ? this.remove(n) : this,
        o = r.find(e),
        i = r.content.slice();
        return o == -1 ? i.push(n || e, t) : (i[o + 1] = t, n && (i[o] = n)),
        new Kr(i)
    },
    remove: function (e) {
        var t = this.find(e);
        if (t == -1)
            return this;
        var n = this.content.slice();
        return n.splice(t, 2),
        new Kr(n)
    },
    addToStart: function (e, t) {
        return new Kr([e, t].concat(this.remove(e).content))
    },
    addToEnd: function (e, t) {
        var n = this.remove(e).content.slice();
        return n.push(e, t),
        new Kr(n)
    },
    addBefore: function (e, t, n) {
        var r = this.remove(t),
        o = r.content.slice(),
        i = r.find(e);
        return o.splice(i == -1 ? o.length : i, 0, t, n),
        new Kr(o)
    },
    forEach: function (e) {
        for (var t = 0; t < this.content.length; t += 2)
            e(this.content[t], this.content[t + 1])
    },
    prepend: function (e) {
        return e = Kr.from(e),
        e.size ? new Kr(e.content.concat(this.subtract(e).content)) : this
    },
    append: function (e) {
        return e = Kr.from(e),
        e.size ? new Kr(this.subtract(e).content.concat(e.content)) : this
    },
    subtract: function (e) {
        var t = this;
        e = Kr.from(e);
        for (var n = 0; n < e.content.length; n += 2)
            t = t.remove(e.content[n]);
        return t
    },
    toObject: function () {
        var e = {};
        return this.forEach(function (t, n) {
            e[t] = n
        }),
        e
    },
    get size() {
        return this.content.length >> 1
    }
};
Kr.from = function (e) {
    if (e instanceof Kr)
        return e;
    var t = [];
    if (e)
        for (var n in e)
            t.push(n, e[n]);
    return new Kr(t)
};
function EF(e, t, n) {
    for (let r = 0; ; r++) {
        if (r == e.childCount || r == t.childCount)
            return e.childCount == t.childCount ? null : n;
        let o = e.child(r),
        i = t.child(r);
        if (o == i) {
            n += o.nodeSize;
            continue
        }
        if (!o.sameMarkup(i))
            return n;
        if (o.isText && o.text != i.text) {
            for (let s = 0; o.text[s] == i.text[s]; s++)
                n++;
            return n
        }
        if (o.content.size || i.content.size) {
            let s = EF(o.content, i.content, n + 1);
            if (s != null)
                return s
        }
        n += o.nodeSize
    }
}
function OF(e, t, n, r) {
    for (let o = e.childCount, i = t.childCount; ; ) {
        if (o == 0 || i == 0)
            return o == i ? null : {
                a: n,
                b: r
            };
        let s = e.child(--o),
        a = t.child(--i),
        l = s.nodeSize;
        if (s == a) {
            n -= l,
            r -= l;
            continue
        }
        if (!s.sameMarkup(a))
            return {
                a: n,
                b: r
            };
        if (s.isText && s.text != a.text) {
            let c = 0,
            u = Math.min(s.text.length, a.text.length);
            for (; c < u && s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1]; )
                c++, n--, r--;
            return {
                a: n,
                b: r
            }
        }
        if (s.content.size || a.content.size) {
            let c = OF(s.content, a.content, n - 1, r - 1);
            if (c)
                return c
        }
        n -= l,
        r -= l
    }
}
class Ne {
    constructor(t, n) {
        if (this.content = t, this.size = n || 0, n == null)
            for (let r = 0; r < t.length; r++)
                this.size += t[r].nodeSize
    }
    nodesBetween(t, n, r, o = 0, i) {
        for (let s = 0, a = 0; a < n; s++) {
            let l = this.content[s],
            c = a + l.nodeSize;
            if (c > t && r(l, o + a, i || null, s) !== !1 && l.content.size) {
                let u = a + 1;
                l.nodesBetween(Math.max(0, t - u), Math.min(l.content.size, n - u), r, o + u)
            }
            a = c
        }
    }
    descendants(t) {
        this.nodesBetween(0, this.size, t)
    }
    textBetween(t, n, r, o) {
        let i = "",
        s = !0;
        return this.nodesBetween(t, n, (a, l) => {
            a.isText ? (i += a.text.slice(Math.max(t, l) - l, n - l), s = !r) : a.isLeaf ? (o ? i += typeof o == "function" ? o(a) : o : a.type.spec.leafText && (i += a.type.spec.leafText(a)), s = !r) : !s && a.isBlock && (i += r, s = !0)
        }, 0),
        i
    }
    append(t) {
        if (!t.size)
            return this;
        if (!this.size)
            return t;
        let n = this.lastChild,
        r = t.firstChild,
        o = this.content.slice(),
        i = 0;
        for (n.isText && n.sameMarkup(r) && (o[o.length - 1] = n.withText(n.text + r.text), i = 1); i < t.content.length; i++)
            o.push(t.content[i]);
        return new Ne(o, this.size + t.size)
    }
    cut(t, n = this.size) {
        if (t == 0 && n == this.size)
            return this;
        let r = [],
        o = 0;
        if (n > t)
            for (let i = 0, s = 0; s < n; i++) {
                let a = this.content[i],
                l = s + a.nodeSize;
                l > t && ((s < t || l > n) && (a.isText ? a = a.cut(Math.max(0, t - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, t - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), o += a.nodeSize),
                s = l
            }
        return new Ne(r, o)
    }
    cutByIndex(t, n) {
        return t == n ? Ne.empty : t == 0 && n == this.content.length ? this : new Ne(this.content.slice(t, n))
    }
    replaceChild(t, n) {
        let r = this.content[t];
        if (r == n)
            return this;
        let o = this.content.slice(),
        i = this.size + n.nodeSize - r.nodeSize;
        return o[t] = n,
        new Ne(o, i)
    }
    addToStart(t) {
        return new Ne([t].concat(this.content), this.size + t.nodeSize)
    }
    addToEnd(t) {
        return new Ne(this.content.concat(t), this.size + t.nodeSize)
    }
    eq(t) {
        if (this.content.length != t.content.length)
            return !1;
        for (let n = 0; n < this.content.length; n++)
            if (!this.content[n].eq(t.content[n]))
                return !1;
        return !0
    }
    get firstChild() {
        return this.content.length ? this.content[0] : null
    }
    get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null
    }
    get childCount() {
        return this.content.length
    }
    child(t) {
        let n = this.content[t];
        if (!n)
            throw new RangeError("Index " + t + " out of range for " + this);
        return n
    }
    maybeChild(t) {
        return this.content[t] || null
    }
    forEach(t) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
            let o = this.content[n];
            t(o, r, n),
            r += o.nodeSize
        }
    }
    findDiffStart(t, n = 0) {
        return EF(this, t, n)
    }
    findDiffEnd(t, n = this.size, r = t.size) {
        return OF(this, t, n, r)
    }
    findIndex(t, n = -1) {
        if (t == 0)
            return qv(0, t);
        if (t == this.size)
            return qv(this.content.length, t);
        if (t > this.size || t < 0)
            throw new RangeError(`Position ${t} outside of fragment (${this})`);
        for (let r = 0, o = 0; ; r++) {
            let i = this.child(r),
            s = o + i.nodeSize;
            if (s >= t)
                return s == t || n > 0 ? qv(r + 1, s) : qv(r, o);
            o = s
        }
    }
    toString() {
        return "<" + this.toStringInner() + ">"
    }
    toStringInner() {
        return this.content.join(", ")
    }
    toJSON() {
        return this.content.length ? this.content.map(t => t.toJSON()) : null
    }
    static fromJSON(t, n) {
        if (!n)
            return Ne.empty;
        if (!Array.isArray(n))
            throw new RangeError("Invalid input for Fragment.fromJSON");
        return new Ne(n.map(t.nodeFromJSON))
    }
    static fromArray(t) {
        if (!t.length)
            return Ne.empty;
        let n,
        r = 0;
        for (let o = 0; o < t.length; o++) {
            let i = t[o];
            r += i.nodeSize,
            o && i.isText && t[o - 1].sameMarkup(i) ? (n || (n = t.slice(0, o)), n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)) : n && n.push(i)
        }
        return new Ne(n || t, r)
    }
    static from(t) {
        if (!t)
            return Ne.empty;
        if (t instanceof Ne)
            return t;
        if (Array.isArray(t))
            return this.fromArray(t);
        if (t.attrs)
            return new Ne([t], t.nodeSize);
        throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
    }
}
Ne.empty = new Ne([], 0);
const N2 = {
    index: 0,
    offset: 0
};
function qv(e, t) {
    return N2.index = e,
    N2.offset = t,
    N2
}
function Gy(e, t) {
    if (e === t)
        return !0;
    if (!(e && typeof e == "object") || !(t && typeof t == "object"))
        return !1;
    let n = Array.isArray(e);
    if (Array.isArray(t) != n)
        return !1;
    if (n) {
        if (e.length != t.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (!Gy(e[r], t[r]))
                return !1
    } else {
        for (let r in e)
            if (!(r in t) || !Gy(e[r], t[r]))
                return !1;
        for (let r in t)
            if (!(r in e))
                return !1
    }
    return !0
}
let Sn = class Xx {
    constructor(t, n) {
        this.type = t,
        this.attrs = n
    }
    addToSet(t) {
        let n,
        r = !1;
        for (let o = 0; o < t.length; o++) {
            let i = t[o];
            if (this.eq(i))
                return t;
            if (this.type.excludes(i.type))
                n || (n = t.slice(0, o));
            else {
                if (i.type.excludes(this.type))
                    return t;
                !r && i.type.rank > this.type.rank && (n || (n = t.slice(0, o)), n.push(this), r = !0),
                n && n.push(i)
            }
        }
        return n || (n = t.slice()),
        r || n.push(this),
        n
    }
    removeFromSet(t) {
        for (let n = 0; n < t.length; n++)
            if (this.eq(t[n]))
                return t.slice(0, n).concat(t.slice(n + 1));
        return t
    }
    isInSet(t) {
        for (let n = 0; n < t.length; n++)
            if (this.eq(t[n]))
                return !0;
        return !1
    }
    eq(t) {
        return this == t || this.type == t.type && Gy(this.attrs, t.attrs)
    }
    toJSON() {
        let t = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            t.attrs = this.attrs;
            break
        }
        return t
    }
    static fromJSON(t, n) {
        if (!n)
            throw new RangeError("Invalid input for Mark.fromJSON");
        let r = t.marks[n.type];
        if (!r)
            throw new RangeError(`There is no mark type ${n.type} in this schema`);
        return r.create(n.attrs)
    }
    static sameSet(t, n) {
        if (t == n)
            return !0;
        if (t.length != n.length)
            return !1;
        for (let r = 0; r < t.length; r++)
            if (!t[r].eq(n[r]))
                return !1;
        return !0
    }
    static setFrom(t) {
        if (!t || Array.isArray(t) && t.length == 0)
            return Xx.none;
        if (t instanceof Xx)
            return [t];
        let n = t.slice();
        return n.sort((r, o) => r.type.rank - o.type.rank),
        n
    }
};
Sn.none = [];
class Xy extends Error {}
class nt {
    constructor(t, n, r) {
        this.content = t,
        this.openStart = n,
        this.openEnd = r
    }
    get size() {
        return this.content.size - this.openStart - this.openEnd
    }
    insertAt(t, n) {
        let r = AF(this.content, t + this.openStart, n);
        return r && new nt(r, this.openStart, this.openEnd)
    }
    removeBetween(t, n) {
        return new nt($F(this.content, t + this.openStart, n + this.openStart), this.openStart, this.openEnd)
    }
    eq(t) {
        return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd
    }
    toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")"
    }
    toJSON() {
        if (!this.content.size)
            return null;
        let t = {
            content: this.content.toJSON()
        };
        return this.openStart > 0 && (t.openStart = this.openStart),
        this.openEnd > 0 && (t.openEnd = this.openEnd),
        t
    }
    static fromJSON(t, n) {
        if (!n)
            return nt.empty;
        let r = n.openStart || 0,
        o = n.openEnd || 0;
        if (typeof r != "number" || typeof o != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
        return new nt(Ne.fromJSON(t, n.content), r, o)
    }
    static maxOpen(t, n = !0) {
        let r = 0,
        o = 0;
        for (let i = t.firstChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.firstChild)
            r++;
        for (let i = t.lastChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.lastChild)
            o++;
        return new nt(t, r, o)
    }
}
nt.empty = new nt(Ne.empty, 0, 0);
function $F(e, t, n) {
    let {
        index: r,
        offset: o
    } = e.findIndex(t),
    i = e.maybeChild(r), {
        index: s,
        offset: a
    } = e.findIndex(n);
    if (o == t || i.isText) {
        if (a != n && !e.child(s).isText)
            throw new RangeError("Removing non-flat range");
        return e.cut(0, t).append(e.cut(n))
    }
    if (r != s)
        throw new RangeError("Removing non-flat range");
    return e.replaceChild(r, i.copy($F(i.content, t - o - 1, n - o - 1)))
}
function AF(e, t, n, r) {
    let {
        index: o,
        offset: i
    } = e.findIndex(t),
    s = e.maybeChild(o);
    if (i == t || s.isText)
        return r && !r.canReplace(o, o, n) ? null : e.cut(0, t).append(n).append(e.cut(t));
    let a = AF(s.content, t - i - 1, n);
    return a && e.replaceChild(o, s.copy(a))
}
function Btt(e, t, n) {
    if (n.openStart > e.depth)
        throw new Xy("Inserted content deeper than insertion position");
    if (e.depth - n.openStart != t.depth - n.openEnd)
        throw new Xy("Inconsistent open depths");
    return DF(e, t, n, 0)
}
function DF(e, t, n, r) {
    let o = e.index(r),
    i = e.node(r);
    if (o == t.index(r) && r < e.depth - n.openStart) {
        let s = DF(e, t, n, r + 1);
        return i.copy(i.content.replaceChild(o, s))
    } else if (n.content.size)
        if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
            let s = e.parent,
            a = s.content;
            return pu(s, a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset)))
        } else {
            let {
                start: s,
                end: a
            } = Vtt(n, e);
            return pu(i, RF(e, s, a, t, r))
        }
    else
        return pu(i, Jy(e, t, r))
}
function NF(e, t) {
    if (!t.type.compatibleContent(e.type))
        throw new Xy("Cannot join " + t.type.name + " onto " + e.type.name)
}
function Jx(e, t, n) {
    let r = e.node(n);
    return NF(r, t.node(n)),
    r
}
function hu(e, t) {
    let n = t.length - 1;
    n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e)
}
function Wp(e, t, n, r) {
    let o = (t || e).node(n),
    i = 0,
    s = t ? t.index(n) : o.childCount;
    e && (i = e.index(n), e.depth > n ? i++ : e.textOffset && (hu(e.nodeAfter, r), i++));
    for (let a = i; a < s; a++)
        hu(o.child(a), r);
    t && t.depth == n && t.textOffset && hu(t.nodeBefore, r)
}
function pu(e, t) {
    return e.type.checkContent(t),
    e.copy(t)
}
function RF(e, t, n, r, o) {
    let i = e.depth > o && Jx(e, t, o + 1),
    s = r.depth > o && Jx(n, r, o + 1),
    a = [];
    return Wp(null, e, o, a),
    i && s && t.index(o) == n.index(o) ? (NF(i, s), hu(pu(i, RF(e, t, n, r, o + 1)), a)) : (i && hu(pu(i, Jy(e, t, o + 1)), a), Wp(t, n, o, a), s && hu(pu(s, Jy(n, r, o + 1)), a)),
    Wp(r, null, o, a),
    new Ne(a)
}
function Jy(e, t, n) {
    let r = [];
    if (Wp(null, e, n, r), e.depth > n) {
        let o = Jx(e, t, n + 1);
        hu(pu(o, Jy(e, t, n + 1)), r)
    }
    return Wp(t, null, n, r),
    new Ne(r)
}
function Vtt(e, t) {
    let n = t.depth - e.openStart,
    o = t.node(n).copy(e.content);
    for (let i = n - 1; i >= 0; i--)
        o = t.node(i).copy(Ne.from(o));
    return {
        start: o.resolveNoCache(e.openStart + n),
        end: o.resolveNoCache(o.content.size - e.openEnd - n)
    }
}
class Bm {
    constructor(t, n, r) {
        this.pos = t,
        this.path = n,
        this.parentOffset = r,
        this.depth = n.length / 3 - 1
    }
    resolveDepth(t) {
        return t == null ? this.depth : t < 0 ? this.depth + t : t
    }
    get parent() {
        return this.node(this.depth)
    }
    get doc() {
        return this.node(0)
    }
    node(t) {
        return this.path[this.resolveDepth(t) * 3]
    }
    index(t) {
        return this.path[this.resolveDepth(t) * 3 + 1]
    }
    indexAfter(t) {
        return t = this.resolveDepth(t),
        this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1)
    }
    start(t) {
        return t = this.resolveDepth(t),
        t == 0 ? 0 : this.path[t * 3 - 1] + 1
    }
    end(t) {
        return t = this.resolveDepth(t),
        this.start(t) + this.node(t).content.size
    }
    before(t) {
        if (t = this.resolveDepth(t), !t)
            throw new RangeError("There is no position before the top-level node");
        return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1]
    }
    after(t) {
        if (t = this.resolveDepth(t), !t)
            throw new RangeError("There is no position after the top-level node");
        return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize
    }
    get textOffset() {
        return this.pos - this.path[this.path.length - 1]
    }
    get nodeAfter() {
        let t = this.parent,
        n = this.index(this.depth);
        if (n == t.childCount)
            return null;
        let r = this.pos - this.path[this.path.length - 1],
        o = t.child(n);
        return r ? t.child(n).cut(r) : o
    }
    get nodeBefore() {
        let t = this.index(this.depth),
        n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1)
    }
    posAtIndex(t, n) {
        n = this.resolveDepth(n);
        let r = this.path[n * 3],
        o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let i = 0; i < t; i++)
            o += r.child(i).nodeSize;
        return o
    }
    marks() {
        let t = this.parent,
        n = this.index();
        if (t.content.size == 0)
            return Sn.none;
        if (this.textOffset)
            return t.child(n).marks;
        let r = t.maybeChild(n - 1),
        o = t.maybeChild(n);
        if (!r) {
            let a = r;
            r = o,
            o = a
        }
        let i = r.marks;
        for (var s = 0; s < i.length; s++)
            i[s].type.spec.inclusive === !1 && (!o || !i[s].isInSet(o.marks)) && (i = i[s--].removeFromSet(i));
        return i
    }
    marksAcross(t) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
            return null;
        let r = n.marks,
        o = t.parent.maybeChild(t.index());
        for (var i = 0; i < r.length; i++)
            r[i].type.spec.inclusive === !1 && (!o || !r[i].isInSet(o.marks)) && (r = r[i--].removeFromSet(r));
        return r
    }
    sharedDepth(t) {
        for (let n = this.depth; n > 0; n--)
            if (this.start(n) <= t && this.end(n) >= t)
                return n;
        return 0
    }
    blockRange(t = this, n) {
        if (t.pos < this.pos)
            return t.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); r >= 0; r--)
            if (t.pos <= this.end(r) && (!n || n(this.node(r))))
                return new Zy(this, t, r);
        return null
    }
    sameParent(t) {
        return this.pos - this.parentOffset == t.pos - t.parentOffset
    }
    max(t) {
        return t.pos > this.pos ? t : this
    }
    min(t) {
        return t.pos < this.pos ? t : this
    }
    toString() {
        let t = "";
        for (let n = 1; n <= this.depth; n++)
            t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return t + ":" + this.parentOffset
    }
    static resolve(t, n) {
        if (!(n >= 0 && n <= t.content.size))
            throw new RangeError("Position " + n + " out of range");
        let r = [],
        o = 0,
        i = n;
        for (let s = t; ; ) {
            let {
                index: a,
                offset: l
            } = s.content.findIndex(i),
            c = i - l;
            if (r.push(s, a, o + l), !c || (s = s.child(a), s.isText))
                break;
            i = c - 1,
            o += l + 1
        }
        return new Bm(n, r, i)
    }
    static resolveCached(t, n) {
        for (let o = 0; o < R2.length; o++) {
            let i = R2[o];
            if (i.pos == n && i.doc == t)
                return i
        }
        let r = R2[L2] = Bm.resolve(t, n);
        return L2 = (L2 + 1) % Ftt,
        r
    }
}
let R2 = [], L2 = 0, Ftt = 12;
class Zy {
    constructor(t, n, r) {
        this.$from = t,
        this.$to = n,
        this.depth = r
    }
    get start() {
        return this.$from.before(this.depth + 1)
    }
    get end() {
        return this.$to.after(this.depth + 1)
    }
    get parent() {
        return this.$from.node(this.depth)
    }
    get startIndex() {
        return this.$from.index(this.depth)
    }
    get endIndex() {
        return this.$to.indexAfter(this.depth)
    }
}
const jtt = Object.create(null);
let mu = class Zx {
    constructor(t, n, r, o = Sn.none) {
        this.type = t,
        this.attrs = n,
        this.marks = o,
        this.content = r || Ne.empty
    }
    get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size
    }
    get childCount() {
        return this.content.childCount
    }
    child(t) {
        return this.content.child(t)
    }
    maybeChild(t) {
        return this.content.maybeChild(t)
    }
    forEach(t) {
        this.content.forEach(t)
    }
    nodesBetween(t, n, r, o = 0) {
        this.content.nodesBetween(t, n, r, o, this)
    }
    descendants(t) {
        this.nodesBetween(0, this.content.size, t)
    }
    get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "")
    }
    textBetween(t, n, r, o) {
        return this.content.textBetween(t, n, r, o)
    }
    get firstChild() {
        return this.content.firstChild
    }
    get lastChild() {
        return this.content.lastChild
    }
    eq(t) {
        return this == t || this.sameMarkup(t) && this.content.eq(t.content)
    }
    sameMarkup(t) {
        return this.hasMarkup(t.type, t.attrs, t.marks)
    }
    hasMarkup(t, n, r) {
        return this.type == t && Gy(this.attrs, n || t.defaultAttrs || jtt) && Sn.sameSet(this.marks, r || Sn.none)
    }
    copy(t = null) {
        return t == this.content ? this : new Zx(this.type, this.attrs, t, this.marks)
    }
    mark(t) {
        return t == this.marks ? this : new Zx(this.type, this.attrs, this.content, t)
    }
    cut(t, n = this.content.size) {
        return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n))
    }
    slice(t, n = this.content.size, r = !1) {
        if (t == n)
            return nt.empty;
        let o = this.resolve(t),
        i = this.resolve(n),
        s = r ? 0 : o.sharedDepth(n),
        a = o.start(s),
        c = o.node(s).content.cut(o.pos - a, i.pos - a);
        return new nt(c, o.depth - s, i.depth - s)
    }
    replace(t, n, r) {
        return Btt(this.resolve(t), this.resolve(n), r)
    }
    nodeAt(t) {
        for (let n = this; ; ) {
            let {
                index: r,
                offset: o
            } = n.content.findIndex(t);
            if (n = n.maybeChild(r), !n)
                return null;
            if (o == t || n.isText)
                return n;
            t -= o + 1
        }
    }
    childAfter(t) {
        let {
            index: n,
            offset: r
        } = this.content.findIndex(t);
        return {
            node: this.content.maybeChild(n),
            index: n,
            offset: r
        }
    }
    childBefore(t) {
        if (t == 0)
            return {
                node: null,
                index: 0,
                offset: 0
            };
        let {
            index: n,
            offset: r
        } = this.content.findIndex(t);
        if (r < t)
            return {
                node: this.content.child(n),
                index: n,
                offset: r
            };
        let o = this.content.child(n - 1);
        return {
            node: o,
            index: n - 1,
            offset: r - o.nodeSize
        }
    }
    resolve(t) {
        return Bm.resolveCached(this, t)
    }
    resolveNoCache(t) {
        return Bm.resolve(this, t)
    }
    rangeHasMark(t, n, r) {
        let o = !1;
        return n > t && this.nodesBetween(t, n, i => (r.isInSet(i.marks) && (o = !0), !o)),
        o
    }
    get isBlock() {
        return this.type.isBlock
    }
    get isTextblock() {
        return this.type.isTextblock
    }
    get inlineContent() {
        return this.type.inlineContent
    }
    get isInline() {
        return this.type.isInline
    }
    get isText() {
        return this.type.isText
    }
    get isLeaf() {
        return this.type.isLeaf
    }
    get isAtom() {
        return this.type.isAtom
    }
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        let t = this.type.name;
        return this.content.size && (t += "(" + this.content.toStringInner() + ")"),
        LF(this.marks, t)
    }
    contentMatchAt(t) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, t);
        if (!n)
            throw new Error("Called contentMatchAt on a node with invalid content");
        return n
    }
    canReplace(t, n, r = Ne.empty, o = 0, i = r.childCount) {
        let s = this.contentMatchAt(t).matchFragment(r, o, i),
        a = s && s.matchFragment(this.content, n);
        if (!a || !a.validEnd)
            return !1;
        for (let l = o; l < i; l++)
            if (!this.type.allowsMarks(r.child(l).marks))
                return !1;
        return !0
    }
    canReplaceWith(t, n, r, o) {
        if (o && !this.type.allowsMarks(o))
            return !1;
        let i = this.contentMatchAt(t).matchType(r),
        s = i && i.matchFragment(this.content, n);
        return s ? s.validEnd : !1
    }
    canAppend(t) {
        return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type)
    }
    check() {
        this.type.checkContent(this.content);
        let t = Sn.none;
        for (let n = 0; n < this.marks.length; n++)
            t = this.marks[n].addToSet(t);
        if (!Sn.sameSet(t, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(n => n.type.name)}`);
        this.content.forEach(n => n.check())
    }
    toJSON() {
        let t = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            t.attrs = this.attrs;
            break
        }
        return this.content.size && (t.content = this.content.toJSON()),
        this.marks.length && (t.marks = this.marks.map(n => n.toJSON())),
        t
    }
    static fromJSON(t, n) {
        if (!n)
            throw new RangeError("Invalid input for Node.fromJSON");
        let r = null;
        if (n.marks) {
            if (!Array.isArray(n.marks))
                throw new RangeError("Invalid mark data for Node.fromJSON");
            r = n.marks.map(t.markFromJSON)
        }
        if (n.type == "text") {
            if (typeof n.text != "string")
                throw new RangeError("Invalid text node in JSON");
            return t.text(n.text, r)
        }
        let o = Ne.fromJSON(t, n.content);
        return t.nodeType(n.type).create(n.attrs, o, r)
    }
};
mu.prototype.text = void 0;
class Qy extends mu {
    constructor(t, n, r, o) {
        if (super(t, n, null, o), !r)
            throw new RangeError("Empty text nodes are not allowed");
        this.text = r
    }
    toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : LF(this.marks, JSON.stringify(this.text))
    }
    get textContent() {
        return this.text
    }
    textBetween(t, n) {
        return this.text.slice(t, n)
    }
    get nodeSize() {
        return this.text.length
    }
    mark(t) {
        return t == this.marks ? this : new Qy(this.type, this.attrs, this.text, t)
    }
    withText(t) {
        return t == this.text ? this : new Qy(this.type, this.attrs, t, this.marks)
    }
    cut(t = 0, n = this.text.length) {
        return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n))
    }
    eq(t) {
        return this.sameMarkup(t) && this.text == t.text
    }
    toJSON() {
        let t = super.toJSON();
        return t.text = this.text,
        t
    }
}
function LF(e, t) {
    for (let n = e.length - 1; n >= 0; n--)
        t = e[n].type.name + "(" + t + ")";
    return t
}
class Ru {
    constructor(t) {
        this.validEnd = t,
        this.next = [],
        this.wrapCache = []
    }
    static parse(t, n) {
        let r = new Wtt(t, n);
        if (r.next == null)
            return Ru.empty;
        let o = BF(r);
        r.next && r.err("Unexpected trailing text");
        let i = Gtt(Ktt(o));
        return Xtt(i, r),
        i
    }
    matchType(t) {
        for (let n = 0; n < this.next.length; n++)
            if (this.next[n].type == t)
                return this.next[n].next;
        return null
    }
    matchFragment(t, n = 0, r = t.childCount) {
        let o = this;
        for (let i = n; o && i < r; i++)
            o = o.matchType(t.child(i).type);
        return o
    }
    get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline
    }
    get defaultType() {
        for (let t = 0; t < this.next.length; t++) {
            let {
                type: n
            } = this.next[t];
            if (!(n.isText || n.hasRequiredAttrs()))
                return n
        }
        return null
    }
    compatible(t) {
        for (let n = 0; n < this.next.length; n++)
            for (let r = 0; r < t.next.length; r++)
                if (this.next[n].type == t.next[r].type)
                    return !0;
        return !1
    }
    fillBefore(t, n = !1, r = 0) {
        let o = [this];
        function i(s, a) {
            let l = s.matchFragment(t, r);
            if (l && (!n || l.validEnd))
                return Ne.from(a.map(c => c.createAndFill()));
            for (let c = 0; c < s.next.length; c++) {
                let {
                    type: u,
                    next: f
                } = s.next[c];
                if (!(u.isText || u.hasRequiredAttrs()) && o.indexOf(f) == -1) {
                    o.push(f);
                    let p = i(f, a.concat(u));
                    if (p)
                        return p
                }
            }
            return null
        }
        return i(this, [])
    }
    findWrapping(t) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
            if (this.wrapCache[r] == t)
                return this.wrapCache[r + 1];
        let n = this.computeWrapping(t);
        return this.wrapCache.push(t, n),
        n
    }
    computeWrapping(t) {
        let n = Object.create(null),
        r = [{
                match: this,
                type: null,
                via: null
            }
        ];
        for (; r.length; ) {
            let o = r.shift(),
            i = o.match;
            if (i.matchType(t)) {
                let s = [];
                for (let a = o; a.type; a = a.via)
                    s.push(a.type);
                return s.reverse()
            }
            for (let s = 0; s < i.next.length; s++) {
                let {
                    type: a,
                    next: l
                } = i.next[s];
                !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!o.type || l.validEnd) && (r.push({
                        match: a.contentMatch,
                        type: a,
                        via: o
                    }), n[a.name] = !0)
            }
        }
        return null
    }
    get edgeCount() {
        return this.next.length
    }
    edge(t) {
        if (t >= this.next.length)
            throw new RangeError(`There's no ${t}th edge in this content match`);
        return this.next[t]
    }
    toString() {
        let t = [];
        function n(r) {
            t.push(r);
            for (let o = 0; o < r.next.length; o++)
                t.indexOf(r.next[o].next) == -1 && n(r.next[o].next)
        }
        return n(this),
        t.map((r, o) => {
            let i = o + (r.validEnd ? "*" : " ") + " ";
            for (let s = 0; s < r.next.length; s++)
                i += (s ? ", " : "") + r.next[s].type.name + "->" + t.indexOf(r.next[s].next);
            return i
        }).join(`
`)
    }
}
Ru.empty = new Ru(!0);
class Wtt {
    constructor(t, n) {
        this.string = t,
        this.nodeTypes = n,
        this.inline = null,
        this.pos = 0,
        this.tokens = t.split(/\s*(?=\b|\W|$)/),
        this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
        this.tokens[0] == "" && this.tokens.shift()
    }
    get next() {
        return this.tokens[this.pos]
    }
    eat(t) {
        return this.next == t && (this.pos++ || !0)
    }
    err(t) {
        throw new SyntaxError(t + " (in content expression '" + this.string + "')")
    }
}
function BF(e) {
    let t = [];
    do
        t.push(ztt(e));
    while (e.eat("|"));
    return t.length == 1 ? t[0] : {
        type: "choice",
        exprs: t
    }
}
function ztt(e) {
    let t = [];
    do
        t.push(Htt(e));
    while (e.next && e.next != ")" && e.next != "|");
    return t.length == 1 ? t[0] : {
        type: "seq",
        exprs: t
    }
}
function Htt(e) {
    let t = Ytt(e);
    for (; ; )
        if (e.eat("+"))
            t = {
                type: "plus",
                expr: t
            };
        else if (e.eat("*"))
            t = {
                type: "star",
                expr: t
            };
        else if (e.eat("?"))
            t = {
                type: "opt",
                expr: t
            };
        else if (e.eat("{"))
            t = Utt(e, t);
        else
            break;
    return t
}
function AN(e) {
    /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
    let t = Number(e.next);
    return e.pos++,
    t
}
function Utt(e, t) {
    let n = AN(e),
    r = n;
    return e.eat(",") && (e.next != "}" ? r = AN(e) : r = -1),
    e.eat("}") || e.err("Unclosed braced range"), {
        type: "range",
        min: n,
        max: r,
        expr: t
    }
}
function qtt(e, t) {
    let n = e.nodeTypes,
    r = n[t];
    if (r)
        return [r];
    let o = [];
    for (let i in n) {
        let s = n[i];
        s.groups.indexOf(t) > -1 && o.push(s)
    }
    return o.length == 0 && e.err("No node type or group '" + t + "' found"),
    o
}
function Ytt(e) {
    if (e.eat("(")) {
        let t = BF(e);
        return e.eat(")") || e.err("Missing closing paren"),
        t
    } else if (/\W/.test(e.next))
        e.err("Unexpected token '" + e.next + "'");
    else {
        let t = qtt(e, e.next).map(n => (e.inline == null ? e.inline = n.isInline : e.inline != n.isInline && e.err("Mixing inline and block content"), {
                    type: "name",
                    value: n
                }));
        return e.pos++,
        t.length == 1 ? t[0] : {
            type: "choice",
            exprs: t
        }
    }
}
function Ktt(e) {
    let t = [[]];
    return o(i(e, 0), n()),
    t;
    function n() {
        return t.push([]) - 1
    }
    function r(s, a, l) {
        let c = {
            term: l,
            to: a
        };
        return t[s].push(c),
        c
    }
    function o(s, a) {
        s.forEach(l => l.to = a)
    }
    function i(s, a) {
        if (s.type == "choice")
            return s.exprs.reduce((l, c) => l.concat(i(c, a)), []);
        if (s.type == "seq")
            for (let l = 0; ; l++) {
                let c = i(s.exprs[l], a);
                if (l == s.exprs.length - 1)
                    return c;
                o(c, a = n())
            }
        else if (s.type == "star") {
            let l = n();
            return r(a, l),
            o(i(s.expr, l), l),
            [r(l)]
        } else if (s.type == "plus") {
            let l = n();
            return o(i(s.expr, a), l),
            o(i(s.expr, l), l),
            [r(l)]
        } else {
            if (s.type == "opt")
                return [r(a)].concat(i(s.expr, a));
            if (s.type == "range") {
                let l = a;
                for (let c = 0; c < s.min; c++) {
                    let u = n();
                    o(i(s.expr, l), u),
                    l = u
                }
                if (s.max == -1)
                    o(i(s.expr, l), l);
                else
                    for (let c = s.min; c < s.max; c++) {
                        let u = n();
                        r(l, u),
                        o(i(s.expr, l), u),
                        l = u
                    }
                return [r(l)]
            } else {
                if (s.type == "name")
                    return [r(a, void 0, s.value)];
                throw new Error("Unknown expr type")
            }
        }
    }
}
function VF(e, t) {
    return t - e
}
function DN(e, t) {
    let n = [];
    return r(t),
    n.sort(VF);
    function r(o) {
        let i = e[o];
        if (i.length == 1 && !i[0].term)
            return r(i[0].to);
        n.push(o);
        for (let s = 0; s < i.length; s++) {
            let {
                term: a,
                to: l
            } = i[s];
            !a && n.indexOf(l) == -1 && r(l)
        }
    }
}
function Gtt(e) {
    let t = Object.create(null);
    return n(DN(e, 0));
    function n(r) {
        let o = [];
        r.forEach(s => {
            e[s].forEach(({
                    term: a,
                    to: l
                }) => {
                if (!a)
                    return;
                let c;
                for (let u = 0; u < o.length; u++)
                    o[u][0] == a && (c = o[u][1]);
                DN(e, l).forEach(u => {
                    c || o.push([a, c = []]),
                    c.indexOf(u) == -1 && c.push(u)
                })
            })
        });
        let i = t[r.join(",")] = new Ru(r.indexOf(e.length - 1) > -1);
        for (let s = 0; s < o.length; s++) {
            let a = o[s][1].sort(VF);
            i.next.push({
                type: o[s][0],
                next: t[a.join(",")] || n(a)
            })
        }
        return i
    }
}
function Xtt(e, t) {
    for (let n = 0, r = [e]; n < r.length; n++) {
        let o = r[n],
        i = !o.validEnd,
        s = [];
        for (let a = 0; a < o.next.length; a++) {
            let {
                type: l,
                next: c
            } = o.next[a];
            s.push(l.name),
            i && !(l.isText || l.hasRequiredAttrs()) && (i = !1),
            r.indexOf(c) == -1 && r.push(c)
        }
        i && t.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)")
    }
}
function FF(e) {
    let t = Object.create(null);
    for (let n in e) {
        let r = e[n];
        if (!r.hasDefault)
            return null;
        t[n] = r.default
    }
    return t
}
function jF(e, t) {
    let n = Object.create(null);
    for (let r in e) {
        let o = t && t[r];
        if (o === void 0) {
            let i = e[r];
            if (i.hasDefault)
                o = i.default;
            else
                throw new RangeError("No value supplied for attribute " + r)
        }
        n[r] = o
    }
    return n
}
function WF(e) {
    let t = Object.create(null);
    if (e)
        for (let n in e)
            t[n] = new Jtt(e[n]);
    return t
}
let NN = class zF {
    constructor(t, n, r) {
        this.name = t,
        this.schema = n,
        this.spec = r,
        this.markSet = null,
        this.groups = r.group ? r.group.split(" ") : [],
        this.attrs = WF(r.attrs),
        this.defaultAttrs = FF(this.attrs),
        this.contentMatch = null,
        this.inlineContent = null,
        this.isBlock = !(r.inline || t == "text"),
        this.isText = t == "text"
    }
    get isInline() {
        return !this.isBlock
    }
    get isTextblock() {
        return this.isBlock && this.inlineContent
    }
    get isLeaf() {
        return this.contentMatch == Ru.empty
    }
    get isAtom() {
        return this.isLeaf || !!this.spec.atom
    }
    get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
    }
    hasRequiredAttrs() {
        for (let t in this.attrs)
            if (this.attrs[t].isRequired)
                return !0;
        return !1
    }
    compatibleContent(t) {
        return this == t || this.contentMatch.compatible(t.contentMatch)
    }
    computeAttrs(t) {
        return !t && this.defaultAttrs ? this.defaultAttrs : jF(this.attrs, t)
    }
    create(t = null, n, r) {
        if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
        return new mu(this, this.computeAttrs(t), Ne.from(n), Sn.setFrom(r))
    }
    createChecked(t = null, n, r) {
        return n = Ne.from(n),
        this.checkContent(n),
        new mu(this, this.computeAttrs(t), n, Sn.setFrom(r))
    }
    createAndFill(t = null, n, r) {
        if (t = this.computeAttrs(t), n = Ne.from(n), n.size) {
            let s = this.contentMatch.fillBefore(n);
            if (!s)
                return null;
            n = s.append(n)
        }
        let o = this.contentMatch.matchFragment(n),
        i = o && o.fillBefore(Ne.empty, !0);
        return i ? new mu(this, t, n.append(i), Sn.setFrom(r)) : null
    }
    validContent(t) {
        let n = this.contentMatch.matchFragment(t);
        if (!n || !n.validEnd)
            return !1;
        for (let r = 0; r < t.childCount; r++)
            if (!this.allowsMarks(t.child(r).marks))
                return !1;
        return !0
    }
    checkContent(t) {
        if (!this.validContent(t))
            throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`)
    }
    allowsMarkType(t) {
        return this.markSet == null || this.markSet.indexOf(t) > -1
    }
    allowsMarks(t) {
        if (this.markSet == null)
            return !0;
        for (let n = 0; n < t.length; n++)
            if (!this.allowsMarkType(t[n].type))
                return !1;
        return !0
    }
    allowedMarks(t) {
        if (this.markSet == null)
            return t;
        let n;
        for (let r = 0; r < t.length; r++)
            this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r));
        return n ? n.length ? n : Sn.none : t
    }
    static compile(t, n) {
        let r = Object.create(null);
        t.forEach((i, s) => r[i] = new zF(i, n, s));
        let o = n.spec.topNode || "doc";
        if (!r[o])
            throw new RangeError("Schema is missing its top node type ('" + o + "')");
        if (!r.text)
            throw new RangeError("Every schema needs a 'text' type");
        for (let i in r.text.attrs)
            throw new RangeError("The text node type should not have attributes");
        return r
    }
};
class Jtt {
    constructor(t) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(t, "default"),
        this.default = t.default
    }
    get isRequired() {
        return !this.hasDefault
    }
}
class Jw {
    constructor(t, n, r, o) {
        this.name = t,
        this.rank = n,
        this.schema = r,
        this.spec = o,
        this.attrs = WF(o.attrs),
        this.excluded = null;
        let i = FF(this.attrs);
        this.instance = i ? new Sn(this, i) : null
    }
    create(t = null) {
        return !t && this.instance ? this.instance : new Sn(this, jF(this.attrs, t))
    }
    static compile(t, n) {
        let r = Object.create(null),
        o = 0;
        return t.forEach((i, s) => r[i] = new Jw(i, o++, n, s)),
        r
    }
    removeFromSet(t) {
        for (var n = 0; n < t.length; n++)
            t[n].type == this && (t = t.slice(0, n).concat(t.slice(n + 1)), n--);
        return t
    }
    isInSet(t) {
        for (let n = 0; n < t.length; n++)
            if (t[n].type == this)
                return t[n]
    }
    excludes(t) {
        return this.excluded.indexOf(t) > -1
    }
}
class Ztt {
    constructor(t) {
        this.cached = Object.create(null);
        let n = this.spec = {};
        for (let o in t)
            n[o] = t[o];
        n.nodes = Kr.from(t.nodes),
        n.marks = Kr.from(t.marks || {}),
        this.nodes = NN.compile(this.spec.nodes, this),
        this.marks = Jw.compile(this.spec.marks, this);
        let r = Object.create(null);
        for (let o in this.nodes) {
            if (o in this.marks)
                throw new RangeError(o + " can not be both a node and a mark");
            let i = this.nodes[o],
            s = i.spec.content || "",
            a = i.spec.marks;
            i.contentMatch = r[s] || (r[s] = Ru.parse(s, this.nodes)),
            i.inlineContent = i.contentMatch.inlineContent,
            i.markSet = a == "_" ? null : a ? RN(this, a.split(" ")) : a == "" || !i.inlineContent ? [] : null
        }
        for (let o in this.marks) {
            let i = this.marks[o],
            s = i.spec.excludes;
            i.excluded = s == null ? [i] : s == "" ? [] : RN(this, s.split(" "))
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this),
        this.markFromJSON = this.markFromJSON.bind(this),
        this.topNodeType = this.nodes[this.spec.topNode || "doc"],
        this.cached.wrappings = Object.create(null)
    }
    node(t, n = null, r, o) {
        if (typeof t == "string")
            t = this.nodeType(t);
        else if (t instanceof NN) {
            if (t.schema != this)
                throw new RangeError("Node type from different schema used (" + t.name + ")")
        } else
            throw new RangeError("Invalid node type: " + t);
        return t.createChecked(n, r, o)
    }
    text(t, n) {
        let r = this.nodes.text;
        return new Qy(r, r.defaultAttrs, t, Sn.setFrom(n))
    }
    mark(t, n) {
        return typeof t == "string" && (t = this.marks[t]),
        t.create(n)
    }
    nodeFromJSON(t) {
        return mu.fromJSON(this, t)
    }
    markFromJSON(t) {
        return Sn.fromJSON(this, t)
    }
    nodeType(t) {
        let n = this.nodes[t];
        if (!n)
            throw new RangeError("Unknown node type: " + t);
        return n
    }
}
function RN(e, t) {
    let n = [];
    for (let r = 0; r < t.length; r++) {
        let o = t[r],
        i = e.marks[o],
        s = i;
        if (i)
            n.push(i);
        else
            for (let a in e.marks) {
                let l = e.marks[a];
                (o == "_" || l.spec.group && l.spec.group.split(" ").indexOf(o) > -1) && n.push(s = l)
            }
        if (!s)
            throw new SyntaxError("Unknown mark type: '" + t[r] + "'")
    }
    return n
}
let vT = class Qx {
    constructor(t, n) {
        this.schema = t,
        this.rules = n,
        this.tags = [],
        this.styles = [],
        n.forEach(r => {
            r.tag ? this.tags.push(r) : r.style && this.styles.push(r)
        }),
        this.normalizeLists = !this.tags.some(r => {
            if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
                return !1;
            let o = t.nodes[r.node];
            return o.contentMatch.matchType(o)
        })
    }
    parse(t, n = {}) {
        let r = new BN(this, n, !1);
        return r.addAll(t, n.from, n.to),
        r.finish()
    }
    parseSlice(t, n = {}) {
        let r = new BN(this, n, !0);
        return r.addAll(t, n.from, n.to),
        nt.maxOpen(r.finish())
    }
    matchTag(t, n, r) {
        for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
            let i = this.tags[o];
            if (tnt(t, i.tag) && (i.namespace === void 0 || t.namespaceURI == i.namespace) && (!i.context || n.matchesContext(i.context))) {
                if (i.getAttrs) {
                    let s = i.getAttrs(t);
                    if (s === !1)
                        continue;
                    i.attrs = s || void 0
                }
                return i
            }
        }
    }
    matchStyle(t, n, r, o) {
        for (let i = o ? this.styles.indexOf(o) + 1 : 0; i < this.styles.length; i++) {
            let s = this.styles[i],
            a = s.style;
            if (!(a.indexOf(t) != 0 || s.context && !r.matchesContext(s.context) || a.length > t.length && (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))) {
                if (s.getAttrs) {
                    let l = s.getAttrs(n);
                    if (l === !1)
                        continue;
                    s.attrs = l || void 0
                }
                return s
            }
        }
    }
    static schemaRules(t) {
        let n = [];
        function r(o) {
            let i = o.priority == null ? 50 : o.priority,
            s = 0;
            for (; s < n.length; s++) {
                let a = n[s];
                if ((a.priority == null ? 50 : a.priority) < i)
                    break
            }
            n.splice(s, 0, o)
        }
        for (let o in t.marks) {
            let i = t.marks[o].spec.parseDOM;
            i && i.forEach(s => {
                r(s = VN(s)),
                s.mark || s.ignore || s.clearMark || (s.mark = o)
            })
        }
        for (let o in t.nodes) {
            let i = t.nodes[o].spec.parseDOM;
            i && i.forEach(s => {
                r(s = VN(s)),
                s.node || s.ignore || s.mark || (s.node = o)
            })
        }
        return n
    }
    static fromSchema(t) {
        return t.cached.domParser || (t.cached.domParser = new Qx(t, Qx.schemaRules(t)))
    }
};
const HF = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
}, Qtt = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
}, UF = {
    ol: !0,
    ul: !0
}, e1 = 1, t1 = 2, zp = 4;
function LN(e, t, n) {
    return t != null ? (t ? e1 : 0) | (t === "full" ? t1 : 0) : e && e.whitespace == "pre" ? e1 | t1 : n & ~zp
}
class Yv {
    constructor(t, n, r, o, i, s, a) {
        this.type = t,
        this.attrs = n,
        this.marks = r,
        this.pendingMarks = o,
        this.solid = i,
        this.options = a,
        this.content = [],
        this.activeMarks = Sn.none,
        this.stashMarks = [],
        this.match = s || (a & zp ? null : t.contentMatch)
    }
    findWrapping(t) {
        if (!this.match) {
            if (!this.type)
                return [];
            let n = this.type.contentMatch.fillBefore(Ne.from(t));
            if (n)
                this.match = this.type.contentMatch.matchFragment(n);
            else {
                let r = this.type.contentMatch,
                o;
                return (o = r.findWrapping(t.type)) ? (this.match = r, o) : null
            }
        }
        return this.match.findWrapping(t.type)
    }
    finish(t) {
        if (!(this.options & e1)) {
            let r = this.content[this.content.length - 1],
            o;
            if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
                let i = r;
                r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - o[0].length))
            }
        }
        let n = Ne.from(this.content);
        return !t && this.match && (n = n.append(this.match.fillBefore(Ne.empty, !0))),
        this.type ? this.type.create(this.attrs, n, this.marks) : n
    }
    popFromStashMark(t) {
        for (let n = this.stashMarks.length - 1; n >= 0; n--)
            if (t.eq(this.stashMarks[n]))
                return this.stashMarks.splice(n, 1)[0]
    }
    applyPending(t) {
        for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
            let o = r[n];
            (this.type ? this.type.allowsMarkType(o.type) : rnt(o.type, t)) && !o.isInSet(this.activeMarks) && (this.activeMarks = o.addToSet(this.activeMarks), this.pendingMarks = o.removeFromSet(this.pendingMarks))
        }
    }
    inlineContext(t) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : t.parentNode && !HF.hasOwnProperty(t.parentNode.nodeName.toLowerCase())
    }
}
class BN {
    constructor(t, n, r) {
        this.parser = t,
        this.options = n,
        this.isOpen = r,
        this.open = 0;
        let o = n.topNode,
        i,
        s = LN(null, n.preserveWhitespace, 0) | (r ? zp : 0);
        o ? i = new Yv(o.type, o.attrs, Sn.none, Sn.none, !0, n.topMatch || o.type.contentMatch, s) : r ? i = new Yv(null, null, Sn.none, Sn.none, !0, null, s) : i = new Yv(t.schema.topNodeType, null, Sn.none, Sn.none, !0, null, s),
        this.nodes = [i],
        this.find = n.findPositions,
        this.needsBlock = !1
    }
    get top() {
        return this.nodes[this.open]
    }
    addDOM(t) {
        if (t.nodeType == 3)
            this.addTextNode(t);
        else if (t.nodeType == 1) {
            let n = t.getAttribute("style");
            if (!n)
                this.addElement(t);
            else {
                let r = this.readStyles(nnt(n));
                if (!r)
                    return;
                let [o, i] = r,
                s = this.top;
                for (let a = 0; a < i.length; a++)
                    this.removePendingMark(i[a], s);
                for (let a = 0; a < o.length; a++)
                    this.addPendingMark(o[a]);
                this.addElement(t);
                for (let a = 0; a < o.length; a++)
                    this.removePendingMark(o[a], s);
                for (let a = 0; a < i.length; a++)
                    this.addPendingMark(i[a])
            }
        }
    }
    addTextNode(t) {
        let n = t.nodeValue,
        r = this.top;
        if (r.options & t1 || r.inlineContext(t) || /[^ \t\r\n\u000c]/.test(n)) {
            if (r.options & e1)
                r.options & t1 ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
            else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
                let o = r.content[r.content.length - 1],
                i = t.previousSibling;
                (!o || i && i.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (n = n.slice(1))
            }
            n && this.insertNode(this.parser.schema.text(n)),
            this.findInText(t)
        } else
            this.findInside(t)
    }
    addElement(t, n) {
        let r = t.nodeName.toLowerCase(),
        o;
        UF.hasOwnProperty(r) && this.parser.normalizeLists && ent(t);
        let i = this.options.ruleFromNode && this.options.ruleFromNode(t) || (o = this.parser.matchTag(t, this, n));
        if (i ? i.ignore : Qtt.hasOwnProperty(r))
            this.findInside(t), this.ignoreFallback(t);
        else if (!i || i.skip || i.closeParent) {
            i && i.closeParent ? this.open = Math.max(0, this.open - 1) : i && i.skip.nodeType && (t = i.skip);
            let s,
            a = this.top,
            l = this.needsBlock;
            if (HF.hasOwnProperty(r))
                a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), s = !0, a.type || (this.needsBlock = !0);
            else if (!t.firstChild) {
                this.leafFallback(t);
                return
            }
            this.addAll(t),
            s && this.sync(a),
            this.needsBlock = l
        } else
            this.addElementByRule(t, i, i.consuming === !1 ? o : void 0)
    }
    leafFallback(t) {
        t.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode(`
`))
    }
    ignoreFallback(t) {
        t.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"))
    }
    readStyles(t) {
        let n = Sn.none,
        r = Sn.none;
        e: for (let o = 0; o < t.length; o += 2)
            for (let i = void 0; ; ) {
                let s = this.parser.matchStyle(t[o], t[o + 1], this, i);
                if (!s)
                    continue e;
                if (s.ignore)
                    return null;
                if (s.clearMark ? this.top.pendingMarks.forEach(a => {
                        s.clearMark(a) && (r = a.addToSet(r))
                    }) : n = this.parser.schema.marks[s.mark].create(s.attrs).addToSet(n), s.consuming === !1)
                    i = s;
                else
                    break
            }
        return [n, r]
    }
    addElementByRule(t, n, r) {
        let o,
        i,
        s;
        n.node ? (i = this.parser.schema.nodes[n.node], i.isLeaf ? this.insertNode(i.create(n.attrs)) || this.leafFallback(t) : o = this.enter(i, n.attrs || null, n.preserveWhitespace)) : (s = this.parser.schema.marks[n.mark].create(n.attrs), this.addPendingMark(s));
        let a = this.top;
        if (i && i.isLeaf)
            this.findInside(t);
        else if (r)
            this.addElement(t, r);
        else if (n.getContent)
            this.findInside(t), n.getContent(t, this.parser.schema).forEach(l => this.insertNode(l));
        else {
            let l = t;
            typeof n.contentElement == "string" ? l = t.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(t) : n.contentElement && (l = n.contentElement),
            this.findAround(t, l, !0),
            this.addAll(l)
        }
        o && this.sync(a) && this.open--,
        s && this.removePendingMark(s, a)
    }
    addAll(t, n, r) {
        let o = n || 0;
        for (let i = n ? t.childNodes[n] : t.firstChild, s = r == null ? null : t.childNodes[r]; i != s; i = i.nextSibling, ++o)
            this.findAtPoint(t, o), this.addDOM(i);
        this.findAtPoint(t, o)
    }
    findPlace(t) {
        let n,
        r;
        for (let o = this.open; o >= 0; o--) {
            let i = this.nodes[o],
            s = i.findWrapping(t);
            if (s && (!n || n.length > s.length) && (n = s, r = i, !s.length) || i.solid)
                break
        }
        if (!n)
            return !1;
        this.sync(r);
        for (let o = 0; o < n.length; o++)
            this.enterInner(n[o], null, !1);
        return !0
    }
    insertNode(t) {
        if (t.isInline && this.needsBlock && !this.top.type) {
            let n = this.textblockFromContext();
            n && this.enterInner(n)
        }
        if (this.findPlace(t)) {
            this.closeExtra();
            let n = this.top;
            n.applyPending(t.type),
            n.match && (n.match = n.match.matchType(t.type));
            let r = n.activeMarks;
            for (let o = 0; o < t.marks.length; o++)
                (!n.type || n.type.allowsMarkType(t.marks[o].type)) && (r = t.marks[o].addToSet(r));
            return n.content.push(t.mark(r)),
            !0
        }
        return !1
    }
    enter(t, n, r) {
        let o = this.findPlace(t.create(n));
        return o && this.enterInner(t, n, !0, r),
        o
    }
    enterInner(t, n = null, r = !1, o) {
        this.closeExtra();
        let i = this.top;
        i.applyPending(t),
        i.match = i.match && i.match.matchType(t);
        let s = LN(t, o, i.options);
        i.options & zp && i.content.length == 0 && (s |= zp),
        this.nodes.push(new Yv(t, n, i.activeMarks, i.pendingMarks, r, null, s)),
        this.open++
    }
    closeExtra(t = !1) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
            for (; n > this.open; n--)
                this.nodes[n - 1].content.push(this.nodes[n].finish(t));
            this.nodes.length = this.open + 1
        }
    }
    finish() {
        return this.open = 0,
        this.closeExtra(this.isOpen),
        this.nodes[0].finish(this.isOpen || this.options.topOpen)
    }
    sync(t) {
        for (let n = this.open; n >= 0; n--)
            if (this.nodes[n] == t)
                return this.open = n, !0;
        return !1
    }
    get currentPos() {
        this.closeExtra();
        let t = 0;
        for (let n = this.open; n >= 0; n--) {
            let r = this.nodes[n].content;
            for (let o = r.length - 1; o >= 0; o--)
                t += r[o].nodeSize;
            n && t++
        }
        return t
    }
    findAtPoint(t, n) {
        if (this.find)
            for (let r = 0; r < this.find.length; r++)
                this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
    }
    findInside(t) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].pos == null && t.nodeType == 1 && t.contains(this.find[n].node) && (this.find[n].pos = this.currentPos)
    }
    findAround(t, n, r) {
        if (t != n && this.find)
            for (let o = 0; o < this.find.length; o++)
                this.find[o].pos == null && t.nodeType == 1 && t.contains(this.find[o].node) && n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos)
    }
    findInText(t) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].node == t && (this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset))
    }
    matchesContext(t) {
        if (t.indexOf("|") > -1)
            return t.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = t.split("/"),
        r = this.options.context,
        o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
        i =  - (r ? r.depth + 1 : 0) + (o ? 0 : 1),
        s = (a, l) => {
            for (; a >= 0; a--) {
                let c = n[a];
                if (c == "") {
                    if (a == n.length - 1 || a == 0)
                        continue;
                    for (; l >= i; l--)
                        if (s(a - 1, l))
                            return !0;
                    return !1
                } else {
                    let u = l > 0 || l == 0 && o ? this.nodes[l].type : r && l >= i ? r.node(l - i).type : null;
                    if (!u || u.name != c && u.groups.indexOf(c) == -1)
                        return !1;
                    l--
                }
            }
            return !0
        };
        return s(n.length - 1, this.open)
    }
    textblockFromContext() {
        let t = this.options.context;
        if (t)
            for (let n = t.depth; n >= 0; n--) {
                let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType;
                if (r && r.isTextblock && r.defaultAttrs)
                    return r
            }
        for (let n in this.parser.schema.nodes) {
            let r = this.parser.schema.nodes[n];
            if (r.isTextblock && r.defaultAttrs)
                return r
        }
    }
    addPendingMark(t) {
        let n = ont(t, this.top.pendingMarks);
        n && this.top.stashMarks.push(n),
        this.top.pendingMarks = t.addToSet(this.top.pendingMarks)
    }
    removePendingMark(t, n) {
        for (let r = this.open; r >= 0; r--) {
            let o = this.nodes[r];
            if (o.pendingMarks.lastIndexOf(t) > -1)
                o.pendingMarks = t.removeFromSet(o.pendingMarks);
            else {
                o.activeMarks = t.removeFromSet(o.activeMarks);
                let s = o.popFromStashMark(t);
                s && o.type && o.type.allowsMarkType(s.type) && (o.activeMarks = s.addToSet(o.activeMarks))
            }
            if (o == n)
                break
        }
    }
}
function ent(e) {
    for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
        let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
        r && UF.hasOwnProperty(r) && n ? (n.appendChild(t), t = n) : r == "li" ? n = t : r && (n = null)
    }
}
function tnt(e, t) {
    return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t)
}
function nnt(e) {
    let t = /\s*([\w-]+)\s*:\s*([^;]+)/g,
    n,
    r = [];
    for (; n = t.exec(e); )
        r.push(n[1], n[2].trim());
    return r
}
function VN(e) {
    let t = {};
    for (let n in e)
        t[n] = e[n];
    return t
}
function rnt(e, t) {
    let n = t.schema.nodes;
    for (let r in n) {
        let o = n[r];
        if (!o.allowsMarkType(e))
            continue;
        let i = [],
        s = a => {
            i.push(a);
            for (let l = 0; l < a.edgeCount; l++) {
                let {
                    type: c,
                    next: u
                } = a.edge(l);
                if (c == t || i.indexOf(u) < 0 && s(u))
                    return !0
            }
        };
        if (s(o.contentMatch))
            return !0
    }
}
function ont(e, t) {
    for (let n = 0; n < t.length; n++)
        if (e.eq(t[n]))
            return t[n]
}
class ta {
    constructor(t, n) {
        this.nodes = t,
        this.marks = n
    }
    serializeFragment(t, n = {}, r) {
        r || (r = B2(n).createDocumentFragment());
        let o = r,
        i = [];
        return t.forEach(s => {
            if (i.length || s.marks.length) {
                let a = 0,
                l = 0;
                for (; a < i.length && l < s.marks.length; ) {
                    let c = s.marks[l];
                    if (!this.marks[c.type.name]) {
                        l++;
                        continue
                    }
                    if (!c.eq(i[a][0]) || c.type.spec.spanning === !1)
                        break;
                    a++,
                    l++
                }
                for (; a < i.length; )
                    o = i.pop()[1];
                for (; l < s.marks.length; ) {
                    let c = s.marks[l++],
                    u = this.serializeMark(c, s.isInline, n);
                    u && (i.push([c, o]), o.appendChild(u.dom), o = u.contentDOM || u.dom)
                }
            }
            o.appendChild(this.serializeNodeInner(s, n))
        }),
        r
    }
    serializeNodeInner(t, n) {
        let {
            dom: r,
            contentDOM: o
        } = ta.renderSpec(B2(n), this.nodes[t.type.name](t));
        if (o) {
            if (t.isLeaf)
                throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(t.content, n, o)
        }
        return r
    }
    serializeNode(t, n = {}) {
        let r = this.serializeNodeInner(t, n);
        for (let o = t.marks.length - 1; o >= 0; o--) {
            let i = this.serializeMark(t.marks[o], t.isInline, n);
            i && ((i.contentDOM || i.dom).appendChild(r), r = i.dom)
        }
        return r
    }
    serializeMark(t, n, r = {}) {
        let o = this.marks[t.type.name];
        return o && ta.renderSpec(B2(r), o(t, n))
    }
    static renderSpec(t, n, r = null) {
        if (typeof n == "string")
            return {
                dom: t.createTextNode(n)
            };
        if (n.nodeType != null)
            return {
                dom: n
            };
        if (n.dom && n.dom.nodeType != null)
            return n;
        let o = n[0],
        i = o.indexOf(" ");
        i > 0 && (r = o.slice(0, i), o = o.slice(i + 1));
        let s,
        a = r ? t.createElementNS(r, o) : t.createElement(o),
        l = n[1],
        c = 1;
        if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
            c = 2;
            for (let u in l)
                if (l[u] != null) {
                    let f = u.indexOf(" ");
                    f > 0 ? a.setAttributeNS(u.slice(0, f), u.slice(f + 1), l[u]) : a.setAttribute(u, l[u])
                }
        }
        for (let u = c; u < n.length; u++) {
            let f = n[u];
            if (f === 0) {
                if (u < n.length - 1 || u > c)
                    throw new RangeError("Content hole must be the only child of its parent node");
                return {
                    dom: a,
                    contentDOM: a
                }
            } else {
                let {
                    dom: p,
                    contentDOM: m
                } = ta.renderSpec(t, f, r);
                if (a.appendChild(p), m) {
                    if (s)
                        throw new RangeError("Multiple content holes");
                    s = m
                }
            }
        }
        return {
            dom: a,
            contentDOM: s
        }
    }
    static fromSchema(t) {
        return t.cached.domSerializer || (t.cached.domSerializer = new ta(this.nodesFromSchema(t), this.marksFromSchema(t)))
    }
    static nodesFromSchema(t) {
        let n = FN(t.nodes);
        return n.text || (n.text = r => r.text),
        n
    }
    static marksFromSchema(t) {
        return FN(t.marks)
    }
}
function FN(e) {
    let t = {};
    for (let n in e) {
        let r = e[n].spec.toDOM;
        r && (t[n] = r)
    }
    return t
}
function B2(e) {
    return e.document || window.document
}
const qF = 65535, YF = Math.pow(2, 16);
function int(e, t) {
    return e + t * YF
}
function jN(e) {
    return e & qF
}
function snt(e) {
    return (e - (e & qF)) / YF
}
const KF = 1, GF = 2, w0 = 4, XF = 8;
class eS {
    constructor(t, n, r) {
        this.pos = t,
        this.delInfo = n,
        this.recover = r
    }
    get deleted() {
        return (this.delInfo & XF) > 0
    }
    get deletedBefore() {
        return (this.delInfo & (KF | w0)) > 0
    }
    get deletedAfter() {
        return (this.delInfo & (GF | w0)) > 0
    }
    get deletedAcross() {
        return (this.delInfo & w0) > 0
    }
}
class qi {
    constructor(t, n = !1) {
        if (this.ranges = t, this.inverted = n, !t.length && qi.empty)
            return qi.empty
    }
    recover(t) {
        let n = 0,
        r = jN(t);
        if (!this.inverted)
            for (let o = 0; o < r; o++)
                n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
        return this.ranges[r * 3] + n + snt(t)
    }
    mapResult(t, n = 1) {
        return this._map(t, n, !1)
    }
    map(t, n = 1) {
        return this._map(t, n, !0)
    }
    _map(t, n, r) {
        let o = 0,
        i = this.inverted ? 2 : 1,
        s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? o : 0);
            if (l > t)
                break;
            let c = this.ranges[a + i],
            u = this.ranges[a + s],
            f = l + c;
            if (t <= f) {
                let p = c ? t == l ? -1 : t == f ? 1 : n : n,
                m = l + o + (p < 0 ? 0 : u);
                if (r)
                    return m;
                let v = t == (n < 0 ? l : f) ? null : int(a / 3, t - l),
                y = t == l ? GF : t == f ? KF : w0;
                return (n < 0 ? t != l : t != f) && (y |= XF),
                new eS(m, y, v)
            }
            o += u - c
        }
        return r ? t + o : new eS(t + o, 0, null)
    }
    touches(t, n) {
        let r = 0,
        o = jN(n),
        i = this.inverted ? 2 : 1,
        s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? r : 0);
            if (l > t)
                break;
            let c = this.ranges[a + i],
            u = l + c;
            if (t <= u && a == o * 3)
                return !0;
            r += this.ranges[a + s] - c
        }
        return !1
    }
    forEach(t) {
        let n = this.inverted ? 2 : 1,
        r = this.inverted ? 1 : 2;
        for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
            let s = this.ranges[o],
            a = s - (this.inverted ? i : 0),
            l = s + (this.inverted ? 0 : i),
            c = this.ranges[o + n],
            u = this.ranges[o + r];
            t(a, a + c, l, l + u),
            i += u - c
        }
    }
    invert() {
        return new qi(this.ranges, !this.inverted)
    }
    toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
    }
    static offset(t) {
        return t == 0 ? qi.empty : new qi(t < 0 ? [0, -t, 0] : [0, 0, t])
    }
}
qi.empty = new qi([]);
class lf {
    constructor(t = [], n, r = 0, o = t.length) {
        this.maps = t,
        this.mirror = n,
        this.from = r,
        this.to = o
    }
    slice(t = 0, n = this.maps.length) {
        return new lf(this.maps, this.mirror, t, n)
    }
    copy() {
        return new lf(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
    }
    appendMap(t, n) {
        this.to = this.maps.push(t),
        n != null && this.setMirror(this.maps.length - 1, n)
    }
    appendMapping(t) {
        for (let n = 0, r = this.maps.length; n < t.maps.length; n++) {
            let o = t.getMirror(n);
            this.appendMap(t.maps[n], o != null && o < n ? r + o : void 0)
        }
    }
    getMirror(t) {
        if (this.mirror) {
            for (let n = 0; n < this.mirror.length; n++)
                if (this.mirror[n] == t)
                    return this.mirror[n + (n % 2 ? -1 : 1)]
        }
    }
    setMirror(t, n) {
        this.mirror || (this.mirror = []),
        this.mirror.push(t, n)
    }
    appendMappingInverted(t) {
        for (let n = t.maps.length - 1, r = this.maps.length + t.maps.length; n >= 0; n--) {
            let o = t.getMirror(n);
            this.appendMap(t.maps[n].invert(), o != null && o > n ? r - o - 1 : void 0)
        }
    }
    invert() {
        let t = new lf;
        return t.appendMappingInverted(this),
        t
    }
    map(t, n = 1) {
        if (this.mirror)
            return this._map(t, n, !0);
        for (let r = this.from; r < this.to; r++)
            t = this.maps[r].map(t, n);
        return t
    }
    mapResult(t, n = 1) {
        return this._map(t, n, !1)
    }
    _map(t, n, r) {
        let o = 0;
        for (let i = this.from; i < this.to; i++) {
            let s = this.maps[i],
            a = s.mapResult(t, n);
            if (a.recover != null) {
                let l = this.getMirror(i);
                if (l != null && l > i && l < this.to) {
                    i = l,
                    t = this.maps[l].recover(a.recover);
                    continue
                }
            }
            o |= a.delInfo,
            t = a.pos
        }
        return r ? t : new eS(t, o, null)
    }
}
const V2 = Object.create(null);
class ai {
    getMap() {
        return qi.empty
    }
    merge(t) {
        return null
    }
    static fromJSON(t, n) {
        if (!n || !n.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
        let r = V2[n.stepType];
        if (!r)
            throw new RangeError(`No step type ${n.stepType} defined`);
        return r.fromJSON(t, n)
    }
    static jsonID(t, n) {
        if (t in V2)
            throw new RangeError("Duplicate use of step JSON ID " + t);
        return V2[t] = n,
        n.prototype.jsonID = t,
        n
    }
}
class Nr {
    constructor(t, n) {
        this.doc = t,
        this.failed = n
    }
    static ok(t) {
        return new Nr(t, null)
    }
    static fail(t) {
        return new Nr(null, t)
    }
    static fromReplace(t, n, r, o) {
        try {
            return Nr.ok(t.replace(n, r, o))
        } catch (i) {
            if (i instanceof Xy)
                return Nr.fail(i.message);
            throw i
        }
    }
}
function yT(e, t, n) {
    let r = [];
    for (let o = 0; o < e.childCount; o++) {
        let i = e.child(o);
        i.content.size && (i = i.copy(yT(i.content, t, i))),
        i.isInline && (i = t(i, n, o)),
        r.push(i)
    }
    return Ne.fromArray(r)
}
class Fl extends ai {
    constructor(t, n, r) {
        super(),
        this.from = t,
        this.to = n,
        this.mark = r
    }
    apply(t) {
        let n = t.slice(this.from, this.to),
        r = t.resolve(this.from),
        o = r.node(r.sharedDepth(this.to)),
        i = new nt(yT(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), o), n.openStart, n.openEnd);
        return Nr.fromReplace(t, this.from, this.to, i)
    }
    invert() {
        return new na(this.from, this.to, this.mark)
    }
    map(t) {
        let n = t.mapResult(this.from, 1),
        r = t.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new Fl(n.pos, r.pos, this.mark)
    }
    merge(t) {
        return t instanceof Fl && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new Fl(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null
    }
    toJSON() {
        return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new Fl(n.from, n.to, t.markFromJSON(n.mark))
    }
}
ai.jsonID("addMark", Fl);
class na extends ai {
    constructor(t, n, r) {
        super(),
        this.from = t,
        this.to = n,
        this.mark = r
    }
    apply(t) {
        let n = t.slice(this.from, this.to),
        r = new nt(yT(n.content, o => o.mark(this.mark.removeFromSet(o.marks)), t), n.openStart, n.openEnd);
        return Nr.fromReplace(t, this.from, this.to, r)
    }
    invert() {
        return new Fl(this.from, this.to, this.mark)
    }
    map(t) {
        let n = t.mapResult(this.from, 1),
        r = t.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new na(n.pos, r.pos, this.mark)
    }
    merge(t) {
        return t instanceof na && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new na(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null
    }
    toJSON() {
        return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new na(n.from, n.to, t.markFromJSON(n.mark))
    }
}
ai.jsonID("removeMark", na);
class jl extends ai {
    constructor(t, n) {
        super(),
        this.pos = t,
        this.mark = n
    }
    apply(t) {
        let n = t.nodeAt(this.pos);
        if (!n)
            return Nr.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return Nr.fromReplace(t, this.pos, this.pos + 1, new nt(Ne.from(r), 0, n.isLeaf ? 0 : 1))
    }
    invert(t) {
        let n = t.nodeAt(this.pos);
        if (n) {
            let r = this.mark.addToSet(n.marks);
            if (r.length == n.marks.length) {
                for (let o = 0; o < n.marks.length; o++)
                    if (!n.marks[o].isInSet(r))
                        return new jl(this.pos, n.marks[o]);
                return new jl(this.pos, this.mark)
            }
        }
        return new jf(this.pos, this.mark)
    }
    map(t) {
        let n = t.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new jl(n.pos, this.mark)
    }
    toJSON() {
        return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new jl(n.pos, t.markFromJSON(n.mark))
    }
}
ai.jsonID("addNodeMark", jl);
class jf extends ai {
    constructor(t, n) {
        super(),
        this.pos = t,
        this.mark = n
    }
    apply(t) {
        let n = t.nodeAt(this.pos);
        if (!n)
            return Nr.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return Nr.fromReplace(t, this.pos, this.pos + 1, new nt(Ne.from(r), 0, n.isLeaf ? 0 : 1))
    }
    invert(t) {
        let n = t.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new jl(this.pos, this.mark)
    }
    map(t) {
        let n = t.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new jf(n.pos, this.mark)
    }
    toJSON() {
        return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new jf(n.pos, t.markFromJSON(n.mark))
    }
}
ai.jsonID("removeNodeMark", jf);
class ao extends ai {
    constructor(t, n, r, o = !1) {
        super(),
        this.from = t,
        this.to = n,
        this.slice = r,
        this.structure = o
    }
    apply(t) {
        return this.structure && tS(t, this.from, this.to) ? Nr.fail("Structure replace would overwrite content") : Nr.fromReplace(t, this.from, this.to, this.slice)
    }
    getMap() {
        return new qi([this.from, this.to - this.from, this.slice.size])
    }
    invert(t) {
        return new ao(this.from, this.from + this.slice.size, t.slice(this.from, this.to))
    }
    map(t) {
        let n = t.mapResult(this.from, 1),
        r = t.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new ao(n.pos, Math.max(n.pos, r.pos), this.slice)
    }
    merge(t) {
        if (!(t instanceof ao) || t.structure || this.structure)
            return null;
        if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
            let n = this.slice.size + t.slice.size == 0 ? nt.empty : new nt(this.slice.content.append(t.slice.content), this.slice.openStart, t.slice.openEnd);
            return new ao(this.from, this.to + (t.to - t.from), n, this.structure)
        } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
            let n = this.slice.size + t.slice.size == 0 ? nt.empty : new nt(t.slice.content.append(this.slice.content), t.slice.openStart, this.slice.openEnd);
            return new ao(t.from, this.to, n, this.structure)
        } else
            return null
    }
    toJSON() {
        let t = {
            stepType: "replace",
            from: this.from,
            to: this.to
        };
        return this.slice.size && (t.slice = this.slice.toJSON()),
        this.structure && (t.structure = !0),
        t
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new ao(n.from, n.to, nt.fromJSON(t, n.slice), !!n.structure)
    }
}
ai.jsonID("replace", ao);
class jr extends ai {
    constructor(t, n, r, o, i, s, a = !1) {
        super(),
        this.from = t,
        this.to = n,
        this.gapFrom = r,
        this.gapTo = o,
        this.slice = i,
        this.insert = s,
        this.structure = a
    }
    apply(t) {
        if (this.structure && (tS(t, this.from, this.gapFrom) || tS(t, this.gapTo, this.to)))
            return Nr.fail("Structure gap-replace would overwrite content");
        let n = t.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
            return Nr.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? Nr.fromReplace(t, this.from, this.to, r) : Nr.fail("Content does not fit in gap")
    }
    getMap() {
        return new qi([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
    }
    invert(t) {
        let n = this.gapTo - this.gapFrom;
        return new jr(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure)
    }
    map(t) {
        let n = t.mapResult(this.from, 1),
        r = t.mapResult(this.to, -1),
        o = t.map(this.gapFrom, -1),
        i = t.map(this.gapTo, 1);
        return n.deletedAcross && r.deletedAcross || o < n.pos || i > r.pos ? null : new jr(n.pos, r.pos, o, i, this.slice, this.insert, this.structure)
    }
    toJSON() {
        let t = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
        };
        return this.slice.size && (t.slice = this.slice.toJSON()),
        this.structure && (t.structure = !0),
        t
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new jr(n.from, n.to, n.gapFrom, n.gapTo, nt.fromJSON(t, n.slice), n.insert, !!n.structure)
    }
}
ai.jsonID("replaceAround", jr);
function tS(e, t, n) {
    let r = e.resolve(t),
    o = n - t,
    i = r.depth;
    for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
        i--, o--;
    if (o > 0) {
        let s = r.node(i).maybeChild(r.indexAfter(i));
        for (; o > 0; ) {
            if (!s || s.isLeaf)
                return !0;
            s = s.firstChild,
            o--
        }
    }
    return !1
}
function ant(e, t, n, r) {
    let o = [],
    i = [],
    s,
    a;
    e.doc.nodesBetween(t, n, (l, c, u) => {
        if (!l.isInline)
            return;
        let f = l.marks;
        if (!r.isInSet(f) && u.type.allowsMarkType(r.type)) {
            let p = Math.max(c, t),
            m = Math.min(c + l.nodeSize, n),
            v = r.addToSet(f);
            for (let y = 0; y < f.length; y++)
                f[y].isInSet(v) || (s && s.to == p && s.mark.eq(f[y]) ? s.to = m : o.push(s = new na(p, m, f[y])));
            a && a.to == p ? a.to = m : i.push(a = new Fl(p, m, r))
        }
    }),
    o.forEach(l => e.step(l)),
    i.forEach(l => e.step(l))
}
function lnt(e, t, n, r) {
    let o = [],
    i = 0;
    e.doc.nodesBetween(t, n, (s, a) => {
        if (!s.isInline)
            return;
        i++;
        let l = null;
        if (r instanceof Jw) {
            let c = s.marks,
            u;
            for (; u = r.isInSet(c); )
                (l || (l = [])).push(u), c = u.removeFromSet(c)
        } else
            r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
        if (l && l.length) {
            let c = Math.min(a + s.nodeSize, n);
            for (let u = 0; u < l.length; u++) {
                let f = l[u],
                p;
                for (let m = 0; m < o.length; m++) {
                    let v = o[m];
                    v.step == i - 1 && f.eq(o[m].style) && (p = v)
                }
                p ? (p.to = c, p.step = i) : o.push({
                    style: f,
                    from: Math.max(a, t),
                    to: c,
                    step: i
                })
            }
        }
    }),
    o.forEach(s => e.step(new na(s.from, s.to, s.style)))
}
function cnt(e, t, n, r = n.contentMatch) {
    let o = e.doc.nodeAt(t),
    i = [],
    s = t + 1;
    for (let a = 0; a < o.childCount; a++) {
        let l = o.child(a),
        c = s + l.nodeSize,
        u = r.matchType(l.type);
        if (!u)
            i.push(new ao(s, c, nt.empty));
        else {
            r = u;
            for (let f = 0; f < l.marks.length; f++)
                n.allowsMarkType(l.marks[f].type) || e.step(new na(s, c, l.marks[f]))
        }
        s = c
    }
    if (!r.validEnd) {
        let a = r.fillBefore(Ne.empty, !0);
        e.replace(s, s, new nt(a, 0, 0))
    }
    for (let a = i.length - 1; a >= 0; a--)
        e.step(i[a])
}
function unt(e, t, n) {
    return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n))
}
function vh(e) {
    let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
    for (let r = e.depth; ; --r) {
        let o = e.$from.node(r),
        i = e.$from.index(r),
        s = e.$to.indexAfter(r);
        if (r < e.depth && o.canReplace(i, s, n))
            return r;
        if (r == 0 || o.type.spec.isolating || !unt(o, i, s))
            break
    }
    return null
}
function dnt(e, t, n) {
    let {
        $from: r,
        $to: o,
        depth: i
    } = t,
    s = r.before(i + 1),
    a = o.after(i + 1),
    l = s,
    c = a,
    u = Ne.empty,
    f = 0;
    for (let v = i, y = !1; v > n; v--)
        y || r.index(v) > 0 ? (y = !0, u = Ne.from(r.node(v).copy(u)), f++) : l--;
    let p = Ne.empty,
    m = 0;
    for (let v = i, y = !1; v > n; v--)
        y || o.after(v + 1) < o.end(v) ? (y = !0, p = Ne.from(o.node(v).copy(p)), m++) : c++;
    e.step(new jr(l, c, s, a, new nt(u.append(p), f, m), u.size - f, !0))
}
function wT(e, t, n = null, r = e) {
    let o = fnt(e, t),
    i = o && hnt(r, t);
    return i ? o.map(WN).concat({
        type: t,
        attrs: n
    }).concat(i.map(WN)) : null
}
function WN(e) {
    return {
        type: e,
        attrs: null
    }
}
function fnt(e, t) {
    let {
        parent: n,
        startIndex: r,
        endIndex: o
    } = e,
    i = n.contentMatchAt(r).findWrapping(t);
    if (!i)
        return null;
    let s = i.length ? i[0] : t;
    return n.canReplaceWith(r, o, s) ? i : null
}
function hnt(e, t) {
    let {
        parent: n,
        startIndex: r,
        endIndex: o
    } = e,
    i = n.child(r),
    s = t.contentMatch.findWrapping(i.type);
    if (!s)
        return null;
    let l = (s.length ? s[s.length - 1] : t).contentMatch;
    for (let c = r; l && c < o; c++)
        l = l.matchType(n.child(c).type);
    return !l || !l.validEnd ? null : s
}
function pnt(e, t, n) {
    let r = Ne.empty;
    for (let s = n.length - 1; s >= 0; s--) {
        if (r.size) {
            let a = n[s].type.contentMatch.matchFragment(r);
            if (!a || !a.validEnd)
                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")
        }
        r = Ne.from(n[s].type.create(n[s].attrs, r))
    }
    let o = t.start,
    i = t.end;
    e.step(new jr(o, i, o, i, new nt(r, 0, 0), n.length, !0))
}
function mnt(e, t, n, r, o) {
    if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
    let i = e.steps.length;
    e.doc.nodesBetween(t, n, (s, a) => {
        if (s.isTextblock && !s.hasMarkup(r, o) && gnt(e.doc, e.mapping.slice(i).map(a), r)) {
            e.clearIncompatible(e.mapping.slice(i).map(a, 1), r);
            let l = e.mapping.slice(i),
            c = l.map(a, 1),
            u = l.map(a + s.nodeSize, 1);
            return e.step(new jr(c, u, c + 1, u - 1, new nt(Ne.from(r.create(o, null, s.marks)), 0, 0), 1, !0)),
            !1
        }
    })
}
function gnt(e, t, n) {
    let r = e.resolve(t),
    o = r.index();
    return r.parent.canReplaceWith(o, o + 1, n)
}
function vnt(e, t, n, r, o) {
    let i = e.doc.nodeAt(t);
    if (!i)
        throw new RangeError("No node at given position");
    n || (n = i.type);
    let s = n.create(r, null, o || i.marks);
    if (i.isLeaf)
        return e.replaceWith(t, t + i.nodeSize, s);
    if (!n.validContent(i.content))
        throw new RangeError("Invalid content for node type " + n.name);
    e.step(new jr(t, t + i.nodeSize, t + 1, t + i.nodeSize - 1, new nt(Ne.from(s), 0, 0), 1, !0))
}
function cf(e, t, n = 1, r) {
    let o = e.resolve(t),
    i = o.depth - n,
    s = r && r[r.length - 1] || o.parent;
    if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
        return !1;
    for (let c = o.depth - 1, u = n - 2; c > i; c--, u--) {
        let f = o.node(c),
        p = o.index(c);
        if (f.type.spec.isolating)
            return !1;
        let m = f.content.cutByIndex(p, f.childCount),
        v = r && r[u] || f;
        if (v != f && (m = m.replaceChild(0, v.type.create(v.attrs))), !f.canReplace(p + 1, f.childCount) || !v.type.validContent(m))
            return !1
    }
    let a = o.indexAfter(i),
    l = r && r[0];
    return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type)
}
function ynt(e, t, n = 1, r) {
    let o = e.doc.resolve(t),
    i = Ne.empty,
    s = Ne.empty;
    for (let a = o.depth, l = o.depth - n, c = n - 1; a > l; a--, c--) {
        i = Ne.from(o.node(a).copy(i));
        let u = r && r[c];
        s = Ne.from(u ? u.type.create(u.attrs, s) : o.node(a).copy(s))
    }
    e.step(new ao(t, t, new nt(i.append(s), n, n), !0))
}
function yc(e, t) {
    let n = e.resolve(t),
    r = n.index();
    return JF(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function JF(e, t) {
    return !!(e && t && !e.isLeaf && e.canAppend(t))
}
function ZF(e, t, n = -1) {
    let r = e.resolve(t);
    for (let o = r.depth; ; o--) {
        let i,
        s,
        a = r.index(o);
        if (o == r.depth ? (i = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (i = r.node(o + 1), a++, s = r.node(o).maybeChild(a)) : (i = r.node(o).maybeChild(a - 1), s = r.node(o + 1)), i && !i.isTextblock && JF(i, s) && r.node(o).canReplace(a, a + 1))
            return t;
        if (o == 0)
            break;
        t = n < 0 ? r.before(o) : r.after(o)
    }
}
function wnt(e, t, n) {
    let r = new ao(t - n, t + n, nt.empty, !0);
    e.step(r)
}
function bnt(e, t, n) {
    let r = e.resolve(t);
    if (r.parent.canReplaceWith(r.index(), r.index(), n))
        return t;
    if (r.parentOffset == 0)
        for (let o = r.depth - 1; o >= 0; o--) {
            let i = r.index(o);
            if (r.node(o).canReplaceWith(i, i, n))
                return r.before(o + 1);
            if (i > 0)
                return null
        }
    if (r.parentOffset == r.parent.content.size)
        for (let o = r.depth - 1; o >= 0; o--) {
            let i = r.indexAfter(o);
            if (r.node(o).canReplaceWith(i, i, n))
                return r.after(o + 1);
            if (i < r.node(o).childCount)
                return null
        }
    return null
}
function QF(e, t, n) {
    let r = e.resolve(t);
    if (!n.content.size)
        return t;
    let o = n.content;
    for (let i = 0; i < n.openStart; i++)
        o = o.firstChild.content;
    for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
        for (let s = r.depth; s >= 0; s--) {
            let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1,
            l = r.index(s) + (a > 0 ? 1 : 0),
            c = r.node(s),
            u = !1;
            if (i == 1)
                u = c.canReplace(l, l, o);
            else {
                let f = c.contentMatchAt(l).findWrapping(o.firstChild.type);
                u = f && c.canReplaceWith(l, l, f[0])
            }
            if (u)
                return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1)
        }
    return null
}
function bT(e, t, n = t, r = nt.empty) {
    if (t == n && !r.size)
        return null;
    let o = e.resolve(t),
    i = e.resolve(n);
    return ej(o, i, r) ? new ao(t, n, r) : new _nt(o, i, r).fit()
}
function ej(e, t, n) {
    return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content)
}
class _nt {
    constructor(t, n, r) {
        this.$from = t,
        this.$to = n,
        this.unplaced = r,
        this.frontier = [],
        this.placed = Ne.empty;
        for (let o = 0; o <= t.depth; o++) {
            let i = t.node(o);
            this.frontier.push({
                type: i.type,
                match: i.contentMatchAt(t.indexAfter(o))
            })
        }
        for (let o = t.depth; o > 0; o--)
            this.placed = Ne.from(t.node(o).copy(this.placed))
    }
    get depth() {
        return this.frontier.length - 1
    }
    fit() {
        for (; this.unplaced.size; ) {
            let c = this.findFittable();
            c ? this.placeNodes(c) : this.openMore() || this.dropNode()
        }
        let t = this.mustMoveInline(),
        n = this.placed.size - this.depth - this.$from.depth,
        r = this.$from,
        o = this.close(t < 0 ? this.$to : r.doc.resolve(t));
        if (!o)
            return null;
        let i = this.placed,
        s = r.depth,
        a = o.depth;
        for (; s && a && i.childCount == 1; )
            i = i.firstChild.content, s--, a--;
        let l = new nt(i, s, a);
        return t > -1 ? new jr(r.pos, t, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new ao(r.pos, o.pos, l) : null
    }
    findFittable() {
        let t = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < t; r++) {
            let i = n.firstChild;
            if (n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r) {
                t = r;
                break
            }
            n = i.content
        }
        for (let n = 1; n <= 2; n++)
            for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
                let o,
                i = null;
                r ? (i = F2(this.unplaced.content, r - 1).firstChild, o = i.content) : o = this.unplaced.content;
                let s = o.firstChild;
                for (let a = this.depth; a >= 0; a--) {
                    let {
                        type: l,
                        match: c
                    } = this.frontier[a],
                    u,
                    f = null;
                    if (n == 1 && (s ? c.matchType(s.type) || (f = c.fillBefore(Ne.from(s), !1)) : i && l.compatibleContent(i.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: a,
                            parent: i,
                            inject: f
                        };
                    if (n == 2 && s && (u = c.findWrapping(s.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: a,
                            parent: i,
                            wrap: u
                        };
                    if (i && c.matchType(i.type))
                        break
                }
            }
    }
    openMore() {
        let {
            content: t,
            openStart: n,
            openEnd: r
        } = this.unplaced,
        o = F2(t, n);
        return !o.childCount || o.firstChild.isLeaf ? !1 : (this.unplaced = new nt(t, n + 1, Math.max(r, o.size + n >= t.size - r ? n + 1 : 0)), !0)
    }
    dropNode() {
        let {
            content: t,
            openStart: n,
            openEnd: r
        } = this.unplaced,
        o = F2(t, n);
        if (o.childCount <= 1 && n > 0) {
            let i = t.size - n <= n + o.size;
            this.unplaced = new nt(mp(t, n - 1, 1), n - 1, i ? n - 1 : r)
        } else
            this.unplaced = new nt(mp(t, n, 1), n, r)
    }
    placeNodes({
        sliceDepth: t,
        frontierDepth: n,
        parent: r,
        inject: o,
        wrap: i
    }) {
        for (; this.depth > n; )
            this.closeFrontierNode();
        if (i)
            for (let y = 0; y < i.length; y++)
                this.openFrontierNode(i[y]);
        let s = this.unplaced,
        a = r ? r.content : s.content,
        l = s.openStart - t,
        c = 0,
        u = [], {
            match: f,
            type: p
        } = this.frontier[n];
        if (o) {
            for (let y = 0; y < o.childCount; y++)
                u.push(o.child(y));
            f = f.matchFragment(o)
        }
        let m = a.size + t - (s.content.size - s.openEnd);
        for (; c < a.childCount; ) {
            let y = a.child(c),
            b = f.matchType(y.type);
            if (!b)
                break;
            c++,
            (c > 1 || l == 0 || y.content.size) && (f = b, u.push(tj(y.mark(p.allowedMarks(y.marks)), c == 1 ? l : 0, c == a.childCount ? m : -1)))
        }
        let v = c == a.childCount;
        v || (m = -1),
        this.placed = gp(this.placed, n, Ne.from(u)),
        this.frontier[n].match = f,
        v && m < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let y = 0, b = a; y < m; y++) {
            let w = b.lastChild;
            this.frontier.push({
                type: w.type,
                match: w.contentMatchAt(w.childCount)
            }),
            b = w.content
        }
        this.unplaced = v ? t == 0 ? nt.empty : new nt(mp(s.content, t - 1, 1), t - 1, m < 0 ? s.openEnd : t - 1) : new nt(mp(s.content, t, c), s.openStart, s.openEnd)
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock)
            return -1;
        let t = this.frontier[this.depth],
        n;
        if (!t.type.isTextblock || !j2(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
            return -1;
        let {
            depth: r
        } = this.$to,
        o = this.$to.after(r);
        for (; r > 1 && o == this.$to.end(--r); )
            ++o;
        return o
    }
    findCloseLevel(t) {
        e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
            let {
                match: r,
                type: o
            } = this.frontier[n],
            i = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)),
            s = j2(t, n, o, r, i);
            if (s) {
                for (let a = n - 1; a >= 0; a--) {
                    let {
                        match: l,
                        type: c
                    } = this.frontier[a],
                    u = j2(t, a, c, l, !0);
                    if (!u || u.childCount)
                        continue e
                }
                return {
                    depth: n,
                    fit: s,
                    move: i ? t.doc.resolve(t.after(n + 1)) : t
                }
            }
        }
    }
    close(t) {
        let n = this.findCloseLevel(t);
        if (!n)
            return null;
        for (; this.depth > n.depth; )
            this.closeFrontierNode();
        n.fit.childCount && (this.placed = gp(this.placed, n.depth, n.fit)),
        t = n.move;
        for (let r = n.depth + 1; r <= t.depth; r++) {
            let o = t.node(r),
            i = o.type.contentMatch.fillBefore(o.content, !0, t.index(r));
            this.openFrontierNode(o.type, o.attrs, i)
        }
        return t
    }
    openFrontierNode(t, n = null, r) {
        let o = this.frontier[this.depth];
        o.match = o.match.matchType(t),
        this.placed = gp(this.placed, this.depth, Ne.from(t.create(n, r))),
        this.frontier.push({
            type: t,
            match: t.contentMatch
        })
    }
    closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(Ne.empty, !0);
        n.childCount && (this.placed = gp(this.placed, this.frontier.length, n))
    }
}
function mp(e, t, n) {
    return t == 0 ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(mp(e.firstChild.content, t - 1, n)))
}
function gp(e, t, n) {
    return t == 0 ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(gp(e.lastChild.content, t - 1, n)))
}
function F2(e, t) {
    for (let n = 0; n < t; n++)
        e = e.firstChild.content;
    return e
}
function tj(e, t, n) {
    if (t <= 0)
        return e;
    let r = e.content;
    return t > 1 && (r = r.replaceChild(0, tj(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))),
    t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(Ne.empty, !0)))),
    e.copy(r)
}
function j2(e, t, n, r, o) {
    let i = e.node(t),
    s = o ? e.indexAfter(t) : e.index(t);
    if (s == i.childCount && !n.compatibleContent(i.type))
        return null;
    let a = r.fillBefore(i.content, !0, s);
    return a && !knt(n, i.content, s) ? a : null
}
function knt(e, t, n) {
    for (let r = n; r < t.childCount; r++)
        if (!e.allowsMarks(t.child(r).marks))
            return !0;
    return !1
}
function xnt(e) {
    return e.spec.defining || e.spec.definingForContent
}
function Snt(e, t, n, r) {
    if (!r.size)
        return e.deleteRange(t, n);
    let o = e.doc.resolve(t),
    i = e.doc.resolve(n);
    if (ej(o, i, r))
        return e.step(new ao(t, n, r));
    let s = rj(o, e.doc.resolve(n));
    s[s.length - 1] == 0 && s.pop();
    let a =  - (o.depth + 1);
    s.unshift(a);
    for (let p = o.depth, m = o.pos - 1; p > 0; p--, m--) {
        let v = o.node(p).type.spec;
        if (v.defining || v.definingAsContext || v.isolating)
            break;
        s.indexOf(p) > -1 ? a = p : o.before(p) == m && s.splice(1, 0, -p)
    }
    let l = s.indexOf(a),
    c = [],
    u = r.openStart;
    for (let p = r.content, m = 0; ; m++) {
        let v = p.firstChild;
        if (c.push(v), m == r.openStart)
            break;
        p = v.content
    }
    for (let p = u - 1; p >= 0; p--) {
        let m = c[p].type,
        v = xnt(m);
        if (v && o.node(l).type != m)
            u = p;
        else if (v || !m.isTextblock)
            break
    }
    for (let p = r.openStart; p >= 0; p--) {
        let m = (p + u + 1) % (r.openStart + 1),
        v = c[m];
        if (v)
            for (let y = 0; y < s.length; y++) {
                let b = s[(y + l) % s.length],
                w = !0;
                b < 0 && (w = !1, b = -b);
                let k = o.node(b - 1),
                C = o.index(b - 1);
                if (k.canReplaceWith(C, C, v.type, v.marks))
                    return e.replace(o.before(b), w ? i.after(b) : n, new nt(nj(r.content, 0, r.openStart, m), m, r.openEnd))
            }
    }
    let f = e.steps.length;
    for (let p = s.length - 1; p >= 0 && (e.replace(t, n, r), !(e.steps.length > f)); p--) {
        let m = s[p];
        m < 0 || (t = o.before(m), n = i.after(m))
    }
}
function nj(e, t, n, r, o) {
    if (t < n) {
        let i = e.firstChild;
        e = e.replaceChild(0, i.copy(nj(i.content, t + 1, n, r, i)))
    }
    if (t > r) {
        let i = o.contentMatchAt(0),
        s = i.fillBefore(e).append(e);
        e = s.append(i.matchFragment(s).fillBefore(Ne.empty, !0))
    }
    return e
}
function Cnt(e, t, n, r) {
    if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
        let o = bnt(e.doc, t, r.type);
        o != null && (t = n = o)
    }
    e.replaceRange(t, n, new nt(Ne.from(r), 0, 0))
}
function Int(e, t, n) {
    let r = e.doc.resolve(t),
    o = e.doc.resolve(n),
    i = rj(r, o);
    for (let s = 0; s < i.length; s++) {
        let a = i[s],
        l = s == i.length - 1;
        if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
            return e.delete(r.start(a), o.end(a));
        if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1))))
            return e.delete(r.before(a), o.after(a))
    }
    for (let s = 1; s <= r.depth && s <= o.depth; s++)
        if (t - r.start(s) == r.depth - s && n > r.end(s) && o.end(s) - n != o.depth - s)
            return e.delete(r.before(s), n);
    e.delete(t, n)
}
function rj(e, t) {
    let n = [],
    r = Math.min(e.depth, t.depth);
    for (let o = r; o >= 0; o--) {
        let i = e.start(o);
        if (i < e.pos - (e.depth - o) || t.end(o) > t.pos + (t.depth - o) || e.node(o).type.spec.isolating || t.node(o).type.spec.isolating)
            break;
        (i == t.start(o) || o == e.depth && o == t.depth && e.parent.inlineContent && t.parent.inlineContent && o && t.start(o - 1) == i - 1) && n.push(o)
    }
    return n
}
class uf extends ai {
    constructor(t, n, r) {
        super(),
        this.pos = t,
        this.attr = n,
        this.value = r
    }
    apply(t) {
        let n = t.nodeAt(this.pos);
        if (!n)
            return Nr.fail("No node at attribute step's position");
        let r = Object.create(null);
        for (let i in n.attrs)
            r[i] = n.attrs[i];
        r[this.attr] = this.value;
        let o = n.type.create(r, null, n.marks);
        return Nr.fromReplace(t, this.pos, this.pos + 1, new nt(Ne.from(o), 0, n.isLeaf ? 0 : 1))
    }
    getMap() {
        return qi.empty
    }
    invert(t) {
        return new uf(this.pos, this.attr, t.nodeAt(this.pos).attrs[this.attr])
    }
    map(t) {
        let n = t.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new uf(n.pos, this.attr, this.value)
    }
    toJSON() {
        return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new uf(n.pos, n.attr, n.value)
    }
}
ai.jsonID("attr", uf);
let Wf = class extends Error {};
Wf = function e(t) {
    let n = Error.call(this, t);
    return n.__proto__ = e.prototype,
    n
};
Wf.prototype = Object.create(Error.prototype);
Wf.prototype.constructor = Wf;
Wf.prototype.name = "TransformError";
class oj {
    constructor(t) {
        this.doc = t,
        this.steps = [],
        this.docs = [],
        this.mapping = new lf
    }
    get before() {
        return this.docs.length ? this.docs[0] : this.doc
    }
    step(t) {
        let n = this.maybeStep(t);
        if (n.failed)
            throw new Wf(n.failed);
        return this
    }
    maybeStep(t) {
        let n = t.apply(this.doc);
        return n.failed || this.addStep(t, n.doc),
        n
    }
    get docChanged() {
        return this.steps.length > 0
    }
    addStep(t, n) {
        this.docs.push(this.doc),
        this.steps.push(t),
        this.mapping.appendMap(t.getMap()),
        this.doc = n
    }
    replace(t, n = t, r = nt.empty) {
        let o = bT(this.doc, t, n, r);
        return o && this.step(o),
        this
    }
    replaceWith(t, n, r) {
        return this.replace(t, n, new nt(Ne.from(r), 0, 0))
    }
    delete (t, n) {
        return this.replace(t, n, nt.empty)
    }
    insert(t, n) {
        return this.replaceWith(t, t, n)
    }
    replaceRange(t, n, r) {
        return Snt(this, t, n, r),
        this
    }
    replaceRangeWith(t, n, r) {
        return Cnt(this, t, n, r),
        this
    }
    deleteRange(t, n) {
        return Int(this, t, n),
        this
    }
    lift(t, n) {
        return dnt(this, t, n),
        this
    }
    join(t, n = 1) {
        return wnt(this, t, n),
        this
    }
    wrap(t, n) {
        return pnt(this, t, n),
        this
    }
    setBlockType(t, n = t, r, o = null) {
        return mnt(this, t, n, r, o),
        this
    }
    setNodeMarkup(t, n, r = null, o) {
        return vnt(this, t, n, r, o),
        this
    }
    setNodeAttribute(t, n, r) {
        return this.step(new uf(t, n, r)),
        this
    }
    addNodeMark(t, n) {
        return this.step(new jl(t, n)),
        this
    }
    removeNodeMark(t, n) {
        if (!(n instanceof Sn)) {
            let r = this.doc.nodeAt(t);
            if (!r)
                throw new RangeError("No node at position " + t);
            if (n = n.isInSet(r.marks), !n)
                return this
        }
        return this.step(new jf(t, n)),
        this
    }
    split(t, n = 1, r) {
        return ynt(this, t, n, r),
        this
    }
    addMark(t, n, r) {
        return ant(this, t, n, r),
        this
    }
    removeMark(t, n, r) {
        return lnt(this, t, n, r),
        this
    }
    clearIncompatible(t, n, r) {
        return cnt(this, t, n, r),
        this
    }
}
const W2 = Object.create(null);
class Wt {
    constructor(t, n, r) {
        this.$anchor = t,
        this.$head = n,
        this.ranges = r || [new Tnt(t.min(n), t.max(n))]
    }
    get anchor() {
        return this.$anchor.pos
    }
    get head() {
        return this.$head.pos
    }
    get from() {
        return this.$from.pos
    }
    get to() {
        return this.$to.pos
    }
    get $from() {
        return this.ranges[0].$from
    }
    get $to() {
        return this.ranges[0].$to
    }
    get empty() {
        let t = this.ranges;
        for (let n = 0; n < t.length; n++)
            if (t[n].$from.pos != t[n].$to.pos)
                return !1;
        return !0
    }
    content() {
        return this.$from.doc.slice(this.from, this.to, !0)
    }
    replace(t, n = nt.empty) {
        let r = n.content.lastChild,
        o = null;
        for (let a = 0; a < n.openEnd; a++)
            o = r, r = r.lastChild;
        let i = t.steps.length,
        s = this.ranges;
        for (let a = 0; a < s.length; a++) {
            let {
                $from: l,
                $to: c
            } = s[a],
            u = t.mapping.slice(i);
            t.replaceRange(u.map(l.pos), u.map(c.pos), a ? nt.empty : n),
            a == 0 && UN(t, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1)
        }
    }
    replaceWith(t, n) {
        let r = t.steps.length,
        o = this.ranges;
        for (let i = 0; i < o.length; i++) {
            let {
                $from: s,
                $to: a
            } = o[i],
            l = t.mapping.slice(r),
            c = l.map(s.pos),
            u = l.map(a.pos);
            i ? t.deleteRange(c, u) : (t.replaceRangeWith(c, u, n), UN(t, r, n.isInline ? -1 : 1))
        }
    }
    static findFrom(t, n, r = !1) {
        let o = t.parent.inlineContent ? new qt(t) : Rd(t.node(0), t.parent, t.pos, t.index(), n, r);
        if (o)
            return o;
        for (let i = t.depth - 1; i >= 0; i--) {
            let s = n < 0 ? Rd(t.node(0), t.node(i), t.before(i + 1), t.index(i), n, r) : Rd(t.node(0), t.node(i), t.after(i + 1), t.index(i) + 1, n, r);
            if (s)
                return s
        }
        return null
    }
    static near(t, n = 1) {
        return this.findFrom(t, n) || this.findFrom(t, -n) || new Ts(t.node(0))
    }
    static atStart(t) {
        return Rd(t, t, 0, 0, 1) || new Ts(t)
    }
    static atEnd(t) {
        return Rd(t, t, t.content.size, t.childCount, -1) || new Ts(t)
    }
    static fromJSON(t, n) {
        if (!n || !n.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
        let r = W2[n.type];
        if (!r)
            throw new RangeError(`No selection type ${n.type} defined`);
        return r.fromJSON(t, n)
    }
    static jsonID(t, n) {
        if (t in W2)
            throw new RangeError("Duplicate use of selection JSON ID " + t);
        return W2[t] = n,
        n.prototype.jsonID = t,
        n
    }
    getBookmark() {
        return qt.between(this.$anchor, this.$head).getBookmark()
    }
}
Wt.prototype.visible = !0;
class Tnt {
    constructor(t, n) {
        this.$from = t,
        this.$to = n
    }
}
let zN = !1;
function HN(e) {
    !zN && !e.parent.inlineContent && (zN = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"))
}
class qt extends Wt {
    constructor(t, n = t) {
        HN(t),
        HN(n),
        super(t, n)
    }
    get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null
    }
    map(t, n) {
        let r = t.resolve(n.map(this.head));
        if (!r.parent.inlineContent)
            return Wt.near(r);
        let o = t.resolve(n.map(this.anchor));
        return new qt(o.parent.inlineContent ? o : r, r)
    }
    replace(t, n = nt.empty) {
        if (super.replace(t, n), n == nt.empty) {
            let r = this.$from.marksAcross(this.$to);
            r && t.ensureMarks(r)
        }
    }
    eq(t) {
        return t instanceof qt && t.anchor == this.anchor && t.head == this.head
    }
    getBookmark() {
        return new Zw(this.anchor, this.head)
    }
    toJSON() {
        return {
            type: "text",
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(t, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new qt(t.resolve(n.anchor), t.resolve(n.head))
    }
    static create(t, n, r = n) {
        let o = t.resolve(n);
        return new this(o, r == n ? o : t.resolve(r))
    }
    static between(t, n, r) {
        let o = t.pos - n.pos;
        if ((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent) {
            let i = Wt.findFrom(n, r, !0) || Wt.findFrom(n, -r, !0);
            if (i)
                n = i.$head;
            else
                return Wt.near(n, r)
        }
        return t.parent.inlineContent || (o == 0 ? t = n : (t = (Wt.findFrom(t, -r, !0) || Wt.findFrom(t, r, !0)).$anchor, t.pos < n.pos != o < 0 && (t = n))),
        new qt(t, n)
    }
}
Wt.jsonID("text", qt);
class Zw {
    constructor(t, n) {
        this.anchor = t,
        this.head = n
    }
    map(t) {
        return new Zw(t.map(this.anchor), t.map(this.head))
    }
    resolve(t) {
        return qt.between(t.resolve(this.anchor), t.resolve(this.head))
    }
}
class Pt extends Wt {
    constructor(t) {
        let n = t.nodeAfter,
        r = t.node(0).resolve(t.pos + n.nodeSize);
        super(t, r),
        this.node = n
    }
    map(t, n) {
        let {
            deleted: r,
            pos: o
        } = n.mapResult(this.anchor),
        i = t.resolve(o);
        return r ? Wt.near(i) : new Pt(i)
    }
    content() {
        return new nt(Ne.from(this.node), 0, 0)
    }
    eq(t) {
        return t instanceof Pt && t.anchor == this.anchor
    }
    toJSON() {
        return {
            type: "node",
            anchor: this.anchor
        }
    }
    getBookmark() {
        return new _T(this.anchor)
    }
    static fromJSON(t, n) {
        if (typeof n.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new Pt(t.resolve(n.anchor))
    }
    static create(t, n) {
        return new Pt(t.resolve(n))
    }
    static isSelectable(t) {
        return !t.isText && t.type.spec.selectable !== !1
    }
}
Pt.prototype.visible = !1;
Wt.jsonID("node", Pt);
class _T {
    constructor(t) {
        this.anchor = t
    }
    map(t) {
        let {
            deleted: n,
            pos: r
        } = t.mapResult(this.anchor);
        return n ? new Zw(r, r) : new _T(r)
    }
    resolve(t) {
        let n = t.resolve(this.anchor),
        r = n.nodeAfter;
        return r && Pt.isSelectable(r) ? new Pt(n) : Wt.near(n)
    }
}
class Ts extends Wt {
    constructor(t) {
        super(t.resolve(0), t.resolve(t.content.size))
    }
    replace(t, n = nt.empty) {
        if (n == nt.empty) {
            t.delete(0, t.doc.content.size);
            let r = Wt.atStart(t.doc);
            r.eq(t.selection) || t.setSelection(r)
        } else
            super.replace(t, n)
    }
    toJSON() {
        return {
            type: "all"
        }
    }
    static fromJSON(t) {
        return new Ts(t)
    }
    map(t) {
        return new Ts(t)
    }
    eq(t) {
        return t instanceof Ts
    }
    getBookmark() {
        return Mnt
    }
}
Wt.jsonID("all", Ts);
const Mnt = {
    map() {
        return this
    },
    resolve(e) {
        return new Ts(e)
    }
};
function Rd(e, t, n, r, o, i = !1) {
    if (t.inlineContent)
        return qt.create(e, n);
    for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < t.childCount : s >= 0; s += o) {
        let a = t.child(s);
        if (a.isAtom) {
            if (!i && Pt.isSelectable(a))
                return Pt.create(e, n - (o < 0 ? a.nodeSize : 0))
        } else {
            let l = Rd(e, a, n + o, o < 0 ? a.childCount : 0, o, i);
            if (l)
                return l
        }
        n += a.nodeSize * o
    }
    return null
}
function UN(e, t, n) {
    let r = e.steps.length - 1;
    if (r < t)
        return;
    let o = e.steps[r];
    if (!(o instanceof ao || o instanceof jr))
        return;
    let i = e.mapping.maps[r],
    s;
    i.forEach((a, l, c, u) => {
        s == null && (s = u)
    }),
    e.setSelection(Wt.near(e.doc.resolve(s), n))
}
const qN = 1, Kv = 2, YN = 4;
class Pnt extends oj {
    constructor(t) {
        super(t.doc),
        this.curSelectionFor = 0,
        this.updated = 0,
        this.meta = Object.create(null),
        this.time = Date.now(),
        this.curSelection = t.selection,
        this.storedMarks = t.storedMarks
    }
    get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length),
        this.curSelection
    }
    setSelection(t) {
        if (t.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = t,
        this.curSelectionFor = this.steps.length,
        this.updated = (this.updated | qN) & ~Kv,
        this.storedMarks = null,
        this
    }
    get selectionSet() {
        return (this.updated & qN) > 0
    }
    setStoredMarks(t) {
        return this.storedMarks = t,
        this.updated |= Kv,
        this
    }
    ensureMarks(t) {
        return Sn.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t),
        this
    }
    addStoredMark(t) {
        return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()))
    }
    removeStoredMark(t) {
        return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()))
    }
    get storedMarksSet() {
        return (this.updated & Kv) > 0
    }
    addStep(t, n) {
        super.addStep(t, n),
        this.updated = this.updated & ~Kv,
        this.storedMarks = null
    }
    setTime(t) {
        return this.time = t,
        this
    }
    replaceSelection(t) {
        return this.selection.replace(this, t),
        this
    }
    replaceSelectionWith(t, n = !0) {
        let r = this.selection;
        return n && (t = t.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Sn.none))),
        r.replaceWith(this, t),
        this
    }
    deleteSelection() {
        return this.selection.replace(this),
        this
    }
    insertText(t, n, r) {
        let o = this.doc.type.schema;
        if (n == null)
            return t ? this.replaceSelectionWith(o.text(t), !0) : this.deleteSelection(); {
            if (r == null && (r = n), r = r ?? n, !t)
                return this.deleteRange(n, r);
            let i = this.storedMarks;
            if (!i) {
                let s = this.doc.resolve(n);
                i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r))
            }
            return this.replaceRangeWith(n, r, o.text(t, i)),
            this.selection.empty || this.setSelection(Wt.near(this.selection.$to)),
            this
        }
    }
    setMeta(t, n) {
        return this.meta[typeof t == "string" ? t : t.key] = n,
        this
    }
    getMeta(t) {
        return this.meta[typeof t == "string" ? t : t.key]
    }
    get isGeneric() {
        for (let t in this.meta)
            return !1;
        return !0
    }
    scrollIntoView() {
        return this.updated |= YN,
        this
    }
    get scrolledIntoView() {
        return (this.updated & YN) > 0
    }
}
function KN(e, t) {
    return !t || !e ? e : e.bind(t)
}
class vp {
    constructor(t, n, r) {
        this.name = t,
        this.init = KN(n.init, r),
        this.apply = KN(n.apply, r)
    }
}
const Ent = [new vp("doc", {
        init(e) {
            return e.doc || e.schema.topNodeType.createAndFill()
        },
        apply(e) {
            return e.doc
        }
    }), new vp("selection", {
        init(e, t) {
            return e.selection || Wt.atStart(t.doc)
        },
        apply(e) {
            return e.selection
        }
    }), new vp("storedMarks", {
        init(e) {
            return e.storedMarks || null
        },
        apply(e, t, n, r) {
            return r.selection.$cursor ? e.storedMarks : null
        }
    }), new vp("scrollToSelection", {
        init() {
            return 0
        },
        apply(e, t) {
            return e.scrolledIntoView ? t + 1 : t
        }
    })];
class z2 {
    constructor(t, n) {
        this.schema = t,
        this.plugins = [],
        this.pluginsByKey = Object.create(null),
        this.fields = Ent.slice(),
        n && n.forEach(r => {
            if (this.pluginsByKey[r.key])
                throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
            this.plugins.push(r),
            this.pluginsByKey[r.key] = r,
            r.spec.state && this.fields.push(new vp(r.key, r.spec.state, r))
        })
    }
}
class zd {
    constructor(t) {
        this.config = t
    }
    get schema() {
        return this.config.schema
    }
    get plugins() {
        return this.config.plugins
    }
    apply(t) {
        return this.applyTransaction(t).state
    }
    filterTransaction(t, n = -1) {
        for (let r = 0; r < this.config.plugins.length; r++)
            if (r != n) {
                let o = this.config.plugins[r];
                if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, t, this))
                    return !1
            }
        return !0
    }
    applyTransaction(t) {
        if (!this.filterTransaction(t))
            return {
                state: this,
                transactions: []
            };
        let n = [t],
        r = this.applyInner(t),
        o = null;
        for (; ; ) {
            let i = !1;
            for (let s = 0; s < this.config.plugins.length; s++) {
                let a = this.config.plugins[s];
                if (a.spec.appendTransaction) {
                    let l = o ? o[s].n : 0,
                    c = o ? o[s].state : this,
                    u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
                    if (u && r.filterTransaction(u, s)) {
                        if (u.setMeta("appendedTransaction", t), !o) {
                            o = [];
                            for (let f = 0; f < this.config.plugins.length; f++)
                                o.push(f < s ? {
                                    state: r,
                                    n: n.length
                                }
                                     : {
                                    state: this,
                                    n: 0
                                })
                        }
                        n.push(u),
                        r = r.applyInner(u),
                        i = !0
                    }
                    o && (o[s] = {
                            state: r,
                            n: n.length
                        })
                }
            }
            if (!i)
                return {
                    state: r,
                    transactions: n
                }
        }
    }
    applyInner(t) {
        if (!t.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
        let n = new zd(this.config),
        r = this.config.fields;
        for (let o = 0; o < r.length; o++) {
            let i = r[o];
            n[i.name] = i.apply(t, this[i.name], this, n)
        }
        return n
    }
    get tr() {
        return new Pnt(this)
    }
    static create(t) {
        let n = new z2(t.doc ? t.doc.type.schema : t.schema, t.plugins),
        r = new zd(n);
        for (let o = 0; o < n.fields.length; o++)
            r[n.fields[o].name] = n.fields[o].init(t, r);
        return r
    }
    reconfigure(t) {
        let n = new z2(this.schema, t.plugins),
        r = n.fields,
        o = new zd(n);
        for (let i = 0; i < r.length; i++) {
            let s = r[i].name;
            o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(t, o)
        }
        return o
    }
    toJSON(t) {
        let n = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
        };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map(r => r.toJSON())), t && typeof t == "object")
            for (let r in t) {
                if (r == "doc" || r == "selection")
                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                let o = t[r],
                i = o.spec.state;
                i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]))
            }
        return n
    }
    static fromJSON(t, n, r) {
        if (!n)
            throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!t.schema)
            throw new RangeError("Required config field 'schema' missing");
        let o = new z2(t.schema, t.plugins),
        i = new zd(o);
        return o.fields.forEach(s => {
            if (s.name == "doc")
                i.doc = mu.fromJSON(t.schema, n.doc);
            else if (s.name == "selection")
                i.selection = Wt.fromJSON(i.doc, n.selection);
            else if (s.name == "storedMarks")
                n.storedMarks && (i.storedMarks = n.storedMarks.map(t.schema.markFromJSON));
            else {
                if (r)
                    for (let a in r) {
                        let l = r[a],
                        c = l.spec.state;
                        if (l.key == s.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
                            i[s.name] = c.fromJSON.call(l, t, n[a], i);
                            return
                        }
                    }
                i[s.name] = s.init(t, i)
            }
        }),
        i
    }
}
function ij(e, t, n) {
    for (let r in e) {
        let o = e[r];
        o instanceof Function ? o = o.bind(t) : r == "handleDOMEvents" && (o = ij(o, t, {})),
        n[r] = o
    }
    return n
}
class go {
    constructor(t) {
        this.spec = t,
        this.props = {},
        t.props && ij(t.props, this, this.props),
        this.key = t.key ? t.key.key : sj("plugin")
    }
    getState(t) {
        return t[this.key]
    }
}
const H2 = Object.create(null);
function sj(e) {
    return e in H2 ? e + "$" + ++H2[e] : (H2[e] = 0, e + "$")
}
class ps {
    constructor(t = "key") {
        this.key = sj(t)
    }
    get(t) {
        return t.config.pluginsByKey[this.key]
    }
    getState(t) {
        return t[this.key]
    }
}
const wi = function (e) {
    for (var t = 0; ; t++)
        if (e = e.previousSibling, !e)
            return t
}, Vm = function (e) {
    let t = e.assignedSlot || e.parentNode;
    return t && t.nodeType == 11 ? t.host : t
};
let GN = null;
const ja = function (e, t, n) {
    let r = GN || (GN = document.createRange());
    return r.setEnd(e, n ?? e.nodeValue.length),
    r.setStart(e, t || 0),
    r
}, Lu = function (e, t, n, r) {
    return n && (XN(e, t, n, r, -1) || XN(e, t, n, r, 1))
}, Ont = /^(img|br|input|textarea|hr)$/i;
function XN(e, t, n, r, o) {
    for (; ; ) {
        if (e == n && t == r)
            return !0;
        if (t == (o < 0 ? 0 : Zs(e))) {
            let i = e.parentNode;
            if (!i || i.nodeType != 1 || Ant(e) || Ont.test(e.nodeName) || e.contentEditable == "false")
                return !1;
            t = wi(e) + (o < 0 ? 0 : 1),
            e = i
        } else if (e.nodeType == 1) {
            if (e = e.childNodes[t + (o < 0 ? -1 : 0)], e.contentEditable == "false")
                return !1;
            t = o < 0 ? Zs(e) : 0
        } else
            return !1
    }
}
function Zs(e) {
    return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function $nt(e, t, n) {
    for (let r = t == 0, o = t == Zs(e); r || o; ) {
        if (e == n)
            return !0;
        let i = wi(e);
        if (e = e.parentNode, !e)
            return !1;
        r = r && i == 0,
        o = o && i == Zs(e)
    }
}
function Ant(e) {
    let t;
    for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode);
    return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e)
}
const Qw = function (e) {
    return e.focusNode && Lu(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
};
function qc(e, t) {
    let n = document.createEvent("Event");
    return n.initEvent("keydown", !0, !0),
    n.keyCode = e,
    n.key = n.code = t,
    n
}
function Dnt(e) {
    let t = e.activeElement;
    for (; t && t.shadowRoot; )
        t = t.shadowRoot.activeElement;
    return t
}
const ac = typeof navigator < "u" ? navigator : null, JN = typeof document < "u" ? document : null, wc = ac && ac.userAgent || "", nS = /Edge\/(\d+)/.exec(wc), aj = /MSIE \d/.exec(wc), rS = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(wc), Jo = !!(aj || rS || nS), Gl = aj ? document.documentMode : rS ? +rS[1] : nS ? +nS[1] : 0, Ns = !Jo && /gecko\/(\d+)/i.test(wc);
Ns &&  + (/Firefox\/(\d+)/.exec(wc) || [0, 0])[1];
const oS = !Jo && /Chrome\/(\d+)/.exec(wc), To = !!oS, Nnt = oS ? +oS[1] : 0, Po = !Jo && !!ac && /Apple Computer/.test(ac.vendor), zf = Po && (/Mobile\/\w+/.test(wc) || !!ac && ac.maxTouchPoints > 2), zi = zf || (ac ? /Mac/.test(ac.platform) : !1), bs = /Android \d/.test(wc), eb = !!JN && "webkitFontSmoothing" in JN.documentElement.style, Rnt = eb ?  + (/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function Lnt(e) {
    return {
        left: 0,
        right: e.documentElement.clientWidth,
        top: 0,
        bottom: e.documentElement.clientHeight
    }
}
function Cl(e, t) {
    return typeof e == "number" ? e : e[t]
}
function Bnt(e) {
    let t = e.getBoundingClientRect(),
    n = t.width / e.offsetWidth || 1,
    r = t.height / e.offsetHeight || 1;
    return {
        left: t.left,
        right: t.left + e.clientWidth * n,
        top: t.top,
        bottom: t.top + e.clientHeight * r
    }
}
function ZN(e, t, n) {
    let r = e.someProp("scrollThreshold") || 0,
    o = e.someProp("scrollMargin") || 5,
    i = e.dom.ownerDocument;
    for (let s = n || e.dom; s; s = Vm(s)) {
        if (s.nodeType != 1)
            continue;
        let a = s,
        l = a == i.body,
        c = l ? Lnt(i) : Bnt(a),
        u = 0,
        f = 0;
        if (t.top < c.top + Cl(r, "top") ? f =  - (c.top - t.top + Cl(o, "top")) : t.bottom > c.bottom - Cl(r, "bottom") && (f = t.bottom - c.bottom + Cl(o, "bottom")), t.left < c.left + Cl(r, "left") ? u =  - (c.left - t.left + Cl(o, "left")) : t.right > c.right - Cl(r, "right") && (u = t.right - c.right + Cl(o, "right")), u || f)
            if (l)
                i.defaultView.scrollBy(u, f);
            else {
                let p = a.scrollLeft,
                m = a.scrollTop;
                f && (a.scrollTop += f),
                u && (a.scrollLeft += u);
                let v = a.scrollLeft - p,
                y = a.scrollTop - m;
                t = {
                    left: t.left - v,
                    top: t.top - y,
                    right: t.right - v,
                    bottom: t.bottom - y
                }
            }
        if (l)
            break
    }
}
function Vnt(e) {
    let t = e.dom.getBoundingClientRect(),
    n = Math.max(0, t.top),
    r,
    o;
    for (let i = (t.left + t.right) / 2, s = n + 1; s < Math.min(innerHeight, t.bottom); s += 5) {
        let a = e.root.elementFromPoint(i, s);
        if (!a || a == e.dom || !e.dom.contains(a))
            continue;
        let l = a.getBoundingClientRect();
        if (l.top >= n - 20) {
            r = a,
            o = l.top;
            break
        }
    }
    return {
        refDOM: r,
        refTop: o,
        stack: lj(e.dom)
    }
}
function lj(e) {
    let t = [],
    n = e.ownerDocument;
    for (let r = e; r && (t.push({
                dom: r,
                top: r.scrollTop,
                left: r.scrollLeft
            }), e != n); r = Vm(r));
    return t
}
function Fnt({
    refDOM: e,
    refTop: t,
    stack: n
}) {
    let r = e ? e.getBoundingClientRect().top : 0;
    cj(n, r == 0 ? 0 : r - t)
}
function cj(e, t) {
    for (let n = 0; n < e.length; n++) {
        let {
            dom: r,
            top: o,
            left: i
        } = e[n];
        r.scrollTop != o + t && (r.scrollTop = o + t),
        r.scrollLeft != i && (r.scrollLeft = i)
    }
}
let Td = null;
function jnt(e) {
    if (e.setActive)
        return e.setActive();
    if (Td)
        return e.focus(Td);
    let t = lj(e);
    e.focus(Td == null ? {
        get preventScroll() {
            return Td = {
                preventScroll: !0
            },
            !0
        }
    }
         : void 0),
    Td || (Td = !1, cj(t, 0))
}
function uj(e, t) {
    let n,
    r = 2e8,
    o,
    i = 0,
    s = t.top,
    a = t.top;
    for (let l = e.firstChild, c = 0; l; l = l.nextSibling, c++) {
        let u;
        if (l.nodeType == 1)
            u = l.getClientRects();
        else if (l.nodeType == 3)
            u = ja(l).getClientRects();
        else
            continue;
        for (let f = 0; f < u.length; f++) {
            let p = u[f];
            if (p.top <= s && p.bottom >= a) {
                s = Math.max(p.bottom, s),
                a = Math.min(p.top, a);
                let m = p.left > t.left ? p.left - t.left : p.right < t.left ? t.left - p.right : 0;
                if (m < r) {
                    n = l,
                    r = m,
                    o = m && n.nodeType == 3 ? {
                        left: p.right < t.left ? p.right : p.left,
                        top: t.top
                    }
                     : t,
                    l.nodeType == 1 && m && (i = c + (t.left >= (p.left + p.right) / 2 ? 1 : 0));
                    continue
                }
            }
            !n && (t.left >= p.right && t.top >= p.top || t.left >= p.left && t.top >= p.bottom) && (i = c + 1)
        }
    }
    return n && n.nodeType == 3 ? Wnt(n, o) : !n || r && n.nodeType == 1 ? {
        node: e,
        offset: i
    }
     : uj(n, o)
}
function Wnt(e, t) {
    let n = e.nodeValue.length,
    r = document.createRange();
    for (let o = 0; o < n; o++) {
        r.setEnd(e, o + 1),
        r.setStart(e, o);
        let i = Pl(r, 1);
        if (i.top != i.bottom && kT(t, i))
            return {
                node: e,
                offset: o + (t.left >= (i.left + i.right) / 2 ? 1 : 0)
            }
    }
    return {
        node: e,
        offset: 0
    }
}
function kT(e, t) {
    return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1
}
function znt(e, t) {
    let n = e.parentNode;
    return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e
}
function Hnt(e, t, n) {
    let {
        node: r,
        offset: o
    } = uj(t, n),
    i = -1;
    if (r.nodeType == 1 && !r.firstChild) {
        let s = r.getBoundingClientRect();
        i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1
    }
    return e.docView.posFromDOM(r, o, i)
}
function Unt(e, t, n, r) {
    let o = -1;
    for (let i = t, s = !1; i != e.dom; ) {
        let a = e.docView.nearestDesc(i, !0);
        if (!a)
            return null;
        if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent && !s || !a.contentDOM)) {
            let l = a.dom.getBoundingClientRect();
            if (a.node.isBlock && a.parent && !s && (s = !0, l.left > r.left || l.top > r.top ? o = a.posBefore : (l.right < r.left || l.bottom < r.top) && (o = a.posAfter)), !a.contentDOM && o < 0)
                return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter
        }
        i = a.dom.parentNode
    }
    return o > -1 ? o : e.docView.posFromDOM(t, n, -1)
}
function dj(e, t, n) {
    let r = e.childNodes.length;
    if (r && n.top < n.bottom)
        for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), i = o; ; ) {
            let s = e.childNodes[i];
            if (s.nodeType == 1) {
                let a = s.getClientRects();
                for (let l = 0; l < a.length; l++) {
                    let c = a[l];
                    if (kT(t, c))
                        return dj(s, t, c)
                }
            }
            if ((i = (i + 1) % r) == o)
                break
        }
    return e
}
function qnt(e, t) {
    let n = e.dom.ownerDocument,
    r,
    o = 0;
    if (n.caretPositionFromPoint)
        try {
            let l = n.caretPositionFromPoint(t.left, t.top);
            l && ({
                offsetNode: r,
                offset: o
            } = l)
        } catch {}
    if (!r && n.caretRangeFromPoint) {
        let l = n.caretRangeFromPoint(t.left, t.top);
        l && ({
            startContainer: r,
            startOffset: o
        } = l)
    }
    let i = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top),
    s;
    if (!i || !e.dom.contains(i.nodeType != 1 ? i.parentNode : i)) {
        let l = e.dom.getBoundingClientRect();
        if (!kT(t, l) || (i = dj(e.dom, t, l), !i))
            return null
    }
    if (Po)
        for (let l = i; r && l; l = Vm(l))
            l.draggable && (r = void 0);
    if (i = znt(i, t), r) {
        if (Ns && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
            let l = r.childNodes[o],
            c;
            l.nodeName == "IMG" && (c = l.getBoundingClientRect()).right <= t.left && c.bottom > t.top && o++
        }
        r == e.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && t.top > r.lastChild.getBoundingClientRect().bottom ? s = e.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (s = Unt(e, r, o, t))
    }
    s == null && (s = Hnt(e, i, t));
    let a = e.docView.nearestDesc(i, !0);
    return {
        pos: s,
        inside: a ? a.posAtStart - a.border : -1
    }
}
function Pl(e, t) {
    let n = e.getClientRects();
    return n.length ? n[t < 0 ? 0 : n.length - 1] : e.getBoundingClientRect()
}
const Ynt = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function fj(e, t, n) {
    let {
        node: r,
        offset: o,
        atom: i
    } = e.docView.domFromPos(t, n < 0 ? -1 : 1),
    s = eb || Ns;
    if (r.nodeType == 3)
        if (s && (Ynt.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
            let l = Pl(ja(r, o, o), n);
            if (Ns && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
                let c = Pl(ja(r, o - 1, o - 1), -1);
                if (c.top == l.top) {
                    let u = Pl(ja(r, o, o + 1), -1);
                    if (u.top != l.top)
                        return np(u, u.left < c.left)
                }
            }
            return l
        } else {
            let l = o,
            c = o,
            u = n < 0 ? 1 : -1;
            return n < 0 && !o ? (c++, u = -1) : n >= 0 && o == r.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++,
            np(Pl(ja(r, l, c), 1), u < 0)
        }
    if (!e.state.doc.resolve(t - (i || 0)).parent.inlineContent) {
        if (i == null && o && (n < 0 || o == Zs(r))) {
            let l = r.childNodes[o - 1];
            if (l.nodeType == 1)
                return U2(l.getBoundingClientRect(), !1)
        }
        if (i == null && o < Zs(r)) {
            let l = r.childNodes[o];
            if (l.nodeType == 1)
                return U2(l.getBoundingClientRect(), !0)
        }
        return U2(r.getBoundingClientRect(), n >= 0)
    }
    if (i == null && o && (n < 0 || o == Zs(r))) {
        let l = r.childNodes[o - 1],
        c = l.nodeType == 3 ? ja(l, Zs(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
        if (c)
            return np(Pl(c, 1), !1)
    }
    if (i == null && o < Zs(r)) {
        let l = r.childNodes[o];
        for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
            l = l.nextSibling;
        let c = l ? l.nodeType == 3 ? ja(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
        if (c)
            return np(Pl(c, -1), !0)
    }
    return np(Pl(r.nodeType == 3 ? ja(r) : r, -n), n >= 0)
}
function np(e, t) {
    if (e.width == 0)
        return e;
    let n = t ? e.left : e.right;
    return {
        top: e.top,
        bottom: e.bottom,
        left: n,
        right: n
    }
}
function U2(e, t) {
    if (e.height == 0)
        return e;
    let n = t ? e.top : e.bottom;
    return {
        top: n,
        bottom: n,
        left: e.left,
        right: e.right
    }
}
function hj(e, t, n) {
    let r = e.state,
    o = e.root.activeElement;
    r != t && e.updateState(t),
    o != e.dom && e.focus();
    try {
        return n()
    } finally {
        r != t && e.updateState(r),
        o != e.dom && o && o.focus()
    }
}
function Knt(e, t, n) {
    let r = t.selection,
    o = n == "up" ? r.$from : r.$to;
    return hj(e, t, () => {
        let {
            node: i
        } = e.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
        for (; ; ) {
            let a = e.docView.nearestDesc(i, !0);
            if (!a)
                break;
            if (a.node.isBlock) {
                i = a.contentDOM || a.dom;
                break
            }
            i = a.dom.parentNode
        }
        let s = fj(e, o.pos, 1);
        for (let a = i.firstChild; a; a = a.nextSibling) {
            let l;
            if (a.nodeType == 1)
                l = a.getClientRects();
            else if (a.nodeType == 3)
                l = ja(a, 0, a.nodeValue.length).getClientRects();
            else
                continue;
            for (let c = 0; c < l.length; c++) {
                let u = l[c];
                if (u.bottom > u.top + 1 && (n == "up" ? s.top - u.top > (u.bottom - s.top) * 2 : u.bottom - s.bottom > (s.bottom - u.top) * 2))
                    return !1
            }
        }
        return !0
    })
}
const Gnt = /[\u0590-\u08ac]/;
function Xnt(e, t, n) {
    let {
        $head: r
    } = t.selection;
    if (!r.parent.isTextblock)
        return !1;
    let o = r.parentOffset,
    i = !o,
    s = o == r.parent.content.size,
    a = e.domSelection();
    return !Gnt.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? i : s : hj(e, t, () => {
        let {
            focusNode: l,
            focusOffset: c,
            anchorNode: u,
            anchorOffset: f
        } = e.domSelectionRange(),
        p = a.caretBidiLevel;
        a.modify("move", n, "character");
        let m = r.depth ? e.docView.domAfterPos(r.before()) : e.dom, {
            focusNode: v,
            focusOffset: y
        } = e.domSelectionRange(),
        b = v && !m.contains(v.nodeType == 1 ? v : v.parentNode) || l == v && c == y;
        try {
            a.collapse(u, f),
            l && (l != u || c != f) && a.extend && a.extend(l, c)
        } catch {}
        return p != null && (a.caretBidiLevel = p),
        b
    })
}
let QN = null, e5 = null, t5 = !1;
function Jnt(e, t, n) {
    return QN == t && e5 == n ? t5 : (QN = t, e5 = n, t5 = n == "up" || n == "down" ? Knt(e, t, n) : Xnt(e, t, n))
}
const Ms = 0, n5 = 1, Hd = 2, va = 3;
class Sg {
    constructor(t, n, r, o) {
        this.parent = t,
        this.children = n,
        this.dom = r,
        this.contentDOM = o,
        this.dirty = Ms,
        r.pmViewDesc = this
    }
    matchesWidget(t) {
        return !1
    }
    matchesMark(t) {
        return !1
    }
    matchesNode(t, n, r) {
        return !1
    }
    matchesHack(t) {
        return !1
    }
    parseRule() {
        return null
    }
    stopEvent(t) {
        return !1
    }
    get size() {
        let t = 0;
        for (let n = 0; n < this.children.length; n++)
            t += this.children[n].size;
        return t
    }
    get border() {
        return 0
    }
    destroy() {
        this.parent = void 0,
        this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let t = 0; t < this.children.length; t++)
            this.children[t].destroy()
    }
    posBeforeChild(t) {
        for (let n = 0, r = this.posAtStart; ; n++) {
            let o = this.children[n];
            if (o == t)
                return r;
            r += o.size
        }
    }
    get posBefore() {
        return this.parent.posBeforeChild(this)
    }
    get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
    }
    get posAfter() {
        return this.posBefore + this.size
    }
    get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border
    }
    localPosFromDOM(t, n, r) {
        if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
            if (r < 0) {
                let i,
                s;
                if (t == this.contentDOM)
                    i = t.childNodes[n - 1];
                else {
                    for (; t.parentNode != this.contentDOM; )
                        t = t.parentNode;
                    i = t.previousSibling
                }
                for (; i && !((s = i.pmViewDesc) && s.parent == this); )
                    i = i.previousSibling;
                return i ? this.posBeforeChild(s) + s.size : this.posAtStart
            } else {
                let i,
                s;
                if (t == this.contentDOM)
                    i = t.childNodes[n];
                else {
                    for (; t.parentNode != this.contentDOM; )
                        t = t.parentNode;
                    i = t.nextSibling
                }
                for (; i && !((s = i.pmViewDesc) && s.parent == this); )
                    i = i.nextSibling;
                return i ? this.posBeforeChild(s) : this.posAtEnd
            }
        let o;
        if (t == this.dom && this.contentDOM)
            o = n > wi(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
            o = t.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
            if (n == 0)
                for (let i = t; ; i = i.parentNode) {
                    if (i == this.dom) {
                        o = !1;
                        break
                    }
                    if (i.previousSibling)
                        break
                }
            if (o == null && n == t.childNodes.length)
                for (let i = t; ; i = i.parentNode) {
                    if (i == this.dom) {
                        o = !0;
                        break
                    }
                    if (i.nextSibling)
                        break
                }
        }
        return o ?? r > 0 ? this.posAtEnd : this.posAtStart
    }
    nearestDesc(t, n = !1) {
        for (let r = !0, o = t; o; o = o.parentNode) {
            let i = this.getDesc(o),
            s;
            if (i && (!n || i.node))
                if (r && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(t.nodeType == 1 ? t : t.parentNode) : s == t))
                    r = !1;
                else
                    return i
        }
    }
    getDesc(t) {
        let n = t.pmViewDesc;
        for (let r = n; r; r = r.parent)
            if (r == this)
                return n
    }
    posFromDOM(t, n, r) {
        for (let o = t; o; o = o.parentNode) {
            let i = this.getDesc(o);
            if (i)
                return i.localPosFromDOM(t, n, r)
        }
        return -1
    }
    descAt(t) {
        for (let n = 0, r = 0; n < this.children.length; n++) {
            let o = this.children[n],
            i = r + o.size;
            if (r == t && i != r) {
                for (; !o.border && o.children.length; )
                    o = o.children[0];
                return o
            }
            if (t < i)
                return o.descAt(t - r - o.border);
            r = i
        }
    }
    domFromPos(t, n) {
        if (!this.contentDOM)
            return {
                node: this.dom,
                offset: 0,
                atom: t + 1
            };
        let r = 0,
        o = 0;
        for (let i = 0; r < this.children.length; r++) {
            let s = this.children[r],
            a = i + s.size;
            if (a > t || s instanceof mj) {
                o = t - i;
                break
            }
            i = a
        }
        if (o)
            return this.children[r].domFromPos(o - this.children[r].border, n);
        for (let i; r && !(i = this.children[r - 1]).size && i instanceof pj && i.side >= 0; r--);
        if (n <= 0) {
            let i,
            s = !0;
            for (; i = r ? this.children[r - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); r--, s = !1);
            return i && n && s && !i.border && !i.domAtom ? i.domFromPos(i.size, n) : {
                node: this.contentDOM,
                offset: i ? wi(i.dom) + 1 : 0
            }
        } else {
            let i,
            s = !0;
            for (; i = r < this.children.length ? this.children[r] : null, !(!i || i.dom.parentNode == this.contentDOM); r++, s = !1);
            return i && s && !i.border && !i.domAtom ? i.domFromPos(0, n) : {
                node: this.contentDOM,
                offset: i ? wi(i.dom) : this.contentDOM.childNodes.length
            }
        }
    }
    parseRange(t, n, r = 0) {
        if (this.children.length == 0)
            return {
                node: this.contentDOM,
                from: t,
                to: n,
                fromOffset: 0,
                toOffset: this.contentDOM.childNodes.length
            };
        let o = -1,
        i = -1;
        for (let s = r, a = 0; ; a++) {
            let l = this.children[a],
            c = s + l.size;
            if (o == -1 && t <= c) {
                let u = s + l.border;
                if (t >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
                    return l.parseRange(t, n, u);
                t = s;
                for (let f = a; f > 0; f--) {
                    let p = this.children[f - 1];
                    if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(1)) {
                        o = wi(p.dom) + 1;
                        break
                    }
                    t -= p.size
                }
                o == -1 && (o = 0)
            }
            if (o > -1 && (c > n || a == this.children.length - 1)) {
                n = c;
                for (let u = a + 1; u < this.children.length; u++) {
                    let f = this.children[u];
                    if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
                        i = wi(f.dom);
                        break
                    }
                    n += f.size
                }
                i == -1 && (i = this.contentDOM.childNodes.length);
                break
            }
            s = c
        }
        return {
            node: this.contentDOM,
            from: t,
            to: n,
            fromOffset: o,
            toOffset: i
        }
    }
    emptyChildAt(t) {
        if (this.border || !this.contentDOM || !this.children.length)
            return !1;
        let n = this.children[t < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(t)
    }
    domAfterPos(t) {
        let {
            node: n,
            offset: r
        } = this.domFromPos(t, 0);
        if (n.nodeType != 1 || r == n.childNodes.length)
            throw new RangeError("No node after pos " + t);
        return n.childNodes[r]
    }
    setSelection(t, n, r, o = !1) {
        let i = Math.min(t, n),
        s = Math.max(t, n);
        for (let p = 0, m = 0; p < this.children.length; p++) {
            let v = this.children[p],
            y = m + v.size;
            if (i > m && s < y)
                return v.setSelection(t - m - v.border, n - m - v.border, r, o);
            m = y
        }
        let a = this.domFromPos(t, t ? -1 : 1),
        l = n == t ? a : this.domFromPos(n, n ? -1 : 1),
        c = r.getSelection(),
        u = !1;
        if ((Ns || Po) && t == n) {
            let {
                node: p,
                offset: m
            } = a;
            if (p.nodeType == 3) {
                if (u = !!(m && p.nodeValue[m - 1] == `
`), u && m == p.nodeValue.length)
                    for (let v = p, y; v; v = v.parentNode) {
                        if (y = v.nextSibling) {
                            y.nodeName == "BR" && (a = l = {
                                    node: y.parentNode,
                                    offset: wi(y) + 1
                                });
                            break
                        }
                        let b = v.pmViewDesc;
                        if (b && b.node && b.node.isBlock)
                            break
                    }
            } else {
                let v = p.childNodes[m - 1];
                u = v && (v.nodeName == "BR" || v.contentEditable == "false")
            }
        }
        if (Ns && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
            let p = c.focusNode.childNodes[c.focusOffset];
            p && p.contentEditable == "false" && (o = !0)
        }
        if (!(o || u && Po) && Lu(a.node, a.offset, c.anchorNode, c.anchorOffset) && Lu(l.node, l.offset, c.focusNode, c.focusOffset))
            return;
        let f = !1;
        if ((c.extend || t == n) && !u) {
            c.collapse(a.node, a.offset);
            try {
                t != n && c.extend(l.node, l.offset),
                f = !0
            } catch {}
        }
        if (!f) {
            if (t > n) {
                let m = a;
                a = l,
                l = m
            }
            let p = document.createRange();
            p.setEnd(l.node, l.offset),
            p.setStart(a.node, a.offset),
            c.removeAllRanges(),
            c.addRange(p)
        }
    }
    ignoreMutation(t) {
        return !this.contentDOM && t.type != "selection"
    }
    get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
    }
    markDirty(t, n) {
        for (let r = 0, o = 0; o < this.children.length; o++) {
            let i = this.children[o],
            s = r + i.size;
            if (r == s ? t <= s && n >= r : t < s && n > r) {
                let a = r + i.border,
                l = s - i.border;
                if (t >= a && n <= l) {
                    this.dirty = t == r || n == s ? Hd : n5,
                    t == a && n == l && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = va : i.markDirty(t - a, n - a);
                    return
                } else
                    i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? Hd : va
            }
            r = s
        }
        this.dirty = Hd
    }
    markParentsDirty() {
        let t = 1;
        for (let n = this.parent; n; n = n.parent, t++) {
            let r = t == 1 ? Hd : n5;
            n.dirty < r && (n.dirty = r)
        }
    }
    get domAtom() {
        return !1
    }
    get ignoreForCoords() {
        return !1
    }
}
class pj extends Sg {
    constructor(t, n, r, o) {
        let i,
        s = n.type.toDOM;
        if (typeof s == "function" && (s = s(r, () => {
                    if (!i)
                        return o;
                    if (i.parent)
                        return i.parent.posBeforeChild(i)
                    })), !n.type.spec.raw) {
            if (s.nodeType != 1) {
                let a = document.createElement("span");
                a.appendChild(s),
                s = a
            }
            s.contentEditable = "false",
            s.classList.add("ProseMirror-widget")
        }
    super(t, [], s, null),
    this.widget = n,
    this.widget = n,
    i = this
}
matchesWidget(t) {
    return this.dirty == Ms && t.type.eq(this.widget.type)
}
parseRule() {
    return {
        ignore: !0
    }
}
stopEvent(t) {
    let n = this.widget.spec.stopEvent;
    return n ? n(t) : !1
}
ignoreMutation(t) {
    return t.type != "selection" || this.widget.spec.ignoreSelection
}
destroy() {
    this.widget.type.destroy(this.dom),
    super.destroy()
}
get domAtom() {
    return !0
}
get side() {
    return this.widget.type.side
}
}
class Znt extends Sg {
    constructor(t, n, r, o) {
        super(t, [], n, null),
        this.textDOM = r,
        this.text = o
    }
    get size() {
        return this.text.length
    }
    localPosFromDOM(t, n) {
        return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
    }
    domFromPos(t) {
        return {
            node: this.textDOM,
            offset: t
        }
    }
    ignoreMutation(t) {
        return t.type === "characterData" && t.target.nodeValue == t.oldValue
    }
}
class Bu extends Sg {
    constructor(t, n, r, o) {
        super(t, [], r, o),
        this.mark = n
    }
    static create(t, n, r, o) {
        let i = o.nodeViews[n.type.name],
        s = i && i(n, o, r);
        return (!s || !s.dom) && (s = ta.renderSpec(document, n.type.spec.toDOM(n, r))),
        new Bu(t, n, s.dom, s.contentDOM || s.dom)
    }
    parseRule() {
        return this.dirty & va || this.mark.type.spec.reparseInView ? null : {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM || void 0
        }
    }
    matchesMark(t) {
        return this.dirty != va && this.mark.eq(t)
    }
    markDirty(t, n) {
        if (super.markDirty(t, n), this.dirty != Ms) {
            let r = this.parent;
            for (; !r.node; )
                r = r.parent;
            r.dirty < this.dirty && (r.dirty = this.dirty),
            this.dirty = Ms
        }
    }
    slice(t, n, r) {
        let o = Bu.create(this.parent, this.mark, !0, r),
        i = this.children,
        s = this.size;
        n < s && (i = aS(i, n, s, r)),
        t > 0 && (i = aS(i, 0, t, r));
        for (let a = 0; a < i.length; a++)
            i[a].parent = o;
        return o.children = i,
        o
    }
}
class Vu extends Sg {
    constructor(t, n, r, o, i, s, a, l, c) {
        super(t, [], i, s),
        this.node = n,
        this.outerDeco = r,
        this.innerDeco = o,
        this.nodeDOM = a,
        s && this.updateChildren(l, c)
    }
    static create(t, n, r, o, i, s) {
        let a = i.nodeViews[n.type.name],
        l,
        c = a && a(n, i, () => {
            if (!l)
                return s;
            if (l.parent)
                return l.parent.posBeforeChild(l)
        }, r, o),
        u = c && c.dom,
        f = c && c.contentDOM;
        if (n.isText) {
            if (!u)
                u = document.createTextNode(n.text);
            else if (u.nodeType != 3)
                throw new RangeError("Text must be rendered as a DOM text node")
        } else
            u || ({
                dom: u,
                contentDOM: f
            } = ta.renderSpec(document, n.type.spec.toDOM(n)));
        !f && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
        let p = u;
        return u = yj(u, r, n),
        c ? l = new Qnt(t, n, r, o, u, f || null, p, c, i, s + 1) : n.isText ? new tb(t, n, r, o, u, p, i) : new Vu(t, n, r, o, u, f || null, p, i, s + 1)
    }
    parseRule() {
        if (this.node.type.spec.reparseInView)
            return null;
        let t = {
            node: this.node.type.name,
            attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"), !this.contentDOM)
            t.getContent = () => this.node.content;
        else if (!this.contentLost)
            t.contentElement = this.contentDOM;
        else {
            for (let n = this.children.length - 1; n >= 0; n--) {
                let r = this.children[n];
                if (this.dom.contains(r.dom.parentNode)) {
                    t.contentElement = r.dom.parentNode;
                    break
                }
            }
            t.contentElement || (t.getContent = () => Ne.empty)
        }
        return t
    }
    matchesNode(t, n, r) {
        return this.dirty == Ms && t.eq(this.node) && sS(n, this.outerDeco) && r.eq(this.innerDeco)
    }
    get size() {
        return this.node.nodeSize
    }
    get border() {
        return this.node.isLeaf ? 0 : 1
    }
    updateChildren(t, n) {
        let r = this.node.inlineContent,
        o = n,
        i = t.composing ? this.localCompositionInfo(t, n) : null,
        s = i && i.pos > -1 ? i : null,
        a = i && i.pos < 0,
        l = new trt(this, s && s.node, t);
        ort(this.node, this.innerDeco, (c, u, f) => {
            c.spec.marks ? l.syncToMarks(c.spec.marks, r, t) : c.type.side >= 0 && !f && l.syncToMarks(u == this.node.childCount ? Sn.none : this.node.child(u).marks, r, t),
            l.placeWidget(c, t, o)
        }, (c, u, f, p) => {
            l.syncToMarks(c.marks, r, t);
            let m;
            l.findNodeMatch(c, u, f, p) || a && t.state.selection.from > o && t.state.selection.to < o + c.nodeSize && (m = l.findIndexWithChild(i.node)) > -1 && l.updateNodeAt(c, u, f, m, t) || l.updateNextNode(c, u, f, t, p) || l.addNode(c, u, f, t, o),
            o += c.nodeSize
        }),
        l.syncToMarks([], r, t),
        this.node.isTextblock && l.addTextblockHacks(),
        l.destroyRest(),
        (l.changed || this.dirty == Hd) && (s && this.protectLocalComposition(t, s), gj(this.contentDOM, this.children, t), zf && irt(this.dom))
    }
    localCompositionInfo(t, n) {
        let {
            from: r,
            to: o
        } = t.state.selection;
        if (!(t.state.selection instanceof qt) || r < n || o > n + this.node.content.size)
            return null;
        let i = t.domSelectionRange(),
        s = srt(i.focusNode, i.focusOffset);
        if (!s || !this.dom.contains(s.parentNode))
            return null;
        if (this.node.inlineContent) {
            let a = s.nodeValue,
            l = art(this.node.content, a, r - n, o - n);
            return l < 0 ? null : {
                node: s,
                pos: l,
                text: a
            }
        } else
            return {
                node: s,
                pos: -1,
                text: ""
            }
    }
    protectLocalComposition(t, {
        node: n,
        pos: r,
        text: o
    }) {
        if (this.getDesc(n))
            return;
        let i = n;
        for (; i.parentNode != this.contentDOM; i = i.parentNode) {
            for (; i.previousSibling; )
                i.parentNode.removeChild(i.previousSibling);
            for (; i.nextSibling; )
                i.parentNode.removeChild(i.nextSibling);
            i.pmViewDesc && (i.pmViewDesc = void 0)
        }
        let s = new Znt(this, i, n, o);
        t.input.compositionNodes.push(s),
        this.children = aS(this.children, r, r + o.length, t, s)
    }
    update(t, n, r, o) {
        return this.dirty == va || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, o), !0)
    }
    updateInner(t, n, r, o) {
        this.updateOuterDeco(n),
        this.node = t,
        this.innerDeco = r,
        this.contentDOM && this.updateChildren(o, this.posAtStart),
        this.dirty = Ms
    }
    updateOuterDeco(t) {
        if (sS(t, this.outerDeco))
            return;
        let n = this.nodeDOM.nodeType != 1,
        r = this.dom;
        this.dom = vj(this.dom, this.nodeDOM, iS(this.outerDeco, this.node, n), iS(t, this.node, n)),
        this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this),
        this.outerDeco = t
    }
    selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0)
    }
    deselectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable")
    }
    get domAtom() {
        return this.node.isAtom
    }
}
function r5(e, t, n, r, o) {
    return yj(r, t, e),
    new Vu(void 0, e, t, n, r, r, r, o, 0)
}
class tb extends Vu {
    constructor(t, n, r, o, i, s, a) {
        super(t, n, r, o, i, null, s, a, 0)
    }
    parseRule() {
        let t = this.nodeDOM.parentNode;
        for (; t && t != this.dom && !t.pmIsDeco; )
            t = t.parentNode;
        return {
            skip: t || !0
        }
    }
    update(t, n, r, o) {
        return this.dirty == va || this.dirty != Ms && !this.inParent() || !t.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Ms || t.text != this.node.text) && t.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = t.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = t, this.dirty = Ms, !0)
    }
    inParent() {
        let t = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == t)
                return !0;
        return !1
    }
    domFromPos(t) {
        return {
            node: this.nodeDOM,
            offset: t
        }
    }
    localPosFromDOM(t, n, r) {
        return t == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(t, n, r)
    }
    ignoreMutation(t) {
        return t.type != "characterData" && t.type != "selection"
    }
    slice(t, n, r) {
        let o = this.node.cut(t, n),
        i = document.createTextNode(o.text);
        return new tb(this.parent, o, this.outerDeco, this.innerDeco, i, i, r)
    }
    markDirty(t, n) {
        super.markDirty(t, n),
        this.dom != this.nodeDOM && (t == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = va)
    }
    get domAtom() {
        return !1
    }
}
class mj extends Sg {
    parseRule() {
        return {
            ignore: !0
        }
    }
    matchesHack(t) {
        return this.dirty == Ms && this.dom.nodeName == t
    }
    get domAtom() {
        return !0
    }
    get ignoreForCoords() {
        return this.dom.nodeName == "IMG"
    }
}
class Qnt extends Vu {
    constructor(t, n, r, o, i, s, a, l, c, u) {
        super(t, n, r, o, i, s, a, c, u),
        this.spec = l
    }
    update(t, n, r, o) {
        if (this.dirty == va)
            return !1;
        if (this.spec.update) {
            let i = this.spec.update(t, n, r);
            return i && this.updateInner(t, n, r, o),
            i
        } else
            return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, o)
    }
    selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
    }
    deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
    }
    setSelection(t, n, r, o) {
        this.spec.setSelection ? this.spec.setSelection(t, n, r) : super.setSelection(t, n, r, o)
    }
    destroy() {
        this.spec.destroy && this.spec.destroy(),
        super.destroy()
    }
    stopEvent(t) {
        return this.spec.stopEvent ? this.spec.stopEvent(t) : !1
    }
    ignoreMutation(t) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t)
    }
}
function gj(e, t, n) {
    let r = e.firstChild,
    o = !1;
    for (let i = 0; i < t.length; i++) {
        let s = t[i],
        a = s.dom;
        if (a.parentNode == e) {
            for (; a != r; )
                r = o5(r), o = !0;
            r = r.nextSibling
        } else
            o = !0, e.insertBefore(a, r);
        if (s instanceof Bu) {
            let l = r ? r.previousSibling : e.lastChild;
            gj(s.contentDOM, s.children, n),
            r = l ? l.nextSibling : e.firstChild
        }
    }
    for (; r; )
        r = o5(r), o = !0;
    o && n.trackWrites == e && (n.trackWrites = null)
}
const Hp = function (e) {
    e && (this.nodeName = e)
};
Hp.prototype = Object.create(null);
const Qc = [new Hp];
function iS(e, t, n) {
    if (e.length == 0)
        return Qc;
    let r = n ? Qc[0] : new Hp,
    o = [r];
    for (let i = 0; i < e.length; i++) {
        let s = e[i].type.attrs;
        if (s) {
            s.nodeName && o.push(r = new Hp(s.nodeName));
            for (let a in s) {
                let l = s[a];
                l != null && (n && o.length == 1 && o.push(r = new Hp(t.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l))
            }
        }
    }
    return o
}
function vj(e, t, n, r) {
    if (n == Qc && r == Qc)
        return t;
    let o = t;
    for (let i = 0; i < r.length; i++) {
        let s = r[i],
        a = n[i];
        if (i) {
            let l;
            a && a.nodeName == s.nodeName && o != e && (l = o.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(o), a = Qc[0]),
            o = l
        }
        ert(o, a || Qc[0], s)
    }
    return o
}
function ert(e, t, n) {
    for (let r in t)
        r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r);
    for (let r in n)
        r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r]);
    if (t.class != n.class) {
        let r = t.class ? t.class.split(" ").filter(Boolean) : [],
        o = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let i = 0; i < r.length; i++)
            o.indexOf(r[i]) == -1 && e.classList.remove(r[i]);
        for (let i = 0; i < o.length; i++)
            r.indexOf(o[i]) == -1 && e.classList.add(o[i]);
        e.classList.length == 0 && e.removeAttribute("class")
    }
    if (t.style != n.style) {
        if (t.style) {
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
            o;
            for (; o = r.exec(t.style); )
                e.style.removeProperty(o[1])
        }
        n.style && (e.style.cssText += n.style)
    }
}
function yj(e, t, n) {
    return vj(e, e, Qc, iS(t, n, e.nodeType != 1))
}
function sS(e, t) {
    if (e.length != t.length)
        return !1;
    for (let n = 0; n < e.length; n++)
        if (!e[n].type.eq(t[n].type))
            return !1;
    return !0
}
function o5(e) {
    let t = e.nextSibling;
    return e.parentNode.removeChild(e),
    t
}
class trt {
    constructor(t, n, r) {
        this.lock = n,
        this.view = r,
        this.index = 0,
        this.stack = [],
        this.changed = !1,
        this.top = t,
        this.preMatch = nrt(t.node.content, t)
    }
    destroyBetween(t, n) {
        if (t != n) {
            for (let r = t; r < n; r++)
                this.top.children[r].destroy();
            this.top.children.splice(t, n - t),
            this.changed = !0
        }
    }
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length)
    }
    syncToMarks(t, n, r) {
        let o = 0,
        i = this.stack.length >> 1,
        s = Math.min(i, t.length);
        for (; o < s && (o == i - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(t[o]) && t[o].type.spec.spanning !== !1; )
            o++;
        for (; o < i; )
            this.destroyRest(), this.top.dirty = Ms, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
        for (; i < t.length; ) {
            this.stack.push(this.top, this.index + 1);
            let a = -1;
            for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
                let c = this.top.children[l];
                if (c.matchesMark(t[i]) && !this.isLocked(c.dom)) {
                    a = l;
                    break
                }
            }
            if (a > -1)
                a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
            else {
                let l = Bu.create(this.top, t[i], n, r);
                this.top.children.splice(this.index, 0, l),
                this.top = l,
                this.changed = !0
            }
            this.index = 0,
            i++
        }
    }
    findNodeMatch(t, n, r, o) {
        let i = -1,
        s;
        if (o >= this.preMatch.index && (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && s.matchesNode(t, n, r))
            i = this.top.children.indexOf(s, this.index);
        else
            for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
                let c = this.top.children[a];
                if (c.matchesNode(t, n, r) && !this.preMatch.matched.has(c)) {
                    i = a;
                    break
                }
            }
        return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0)
    }
    updateNodeAt(t, n, r, o, i) {
        let s = this.top.children[o];
        return s.dirty == va && s.dom == s.contentDOM && (s.dirty = Hd),
        s.update(t, n, r, i) ? (this.destroyBetween(this.index, o), this.index++, !0) : !1
    }
    findIndexWithChild(t) {
        for (; ; ) {
            let n = t.parentNode;
            if (!n)
                return -1;
            if (n == this.top.contentDOM) {
                let r = t.pmViewDesc;
                if (r) {
                    for (let o = this.index; o < this.top.children.length; o++)
                        if (this.top.children[o] == r)
                            return o
                }
                return -1
            }
            t = n
        }
    }
    updateNextNode(t, n, r, o, i) {
        for (let s = this.index; s < this.top.children.length; s++) {
            let a = this.top.children[s];
            if (a instanceof Vu) {
                let l = this.preMatch.matched.get(a);
                if (l != null && l != i)
                    return !1;
                let c = a.dom;
                if (!(this.isLocked(c) && !(t.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == t.text && a.dirty != va && sS(n, a.outerDeco))) && a.update(t, n, r, o))
                    return this.destroyBetween(this.index, s), a.dom != c && (this.changed = !0), this.index++, !0;
                break
            }
        }
        return !1
    }
    addNode(t, n, r, o, i) {
        this.top.children.splice(this.index++, 0, Vu.create(this.top, t, n, r, o, i)),
        this.changed = !0
    }
    placeWidget(t, n, r) {
        let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (o && o.matchesWidget(t) && (t == o.widget || !o.widget.type.toDOM.parentNode))
            this.index++;
        else {
            let i = new pj(this.top, t, n, r);
            this.top.children.splice(this.index++, 0, i),
            this.changed = !0
        }
    }
    addTextblockHacks() {
        let t = this.top.children[this.index - 1],
        n = this.top;
        for (; t instanceof Bu; )
            n = t, t = n.children[n.children.length - 1];
        (!t || !(t instanceof tb) || /\n$/.test(t.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(t.node.text)) && ((Po || To) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top))
    }
    addHackNode(t, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
            this.index++;
        else {
            let r = document.createElement(t);
            t == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""),
            t == "BR" && (r.className = "ProseMirror-trailingBreak");
            let o = new mj(this.top, [], r, null);
            n != this.top ? n.children.push(o) : n.children.splice(this.index++, 0, o),
            this.changed = !0
        }
    }
    isLocked(t) {
        return this.lock && (t == this.lock || t.nodeType == 1 && t.contains(this.lock.parentNode))
    }
}
function nrt(e, t) {
    let n = t,
    r = n.children.length,
    o = e.childCount,
    i = new Map,
    s = [];
    e: for (; o > 0; ) {
        let a;
        for (; ; )
            if (r) {
                let c = n.children[r - 1];
                if (c instanceof Bu)
                    n = c, r = c.children.length;
                else {
                    a = c,
                    r--;
                    break
                }
            } else {
                if (n == t)
                    break e;
                r = n.parent.children.indexOf(n),
                n = n.parent
            }
        let l = a.node;
        if (l) {
            if (l != e.child(o - 1))
                break;
            --o,
            i.set(a, o),
            s.push(a)
        }
    }
    return {
        index: o,
        matched: i,
        matches: s.reverse()
    }
}
function rrt(e, t) {
    return e.type.side - t.type.side
}
function ort(e, t, n, r) {
    let o = t.locals(e),
    i = 0;
    if (o.length == 0) {
        for (let c = 0; c < e.childCount; c++) {
            let u = e.child(c);
            r(u, o, t.forChild(i, u), c),
            i += u.nodeSize
        }
        return
    }
    let s = 0,
    a = [],
    l = null;
    for (let c = 0; ; ) {
        if (s < o.length && o[s].to == i) {
            let v = o[s++],
            y;
            for (; s < o.length && o[s].to == i; )
                (y || (y = [v])).push(o[s++]);
            if (y) {
                y.sort(rrt);
                for (let b = 0; b < y.length; b++)
                    n(y[b], c, !!l)
            } else
                n(v, c, !!l)
        }
        let u,
        f;
        if (l)
            f = -1, u = l, l = null;
        else if (c < e.childCount)
            f = c, u = e.child(c++);
        else
            break;
        for (let v = 0; v < a.length; v++)
            a[v].to <= i && a.splice(v--, 1);
        for (; s < o.length && o[s].from <= i && o[s].to > i; )
            a.push(o[s++]);
        let p = i + u.nodeSize;
        if (u.isText) {
            let v = p;
            s < o.length && o[s].from < v && (v = o[s].from);
            for (let y = 0; y < a.length; y++)
                a[y].to < v && (v = a[y].to);
            v < p && (l = u.cut(v - i), u = u.cut(0, v - i), p = v, f = -1)
        }
        let m = u.isInline && !u.isLeaf ? a.filter(v => !v.inline) : a.slice();
        r(u, m, t.forChild(i, u), f),
        i = p
    }
}
function irt(e) {
    if (e.nodeName == "UL" || e.nodeName == "OL") {
        let t = e.style.cssText;
        e.style.cssText = t + "; list-style: square !important",
        window.getComputedStyle(e).listStyle,
        e.style.cssText = t
    }
}
function srt(e, t) {
    for (; ; ) {
        if (e.nodeType == 3)
            return e;
        if (e.nodeType == 1 && t > 0) {
            if (e.childNodes.length > t && e.childNodes[t].nodeType == 3)
                return e.childNodes[t];
            e = e.childNodes[t - 1],
            t = Zs(e)
        } else if (e.nodeType == 1 && t < e.childNodes.length)
            e = e.childNodes[t], t = 0;
        else
            return null
    }
}
function art(e, t, n, r) {
    for (let o = 0, i = 0; o < e.childCount && i <= r; ) {
        let s = e.child(o++),
        a = i;
        if (i += s.nodeSize, !s.isText)
            continue;
        let l = s.text;
        for (; o < e.childCount; ) {
            let c = e.child(o++);
            if (i += c.nodeSize, !c.isText)
                break;
            l += c.text
        }
        if (i >= n) {
            let c = a < r ? l.lastIndexOf(t, r - a - 1) : -1;
            if (c >= 0 && c + t.length + a >= n)
                return a + c;
            if (n == r && l.length >= r + t.length - a && l.slice(r - a, r - a + t.length) == t)
                return r
        }
    }
    return -1
}
function aS(e, t, n, r, o) {
    let i = [];
    for (let s = 0, a = 0; s < e.length; s++) {
        let l = e[s],
        c = a,
        u = a += l.size;
        c >= n || u <= t ? i.push(l) : (c < t && i.push(l.slice(0, t - c, r)), o && (i.push(o), o = void 0), u > n && i.push(l.slice(n - c, l.size, r)))
    }
    return i
}
function xT(e, t = null) {
    let n = e.domSelectionRange(),
    r = e.state.doc;
    if (!n.focusNode)
        return null;
    let o = e.docView.nearestDesc(n.focusNode),
    i = o && o.size == 0,
    s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (s < 0)
        return null;
    let a = r.resolve(s),
    l,
    c;
    if (Qw(n)) {
        for (l = a; o && !o.node; )
            o = o.parent;
        let u = o.node;
        if (o && u.isAtom && Pt.isSelectable(u) && o.parent && !(u.isInline && $nt(n.focusNode, n.focusOffset, o.dom))) {
            let f = o.posBefore;
            c = new Pt(s == f ? a : r.resolve(f))
        }
    } else {
        let u = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (u < 0)
            return null;
        l = r.resolve(u)
    }
    if (!c) {
        let u = t == "pointer" || e.state.selection.head < a.pos && !i ? 1 : -1;
        c = ST(e, l, a, u)
    }
    return c
}
function wj(e) {
    return e.editable ? e.hasFocus() : _j(e) && document.activeElement && document.activeElement.contains(e.dom)
}
function Ka(e, t = !1) {
    let n = e.state.selection;
    if (bj(e, n), !!wj(e)) {
        if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && To) {
            let r = e.domSelectionRange(),
            o = e.domObserver.currentSelection;
            if (r.anchorNode && o.anchorNode && Lu(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
                e.input.mouseDown.delayedSelectionSync = !0,
                e.domObserver.setCurSelection();
                return
            }
        }
        if (e.domObserver.disconnectSelection(), e.cursorWrapper)
            crt(e);
        else {
            let {
                anchor: r,
                head: o
            } = n,
            i,
            s;
            i5 && !(n instanceof qt) && (n.$from.parent.inlineContent || (i = s5(e, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = s5(e, n.to))),
            e.docView.setSelection(r, o, e.root, t),
            i5 && (i && a5(i), s && a5(s)),
            n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && lrt(e))
        }
        e.domObserver.setCurSelection(),
        e.domObserver.connectSelection()
    }
}
const i5 = Po || To && Nnt < 63;
function s5(e, t) {
    let {
        node: n,
        offset: r
    } = e.docView.domFromPos(t, 0),
    o = r < n.childNodes.length ? n.childNodes[r] : null,
    i = r ? n.childNodes[r - 1] : null;
    if (Po && o && o.contentEditable == "false")
        return q2(o);
    if ((!o || o.contentEditable == "false") && (!i || i.contentEditable == "false")) {
        if (o)
            return q2(o);
        if (i)
            return q2(i)
    }
}
function q2(e) {
    return e.contentEditable = "true",
    Po && e.draggable && (e.draggable = !1, e.wasDraggable = !0),
    e
}
function a5(e) {
    e.contentEditable = "false",
    e.wasDraggable && (e.draggable = !0, e.wasDraggable = null)
}
function lrt(e) {
    let t = e.dom.ownerDocument;
    t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
    let n = e.domSelectionRange(),
    r = n.anchorNode,
    o = n.anchorOffset;
    t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != o) && (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout(() => {
                (!wj(e) || e.state.selection.visible) && e.dom.classList.remove("ProseMirror-hideselection")
            }, 20))
    })
}
function crt(e) {
    let t = e.domSelection(),
    n = document.createRange(),
    r = e.cursorWrapper.dom,
    o = r.nodeName == "IMG";
    o ? n.setEnd(r.parentNode, wi(r) + 1) : n.setEnd(r, 0),
    n.collapse(!1),
    t.removeAllRanges(),
    t.addRange(n),
    !o && !e.state.selection.visible && Jo && Gl <= 11 && (r.disabled = !0, r.disabled = !1)
}
function bj(e, t) {
    if (t instanceof Pt) {
        let n = e.docView.descAt(t.from);
        n != e.lastSelectedViewDesc && (l5(e), n && n.selectNode(), e.lastSelectedViewDesc = n)
    } else
        l5(e)
}
function l5(e) {
    e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0)
}
function ST(e, t, n, r) {
    return e.someProp("createSelectionBetween", o => o(e, t, n)) || qt.between(t, n, r)
}
function c5(e) {
    return e.editable && !e.hasFocus() ? !1 : _j(e)
}
function _j(e) {
    let t = e.domSelectionRange();
    if (!t.anchorNode)
        return !1;
    try {
        return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode))
    } catch {
        return !1
    }
}
function urt(e) {
    let t = e.docView.domFromPos(e.state.selection.anchor, 0),
    n = e.domSelectionRange();
    return Lu(t.node, t.offset, n.anchorNode, n.anchorOffset)
}
function lS(e, t) {
    let {
        $anchor: n,
        $head: r
    } = e.selection,
    o = t > 0 ? n.max(r) : n.min(r),
    i = o.parent.inlineContent ? o.depth ? e.doc.resolve(t > 0 ? o.after() : o.before()) : null : o;
    return i && Wt.findFrom(i, t)
}
function Yc(e, t) {
    return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()),
    !0
}
function u5(e, t, n) {
    let r = e.state.selection;
    if (r instanceof qt) {
        if (!r.empty || n.indexOf("s") > -1)
            return !1;
        if (e.endOfTextblock(t > 0 ? "right" : "left")) {
            let o = lS(e.state, t);
            return o && o instanceof Pt ? Yc(e, o) : !1
        } else if (!(zi && n.indexOf("m") > -1)) {
            let o = r.$head,
            i = o.textOffset ? null : t < 0 ? o.nodeBefore : o.nodeAfter,
            s;
            if (!i || i.isText)
                return !1;
            let a = t < 0 ? o.pos - i.nodeSize : o.pos;
            return i.isAtom || (s = e.docView.descAt(a)) && !s.contentDOM ? Pt.isSelectable(i) ? Yc(e, new Pt(t < 0 ? e.state.doc.resolve(o.pos - i.nodeSize) : o)) : eb ? Yc(e, new qt(e.state.doc.resolve(t < 0 ? a : a + i.nodeSize))) : !1 : !1
        }
    } else {
        if (r instanceof Pt && r.node.isInline)
            return Yc(e, new qt(t > 0 ? r.$to : r.$from)); {
            let o = lS(e.state, t);
            return o ? Yc(e, o) : !1
        }
    }
}
function n1(e) {
    return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function Up(e) {
    let t = e.pmViewDesc;
    return t && t.size == 0 && (e.nextSibling || e.nodeName != "BR")
}
function Y2(e) {
    let t = e.domSelectionRange(),
    n = t.focusNode,
    r = t.focusOffset;
    if (!n)
        return;
    let o,
    i,
    s = !1;
    for (Ns && n.nodeType == 1 && r < n1(n) && Up(n.childNodes[r]) && (s = !0); ; )
        if (r > 0) {
            if (n.nodeType != 1)
                break; {
                let a = n.childNodes[r - 1];
                if (Up(a))
                    o = n, i = --r;
                else if (a.nodeType == 3)
                    n = a, r = n.nodeValue.length;
                else
                    break
            }
        } else {
            if (kj(n))
                break; {
                let a = n.previousSibling;
                for (; a && Up(a); )
                    o = n.parentNode, i = wi(a), a = a.previousSibling;
                if (a)
                    n = a, r = n1(n);
                else {
                    if (n = n.parentNode, n == e.dom)
                        break;
                    r = 0
                }
            }
        }
    s ? cS(e, n, r) : o && cS(e, o, i)
}
function K2(e) {
    let t = e.domSelectionRange(),
    n = t.focusNode,
    r = t.focusOffset;
    if (!n)
        return;
    let o = n1(n),
    i,
    s;
    for (; ; )
        if (r < o) {
            if (n.nodeType != 1)
                break;
            let a = n.childNodes[r];
            if (Up(a))
                i = n, s = ++r;
            else
                break
        } else {
            if (kj(n))
                break; {
                let a = n.nextSibling;
                for (; a && Up(a); )
                    i = a.parentNode, s = wi(a) + 1, a = a.nextSibling;
                if (a)
                    n = a, r = 0, o = n1(n);
                else {
                    if (n = n.parentNode, n == e.dom)
                        break;
                    r = o = 0
                }
            }
        }
    i && cS(e, i, s)
}
function kj(e) {
    let t = e.pmViewDesc;
    return t && t.node && t.node.isBlock
}
function cS(e, t, n) {
    let r = e.domSelection();
    if (Qw(r)) {
        let i = document.createRange();
        i.setEnd(t, n),
        i.setStart(t, n),
        r.removeAllRanges(),
        r.addRange(i)
    } else
        r.extend && r.extend(t, n);
    e.domObserver.setCurSelection();
    let {
        state: o
    } = e;
    setTimeout(() => {
        e.state == o && Ka(e)
    }, 50)
}
function d5(e, t, n) {
    let r = e.state.selection;
    if (r instanceof qt && !r.empty || n.indexOf("s") > -1 || zi && n.indexOf("m") > -1)
        return !1;
    let {
        $from: o,
        $to: i
    } = r;
    if (!o.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
        let s = lS(e.state, t);
        if (s && s instanceof Pt)
            return Yc(e, s)
    }
    if (!o.parent.inlineContent) {
        let s = t < 0 ? o : i,
        a = r instanceof Ts ? Wt.near(s, t) : Wt.findFrom(s, t);
        return a ? Yc(e, a) : !1
    }
    return !1
}
function f5(e, t) {
    if (!(e.state.selection instanceof qt))
        return !0;
    let {
        $head: n,
        $anchor: r,
        empty: o
    } = e.state.selection;
    if (!n.sameParent(r))
        return !0;
    if (!o)
        return !1;
    if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
        return !0;
    let i = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
    if (i && !i.isText) {
        let s = e.state.tr;
        return t < 0 ? s.delete(n.pos - i.nodeSize, n.pos) : s.delete(n.pos, n.pos + i.nodeSize),
        e.dispatch(s),
        !0
    }
    return !1
}
function h5(e, t, n) {
    e.domObserver.stop(),
    t.contentEditable = n,
    e.domObserver.start()
}
function drt(e) {
    if (!Po || e.state.selection.$head.parentOffset > 0)
        return !1;
    let {
        focusNode: t,
        focusOffset: n
    } = e.domSelectionRange();
    if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
        let r = t.firstChild;
        h5(e, r, "true"),
        setTimeout(() => h5(e, r, "false"), 20)
    }
    return !1
}
function frt(e) {
    let t = "";
    return e.ctrlKey && (t += "c"),
    e.metaKey && (t += "m"),
    e.altKey && (t += "a"),
    e.shiftKey && (t += "s"),
    t
}
function hrt(e, t) {
    let n = t.keyCode,
    r = frt(t);
    return n == 8 || zi && n == 72 && r == "c" ? f5(e, -1) || Y2(e) : n == 46 || zi && n == 68 && r == "c" ? f5(e, 1) || K2(e) : n == 13 || n == 27 ? !0 : n == 37 || zi && n == 66 && r == "c" ? u5(e, -1, r) || Y2(e) : n == 39 || zi && n == 70 && r == "c" ? u5(e, 1, r) || K2(e) : n == 38 || zi && n == 80 && r == "c" ? d5(e, -1, r) || Y2(e) : n == 40 || zi && n == 78 && r == "c" ? drt(e) || d5(e, 1, r) || K2(e) : r == (zi ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90)
}
function xj(e, t) {
    e.someProp("transformCopied", m => {
        t = m(t, e)
    });
    let n = [], {
        content: r,
        openStart: o,
        openEnd: i
    } = t;
    for (; o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        o--,
        i--;
        let m = r.firstChild;
        n.push(m.type.name, m.attrs != m.type.defaultAttrs ? m.attrs : null),
        r = m.content
    }
    let s = e.someProp("clipboardSerializer") || ta.fromSchema(e.state.schema),
    a = Pj(),
    l = a.createElement("div");
    l.appendChild(s.serializeFragment(r, {
            document: a
        }));
    let c = l.firstChild,
    u,
    f = 0;
    for (; c && c.nodeType == 1 && (u = Mj[c.nodeName.toLowerCase()]); ) {
        for (let m = u.length - 1; m >= 0; m--) {
            let v = a.createElement(u[m]);
            for (; l.firstChild; )
                v.appendChild(l.firstChild);
            l.appendChild(v),
            f++
        }
        c = l.firstChild
    }
    c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${o} ${i}${f ? ` -${f}` : ""} ${JSON.stringify(n)}`);
    let p = e.someProp("clipboardTextSerializer", m => m(t, e)) || t.content.textBetween(0, t.content.size, `

`);
    return {
        dom: l,
        text: p
    }
}
function Sj(e, t, n, r, o) {
    let i = o.parent.type.spec.code,
    s,
    a;
    if (!n && !t)
        return null;
    let l = t && (r || i || !n);
    if (l) {
        if (e.someProp("transformPastedText", p => {
                t = p(t, i || r, e)
            }), i)
            return t ? new nt(Ne.from(e.state.schema.text(t.replace(/\r\n?/g, `
`))), 0, 0) : nt.empty;
        let f = e.someProp("clipboardTextParser", p => p(t, o, r, e));
        if (f)
            a = f;
        else {
            let p = o.marks(), {
                schema: m
            } = e.state,
            v = ta.fromSchema(m);
            s = document.createElement("div"),
            t.split(/(?:\r\n?|\n)+/).forEach(y => {
                let b = s.appendChild(document.createElement("p"));
                y && b.appendChild(v.serializeNode(m.text(y, p)))
            })
        }
    } else
        e.someProp("transformPastedHTML", f => {
            n = f(n, e)
        }), s = grt(n), eb && vrt(s);
    let c = s && s.querySelector("[data-pm-slice]"),
    u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
    if (u && u[3])
        for (let f = +u[3]; f > 0; f--) {
            let p = s.firstChild;
            for (; p && p.nodeType != 1; )
                p = p.nextSibling;
            if (!p)
                break;
            s = p
        }
    if (a || (a = (e.someProp("clipboardParser") || e.someProp("domParser") || vT.fromSchema(e.state.schema)).parseSlice(s, {
                preserveWhitespace: !!(l || u),
                context: o,
                ruleFromNode(p) {
                    return p.nodeName == "BR" && !p.nextSibling && p.parentNode && !prt.test(p.parentNode.nodeName) ? {
                        ignore: !0
                    }
                     : null
                }
            })), u)
        a = yrt(p5(a, +u[1], +u[2]), u[4]);
    else if (a = nt.maxOpen(mrt(a.content, o), !0), a.openStart || a.openEnd) {
        let f = 0,
        p = 0;
        for (let m = a.content.firstChild; f < a.openStart && !m.type.spec.isolating; f++, m = m.firstChild);
        for (let m = a.content.lastChild; p < a.openEnd && !m.type.spec.isolating; p++, m = m.lastChild);
        a = p5(a, f, p)
    }
    return e.someProp("transformPasted", f => {
        a = f(a, e)
    }),
    a
}
const prt = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function mrt(e, t) {
    if (e.childCount < 2)
        return e;
    for (let n = t.depth; n >= 0; n--) {
        let o = t.node(n).contentMatchAt(t.index(n)),
        i,
        s = [];
        if (e.forEach(a => {
                if (!s)
                    return;
                let l = o.findWrapping(a.type),
                c;
                if (!l)
                    return s = null;
                if (c = s.length && i.length && Ij(l, i, a, s[s.length - 1], 0))
                    s[s.length - 1] = c;
                else {
                    s.length && (s[s.length - 1] = Tj(s[s.length - 1], i.length));
                    let u = Cj(a, l);
                    s.push(u),
                    o = o.matchType(u.type),
                    i = l
                }
            }), s)
            return Ne.from(s)
    }
    return e
}
function Cj(e, t, n = 0) {
    for (let r = t.length - 1; r >= n; r--)
        e = t[r].create(null, Ne.from(e));
    return e
}
function Ij(e, t, n, r, o) {
    if (o < e.length && o < t.length && e[o] == t[o]) {
        let i = Ij(e, t, n, r.lastChild, o + 1);
        if (i)
            return r.copy(r.content.replaceChild(r.childCount - 1, i));
        if (r.contentMatchAt(r.childCount).matchType(o == e.length - 1 ? n.type : e[o + 1]))
            return r.copy(r.content.append(Ne.from(Cj(n, e, o + 1))))
    }
}
function Tj(e, t) {
    if (t == 0)
        return e;
    let n = e.content.replaceChild(e.childCount - 1, Tj(e.lastChild, t - 1)),
    r = e.contentMatchAt(e.childCount).fillBefore(Ne.empty, !0);
    return e.copy(n.append(r))
}
function uS(e, t, n, r, o, i) {
    let s = t < 0 ? e.firstChild : e.lastChild,
    a = s.content;
    return o < r - 1 && (a = uS(a, t, n, r, o + 1, i)),
    o >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, e.childCount > 1 || i <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(Ne.empty, !0))),
    e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a))
}
function p5(e, t, n) {
    return t < e.openStart && (e = new nt(uS(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)),
    n < e.openEnd && (e = new nt(uS(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)),
    e
}
const Mj = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
};
let m5 = null;
function Pj() {
    return m5 || (m5 = document.implementation.createHTMLDocument("title"))
}
function grt(e) {
    let t = /^(\s*<meta [^>]*>)*/.exec(e);
    t && (e = e.slice(t[0].length));
    let n = Pj().createElement("div"),
    r = /<([a-z][^>\s]+)/i.exec(e),
    o;
    if ((o = r && Mj[r[1].toLowerCase()]) && (e = o.map(i => "<" + i + ">").join("") + e + o.map(i => "</" + i + ">").reverse().join("")), n.innerHTML = e, o)
        for (let i = 0; i < o.length; i++)
            n = n.querySelector(o[i]) || n;
    return n
}
function vrt(e) {
    let t = e.querySelectorAll(To ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let n = 0; n < t.length; n++) {
        let r = t[n];
        r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r)
    }
}
function yrt(e, t) {
    if (!e.size)
        return e;
    let n = e.content.firstChild.type.schema,
    r;
    try {
        r = JSON.parse(t)
    } catch {
        return e
    }
    let {
        content: o,
        openStart: i,
        openEnd: s
    } = e;
    for (let a = r.length - 2; a >= 0; a -= 2) {
        let l = n.nodes[r[a]];
        if (!l || l.hasRequiredAttrs())
            break;
        o = Ne.from(l.create(r[a + 1], o)),
        i++,
        s++
    }
    return new nt(o, i, s)
}
const Eo = {}, Oo = {}, wrt = {
    touchstart: !0,
    touchmove: !0
};
class brt {
    constructor() {
        this.shiftKey = !1,
        this.mouseDown = null,
        this.lastKeyCode = null,
        this.lastKeyCodeTime = 0,
        this.lastClick = {
            time: 0,
            x: 0,
            y: 0,
            type: ""
        },
        this.lastSelectionOrigin = null,
        this.lastSelectionTime = 0,
        this.lastIOSEnter = 0,
        this.lastIOSEnterFallbackTimeout = -1,
        this.lastFocus = 0,
        this.lastTouch = 0,
        this.lastAndroidDelete = 0,
        this.composing = !1,
        this.composingTimeout = -1,
        this.compositionNodes = [],
        this.compositionEndedAt = -2e8,
        this.domChangeCount = 0,
        this.eventHandlers = Object.create(null),
        this.hideSelectionGuard = null
    }
}
function _rt(e) {
    for (let t in Eo) {
        let n = Eo[t];
        e.dom.addEventListener(t, e.input.eventHandlers[t] = r => {
                xrt(e, r) && !CT(e, r) && (e.editable || !(r.type in Oo)) && n(e, r)
            }, wrt[t] ? {
            passive: !0
        }
             : void 0)
    }
    Po && e.dom.addEventListener("input", () => null),
    dS(e)
}
function Wl(e, t) {
    e.input.lastSelectionOrigin = t,
    e.input.lastSelectionTime = Date.now()
}
function krt(e) {
    e.domObserver.stop();
    for (let t in e.input.eventHandlers)
        e.dom.removeEventListener(t, e.input.eventHandlers[t]);
    clearTimeout(e.input.composingTimeout),
    clearTimeout(e.input.lastIOSEnterFallbackTimeout)
}
function dS(e) {
    e.someProp("handleDOMEvents", t => {
        for (let n in t)
            e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = r => CT(e, r))
    })
}
function CT(e, t) {
    return e.someProp("handleDOMEvents", n => {
        let r = n[t.type];
        return r ? r(e, t) || t.defaultPrevented : !1
    })
}
function xrt(e, t) {
    if (!t.bubbles)
        return !0;
    if (t.defaultPrevented)
        return !1;
    for (let n = t.target; n != e.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
            return !1;
    return !0
}
function Srt(e, t) {
    !CT(e, t) && Eo[t.type] && (e.editable || !(t.type in Oo)) && Eo[t.type](e, t)
}
Oo.keydown = (e, t) => {
    let n = t;
    if (e.input.shiftKey = n.keyCode == 16 || n.shiftKey, !Oj(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !(bs && To && n.keyCode == 13)))
        if (n.keyCode != 229 && e.domObserver.forceFlush(), zf && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
            let r = Date.now();
            e.input.lastIOSEnter = r,
            e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
                e.input.lastIOSEnter == r && (e.someProp("handleKeyDown", o => o(e, qc(13, "Enter"))), e.input.lastIOSEnter = 0)
            }, 200)
        } else
            e.someProp("handleKeyDown", r => r(e, n)) || hrt(e, n) ? n.preventDefault() : Wl(e, "key")
};
Oo.keyup = (e, t) => {
    t.keyCode == 16 && (e.input.shiftKey = !1)
};
Oo.keypress = (e, t) => {
    let n = t;
    if (Oj(e, n) || !n.charCode || n.ctrlKey && !n.altKey || zi && n.metaKey)
        return;
    if (e.someProp("handleKeyPress", o => o(e, n))) {
        n.preventDefault();
        return
    }
    let r = e.state.selection;
    if (!(r instanceof qt) || !r.$from.sameParent(r.$to)) {
        let o = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(o) && !e.someProp("handleTextInput", i => i(e, r.$from.pos, r.$to.pos, o)) && e.dispatch(e.state.tr.insertText(o).scrollIntoView()),
        n.preventDefault()
    }
};
function nb(e) {
    return {
        left: e.clientX,
        top: e.clientY
    }
}
function Crt(e, t) {
    let n = t.x - e.clientX,
    r = t.y - e.clientY;
    return n * n + r * r < 100
}
function IT(e, t, n, r, o) {
    if (r == -1)
        return !1;
    let i = e.state.doc.resolve(r);
    for (let s = i.depth + 1; s > 0; s--)
        if (e.someProp(t, a => s > i.depth ? a(e, n, i.nodeAfter, i.before(s), o, !0) : a(e, n, i.node(s), i.before(s), o, !1)))
            return !0;
    return !1
}
function df(e, t, n) {
    e.focused || e.focus();
    let r = e.state.tr.setSelection(t);
    n == "pointer" && r.setMeta("pointer", !0),
    e.dispatch(r)
}
function Irt(e, t) {
    if (t == -1)
        return !1;
    let n = e.state.doc.resolve(t),
    r = n.nodeAfter;
    return r && r.isAtom && Pt.isSelectable(r) ? (df(e, new Pt(n), "pointer"), !0) : !1
}
function Trt(e, t) {
    if (t == -1)
        return !1;
    let n = e.state.selection,
    r,
    o;
    n instanceof Pt && (r = n.node);
    let i = e.state.doc.resolve(t);
    for (let s = i.depth + 1; s > 0; s--) {
        let a = s > i.depth ? i.nodeAfter : i.node(s);
        if (Pt.isSelectable(a)) {
            r && n.$from.depth > 0 && s >= n.$from.depth && i.before(n.$from.depth + 1) == n.$from.pos ? o = i.before(n.$from.depth) : o = i.before(s);
            break
        }
    }
    return o != null ? (df(e, Pt.create(e.state.doc, o), "pointer"), !0) : !1
}
function Mrt(e, t, n, r, o) {
    return IT(e, "handleClickOn", t, n, r) || e.someProp("handleClick", i => i(e, t, r)) || (o ? Trt(e, n) : Irt(e, n))
}
function Prt(e, t, n, r) {
    return IT(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", o => o(e, t, r))
}
function Ert(e, t, n, r) {
    return IT(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", o => o(e, t, r)) || Ort(e, n, r)
}
function Ort(e, t, n) {
    if (n.button != 0)
        return !1;
    let r = e.state.doc;
    if (t == -1)
        return r.inlineContent ? (df(e, qt.create(r, 0, r.content.size), "pointer"), !0) : !1;
    let o = r.resolve(t);
    for (let i = o.depth + 1; i > 0; i--) {
        let s = i > o.depth ? o.nodeAfter : o.node(i),
        a = o.before(i);
        if (s.inlineContent)
            df(e, qt.create(r, a + 1, a + 1 + s.content.size), "pointer");
        else if (Pt.isSelectable(s))
            df(e, Pt.create(r, a), "pointer");
        else
            continue;
        return !0
    }
}
function TT(e) {
    return r1(e)
}
const Ej = zi ? "metaKey" : "ctrlKey";
Eo.mousedown = (e, t) => {
    let n = t;
    e.input.shiftKey = n.shiftKey;
    let r = TT(e),
    o = Date.now(),
    i = "singleClick";
    o - e.input.lastClick.time < 500 && Crt(n, e.input.lastClick) && !n[Ej] && (e.input.lastClick.type == "singleClick" ? i = "doubleClick" : e.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
    e.input.lastClick = {
        time: o,
        x: n.clientX,
        y: n.clientY,
        type: i
    };
    let s = e.posAtCoords(nb(n));
    s && (i == "singleClick" ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new $rt(e, s, n, !!r)) : (i == "doubleClick" ? Prt : Ert)(e, s.pos, s.inside, n) ? n.preventDefault() : Wl(e, "pointer"))
};
class $rt {
    constructor(t, n, r, o) {
        this.view = t,
        this.pos = n,
        this.event = r,
        this.flushed = o,
        this.delayedSelectionSync = !1,
        this.mightDrag = null,
        this.startDoc = t.state.doc,
        this.selectNode = !!r[Ej],
        this.allowDefault = r.shiftKey;
        let i,
        s;
        if (n.inside > -1)
            i = t.state.doc.nodeAt(n.inside), s = n.inside;
        else {
            let u = t.state.doc.resolve(n.pos);
            i = u.parent,
            s = u.depth ? u.before() : 0
        }
        const a = o ? null : r.target,
        l = a ? t.docView.nearestDesc(a, !0) : null;
        this.target = l ? l.dom : null;
        let {
            selection: c
        } = t.state;
        (r.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== !1 || c instanceof Pt && c.from <= s && c.to > s) && (this.mightDrag = {
                node: i,
                pos: s,
                addAttr: !!(this.target && !this.target.draggable),
                setUneditable: !!(this.target && Ns && !this.target.hasAttribute("contentEditable"))
            }),
        this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
                this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false")
            }, 20), this.view.domObserver.start()),
        t.root.addEventListener("mouseup", this.up = this.up.bind(this)),
        t.root.addEventListener("mousemove", this.move = this.move.bind(this)),
        Wl(t, "pointer")
    }
    done() {
        this.view.root.removeEventListener("mouseup", this.up),
        this.view.root.removeEventListener("mousemove", this.move),
        this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()),
        this.delayedSelectionSync && setTimeout(() => Ka(this.view)),
        this.view.input.mouseDown = null
    }
    up(t) {
        if (this.done(), !this.view.dom.contains(t.target))
            return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(nb(t))),
        this.updateAllowDefault(t),
        this.allowDefault || !n ? Wl(this.view, "pointer") : Mrt(this.view, n.pos, n.inside, t, this.selectNode) ? t.preventDefault() : t.button == 0 && (this.flushed || Po && this.mightDrag && !this.mightDrag.node.isAtom || To && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (df(this.view, Wt.near(this.view.state.doc.resolve(n.pos)), "pointer"), t.preventDefault()) : Wl(this.view, "pointer")
    }
    move(t) {
        this.updateAllowDefault(t),
        Wl(this.view, "pointer"),
        t.buttons == 0 && this.done()
    }
    updateAllowDefault(t) {
        !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0)
    }
}
Eo.touchstart = e => {
    e.input.lastTouch = Date.now(),
    TT(e),
    Wl(e, "pointer")
};
Eo.touchmove = e => {
    e.input.lastTouch = Date.now(),
    Wl(e, "pointer")
};
Eo.contextmenu = e => TT(e);
function Oj(e, t) {
    return e.composing ? !0 : Po && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500 ? (e.input.compositionEndedAt = -2e8, !0) : !1
}
const Art = bs ? 5e3 : -1;
Oo.compositionstart = Oo.compositionupdate = e => {
    if (!e.composing) {
        e.domObserver.flush();
        let {
            state: t
        } = e,
        n = t.selection.$from;
        if (t.selection.empty && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(r => r.type.spec.inclusive === !1)))
            e.markCursor = e.state.storedMarks || n.marks(), r1(e, !0), e.markCursor = null;
        else if (r1(e), Ns && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
            let r = e.domSelectionRange();
            for (let o = r.focusNode, i = r.focusOffset; o && o.nodeType == 1 && i != 0; ) {
                let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
                if (!s)
                    break;
                if (s.nodeType == 3) {
                    e.domSelection().collapse(s, s.nodeValue.length);
                    break
                } else
                    o = s, i = -1
            }
        }
        e.input.composing = !0
    }
    $j(e, Art)
};
Oo.compositionend = (e, t) => {
    e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, $j(e, 20))
};
function $j(e, t) {
    clearTimeout(e.input.composingTimeout),
    t > -1 && (e.input.composingTimeout = setTimeout(() => r1(e), t))
}
function Aj(e) {
    for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = Drt()); e.input.compositionNodes.length > 0; )
        e.input.compositionNodes.pop().markParentsDirty()
}
function Drt() {
    let e = document.createEvent("Event");
    return e.initEvent("event", !0, !0),
    e.timeStamp
}
function r1(e, t = !1) {
    if (!(bs && e.domObserver.flushingSoon >= 0)) {
        if (e.domObserver.forceFlush(), Aj(e), t || e.docView && e.docView.dirty) {
            let n = xT(e);
            return n && !n.eq(e.state.selection) ? e.dispatch(e.state.tr.setSelection(n)) : e.updateState(e.state),
            !0
        }
        return !1
    }
}
function Nrt(e, t) {
    if (!e.dom.parentNode)
        return;
    let n = e.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(t),
    n.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection(),
    o = document.createRange();
    o.selectNodeContents(t),
    e.dom.blur(),
    r.removeAllRanges(),
    r.addRange(o),
    setTimeout(() => {
        n.parentNode && n.parentNode.removeChild(n),
        e.focus()
    }, 50)
}
const Hf = Jo && Gl < 15 || zf && Rnt < 604;
Eo.copy = Oo.cut = (e, t) => {
    let n = t,
    r = e.state.selection,
    o = n.type == "cut";
    if (r.empty)
        return;
    let i = Hf ? null : n.clipboardData,
    s = r.content(), {
        dom: a,
        text: l
    } = xj(e, s);
    i ? (n.preventDefault(), i.clearData(), i.setData("text/html", a.innerHTML), i.setData("text/plain", l)) : Nrt(e, a),
    o && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
};
function Rrt(e) {
    return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1 ? e.content.firstChild : null
}
function Lrt(e, t) {
    if (!e.dom.parentNode)
        return;
    let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code,
    r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
    n || (r.contentEditable = "true"),
    r.style.cssText = "position: fixed; left: -10000px; top: 10px",
    r.focus(),
    setTimeout(() => {
        e.focus(),
        r.parentNode && r.parentNode.removeChild(r),
        n ? Fm(e, r.value, null, e.input.shiftKey, t) : Fm(e, r.textContent, r.innerHTML, e.input.shiftKey, t)
    }, 50)
}
function Fm(e, t, n, r, o) {
    let i = Sj(e, t, n, r, e.state.selection.$from);
    if (e.someProp("handlePaste", l => l(e, o, i || nt.empty)))
        return !0;
    if (!i)
        return !1;
    let s = Rrt(i),
    a = s ? e.state.tr.replaceSelectionWith(s, e.input.shiftKey) : e.state.tr.replaceSelection(i);
    return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")),
    !0
}
Oo.paste = (e, t) => {
    let n = t;
    if (e.composing && !bs)
        return;
    let r = Hf ? null : n.clipboardData;
    r && Fm(e, r.getData("text/plain"), r.getData("text/html"), e.input.shiftKey, n) ? n.preventDefault() : Lrt(e, n)
};
class Brt {
    constructor(t, n) {
        this.slice = t,
        this.move = n
    }
}
const Dj = zi ? "altKey" : "ctrlKey";
Eo.dragstart = (e, t) => {
    let n = t,
    r = e.input.mouseDown;
    if (r && r.done(), !n.dataTransfer)
        return;
    let o = e.state.selection,
    i = o.empty ? null : e.posAtCoords(nb(n));
    if (!(i && i.pos >= o.from && i.pos <= (o instanceof Pt ? o.to - 1 : o.to))) {
        if (r && r.mightDrag)
            e.dispatch(e.state.tr.setSelection(Pt.create(e.state.doc, r.mightDrag.pos)));
        else if (n.target && n.target.nodeType == 1) {
            let c = e.docView.nearestDesc(n.target, !0);
            c && c.node.type.spec.draggable && c != e.docView && e.dispatch(e.state.tr.setSelection(Pt.create(e.state.doc, c.posBefore)))
        }
    }
    let s = e.state.selection.content(), {
        dom: a,
        text: l
    } = xj(e, s);
    n.dataTransfer.clearData(),
    n.dataTransfer.setData(Hf ? "Text" : "text/html", a.innerHTML),
    n.dataTransfer.effectAllowed = "copyMove",
    Hf || n.dataTransfer.setData("text/plain", l),
    e.dragging = new Brt(s, !n[Dj])
};
Eo.dragend = e => {
    let t = e.dragging;
    window.setTimeout(() => {
        e.dragging == t && (e.dragging = null)
    }, 50)
};
Oo.dragover = Oo.dragenter = (e, t) => t.preventDefault();
Oo.drop = (e, t) => {
    let n = t,
    r = e.dragging;
    if (e.dragging = null, !n.dataTransfer)
        return;
    let o = e.posAtCoords(nb(n));
    if (!o)
        return;
    let i = e.state.doc.resolve(o.pos),
    s = r && r.slice;
    s ? e.someProp("transformPasted", v => {
        s = v(s, e)
    }) : s = Sj(e, n.dataTransfer.getData(Hf ? "Text" : "text/plain"), Hf ? null : n.dataTransfer.getData("text/html"), !1, i);
    let a = !!(r && !n[Dj]);
    if (e.someProp("handleDrop", v => v(e, n, s || nt.empty, a))) {
        n.preventDefault();
        return
    }
    if (!s)
        return;
    n.preventDefault();
    let l = s ? QF(e.state.doc, i.pos, s) : i.pos;
    l == null && (l = i.pos);
    let c = e.state.tr;
    a && c.deleteSelection();
    let u = c.mapping.map(l),
    f = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
    p = c.doc;
    if (f ? c.replaceRangeWith(u, u, s.content.firstChild) : c.replaceRange(u, u, s), c.doc.eq(p))
        return;
    let m = c.doc.resolve(u);
    if (f && Pt.isSelectable(s.content.firstChild) && m.nodeAfter && m.nodeAfter.sameMarkup(s.content.firstChild))
        c.setSelection(new Pt(m));
    else {
        let v = c.mapping.map(l);
        c.mapping.maps[c.mapping.maps.length - 1].forEach((y, b, w, k) => v = k),
        c.setSelection(ST(e, m, c.doc.resolve(v)))
    }
    e.focus(),
    e.dispatch(c.setMeta("uiEvent", "drop"))
};
Eo.focus = e => {
    e.input.lastFocus = Date.now(),
    e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout(() => {
            e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && Ka(e)
        }, 20))
};
Eo.blur = (e, t) => {
    let n = t;
    e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1)
};
Eo.beforeinput = (e, t) => {
    if (To && bs && t.inputType == "deleteContentBackward") {
        e.domObserver.flushSoon();
        let {
            domChangeCount: r
        } = e.input;
        setTimeout(() => {
            if (e.input.domChangeCount != r || (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", i => i(e, qc(8, "Backspace")))))
                return;
            let {
                $cursor: o
            } = e.state.selection;
            o && o.pos > 0 && e.dispatch(e.state.tr.delete(o.pos - 1, o.pos).scrollIntoView())
        }, 50)
    }
};
for (let e in Oo)
    Eo[e] = Oo[e];
function jm(e, t) {
    if (e == t)
        return !0;
    for (let n in e)
        if (e[n] !== t[n])
            return !1;
    for (let n in t)
        if (!(n in e))
            return !1;
    return !0
}
class MT {
    constructor(t, n) {
        this.toDOM = t,
        this.spec = n || gu,
        this.side = this.spec.side || 0
    }
    map(t, n, r, o) {
        let {
            pos: i,
            deleted: s
        } = t.mapResult(n.from + o, this.side < 0 ? -1 : 1);
        return s ? null : new Xi(i - r, i - r, this)
    }
    valid() {
        return !0
    }
    eq(t) {
        return this == t || t instanceof MT && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && jm(this.spec, t.spec))
    }
    destroy(t) {
        this.spec.destroy && this.spec.destroy(t)
    }
}
class Xl {
    constructor(t, n) {
        this.attrs = t,
        this.spec = n || gu
    }
    map(t, n, r, o) {
        let i = t.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
        s = t.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
        return i >= s ? null : new Xi(i, s, this)
    }
    valid(t, n) {
        return n.from < n.to
    }
    eq(t) {
        return this == t || t instanceof Xl && jm(this.attrs, t.attrs) && jm(this.spec, t.spec)
    }
    static is(t) {
        return t.type instanceof Xl
    }
    destroy() {}
}
class PT {
    constructor(t, n) {
        this.attrs = t,
        this.spec = n || gu
    }
    map(t, n, r, o) {
        let i = t.mapResult(n.from + o, 1);
        if (i.deleted)
            return null;
        let s = t.mapResult(n.to + o, -1);
        return s.deleted || s.pos <= i.pos ? null : new Xi(i.pos - r, s.pos - r, this)
    }
    valid(t, n) {
        let {
            index: r,
            offset: o
        } = t.content.findIndex(n.from),
        i;
        return o == n.from && !(i = t.child(r)).isText && o + i.nodeSize == n.to
    }
    eq(t) {
        return this == t || t instanceof PT && jm(this.attrs, t.attrs) && jm(this.spec, t.spec)
    }
    destroy() {}
}
class Xi {
    constructor(t, n, r) {
        this.from = t,
        this.to = n,
        this.type = r
    }
    copy(t, n) {
        return new Xi(t, n, this.type)
    }
    eq(t, n = 0) {
        return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to
    }
    map(t, n, r) {
        return this.type.map(t, this, n, r)
    }
    static widget(t, n, r) {
        return new Xi(t, t, new MT(n, r))
    }
    static inline(t, n, r, o) {
        return new Xi(t, n, new Xl(r, o))
    }
    static node(t, n, r, o) {
        return new Xi(t, n, new PT(r, o))
    }
    get spec() {
        return this.type.spec
    }
    get inline() {
        return this.type instanceof Xl
    }
}
const Ld = [], gu = {};
class Ar {
    constructor(t, n) {
        this.local = t.length ? t : Ld,
        this.children = n.length ? n : Ld
    }
    static create(t, n) {
        return n.length ? o1(n, t, 0, gu) : io
    }
    find(t, n, r) {
        let o = [];
        return this.findInner(t ?? 0, n ?? 1e9, o, 0, r),
        o
    }
    findInner(t, n, r, o, i) {
        for (let s = 0; s < this.local.length; s++) {
            let a = this.local[s];
            a.from <= n && a.to >= t && (!i || i(a.spec)) && r.push(a.copy(a.from + o, a.to + o))
        }
        for (let s = 0; s < this.children.length; s += 3)
            if (this.children[s] < n && this.children[s + 1] > t) {
                let a = this.children[s] + 1;
                this.children[s + 2].findInner(t - a, n - a, r, o + a, i)
            }
    }
    map(t, n, r) {
        return this == io || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || gu)
    }
    mapInner(t, n, r, o, i) {
        let s;
        for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a].map(t, r, o);
            l && l.type.valid(n, l) ? (s || (s = [])).push(l) : i.onRemove && i.onRemove(this.local[a].spec)
        }
        return this.children.length ? Vrt(this.children, s || [], t, n, r, o, i) : s ? new Ar(s.sort(vu), Ld) : io
    }
    add(t, n) {
        return n.length ? this == io ? Ar.create(t, n) : this.addInner(t, n, 0) : this
    }
    addInner(t, n, r) {
        let o,
        i = 0;
        t.forEach((a, l) => {
            let c = l + r,
            u;
            if (u = Rj(n, a, c)) {
                for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
                    i += 3;
                o[i] == l ? o[i + 2] = o[i + 2].addInner(a, u, c + 1) : o.splice(i, 0, l, l + a.nodeSize, o1(u, a, c + 1, gu)),
                i += 3
            }
        });
        let s = Nj(i ? Lj(n) : n, -r);
        for (let a = 0; a < s.length; a++)
            s[a].type.valid(t, s[a]) || s.splice(a--, 1);
        return new Ar(s.length ? this.local.concat(s).sort(vu) : this.local, o || this.children)
    }
    remove(t) {
        return t.length == 0 || this == io ? this : this.removeInner(t, 0)
    }
    removeInner(t, n) {
        let r = this.children,
        o = this.local;
        for (let i = 0; i < r.length; i += 3) {
            let s,
            a = r[i] + n,
            l = r[i + 1] + n;
            for (let u = 0, f; u < t.length; u++)
                (f = t[u]) && f.from > a && f.to < l && (t[u] = null, (s || (s = [])).push(f));
            if (!s)
                continue;
            r == this.children && (r = this.children.slice());
            let c = r[i + 2].removeInner(s, a + 1);
            c != io ? r[i + 2] = c : (r.splice(i, 3), i -= 3)
        }
        if (o.length) {
            for (let i = 0, s; i < t.length; i++)
                if (s = t[i])
                    for (let a = 0; a < o.length; a++)
                        o[a].eq(s, n) && (o == this.local && (o = this.local.slice()), o.splice(a--, 1))
        }
        return r == this.children && o == this.local ? this : o.length || r.length ? new Ar(o, r) : io
    }
    forChild(t, n) {
        if (this == io)
            return this;
        if (n.isLeaf)
            return Ar.empty;
        let r,
        o;
        for (let a = 0; a < this.children.length; a += 3)
            if (this.children[a] >= t) {
                this.children[a] == t && (r = this.children[a + 2]);
                break
            }
        let i = t + 1,
        s = i + n.content.size;
        for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a];
            if (l.from < s && l.to > i && l.type instanceof Xl) {
                let c = Math.max(i, l.from) - i,
                u = Math.min(s, l.to) - i;
                c < u && (o || (o = [])).push(l.copy(c, u))
            }
        }
        if (o) {
            let a = new Ar(o.sort(vu), Ld);
            return r ? new Dl([a, r]) : a
        }
        return r || io
    }
    eq(t) {
        if (this == t)
            return !0;
        if (!(t instanceof Ar) || this.local.length != t.local.length || this.children.length != t.children.length)
            return !1;
        for (let n = 0; n < this.local.length; n++)
            if (!this.local[n].eq(t.local[n]))
                return !1;
        for (let n = 0; n < this.children.length; n += 3)
            if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2]))
                return !1;
        return !0
    }
    locals(t) {
        return ET(this.localsInner(t))
    }
    localsInner(t) {
        if (this == io)
            return Ld;
        if (t.inlineContent || !this.local.some(Xl.is))
            return this.local;
        let n = [];
        for (let r = 0; r < this.local.length; r++)
            this.local[r].type instanceof Xl || n.push(this.local[r]);
        return n
    }
}
Ar.empty = new Ar([], []);
Ar.removeOverlap = ET;
const io = Ar.empty;
class Dl {
    constructor(t) {
        this.members = t
    }
    map(t, n) {
        const r = this.members.map(o => o.map(t, n, gu));
        return Dl.from(r)
    }
    forChild(t, n) {
        if (n.isLeaf)
            return Ar.empty;
        let r = [];
        for (let o = 0; o < this.members.length; o++) {
            let i = this.members[o].forChild(t, n);
            i != io && (i instanceof Dl ? r = r.concat(i.members) : r.push(i))
        }
        return Dl.from(r)
    }
    eq(t) {
        if (!(t instanceof Dl) || t.members.length != this.members.length)
            return !1;
        for (let n = 0; n < this.members.length; n++)
            if (!this.members[n].eq(t.members[n]))
                return !1;
        return !0
    }
    locals(t) {
        let n,
        r = !0;
        for (let o = 0; o < this.members.length; o++) {
            let i = this.members[o].localsInner(t);
            if (i.length)
                if (!n)
                    n = i;
                else {
                    r && (n = n.slice(), r = !1);
                    for (let s = 0; s < i.length; s++)
                        n.push(i[s])
                }
        }
        return n ? ET(r ? n : n.sort(vu)) : Ld
    }
    static from(t) {
        switch (t.length) {
        case 0:
            return io;
        case 1:
            return t[0];
        default:
            return new Dl(t.every(n => n instanceof Ar) ? t : t.reduce((n, r) => n.concat(r instanceof Ar ? r : r.members), []))
        }
    }
}
function Vrt(e, t, n, r, o, i, s) {
    let a = e.slice();
    for (let c = 0, u = i; c < n.maps.length; c++) {
        let f = 0;
        n.maps[c].forEach((p, m, v, y) => {
            let b = y - v - (m - p);
            for (let w = 0; w < a.length; w += 3) {
                let k = a[w + 1];
                if (k < 0 || p > k + u - f)
                    continue;
                let C = a[w] + u - f;
                m >= C ? a[w + 1] = p <= C ? -2 : -1 : v >= o && b && (a[w] += b, a[w + 1] += b)
            }
            f += b
        }),
        u = n.maps[c].map(u, -1)
    }
    let l = !1;
    for (let c = 0; c < a.length; c += 3)
        if (a[c + 1] < 0) {
            if (a[c + 1] == -2) {
                l = !0,
                a[c + 1] = -1;
                continue
            }
            let u = n.map(e[c] + i),
            f = u - o;
            if (f < 0 || f >= r.content.size) {
                l = !0;
                continue
            }
            let p = n.map(e[c + 1] + i, -1),
            m = p - o, {
                index: v,
                offset: y
            } = r.content.findIndex(f),
            b = r.maybeChild(v);
            if (b && y == f && y + b.nodeSize == m) {
                let w = a[c + 2].mapInner(n, b, u + 1, e[c] + i + 1, s);
                w != io ? (a[c] = f, a[c + 1] = m, a[c + 2] = w) : (a[c + 1] = -2, l = !0)
            } else
                l = !0
        }
    if (l) {
        let c = Frt(a, e, t, n, o, i, s),
        u = o1(c, r, 0, s);
        t = u.local;
        for (let f = 0; f < a.length; f += 3)
            a[f + 1] < 0 && (a.splice(f, 3), f -= 3);
        for (let f = 0, p = 0; f < u.children.length; f += 3) {
            let m = u.children[f];
            for (; p < a.length && a[p] < m; )
                p += 3;
            a.splice(p, 0, u.children[f], u.children[f + 1], u.children[f + 2])
        }
    }
    return new Ar(t.sort(vu), a)
}
function Nj(e, t) {
    if (!t || !e.length)
        return e;
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let o = e[r];
        n.push(new Xi(o.from + t, o.to + t, o.type))
    }
    return n
}
function Frt(e, t, n, r, o, i, s) {
    function a(l, c) {
        for (let u = 0; u < l.local.length; u++) {
            let f = l.local[u].map(r, o, c);
            f ? n.push(f) : s.onRemove && s.onRemove(l.local[u].spec)
        }
        for (let u = 0; u < l.children.length; u += 3)
            a(l.children[u + 2], l.children[u] + c + 1)
    }
    for (let l = 0; l < e.length; l += 3)
        e[l + 1] == -1 && a(e[l + 2], t[l] + i + 1);
    return n
}
function Rj(e, t, n) {
    if (t.isLeaf)
        return null;
    let r = n + t.nodeSize,
    o = null;
    for (let i = 0, s; i < e.length; i++)
        (s = e[i]) && s.from > n && s.to < r && ((o || (o = [])).push(s), e[i] = null);
    return o
}
function Lj(e) {
    let t = [];
    for (let n = 0; n < e.length; n++)
        e[n] != null && t.push(e[n]);
    return t
}
function o1(e, t, n, r) {
    let o = [],
    i = !1;
    t.forEach((a, l) => {
        let c = Rj(e, a, l + n);
        if (c) {
            i = !0;
            let u = o1(c, a, n + l + 1, r);
            u != io && o.push(l, l + a.nodeSize, u)
        }
    });
    let s = Nj(i ? Lj(e) : e, -n).sort(vu);
    for (let a = 0; a < s.length; a++)
        s[a].type.valid(t, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
    return s.length || o.length ? new Ar(s, o) : io
}
function vu(e, t) {
    return e.from - t.from || e.to - t.to
}
function ET(e) {
    let t = e;
    for (let n = 0; n < t.length - 1; n++) {
        let r = t[n];
        if (r.from != r.to)
            for (let o = n + 1; o < t.length; o++) {
                let i = t[o];
                if (i.from == r.from) {
                    i.to != r.to && (t == e && (t = e.slice()), t[o] = i.copy(i.from, r.to), g5(t, o + 1, i.copy(r.to, i.to)));
                    continue
                } else {
                    i.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, i.from), g5(t, o, r.copy(i.from, r.to)));
                    break
                }
            }
    }
    return t
}
function g5(e, t, n) {
    for (; t < e.length && vu(n, e[t]) > 0; )
        t++;
    e.splice(t, 0, n)
}
function G2(e) {
    let t = [];
    return e.someProp("decorations", n => {
        let r = n(e.state);
        r && r != io && t.push(r)
    }),
    e.cursorWrapper && t.push(Ar.create(e.state.doc, [e.cursorWrapper.deco])),
    Dl.from(t)
}
const jrt = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
}, Wrt = Jo && Gl <= 11;
class zrt {
    constructor() {
        this.anchorNode = null,
        this.anchorOffset = 0,
        this.focusNode = null,
        this.focusOffset = 0
    }
    set(t) {
        this.anchorNode = t.anchorNode,
        this.anchorOffset = t.anchorOffset,
        this.focusNode = t.focusNode,
        this.focusOffset = t.focusOffset
    }
    clear() {
        this.anchorNode = this.focusNode = null
    }
    eq(t) {
        return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset
    }
}
class Hrt {
    constructor(t, n) {
        this.view = t,
        this.handleDOMChange = n,
        this.queue = [],
        this.flushingSoon = -1,
        this.observer = null,
        this.currentSelection = new zrt,
        this.onCharData = null,
        this.suppressingSelectionUpdates = !1,
        this.observer = window.MutationObserver && new window.MutationObserver(r => {
            for (let o = 0; o < r.length; o++)
                this.queue.push(r[o]);
            Jo && Gl <= 11 && r.some(o => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : this.flush()
        }),
        Wrt && (this.onCharData = r => {
                this.queue.push({
                    target: r.target,
                    type: "characterData",
                    oldValue: r.prevValue
                }),
                this.flushSoon()
            }),
        this.onSelectionChange = this.onSelectionChange.bind(this)
    }
    flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
                this.flushingSoon = -1,
                this.flush()
            }, 20))
    }
    forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush())
    }
    start() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, jrt)),
        this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
        this.connectSelection()
    }
    stop() {
        if (this.observer) {
            let t = this.observer.takeRecords();
            if (t.length) {
                for (let n = 0; n < t.length; n++)
                    this.queue.push(t[n]);
                window.setTimeout(() => this.flush(), 20)
            }
            this.observer.disconnect()
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
        this.disconnectSelection()
    }
    connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
    }
    disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
    }
    suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = !0,
        setTimeout(() => this.suppressingSelectionUpdates = !1, 50)
    }
    onSelectionChange() {
        if (c5(this.view)) {
            if (this.suppressingSelectionUpdates)
                return Ka(this.view);
            if (Jo && Gl <= 11 && !this.view.state.selection.empty) {
                let t = this.view.domSelectionRange();
                if (t.focusNode && Lu(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
                    return this.flushSoon()
            }
            this.flush()
        }
    }
    setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange())
    }
    ignoreSelectionChange(t) {
        if (!t.focusNode)
            return !0;
        let n = new Set,
        r;
        for (let i = t.focusNode; i; i = Vm(i))
            n.add(i);
        for (let i = t.anchorNode; i; i = Vm(i))
            if (n.has(i)) {
                r = i;
                break
            }
        let o = r && this.view.docView.nearestDesc(r);
        if (o && o.ignoreMutation({
                type: "selection",
                target: r.nodeType == 3 ? r.parentNode : r
            }))
            return this.setCurSelection(), !0
    }
    flush() {
        let {
            view: t
        } = this;
        if (!t.docView || this.flushingSoon > -1)
            return;
        let n = this.observer ? this.observer.takeRecords() : [];
        this.queue.length && (n = this.queue.concat(n), this.queue.length = 0);
        let r = t.domSelectionRange(),
        o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && c5(t) && !this.ignoreSelectionChange(r),
        i = -1,
        s = -1,
        a = !1,
        l = [];
        if (t.editable)
            for (let u = 0; u < n.length; u++) {
                let f = this.registerMutation(n[u], l);
                f && (i = i < 0 ? f.from : Math.min(f.from, i), s = s < 0 ? f.to : Math.max(f.to, s), f.typeOver && (a = !0))
            }
        if (Ns && l.length > 1) {
            let u = l.filter(f => f.nodeName == "BR");
            if (u.length == 2) {
                let f = u[0],
                p = u[1];
                f.parentNode && f.parentNode.parentNode == p.parentNode ? p.remove() : f.remove()
            }
        }
        let c = null;
        i < 0 && o && t.input.lastFocus > Date.now() - 200 && Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 && Qw(r) && (c = xT(t)) && c.eq(Wt.near(t.state.doc.resolve(0), 1)) ? (t.input.lastFocus = 0, Ka(t), this.currentSelection.set(r), t.scrollToSelection()) : (i > -1 || o) && (i > -1 && (t.docView.markDirty(i, s), Urt(t)), this.handleDOMChange(i, s, a, l), t.docView && t.docView.dirty ? t.updateState(t.state) : this.currentSelection.eq(r) || Ka(t), this.currentSelection.set(r))
    }
    registerMutation(t, n) {
        if (n.indexOf(t.target) > -1)
            return null;
        let r = this.view.docView.nearestDesc(t.target);
        if (t.type == "attributes" && (r == this.view.docView || t.attributeName == "contenteditable" || t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")) || !r || r.ignoreMutation(t))
            return null;
        if (t.type == "childList") {
            for (let u = 0; u < t.addedNodes.length; u++)
                n.push(t.addedNodes[u]);
            if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
                return {
                    from: r.posBefore,
                    to: r.posAfter
                };
            let o = t.previousSibling,
            i = t.nextSibling;
            if (Jo && Gl <= 11 && t.addedNodes.length)
                for (let u = 0; u < t.addedNodes.length; u++) {
                    let {
                        previousSibling: f,
                        nextSibling: p
                    } = t.addedNodes[u];
                    (!f || Array.prototype.indexOf.call(t.addedNodes, f) < 0) && (o = f),
                    (!p || Array.prototype.indexOf.call(t.addedNodes, p) < 0) && (i = p)
                }
            let s = o && o.parentNode == t.target ? wi(o) + 1 : 0,
            a = r.localPosFromDOM(t.target, s, -1),
            l = i && i.parentNode == t.target ? wi(i) : t.target.childNodes.length,
            c = r.localPosFromDOM(t.target, l, 1);
            return {
                from: a,
                to: c
            }
        } else
            return t.type == "attributes" ? {
                from: r.posAtStart - r.border,
                to: r.posAtEnd + r.border
            }
         : {
            from: r.posAtStart,
            to: r.posAtEnd,
            typeOver: t.target.nodeValue == t.oldValue
        }
    }
}
let v5 = new WeakMap, y5 = !1;
function Urt(e) {
    if (!v5.has(e) && (v5.set(e, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)) {
        if (e.requiresGeckoHackNode = Ns, y5)
            return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."),
        y5 = !0
    }
}
function qrt(e) {
    let t;
    function n(l) {
        l.preventDefault(),
        l.stopImmediatePropagation(),
        t = l.getTargetRanges()[0]
    }
    e.dom.addEventListener("beforeinput", n, !0),
    document.execCommand("indent"),
    e.dom.removeEventListener("beforeinput", n, !0);
    let r = t.startContainer,
    o = t.startOffset,
    i = t.endContainer,
    s = t.endOffset,
    a = e.domAtPos(e.state.selection.anchor);
    return Lu(a.node, a.offset, i, s) && ([r, o, i, s] = [i, s, r, o]), {
        anchorNode: r,
        anchorOffset: o,
        focusNode: i,
        focusOffset: s
    }
}
function Yrt(e, t, n) {
    let {
        node: r,
        fromOffset: o,
        toOffset: i,
        from: s,
        to: a
    } = e.docView.parseRange(t, n),
    l = e.domSelectionRange(),
    c,
    u = l.anchorNode;
    if (u && e.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{
                    node: u,
                    offset: l.anchorOffset
                }
            ], Qw(l) || c.push({
                node: l.focusNode,
                offset: l.focusOffset
            })), To && e.input.lastKeyCode === 8)
        for (let b = i; b > o; b--) {
            let w = r.childNodes[b - 1],
            k = w.pmViewDesc;
            if (w.nodeName == "BR" && !k) {
                i = b;
                break
            }
            if (!k || k.size)
                break
        }
    let f = e.state.doc,
    p = e.someProp("domParser") || vT.fromSchema(e.state.schema),
    m = f.resolve(s),
    v = null,
    y = p.parse(r, {
        topNode: m.parent,
        topMatch: m.parent.contentMatchAt(m.index()),
        topOpen: !0,
        from: o,
        to: i,
        preserveWhitespace: m.parent.type.whitespace == "pre" ? "full" : !0,
        findPositions: c,
        ruleFromNode: Krt,
        context: m
    });
    if (c && c[0].pos != null) {
        let b = c[0].pos,
        w = c[1] && c[1].pos;
        w == null && (w = b),
        v = {
            anchor: b + s,
            head: w + s
        }
    }
    return {
        doc: y,
        sel: v,
        from: s,
        to: a
    }
}
function Krt(e) {
    let t = e.pmViewDesc;
    if (t)
        return t.parseRule();
    if (e.nodeName == "BR" && e.parentNode) {
        if (Po && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
            let n = document.createElement("div");
            return n.appendChild(document.createElement("li")), {
                skip: n
            }
        } else if (e.parentNode.lastChild == e || Po && /^(tr|table)$/i.test(e.parentNode.nodeName))
            return {
                ignore: !0
            }
    } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
        return {
            ignore: !0
        };
    return null
}
const Grt = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function Xrt(e, t, n, r, o) {
    if (t < 0) {
        let M = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null,
        N = xT(e, M);
        if (N && !e.state.selection.eq(N)) {
            if (To && bs && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", K => K(e, qc(13, "Enter"))))
                return;
            let F = e.state.tr.setSelection(N);
            M == "pointer" ? F.setMeta("pointer", !0) : M == "key" && F.scrollIntoView(),
            e.dispatch(F)
        }
        return
    }
    let i = e.state.doc.resolve(t),
    s = i.sharedDepth(n);
    t = i.before(s + 1),
    n = e.state.doc.resolve(n).after(s + 1);
    let a = e.state.selection,
    l = Yrt(e, t, n),
    c = e.state.doc,
    u = c.slice(l.from, l.to),
    f,
    p;
    e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime ? (f = e.state.selection.to, p = "end") : (f = e.state.selection.from, p = "start"),
    e.input.lastKeyCode = null;
    let m = Qrt(u.content, l.doc.content, l.from, f, p);
    if ((zf && e.input.lastIOSEnter > Date.now() - 225 || bs) && o.some(M => M.nodeType == 1 && !Grt.test(M.nodeName)) && (!m || m.endA >= m.endB) && e.someProp("handleKeyDown", M => M(e, qc(13, "Enter")))) {
        e.input.lastIOSEnter = 0;
        return
    }
    if (!m)
        if (r && a instanceof qt && !a.empty && a.$head.sameParent(a.$anchor) && !e.composing && !(l.sel && l.sel.anchor != l.sel.head))
            m = {
                start: a.from,
                endA: a.to,
                endB: a.to
            };
        else {
            if (l.sel) {
                let M = w5(e, e.state.doc, l.sel);
                M && !M.eq(e.state.selection) && e.dispatch(e.state.tr.setSelection(M))
            }
            return
        }
    if (To && e.cursorWrapper && l.sel && l.sel.anchor == e.cursorWrapper.deco.from && l.sel.head == l.sel.anchor) {
        let M = m.endB - m.start;
        l.sel = {
            anchor: l.sel.anchor + M,
            head: l.sel.anchor + M
        }
    }
    e.input.domChangeCount++,
    e.state.selection.from < e.state.selection.to && m.start == m.endB && e.state.selection instanceof qt && (m.start > e.state.selection.from && m.start <= e.state.selection.from + 2 && e.state.selection.from >= l.from ? m.start = e.state.selection.from : m.endA < e.state.selection.to && m.endA >= e.state.selection.to - 2 && e.state.selection.to <= l.to && (m.endB += e.state.selection.to - m.endA, m.endA = e.state.selection.to)),
    Jo && Gl <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > l.from && l.doc.textBetween(m.start - l.from - 1, m.start - l.from + 1) == "  " && (m.start--, m.endA--, m.endB--);
    let v = l.doc.resolveNoCache(m.start - l.from),
    y = l.doc.resolveNoCache(m.endB - l.from),
    b = c.resolve(m.start),
    w = v.sameParent(y) && v.parent.inlineContent && b.end() >= m.endA,
    k;
    if ((zf && e.input.lastIOSEnter > Date.now() - 225 && (!w || o.some(M => M.nodeName == "DIV" || M.nodeName == "P")) || !w && v.pos < l.doc.content.size && (k = Wt.findFrom(l.doc.resolve(v.pos + 1), 1, !0)) && k.head == y.pos) && e.someProp("handleKeyDown", M => M(e, qc(13, "Enter")))) {
        e.input.lastIOSEnter = 0;
        return
    }
    if (e.state.selection.anchor > m.start && Zrt(c, m.start, m.endA, v, y) && e.someProp("handleKeyDown", M => M(e, qc(8, "Backspace")))) {
        bs && To && e.domObserver.suppressSelectionUpdates();
        return
    }
    To && bs && m.endB == m.start && (e.input.lastAndroidDelete = Date.now()),
    bs && !w && v.start() != y.start() && y.parentOffset == 0 && v.depth == y.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == m.endA && (m.endB -= 2, y = l.doc.resolveNoCache(m.endB - l.from), setTimeout(() => {
            e.someProp("handleKeyDown", function (M) {
                return M(e, qc(13, "Enter"))
            })
        }, 20));
    let C = m.start,
    x = m.endA,
    S,
    T,
    E;
    if (w) {
        if (v.pos == y.pos)
            Jo && Gl <= 11 && v.parentOffset == 0 && (e.domObserver.suppressSelectionUpdates(), setTimeout(() => Ka(e), 20)), S = e.state.tr.delete(C, x), T = c.resolve(m.start).marksAcross(c.resolve(m.endA));
        else if (m.endA == m.endB && (E = Jrt(v.parent.content.cut(v.parentOffset, y.parentOffset), b.parent.content.cut(b.parentOffset, m.endA - b.start()))))
            S = e.state.tr, E.type == "add" ? S.addMark(C, x, E.mark) : S.removeMark(C, x, E.mark);
        else if (v.parent.child(v.index()).isText && v.index() == y.index() - (y.textOffset ? 0 : 1)) {
            let M = v.parent.textBetween(v.parentOffset, y.parentOffset);
            if (e.someProp("handleTextInput", N => N(e, C, x, M)))
                return;
            S = e.state.tr.insertText(M, C, x)
        }
    }
    if (S || (S = e.state.tr.replace(C, x, l.doc.slice(m.start - l.from, m.endB - l.from))), l.sel) {
        let M = w5(e, S.doc, l.sel);
        M && !(To && bs && e.composing && M.empty && (m.start != m.endB || e.input.lastAndroidDelete < Date.now() - 100) && (M.head == C || M.head == S.mapping.map(x) - 1) || Jo && M.empty && M.head == C) && S.setSelection(M)
    }
    T && S.ensureMarks(T),
    e.dispatch(S.scrollIntoView())
}
function w5(e, t, n) {
    return Math.max(n.anchor, n.head) > t.content.size ? null : ST(e, t.resolve(n.anchor), t.resolve(n.head))
}
function Jrt(e, t) {
    let n = e.firstChild.marks,
    r = t.firstChild.marks,
    o = n,
    i = r,
    s,
    a,
    l;
    for (let u = 0; u < r.length; u++)
        o = r[u].removeFromSet(o);
    for (let u = 0; u < n.length; u++)
        i = n[u].removeFromSet(i);
    if (o.length == 1 && i.length == 0)
        a = o[0], s = "add", l = u => u.mark(a.addToSet(u.marks));
    else if (o.length == 0 && i.length == 1)
        a = i[0], s = "remove", l = u => u.mark(a.removeFromSet(u.marks));
    else
        return null;
    let c = [];
    for (let u = 0; u < t.childCount; u++)
        c.push(l(t.child(u)));
    if (Ne.from(c).eq(e))
        return {
            mark: a,
            type: s
        }
}
function Zrt(e, t, n, r, o) {
    if (!r.parent.isTextblock || n - t <= o.pos - r.pos || X2(r, !0, !1) < o.pos)
        return !1;
    let i = e.resolve(t);
    if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
        return !1;
    let s = e.resolve(X2(i, !0, !0));
    return !s.parent.isTextblock || s.pos > n || X2(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content)
}
function X2(e, t, n) {
    let r = e.depth,
    o = t ? e.end() : e.pos;
    for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
        r--, o++, t = !1;
    if (n) {
        let i = e.node(r).maybeChild(e.indexAfter(r));
        for (; i && !i.isLeaf; )
            i = i.firstChild, o++
    }
    return o
}
function Qrt(e, t, n, r, o) {
    let i = e.findDiffStart(t, n);
    if (i == null)
        return null;
    let {
        a: s,
        b: a
    } = e.findDiffEnd(t, n + e.size, n + t.size);
    if (o == "end") {
        let l = Math.max(0, i - Math.min(s, a));
        r -= s + l - i
    }
    if (s < i && e.size < t.size) {
        let l = r <= i && r >= s ? i - r : 0;
        i -= l,
        a = i + (a - s),
        s = i
    } else if (a < i) {
        let l = r <= i && r >= a ? i - r : 0;
        i -= l,
        s = i + (s - a),
        a = i
    }
    return {
        start: i,
        endA: s,
        endB: a
    }
}
class eot {
    constructor(t, n) {
        this._root = null,
        this.focused = !1,
        this.trackWrites = null,
        this.mounted = !1,
        this.markCursor = null,
        this.cursorWrapper = null,
        this.lastSelectedViewDesc = void 0,
        this.input = new brt,
        this.prevDirectPlugins = [],
        this.pluginViews = [],
        this.requiresGeckoHackNode = !1,
        this.dragging = null,
        this._props = n,
        this.state = n.state,
        this.directPlugins = n.plugins || [],
        this.directPlugins.forEach(S5),
        this.dispatch = this.dispatch.bind(this),
        this.dom = t && t.mount || document.createElement("div"),
        t && (t.appendChild ? t.appendChild(this.dom) : typeof t == "function" ? t(this.dom) : t.mount && (this.mounted = !0)),
        this.editable = k5(this),
        _5(this),
        this.nodeViews = x5(this),
        this.docView = r5(this.state.doc, b5(this), G2(this), this.dom, this),
        this.domObserver = new Hrt(this, (r, o, i, s) => Xrt(this, r, o, i, s)),
        this.domObserver.start(),
        _rt(this),
        this.updatePluginViews()
    }
    get composing() {
        return this.input.composing
    }
    get props() {
        if (this._props.state != this.state) {
            let t = this._props;
            this._props = {};
            for (let n in t)
                this._props[n] = t[n];
            this._props.state = this.state
        }
        return this._props
    }
    update(t) {
        t.handleDOMEvents != this._props.handleDOMEvents && dS(this);
        let n = this._props;
        this._props = t,
        t.plugins && (t.plugins.forEach(S5), this.directPlugins = t.plugins),
        this.updateStateInner(t.state, n)
    }
    setProps(t) {
        let n = {};
        for (let r in this._props)
            n[r] = this._props[r];
        n.state = this.state;
        for (let r in t)
            n[r] = t[r];
        this.update(n)
    }
    updateState(t) {
        this.updateStateInner(t, this._props)
    }
    updateStateInner(t, n) {
        let r = this.state,
        o = !1,
        i = !1;
        t.storedMarks && this.composing && (Aj(this), i = !0),
        this.state = t;
        let s = r.plugins != t.plugins || this._props.plugins != n.plugins;
        if (s || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
            let p = x5(this);
            not(p, this.nodeViews) && (this.nodeViews = p, o = !0)
        }
        (s || n.handleDOMEvents != this._props.handleDOMEvents) && dS(this),
        this.editable = k5(this),
        _5(this);
        let a = G2(this),
        l = b5(this),
        c = r.plugins != t.plugins && !r.doc.eq(t.doc) ? "reset" : t.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve",
        u = o || !this.docView.matchesNode(t.doc, l, a);
        (u || !t.selection.eq(r.selection)) && (i = !0);
        let f = c == "preserve" && i && this.dom.style.overflowAnchor == null && Vnt(this);
        if (i) {
            this.domObserver.stop();
            let p = u && (Jo || To) && !this.composing && !r.selection.empty && !t.selection.empty && tot(r.selection, t.selection);
            if (u) {
                let m = To ? this.trackWrites = this.domSelectionRange().focusNode : null;
                (o || !this.docView.update(t.doc, l, a, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = r5(t.doc, l, a, this.dom, this)),
                m && !this.trackWrites && (p = !0)
            }
            p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && urt(this)) ? Ka(this, p) : (bj(this, t.selection), this.domObserver.setCurSelection()),
            this.domObserver.start()
        }
        this.updatePluginViews(r),
        c == "reset" ? this.dom.scrollTop = 0 : c == "to selection" ? this.scrollToSelection() : f && Fnt(f)
    }
    scrollToSelection() {
        let t = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", n => n(this)))
            if (this.state.selection instanceof Pt) {
                let n = this.docView.domAfterPos(this.state.selection.from);
                n.nodeType == 1 && ZN(this, n.getBoundingClientRect(), t)
            } else
                ZN(this, this.coordsAtPos(this.state.selection.head, 1), t)
    }
    destroyPluginViews() {
        let t;
        for (; t = this.pluginViews.pop(); )
            t.destroy && t.destroy()
    }
    updatePluginViews(t) {
        if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins,
            this.destroyPluginViews();
            for (let n = 0; n < this.directPlugins.length; n++) {
                let r = this.directPlugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
            for (let n = 0; n < this.state.plugins.length; n++) {
                let r = this.state.plugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
        } else
            for (let n = 0; n < this.pluginViews.length; n++) {
                let r = this.pluginViews[n];
                r.update && r.update(this, t)
            }
    }
    someProp(t, n) {
        let r = this._props && this._props[t],
        o;
        if (r != null && (o = n ? n(r) : r))
            return o;
        for (let s = 0; s < this.directPlugins.length; s++) {
            let a = this.directPlugins[s].props[t];
            if (a != null && (o = n ? n(a) : a))
                return o
        }
        let i = this.state.plugins;
        if (i)
            for (let s = 0; s < i.length; s++) {
                let a = i[s].props[t];
                if (a != null && (o = n ? n(a) : a))
                    return o
            }
    }
    hasFocus() {
        if (Jo) {
            let t = this.root.activeElement;
            if (t == this.dom)
                return !0;
            if (!t || !this.dom.contains(t))
                return !1;
            for (; t && this.dom != t && this.dom.contains(t); ) {
                if (t.contentEditable == "false")
                    return !1;
                t = t.parentElement
            }
            return !0
        }
        return this.root.activeElement == this.dom
    }
    focus() {
        this.domObserver.stop(),
        this.editable && jnt(this.dom),
        Ka(this),
        this.domObserver.start()
    }
    get root() {
        let t = this._root;
        if (t == null) {
            for (let n = this.dom.parentNode; n; n = n.parentNode)
                if (n.nodeType == 9 || n.nodeType == 11 && n.host)
                    return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n
        }
        return t || document
    }
    posAtCoords(t) {
        return qnt(this, t)
    }
    coordsAtPos(t, n = 1) {
        return fj(this, t, n)
    }
    domAtPos(t, n = 0) {
        return this.docView.domFromPos(t, n)
    }
    nodeDOM(t) {
        let n = this.docView.descAt(t);
        return n ? n.nodeDOM : null
    }
    posAtDOM(t, n, r = -1) {
        let o = this.docView.posFromDOM(t, n, r);
        if (o == null)
            throw new RangeError("DOM position not inside the editor");
        return o
    }
    endOfTextblock(t, n) {
        return Jnt(this, n || this.state, t)
    }
    pasteHTML(t, n) {
        return Fm(this, "", t, !1, n || new ClipboardEvent("paste"))
    }
    pasteText(t, n) {
        return Fm(this, t, null, !0, n || new ClipboardEvent("paste"))
    }
    destroy() {
        this.docView && (krt(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], G2(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null)
    }
    get isDestroyed() {
        return this.docView == null
    }
    dispatchEvent(t) {
        return Srt(this, t)
    }
    dispatch(t) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, t) : this.updateState(this.state.apply(t))
    }
    domSelectionRange() {
        return Po && this.root.nodeType === 11 && Dnt(this.dom.ownerDocument) == this.dom ? qrt(this) : this.domSelection()
    }
    domSelection() {
        return this.root.getSelection()
    }
}
function b5(e) {
    let t = Object.create(null);
    return t.class = "ProseMirror",
    t.contenteditable = String(e.editable),
    t.translate = "no",
    e.someProp("attributes", n => {
        if (typeof n == "function" && (n = n(e.state)), n)
            for (let r in n)
                r == "class" && (t.class += " " + n[r]), r == "style" ? t.style = (t.style ? t.style + ";" : "") + n[r] : !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]))
    }),
    [Xi.node(0, e.state.doc.content.size, t)]
}
function _5(e) {
    if (e.markCursor) {
        let t = document.createElement("img");
        t.className = "ProseMirror-separator",
        t.setAttribute("mark-placeholder", "true"),
        t.setAttribute("alt", ""),
        e.cursorWrapper = {
            dom: t,
            deco: Xi.widget(e.state.selection.head, t, {
                raw: !0,
                marks: e.markCursor
            })
        }
    } else
        e.cursorWrapper = null
}
function k5(e) {
    return !e.someProp("editable", t => t(e.state) === !1)
}
function tot(e, t) {
    let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
    return e.$anchor.start(n) != t.$anchor.start(n)
}
function x5(e) {
    let t = Object.create(null);
    function n(r) {
        for (let o in r)
            Object.prototype.hasOwnProperty.call(t, o) || (t[o] = r[o])
    }
    return e.someProp("nodeViews", n),
    e.someProp("markViews", n),
    t
}
function not(e, t) {
    let n = 0,
    r = 0;
    for (let o in e) {
        if (e[o] != t[o])
            return !0;
        n++
    }
    for (let o in t)
        r++;
    return n != r
}
function S5(e) {
    if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component")
}
var lc = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
}, i1 = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
}, C5 = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent), rot = typeof navigator < "u" && /Mac/.test(navigator.platform), oot = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), iot = rot || C5 && +C5[1] < 57;
for (var Jr = 0; Jr < 10; Jr++)
    lc[48 + Jr] = lc[96 + Jr] = String(Jr);
for (var Jr = 1; Jr <= 24; Jr++)
    lc[Jr + 111] = "F" + Jr;
for (var Jr = 65; Jr <= 90; Jr++)
    lc[Jr] = String.fromCharCode(Jr + 32), i1[Jr] = String.fromCharCode(Jr);
for (var J2 in lc)
    i1.hasOwnProperty(J2) || (i1[J2] = lc[J2]);
function sot(e) {
    var t = iot && (e.ctrlKey || e.altKey || e.metaKey) || oot && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified",
    n = !t && e.key || (e.shiftKey ? i1 : lc)[e.keyCode] || e.key || "Unidentified";
    return n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
}
const aot = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function lot(e) {
    let t = e.split(/-(?!$)/),
    n = t[t.length - 1];
    n == "Space" && (n = " ");
    let r,
    o,
    i,
    s;
    for (let a = 0; a < t.length - 1; a++) {
        let l = t[a];
        if (/^(cmd|meta|m)$/i.test(l))
            s = !0;
        else if (/^a(lt)?$/i.test(l))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(l))
            o = !0;
        else if (/^s(hift)?$/i.test(l))
            i = !0;
        else if (/^mod$/i.test(l))
            aot ? s = !0 : o = !0;
        else
            throw new Error("Unrecognized modifier name: " + l)
    }
    return r && (n = "Alt-" + n),
    o && (n = "Ctrl-" + n),
    s && (n = "Meta-" + n),
    i && (n = "Shift-" + n),
    n
}
function cot(e) {
    let t = Object.create(null);
    for (let n in e)
        t[lot(n)] = e[n];
    return t
}
function Z2(e, t, n = !0) {
    return t.altKey && (e = "Alt-" + e),
    t.ctrlKey && (e = "Ctrl-" + e),
    t.metaKey && (e = "Meta-" + e),
    n && t.shiftKey && (e = "Shift-" + e),
    e
}
function uot(e) {
    return new go({
        props: {
            handleKeyDown: Bj(e)
        }
    })
}
function Bj(e) {
    let t = cot(e);
    return function (n, r) {
        let o = sot(r),
        i,
        s = t[Z2(o, r)];
        if (s && s(n.state, n.dispatch, n))
            return !0;
        if (o.length == 1 && o != " ") {
            if (r.shiftKey) {
                let a = t[Z2(o, r, !1)];
                if (a && a(n.state, n.dispatch, n))
                    return !0
            }
            if ((r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) && (i = lc[r.keyCode]) && i != o) {
                let a = t[Z2(i, r)];
                if (a && a(n.state, n.dispatch, n))
                    return !0
            }
        }
        return !1
    }
}
const dot = (e, t) => e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0);
function fot(e, t) {
    let {
        $cursor: n
    } = e.selection;
    return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n
}
const hot = (e, t, n) => {
    let r = fot(e, n);
    if (!r)
        return !1;
    let o = Vj(r);
    if (!o) {
        let s = r.blockRange(),
        a = s && vh(s);
        return a == null ? !1 : (t && t(e.tr.lift(s, a).scrollIntoView()), !0)
    }
    let i = o.nodeBefore;
    if (!i.type.spec.isolating && Wj(e, o, t))
        return !0;
    if (r.parent.content.size == 0 && (Uf(i, "end") || Pt.isSelectable(i))) {
        let s = bT(e.doc, r.before(), r.after(), nt.empty);
        if (s && s.slice.size < s.to - s.from) {
            if (t) {
                let a = e.tr.step(s);
                a.setSelection(Uf(i, "end") ? Wt.findFrom(a.doc.resolve(a.mapping.map(o.pos, -1)), -1) : Pt.create(a.doc, o.pos - i.nodeSize)),
                t(a.scrollIntoView())
            }
            return !0
        }
    }
    return i.isAtom && o.depth == r.depth - 1 ? (t && t(e.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0) : !1
};
function Uf(e, t, n = !1) {
    for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
            return !0;
        if (n && r.childCount != 1)
            return !1
    }
    return !1
}
const pot = (e, t, n) => {
    let {
        $head: r,
        empty: o
    } = e.selection,
    i = r;
    if (!o)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
            return !1;
        i = Vj(r)
    }
    let s = i && i.nodeBefore;
    return !s || !Pt.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(Pt.create(e.doc, i.pos - s.nodeSize)).scrollIntoView()), !0)
};
function Vj(e) {
    if (!e.parent.type.spec.isolating)
        for (let t = e.depth - 1; t >= 0; t--) {
            if (e.index(t) > 0)
                return e.doc.resolve(e.before(t + 1));
            if (e.node(t).type.spec.isolating)
                break
        }
    return null
}
function mot(e, t) {
    let {
        $cursor: n
    } = e.selection;
    return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n
}
const got = (e, t, n) => {
    let r = mot(e, n);
    if (!r)
        return !1;
    let o = Fj(r);
    if (!o)
        return !1;
    let i = o.nodeAfter;
    if (Wj(e, o, t))
        return !0;
    if (r.parent.content.size == 0 && (Uf(i, "start") || Pt.isSelectable(i))) {
        let s = bT(e.doc, r.before(), r.after(), nt.empty);
        if (s && s.slice.size < s.to - s.from) {
            if (t) {
                let a = e.tr.step(s);
                a.setSelection(Uf(i, "start") ? Wt.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1) : Pt.create(a.doc, a.mapping.map(o.pos))),
                t(a.scrollIntoView())
            }
            return !0
        }
    }
    return i.isAtom && o.depth == r.depth - 1 ? (t && t(e.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0) : !1
}, vot = (e, t, n) => {
    let {
        $head: r,
        empty: o
    } = e.selection,
    i = r;
    if (!o)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
            return !1;
        i = Fj(r)
    }
    let s = i && i.nodeAfter;
    return !s || !Pt.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(Pt.create(e.doc, i.pos)).scrollIntoView()), !0)
};
function Fj(e) {
    if (!e.parent.type.spec.isolating)
        for (let t = e.depth - 1; t >= 0; t--) {
            let n = e.node(t);
            if (e.index(t) + 1 < n.childCount)
                return e.doc.resolve(e.after(t + 1));
            if (n.type.spec.isolating)
                break
        }
    return null
}
const yot = (e, t) => {
    let n = e.selection,
    r = n instanceof Pt,
    o;
    if (r) {
        if (n.node.isTextblock || !yc(e.doc, n.from))
            return !1;
        o = n.from
    } else if (o = ZF(e.doc, n.from, -1), o == null)
        return !1;
    if (t) {
        let i = e.tr.join(o);
        r && i.setSelection(Pt.create(i.doc, o - e.doc.resolve(o).nodeBefore.nodeSize)),
        t(i.scrollIntoView())
    }
    return !0
}, wot = (e, t) => {
    let n = e.selection,
    r;
    if (n instanceof Pt) {
        if (n.node.isTextblock || !yc(e.doc, n.to))
            return !1;
        r = n.to
    } else if (r = ZF(e.doc, n.to, 1), r == null)
        return !1;
    return t && t(e.tr.join(r).scrollIntoView()),
    !0
}, bot = (e, t) => {
    let {
        $from: n,
        $to: r
    } = e.selection,
    o = n.blockRange(r),
    i = o && vh(o);
    return i == null ? !1 : (t && t(e.tr.lift(o, i).scrollIntoView()), !0)
}, _ot = (e, t) => {
    let {
        $head: n,
        $anchor: r
    } = e.selection;
    return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (t && t(e.tr.insertText(`
`).scrollIntoView()), !0)
};
function jj(e) {
    for (let t = 0; t < e.edgeCount; t++) {
        let {
            type: n
        } = e.edge(t);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
const kot = (e, t) => {
    let {
        $head: n,
        $anchor: r
    } = e.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r))
        return !1;
    let o = n.node(-1),
    i = n.indexAfter(-1),
    s = jj(o.contentMatchAt(i));
    if (!s || !o.canReplaceWith(i, i, s))
        return !1;
    if (t) {
        let a = n.after(),
        l = e.tr.replaceWith(a, a, s.createAndFill());
        l.setSelection(Wt.near(l.doc.resolve(a), 1)),
        t(l.scrollIntoView())
    }
    return !0
}, xot = (e, t) => {
    let n = e.selection, {
        $from: r,
        $to: o
    } = n;
    if (n instanceof Ts || r.parent.inlineContent || o.parent.inlineContent)
        return !1;
    let i = jj(o.parent.contentMatchAt(o.indexAfter()));
    if (!i || !i.isTextblock)
        return !1;
    if (t) {
        let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos,
        a = e.tr.insert(s, i.createAndFill());
        a.setSelection(qt.create(a.doc, s + 1)),
        t(a.scrollIntoView())
    }
    return !0
}, Sot = (e, t) => {
    let {
        $cursor: n
    } = e.selection;
    if (!n || n.parent.content.size)
        return !1;
    if (n.depth > 1 && n.after() != n.end(-1)) {
        let i = n.before();
        if (cf(e.doc, i))
            return t && t(e.tr.split(i).scrollIntoView()), !0
    }
    let r = n.blockRange(),
    o = r && vh(r);
    return o == null ? !1 : (t && t(e.tr.lift(r, o).scrollIntoView()), !0)
}, Cot = (e, t) => {
    let {
        $from: n,
        to: r
    } = e.selection,
    o,
    i = n.sharedDepth(r);
    return i == 0 ? !1 : (o = n.before(i), t && t(e.tr.setSelection(Pt.create(e.doc, o))), !0)
};
function Iot(e, t, n) {
    let r = t.nodeBefore,
    o = t.nodeAfter,
    i = t.index();
    return !r || !o || !r.type.compatibleContent(o.type) ? !1 : !r.content.size && t.parent.canReplace(i - 1, i) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0) : !t.parent.canReplace(i, i + 1) || !(o.isTextblock || yc(e.doc, t.pos)) ? !1 : (n && n(e.tr.clearIncompatible(t.pos, r.type, r.contentMatchAt(r.childCount)).join(t.pos).scrollIntoView()), !0)
}
function Wj(e, t, n) {
    let r = t.nodeBefore,
    o = t.nodeAfter,
    i,
    s;
    if (r.type.spec.isolating || o.type.spec.isolating)
        return !1;
    if (Iot(e, t, n))
        return !0;
    let a = t.parent.canReplace(t.index(), t.index() + 1);
    if (a && (i = (s = r.contentMatchAt(r.childCount)).findWrapping(o.type)) && s.matchType(i[0] || o.type).validEnd) {
        if (n) {
            let f = t.pos + o.nodeSize,
            p = Ne.empty;
            for (let y = i.length - 1; y >= 0; y--)
                p = Ne.from(i[y].create(null, p));
            p = Ne.from(r.copy(p));
            let m = e.tr.step(new jr(t.pos - 1, f, t.pos, f, new nt(p, 1, 0), i.length, !0)),
            v = f + 2 * i.length;
            yc(m.doc, v) && m.join(v),
            n(m.scrollIntoView())
        }
        return !0
    }
    let l = Wt.findFrom(t, 1),
    c = l && l.$from.blockRange(l.$to),
    u = c && vh(c);
    if (u != null && u >= t.depth)
        return n && n(e.tr.lift(c, u).scrollIntoView()), !0;
    if (a && Uf(o, "start", !0) && Uf(r, "end")) {
        let f = r,
        p = [];
        for (; p.push(f), !f.isTextblock; )
            f = f.lastChild;
        let m = o,
        v = 1;
        for (; !m.isTextblock; m = m.firstChild)
            v++;
        if (f.canReplace(f.childCount, f.childCount, m.content)) {
            if (n) {
                let y = Ne.empty;
                for (let w = p.length - 1; w >= 0; w--)
                    y = Ne.from(p[w].copy(y));
                let b = e.tr.step(new jr(t.pos - p.length, t.pos + o.nodeSize, t.pos + v, t.pos + o.nodeSize - v, new nt(y, p.length, 0), 0, !0));
                n(b.scrollIntoView())
            }
            return !0
        }
    }
    return !1
}
function zj(e) {
    return function (t, n) {
        let r = t.selection,
        o = e < 0 ? r.$from : r.$to,
        i = o.depth;
        for (; o.node(i).isInline; ) {
            if (!i)
                return !1;
            i--
        }
        return o.node(i).isTextblock ? (n && n(t.tr.setSelection(qt.create(t.doc, e < 0 ? o.start(i) : o.end(i)))), !0) : !1
    }
}
const Tot = zj(-1), Mot = zj(1);
function Pot(e, t = null) {
    return function (n, r) {
        let {
            $from: o,
            $to: i
        } = n.selection,
        s = o.blockRange(i),
        a = s && wT(s, e, t);
        return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1
    }
}
function I5(e, t = null) {
    return function (n, r) {
        let o = !1;
        for (let i = 0; i < n.selection.ranges.length && !o; i++) {
            let {
                $from: {
                    pos: s
                },
                $to: {
                    pos: a
                }
            } = n.selection.ranges[i];
            n.doc.nodesBetween(s, a, (l, c) => {
                if (o)
                    return !1;
                if (!(!l.isTextblock || l.hasMarkup(e, t)))
                    if (l.type == e)
                        o = !0;
                    else {
                        let u = n.doc.resolve(c),
                        f = u.index();
                        o = u.parent.canReplaceWith(f, f + 1, e)
                    }
            })
        }
        if (!o)
            return !1;
        if (r) {
            let i = n.tr;
            for (let s = 0; s < n.selection.ranges.length; s++) {
                let {
                    $from: {
                        pos: a
                    },
                    $to: {
                        pos: l
                    }
                } = n.selection.ranges[s];
                i.setBlockType(a, l, e, t)
            }
            r(i.scrollIntoView())
        }
        return !0
    }
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function Eot(e, t = null) {
    return function (n, r) {
        let {
            $from: o,
            $to: i
        } = n.selection,
        s = o.blockRange(i),
        a = !1,
        l = s;
        if (!s)
            return !1;
        if (s.depth >= 2 && o.node(s.depth - 1).type.compatibleContent(e) && s.startIndex == 0) {
            if (o.index(s.depth - 1) == 0)
                return !1;
            let u = n.doc.resolve(s.start - 2);
            l = new Zy(u, u, s.depth),
            s.endIndex < s.parent.childCount && (s = new Zy(o, n.doc.resolve(i.end(s.depth)), s.depth)),
            a = !0
        }
        let c = wT(l, e, t, s);
        return c ? (r && r(Oot(n.tr, s, c, a, e).scrollIntoView()), !0) : !1
    }
}
function Oot(e, t, n, r, o) {
    let i = Ne.empty;
    for (let u = n.length - 1; u >= 0; u--)
        i = Ne.from(n[u].type.create(n[u].attrs, i));
    e.step(new jr(t.start - (r ? 2 : 0), t.end, t.start, t.end, new nt(i, 0, 0), n.length, !0));
    let s = 0;
    for (let u = 0; u < n.length; u++)
        n[u].type == o && (s = u + 1);
    let a = n.length - s,
    l = t.start + n.length - (r ? 2 : 0),
    c = t.parent;
    for (let u = t.startIndex, f = t.endIndex, p = !0; u < f; u++, p = !1)
        !p && cf(e.doc, l, a) && (e.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
    return e
}
function $ot(e) {
    return function (t, n) {
        let {
            $from: r,
            $to: o
        } = t.selection,
        i = r.blockRange(o, s => s.childCount > 0 && s.firstChild.type == e);
        return i ? n ? r.node(i.depth - 1).type == e ? Aot(t, n, e, i) : Dot(t, n, i) : !0 : !1
    }
}
function Aot(e, t, n, r) {
    let o = e.tr,
    i = r.end,
    s = r.$to.end(r.depth);
    i < s && (o.step(new jr(i - 1, s, i, s, new nt(Ne.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Zy(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
    const a = vh(r);
    if (a == null)
        return !1;
    o.lift(r, a);
    let l = o.mapping.map(i, -1) - 1;
    return yc(o.doc, l) && o.join(l),
    t(o.scrollIntoView()),
    !0
}
function Dot(e, t, n) {
    let r = e.tr,
    o = n.parent;
    for (let m = n.end, v = n.endIndex - 1, y = n.startIndex; v > y; v--)
        m -= o.child(v).nodeSize, r.delete(m - 1, m + 1);
    let i = r.doc.resolve(n.start),
    s = i.nodeAfter;
    if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
        return !1;
    let a = n.startIndex == 0,
    l = n.endIndex == o.childCount,
    c = i.node(-1),
    u = i.index(-1);
    if (!c.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? Ne.empty : Ne.from(o))))
        return !1;
    let f = i.pos,
    p = f + s.nodeSize;
    return r.step(new jr(f - (a ? 1 : 0), p + (l ? 1 : 0), f + 1, p - 1, new nt((a ? Ne.empty : Ne.from(o.copy(Ne.empty))).append(l ? Ne.empty : Ne.from(o.copy(Ne.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)),
    t(r.scrollIntoView()),
    !0
}
function Not(e) {
    return function (t, n) {
        let {
            $from: r,
            $to: o
        } = t.selection,
        i = r.blockRange(o, c => c.childCount > 0 && c.firstChild.type == e);
        if (!i)
            return !1;
        let s = i.startIndex;
        if (s == 0)
            return !1;
        let a = i.parent,
        l = a.child(s - 1);
        if (l.type != e)
            return !1;
        if (n) {
            let c = l.lastChild && l.lastChild.type == a.type,
            u = Ne.from(c ? e.create() : null),
            f = new nt(Ne.from(e.create(null, Ne.from(a.type.create(null, u)))), c ? 3 : 1, 0),
            p = i.start,
            m = i.end;
            n(t.tr.step(new jr(p - (c ? 3 : 1), m, p, m, f, 1, !0)).scrollIntoView())
        }
        return !0
    }
}
function rb(e) {
    const {
        state: t,
        transaction: n
    } = e;
    let {
        selection: r
    } = n, {
        doc: o
    } = n, {
        storedMarks: i
    } = n;
    return {
        ...t,
        apply: t.apply.bind(t),
        applyTransaction: t.applyTransaction.bind(t),
        filterTransaction: t.filterTransaction,
        plugins: t.plugins,
        schema: t.schema,
        reconfigure: t.reconfigure.bind(t),
        toJSON: t.toJSON.bind(t),
        get storedMarks() {
            return i
        },
        get selection() {
            return r
        },
        get doc() {
            return o
        },
        get tr() {
            return r = n.selection,
            o = n.doc,
            i = n.storedMarks,
            n
        }
    }
}
class ob {
    constructor(t) {
        this.editor = t.editor,
        this.rawCommands = this.editor.extensionManager.commands,
        this.customState = t.state
    }
    get hasCustomState() {
        return !!this.customState
    }
    get state() {
        return this.customState || this.editor.state
    }
    get commands() {
        const {
            rawCommands: t,
            editor: n,
            state: r
        } = this, {
            view: o
        } = n, {
            tr: i
        } = r,
        s = this.buildProps(i);
        return Object.fromEntries(Object.entries(t).map(([a, l]) => [a, (...u) => {
                        const f = l(...u)(s);
                        return !i.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(i),
                        f
                    }
                ]))
    }
    get chain() {
        return () => this.createChain()
    }
    get can() {
        return () => this.createCan()
    }
    createChain(t, n = !0) {
        const {
            rawCommands: r,
            editor: o,
            state: i
        } = this, {
            view: s
        } = o,
        a = [],
        l = !!t,
        c = t || i.tr,
        u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c), a.every(p => p === !0)),
        f = {
            ...Object.fromEntries(Object.entries(r).map(([p, m]) => [p, (...y) => {
                            const b = this.buildProps(c, n),
                            w = m(...y)(b);
                            return a.push(w),
                            f
                        }
                    ])),
            run: u
        };
        return f
    }
    createCan(t) {
        const {
            rawCommands: n,
            state: r
        } = this,
        o = !1,
        i = t || r.tr,
        s = this.buildProps(i, o);
        return {
            ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({
                            ...s,
                            dispatch: void 0
                        })])),
            chain: () => this.createChain(i, o)
        }
    }
    buildProps(t, n = !0) {
        const {
            rawCommands: r,
            editor: o,
            state: i
        } = this, {
            view: s
        } = o;
        i.storedMarks && t.setStoredMarks(i.storedMarks);
        const a = {
            tr: t,
            editor: o,
            view: s,
            state: rb({
                state: i,
                transaction: t
            }),
            dispatch: n ? () => {}
             : void 0,
            chain: () => this.createChain(t),
            can: () => this.createCan(t),
            get commands() {
                return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(a)]))
            }
        };
        return a
    }
}
class Rot {
    constructor() {
        this.callbacks = {}
    }
    on(t, n) {
        return this.callbacks[t] || (this.callbacks[t] = []),
        this.callbacks[t].push(n),
        this
    }
    emit(t, ...n) {
        const r = this.callbacks[t];
        return r && r.forEach(o => o.apply(this, n)),
        this
    }
    off(t, n) {
        const r = this.callbacks[t];
        return r && (n ? this.callbacks[t] = r.filter(o => o !== n) : delete this.callbacks[t]),
        this
    }
    removeAllListeners() {
        this.callbacks = {}
    }
}
function lt(e, t, n) {
    return e.config[t] === void 0 && e.parent ? lt(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
        ...n,
        parent: e.parent ? lt(e.parent, t, n) : null
    }) : e.config[t]
}
function ib(e) {
    const t = e.filter(o => o.type === "extension"),
    n = e.filter(o => o.type === "node"),
    r = e.filter(o => o.type === "mark");
    return {
        baseExtensions: t,
        nodeExtensions: n,
        markExtensions: r
    }
}
function Hj(e) {
    const t = [], {
        nodeExtensions: n,
        markExtensions: r
    } = ib(e),
    o = [...n, ...r],
    i = {
    default:
        null,
        rendered: !0,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: !0,
        isRequired: !1
    };
    return e.forEach(s => {
        const a = {
            name: s.name,
            options: s.options,
            storage: s.storage
        },
        l = lt(s, "addGlobalAttributes", a);
        if (!l)
            return;
        l().forEach(u => {
            u.types.forEach(f => {
                Object.entries(u.attributes).forEach(([p, m]) => {
                    t.push({
                        type: f,
                        name: p,
                        attribute: {
                            ...i,
                            ...m
                        }
                    })
                })
            })
        })
    }),
    o.forEach(s => {
        const a = {
            name: s.name,
            options: s.options,
            storage: s.storage
        },
        l = lt(s, "addAttributes", a);
        if (!l)
            return;
        const c = l();
        Object.entries(c).forEach(([u, f]) => {
            const p = {
                ...i,
                ...f
            };
            typeof p?.default  == "function" && (p.default = p.default()), p?.isRequired && p?.default  === void 0 && delete p.default, t.push({
                type: s.name,
                name: u,
                attribute: p
            })
        })
    }),
    t
}
function Hr(e, t) {
    if (typeof e == "string") {
        if (!t.nodes[e])
            throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
        return t.nodes[e]
    }
    return e
}
function xr(...e) {
    return e.filter(t => !!t).reduce((t, n) => {
        const r = {
            ...t
        };
        return Object.entries(n).forEach(([o, i]) => {
            if (!r[o]) {
                r[o] = i;
                return
            }
            o === "class" ? r[o] = [r[o], i].join(" ") : o === "style" ? r[o] = [r[o], i].join("; ") : r[o] = i
        }),
        r
    }, {})
}
function fS(e, t) {
    return t.filter(n => n.attribute.rendered).map(n => n.attribute.renderHTML ? n.attribute.renderHTML(e.attrs) || {}
         : {
        [n.name]: e.attrs[n.name]
    }).reduce((n, r) => xr(n, r), {})
}
function Uj(e) {
    return typeof e == "function"
}
function jt(e, t = void 0, ...n) {
    return Uj(e) ? t ? e.bind(t)(...n) : e(...n) : e
}
function Lot(e = {}) {
    return Object.keys(e).length === 0 && e.constructor === Object
}
function Bot(e) {
    return typeof e != "string" ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : e === "true" ? !0 : e === "false" ? !1 : e
}
function T5(e, t) {
    return e.style ? e : {
        ...e,
        getAttrs: n => {
            const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
            if (r === !1)
                return !1;
            const o = t.reduce((i, s) => {
                const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : Bot(n.getAttribute(s.name));
                return a == null ? i : {
                    ...i,
                    [s.name]: a
                }
            }, {});
            return {
                ...r,
                ...o
            }
        }
    }
}
function M5(e) {
    return Object.fromEntries(Object.entries(e).filter(([t, n]) => t === "attrs" && Lot(n) ? !1 : n != null))
}
function Vot(e, t) {
    var n;
    const r = Hj(e), {
        nodeExtensions: o,
        markExtensions: i
    } = ib(e),
    s = (n = o.find(c => lt(c, "topNode"))) === null || n === void 0 ? void 0 : n.name,
    a = Object.fromEntries(o.map(c => {
                const u = r.filter(w => w.type === c.name),
                f = {
                    name: c.name,
                    options: c.options,
                    storage: c.storage,
                    editor: t
                },
                p = e.reduce((w, k) => {
                    const C = lt(k, "extendNodeSchema", f);
                    return {
                        ...w,
                        ...C ? C(c) : {}
                    }
                }, {}),
                m = M5({
                    ...p,
                    content: jt(lt(c, "content", f)),
                    marks: jt(lt(c, "marks", f)),
                    group: jt(lt(c, "group", f)),
                    inline: jt(lt(c, "inline", f)),
                    atom: jt(lt(c, "atom", f)),
                    selectable: jt(lt(c, "selectable", f)),
                    draggable: jt(lt(c, "draggable", f)),
                    code: jt(lt(c, "code", f)),
                    defining: jt(lt(c, "defining", f)),
                    isolating: jt(lt(c, "isolating", f)),
                    attrs: Object.fromEntries(u.map(w => {
                            var k;
                            return [w.name, {
                                default:
                                    (k = w?.attribute) === null || k === void 0 ? void 0 : k.default
                                }
                            ]
                        }))
                }),
                v = jt(lt(c, "parseHTML", f));
                v && (m.parseDOM = v.map(w => T5(w, u)));
                const y = lt(c, "renderHTML", f);
                y && (m.toDOM = w => y({
                        node: w,
                        HTMLAttributes: fS(w, u)
                    }));
                const b = lt(c, "renderText", f);
                return b && (m.toText = b),
                [c.name, m]
            })),
    l = Object.fromEntries(i.map(c => {
                const u = r.filter(b => b.type === c.name),
                f = {
                    name: c.name,
                    options: c.options,
                    storage: c.storage,
                    editor: t
                },
                p = e.reduce((b, w) => {
                    const k = lt(w, "extendMarkSchema", f);
                    return {
                        ...b,
                        ...k ? k(c) : {}
                    }
                }, {}),
                m = M5({
                    ...p,
                    inclusive: jt(lt(c, "inclusive", f)),
                    excludes: jt(lt(c, "excludes", f)),
                    group: jt(lt(c, "group", f)),
                    spanning: jt(lt(c, "spanning", f)),
                    code: jt(lt(c, "code", f)),
                    attrs: Object.fromEntries(u.map(b => {
                            var w;
                            return [b.name, {
                                default:
                                    (w = b?.attribute) === null || w === void 0 ? void 0 : w.default
                                }
                            ]
                        }))
                }),
                v = jt(lt(c, "parseHTML", f));
                v && (m.parseDOM = v.map(b => T5(b, u)));
                const y = lt(c, "renderHTML", f);
                return y && (m.toDOM = b => y({
                        mark: b,
                        HTMLAttributes: fS(b, u)
                    })),
                [c.name, m]
            }));
    return new Ztt({
        topNode: s,
        nodes: a,
        marks: l
    })
}
function Q2(e, t) {
    return t.nodes[e] || t.marks[e] || null
}
function P5(e, t) {
    return Array.isArray(t) ? t.some(n => (typeof n == "string" ? n : n.name) === e.name) : t
}
const Fot = (e, t = 500) => {
    let n = "";
    const r = e.parentOffset;
    return e.parent.nodesBetween(Math.max(0, r - t), r, (o, i, s, a) => {
        var l,
        c;
        const u = ((c = (l = o.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
                node: o,
                pos: i,
                parent: s,
                index: a
            })) || o.textContent || "%leaf%";
        n += u.slice(0, Math.max(0, r - i))
    }),
    n
};
function OT(e) {
    return Object.prototype.toString.call(e) === "[object RegExp]"
}
class sb {
    constructor(t) {
        this.find = t.find,
        this.handler = t.handler
    }
}
const jot = (e, t) => {
    if (OT(t))
        return t.exec(e);
    const n = t(e);
    if (!n)
        return null;
    const r = [n.text];
    return r.index = n.index,
    r.input = e,
    r.data = n.data,
    n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)),
    r
};
function ek(e) {
    var t;
    const {
        editor: n,
        from: r,
        to: o,
        text: i,
        rules: s,
        plugin: a
    } = e, {
        view: l
    } = n;
    if (l.composing)
        return !1;
    const c = l.state.doc.resolve(r);
    if (c.parent.type.spec.code || !((t = c.nodeBefore || c.nodeAfter) === null || t === void 0) && t.marks.find(p => p.type.spec.code))
        return !1;
    let u = !1;
    const f = Fot(c) + i;
    return s.forEach(p => {
        if (u)
            return;
        const m = jot(f, p.find);
        if (!m)
            return;
        const v = l.state.tr,
        y = rb({
            state: l.state,
            transaction: v
        }),
        b = {
            from: r - (m[0].length - i.length),
            to: o
        }, {
            commands: w,
            chain: k,
            can: C
        } = new ob({
            editor: n,
            state: y
        });
        p.handler({
            state: y,
            range: b,
            match: m,
            commands: w,
            chain: k,
            can: C
        }) === null || !v.steps.length || (v.setMeta(a, {
                transform: v,
                from: r,
                to: o,
                text: i
            }), l.dispatch(v), u = !0)
    }),
    u
}
function Wot(e) {
    const {
        editor: t,
        rules: n
    } = e,
    r = new go({
        state: {
            init() {
                return null
            },
            apply(o, i) {
                const s = o.getMeta(r);
                return s || (o.selectionSet || o.docChanged ? null : i)
            }
        },
        props: {
            handleTextInput(o, i, s, a) {
                return ek({
                    editor: t,
                    from: i,
                    to: s,
                    text: a,
                    rules: n,
                    plugin: r
                })
            },
            handleDOMEvents: {
                compositionend: o => (setTimeout(() => {
                        const {
                            $cursor: i
                        } = o.state.selection;
                        i && ek({
                            editor: t,
                            from: i.pos,
                            to: i.pos,
                            text: "",
                            rules: n,
                            plugin: r
                        })
                    }), !1)
            },
            handleKeyDown(o, i) {
                if (i.key !== "Enter")
                    return !1;
                const {
                    $cursor: s
                } = o.state.selection;
                return s ? ek({
                    editor: t,
                    from: s.pos,
                    to: s.pos,
                    text: `
`,
                    rules: n,
                    plugin: r
                }) : !1
            }
        },
        isInputRules: !0
    });
    return r
}
function zot(e) {
    return typeof e == "number"
}
class Hot {
    constructor(t) {
        this.find = t.find,
        this.handler = t.handler
    }
}
const Uot = (e, t) => {
    if (OT(t))
        return [...e.matchAll(t)];
    const n = t(e);
    return n ? n.map(r => {
        const o = [r.text];
        return o.index = r.index,
        o.input = e,
        o.data = r.data,
        r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(r.replaceWith)),
        o
    }) : []
};
function qot(e) {
    const {
        editor: t,
        state: n,
        from: r,
        to: o,
        rule: i
    } = e, {
        commands: s,
        chain: a,
        can: l
    } = new ob({
        editor: t,
        state: n
    }),
    c = [];
    return n.doc.nodesBetween(r, o, (f, p) => {
        if (!f.isTextblock || f.type.spec.code)
            return;
        const m = Math.max(r, p),
        v = Math.min(o, p + f.content.size),
        y = f.textBetween(m - p, v - p, void 0, "￼");
        Uot(y, i.find).forEach(w => {
            if (w.index === void 0)
                return;
            const k = m + w.index + 1,
            C = k + w[0].length,
            x = {
                from: n.tr.mapping.map(k),
                to: n.tr.mapping.map(C)
            },
            S = i.handler({
                state: n,
                range: x,
                match: w,
                commands: s,
                chain: a,
                can: l
            });
            c.push(S)
        })
    }),
    c.every(f => f !== null)
}
function Yot(e) {
    const {
        editor: t,
        rules: n
    } = e;
    let r = null,
    o = !1,
    i = !1;
    return n.map(a => new go({
            view(l) {
                const c = u => {
                    var f;
                    r = !((f = l.dom.parentElement) === null || f === void 0) && f.contains(u.target) ? l.dom.parentElement : null
                };
                return window.addEventListener("dragstart", c), {
                    destroy() {
                        window.removeEventListener("dragstart", c)
                    }
                }
            },
            props: {
                handleDOMEvents: {
                    drop: l => (i = r === l.dom.parentElement, !1),
                    paste: (l, c) => {
                        var u;
                        const f = (u = c.clipboardData) === null || u === void 0 ? void 0 : u.getData("text/html");
                        return o = !!f?.includes("data-pm-slice"),
                        !1
                    }
                }
            },
            appendTransaction: (l, c, u) => {
                const f = l[0],
                p = f.getMeta("uiEvent") === "paste" && !o,
                m = f.getMeta("uiEvent") === "drop" && !i;
                if (!p && !m)
                    return;
                const v = c.doc.content.findDiffStart(u.doc.content),
                y = c.doc.content.findDiffEnd(u.doc.content);
                if (!zot(v) || !y || v === y.b)
                    return;
                const b = u.tr,
                w = rb({
                    state: u,
                    transaction: b
                });
                if (!(!qot({
                            editor: t,
                            state: w,
                            from: Math.max(v - 1, 0),
                            to: y.b - 1,
                            rule: a
                        }) || !b.steps.length))
                    return b
            }
        }))
}
function Kot(e) {
    const t = e.filter((n, r) => e.indexOf(n) !== r);
    return [...new Set(t)]
}
class Ud {
    constructor(t, n) {
        this.splittableMarks = [],
        this.editor = n,
        this.extensions = Ud.resolve(t),
        this.schema = Vot(this.extensions, n),
        this.extensions.forEach(r => {
            var o;
            this.editor.extensionStorage[r.name] = r.storage;
            const i = {
                name: r.name,
                options: r.options,
                storage: r.storage,
                editor: this.editor,
                type: Q2(r.name, this.schema)
            };
            r.type === "mark" && (!((o = jt(lt(r, "keepOnSplit", i))) !== null && o !== void 0) || o) && this.splittableMarks.push(r.name);
            const s = lt(r, "onBeforeCreate", i);
            s && this.editor.on("beforeCreate", s);
            const a = lt(r, "onCreate", i);
            a && this.editor.on("create", a);
            const l = lt(r, "onUpdate", i);
            l && this.editor.on("update", l);
            const c = lt(r, "onSelectionUpdate", i);
            c && this.editor.on("selectionUpdate", c);
            const u = lt(r, "onTransaction", i);
            u && this.editor.on("transaction", u);
            const f = lt(r, "onFocus", i);
            f && this.editor.on("focus", f);
            const p = lt(r, "onBlur", i);
            p && this.editor.on("blur", p);
            const m = lt(r, "onDestroy", i);
            m && this.editor.on("destroy", m)
        })
    }
    static resolve(t) {
        const n = Ud.sort(Ud.flatten(t)),
        r = Kot(n.map(o => o.name));
        return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map(o => `'${o}'`).join(", ")}]. This can lead to issues.`),
        n
    }
    static flatten(t) {
        return t.map(n => {
            const r = {
                name: n.name,
                options: n.options,
                storage: n.storage
            },
            o = lt(n, "addExtensions", r);
            return o ? [n, ...this.flatten(o())] : n
        }).flat(10)
    }
    static sort(t) {
        return t.sort((r, o) => {
            const i = lt(r, "priority") || 100,
            s = lt(o, "priority") || 100;
            return i > s ? -1 : i < s ? 1 : 0
        })
    }
    get commands() {
        return this.extensions.reduce((t, n) => {
            const r = {
                name: n.name,
                options: n.options,
                storage: n.storage,
                editor: this.editor,
                type: Q2(n.name, this.schema)
            },
            o = lt(n, "addCommands", r);
            return o ? {
                ...t,
                ...o()
            }
             : t
        }, {})
    }
    get plugins() {
        const {
            editor: t
        } = this,
        n = Ud.sort([...this.extensions].reverse()),
        r = [],
        o = [],
        i = n.map(s => {
            const a = {
                name: s.name,
                options: s.options,
                storage: s.storage,
                editor: t,
                type: Q2(s.name, this.schema)
            },
            l = [],
            c = lt(s, "addKeyboardShortcuts", a);
            let u = {};
            if (s.type === "mark" && s.config.exitable && (u.ArrowRight = () => ls.handleExit({
                        editor: t,
                        mark: s
                    })), c) {
                const y = Object.fromEntries(Object.entries(c()).map(([b, w]) => [b, () => w({
                                    editor: t
                                })]));
                u = {
                    ...u,
                    ...y
                }
            }
            const f = uot(u);
            l.push(f);
            const p = lt(s, "addInputRules", a);
            P5(s, t.options.enableInputRules) && p && r.push(...p());
            const m = lt(s, "addPasteRules", a);
            P5(s, t.options.enablePasteRules) && m && o.push(...m());
            const v = lt(s, "addProseMirrorPlugins", a);
            if (v) {
                const y = v();
                l.push(...y)
            }
            return l
        }).flat();
        return [Wot({
                editor: t,
                rules: r
            }), ...Yot({
                editor: t,
                rules: o
            }), ...i]
    }
    get attributes() {
        return Hj(this.extensions)
    }
    get nodeViews() {
        const {
            editor: t
        } = this, {
            nodeExtensions: n
        } = ib(this.extensions);
        return Object.fromEntries(n.filter(r => !!lt(r, "addNodeView")).map(r => {
                const o = this.attributes.filter(l => l.type === r.name),
                i = {
                    name: r.name,
                    options: r.options,
                    storage: r.storage,
                    editor: t,
                    type: Hr(r.name, this.schema)
                },
                s = lt(r, "addNodeView", i);
                if (!s)
                    return [];
                const a = (l, c, u, f) => {
                    const p = fS(l, o);
                    return s()({
                        editor: t,
                        node: l,
                        getPos: u,
                        decorations: f,
                        HTMLAttributes: p,
                        extension: r
                    })
                };
                return [r.name, a]
            }))
    }
}
function Got(e) {
    return Object.prototype.toString.call(e).slice(8, -1)
}
function tk(e) {
    return Got(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype
}
function ab(e, t) {
    const n = {
        ...e
    };
    return tk(e) && tk(t) && Object.keys(t).forEach(r => {
        tk(t[r]) ? r in e ? n[r] = ab(e[r], t[r]) : Object.assign(n, {
            [r]: t[r]
        }) : Object.assign(n, {
            [r]: t[r]
        })
    }),
    n
}
class oi {
    constructor(t = {}) {
        this.type = "extension",
        this.name = "extension",
        this.parent = null,
        this.child = null,
        this.config = {
            name: this.name,
            defaultOptions: {}
        },
        this.config = {
            ...this.config,
            ...t
        },
        this.name = this.config.name,
        t.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
        this.options = this.config.defaultOptions,
        this.config.addOptions && (this.options = jt(lt(this, "addOptions", {
                        name: this.name
                    }))),
        this.storage = jt(lt(this, "addStorage", {
                    name: this.name,
                    options: this.options
                })) || {}
    }
    static create(t = {}) {
        return new oi(t)
    }
    configure(t = {}) {
        const n = this.extend();
        return n.options = ab(this.options, t),
        n.storage = jt(lt(n, "addStorage", {
                    name: n.name,
                    options: n.options
                })),
        n
    }
    extend(t = {}) {
        const n = new oi(t);
        return n.parent = this,
        this.child = n,
        n.name = t.name ? t.name : n.parent.name,
        t.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
        n.options = jt(lt(n, "addOptions", {
                    name: n.name
                })),
        n.storage = jt(lt(n, "addStorage", {
                    name: n.name,
                    options: n.options
                })),
        n
    }
}
function qj(e, t, n) {
    const {
        from: r,
        to: o
    } = t, {
        blockSeparator: i = `

`,
        textSerializers: s = {}
    } = n || {};
    let a = "",
    l = !0;
    return e.nodesBetween(r, o, (c, u, f, p) => {
        var m;
        const v = s?.[c.type.name];
        v ? (c.isBlock && !l && (a += i, l = !0), f && (a += v({
                    node: c,
                    pos: u,
                    parent: f,
                    index: p,
                    range: t
                }))) : c.isText ? (a += (m = c?.text) === null || m === void 0 ? void 0 : m.slice(Math.max(r, u) - u, o - u), l = !1) : c.isBlock && !l && (a += i, l = !0)
    }),
    a
}
function Yj(e) {
    return Object.fromEntries(Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText]))
}
const Xot = oi.create({
    name: "clipboardTextSerializer",
    addProseMirrorPlugins() {
        return [new go({
                key: new ps("clipboardTextSerializer"),
                props: {
                    clipboardTextSerializer: () => {
                        const {
                            editor: e
                        } = this, {
                            state: t,
                            schema: n
                        } = e, {
                            doc: r,
                            selection: o
                        } = t, {
                            ranges: i
                        } = o,
                        s = Math.min(...i.map(u => u.$from.pos)),
                        a = Math.max(...i.map(u => u.$to.pos)),
                        l = Yj(n);
                        return qj(r, {
                            from: s,
                            to: a
                        }, {
                            textSerializers: l
                        })
                    }
                }
            })]
    }
}), Jot = () => ({
    editor: e,
    view: t
}) => (requestAnimationFrame(() => {
        var n;
        e.isDestroyed || (t.dom.blur(), (n = window?.getSelection()) === null || n === void 0 || n.removeAllRanges())
    }), !0), Zot = (e = !1) => ({
    commands: t
}) => t.setContent("", e), Qot = () => ({
    state: e,
    tr: t,
    dispatch: n
}) => {
    const {
        selection: r
    } = t, {
        ranges: o
    } = r;
    return n && o.forEach(({
            $from: i,
            $to: s
        }) => {
        e.doc.nodesBetween(i.pos, s.pos, (a, l) => {
            if (a.type.isText)
                return;
            const {
                doc: c,
                mapping: u
            } = t,
            f = c.resolve(u.map(l)),
            p = c.resolve(u.map(l + a.nodeSize)),
            m = f.blockRange(p);
            if (!m)
                return;
            const v = vh(m);
            if (a.type.isTextblock) {
                const {
                    defaultType: y
                } = f.parent.contentMatchAt(f.index());
                t.setNodeMarkup(m.start, y)
            }
            (v || v === 0) && t.lift(m, v)
        })
    }),
    !0
}, eit = e => t => e(t), tit = () => ({
    state: e,
    dispatch: t
}) => xot(e, t), nit = () => ({
    tr: e,
    dispatch: t
}) => {
    const {
        selection: n
    } = e,
    r = n.$anchor.node();
    if (r.content.size > 0)
        return !1;
    const o = e.selection.$anchor;
    for (let i = o.depth; i > 0; i -= 1)
        if (o.node(i).type === r.type) {
            if (t) {
                const a = o.before(i),
                l = o.after(i);
                e.delete(a, l).scrollIntoView()
            }
            return !0
        }
    return !1
}, rit = e => ({
    tr: t,
    state: n,
    dispatch: r
}) => {
    const o = Hr(e, n.schema),
    i = t.selection.$anchor;
    for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === o) {
            if (r) {
                const l = i.before(s),
                c = i.after(s);
                t.delete(l, c).scrollIntoView()
            }
            return !0
        }
    return !1
}, oit = e => ({
    tr: t,
    dispatch: n
}) => {
    const {
        from: r,
        to: o
    } = e;
    return n && t.delete(r, o),
    !0
}, iit = () => ({
    state: e,
    dispatch: t
}) => dot(e, t), sit = () => ({
    commands: e
}) => e.keyboardShortcut("Enter"), ait = () => ({
    state: e,
    dispatch: t
}) => kot(e, t);
function s1(e, t, n = {
        strict: !0
    }) {
    const r = Object.keys(t);
    return r.length ? r.every(o => n.strict ? t[o] === e[o] : OT(t[o]) ? t[o].test(e[o]) : t[o] === e[o]) : !0
}
function hS(e, t, n = {}) {
    return e.find(r => r.type === t && s1(r.attrs, n))
}
function lit(e, t, n = {}) {
    return !!hS(e, t, n)
}
function $T(e, t, n = {}) {
    if (!e || !t)
        return;
    let r = e.parent.childAfter(e.parentOffset);
    if (e.parentOffset === r.offset && r.offset !== 0 && (r = e.parent.childBefore(e.parentOffset)), !r.node)
        return;
    const o = hS([...r.node.marks], t, n);
    if (!o)
        return;
    let i = r.index,
    s = e.start() + r.offset,
    a = i + 1,
    l = s + r.node.nodeSize;
    for (hS([...r.node.marks], t, n); i > 0 && o.isInSet(e.parent.child(i - 1).marks); )
        i -= 1, s -= e.parent.child(i).nodeSize;
    for (; a < e.parent.childCount && lit([...e.parent.child(a).marks], t, n); )
        l += e.parent.child(a).nodeSize, a += 1;
    return {
        from: s,
        to: l
    }
}
function bc(e, t) {
    if (typeof e == "string") {
        if (!t.marks[e])
            throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
        return t.marks[e]
    }
    return e
}
const cit = (e, t = {}) => ({
    tr: n,
    state: r,
    dispatch: o
}) => {
    const i = bc(e, r.schema), {
        doc: s,
        selection: a
    } = n, {
        $from: l,
        from: c,
        to: u
    } = a;
    if (o) {
        const f = $T(l, i, t);
        if (f && f.from <= c && f.to >= u) {
            const p = qt.create(s, f.from, f.to);
            n.setSelection(p)
        }
    }
    return !0
}, uit = e => t => {
    const n = typeof e == "function" ? e(t) : e;
    for (let r = 0; r < n.length; r += 1)
        if (n[r](t))
            return !0;
    return !1
};
function Kj(e) {
    return e instanceof qt
}
function eu(e = 0, t = 0, n = 0) {
    return Math.min(Math.max(e, t), n)
}
function Gj(e, t = null) {
    if (!t)
        return null;
    const n = Wt.atStart(e),
    r = Wt.atEnd(e);
    if (t === "start" || t === !0)
        return n;
    if (t === "end")
        return r;
    const o = n.from,
    i = r.to;
    return t === "all" ? qt.create(e, eu(0, o, i), eu(e.content.size, o, i)) : qt.create(e, eu(t, o, i), eu(t, o, i))
}
function AT() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document
}
const dit = (e = null, t = {}) => ({
    editor: n,
    view: r,
    tr: o,
    dispatch: i
}) => {
    t = {
        scrollIntoView: !0,
        ...t
    };
    const s = () => {
        AT() && r.dom.focus(),
        requestAnimationFrame(() => {
            n.isDestroyed || (r.focus(), t?.scrollIntoView && n.commands.scrollIntoView())
        })
    };
    if (r.hasFocus() && e === null || e === !1)
        return !0;
    if (i && e === null && !Kj(n.state.selection))
        return s(), !0;
    const a = Gj(o.doc, e) || n.state.selection,
    l = n.state.selection.eq(a);
    return i && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), s()),
    !0
}, fit = (e, t) => n => e.every((r, o) => t(r, {
        ...n,
        index: o
    })), hit = (e, t) => ({
    tr: n,
    commands: r
}) => r.insertContentAt({
    from: n.selection.from,
    to: n.selection.to
}, e, t);
function E5(e) {
    const t = `<body>${e}</body>`;
    return new window.DOMParser().parseFromString(t, "text/html").body
}
function a1(e, t, n) {
    if (n = {
            slice: !0,
            parseOptions: {},
            ...n
        }, typeof e == "object" && e !== null)
        try {
            return Array.isArray(e) && e.length > 0 ? Ne.fromArray(e.map(r => t.nodeFromJSON(r))) : t.nodeFromJSON(e)
        } catch (r) {
            return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", r),
            a1("", t, n)
        }
    if (typeof e == "string") {
        const r = vT.fromSchema(t);
        return n.slice ? r.parseSlice(E5(e), n.parseOptions).content : r.parse(E5(e), n.parseOptions)
    }
    return a1("", t, n)
}
function pit(e, t, n) {
    const r = e.steps.length - 1;
    if (r < t)
        return;
    const o = e.steps[r];
    if (!(o instanceof ao || o instanceof jr))
        return;
    const i = e.mapping.maps[r];
    let s = 0;
    i.forEach((a, l, c, u) => {
        s === 0 && (s = u)
    }),
    e.setSelection(Wt.near(e.doc.resolve(s), n))
}
const mit = e => e.toString().startsWith("<"), git = (e, t, n) => ({
    tr: r,
    dispatch: o,
    editor: i
}) => {
    if (o) {
        n = {
            parseOptions: {},
            updateSelection: !0,
            ...n
        };
        const s = a1(t, i.schema, {
            parseOptions: {
                preserveWhitespace: "full",
                ...n.parseOptions
            }
        });
        if (s.toString() === "<>")
            return !0;
        let {
            from: a,
            to: l
        } = typeof e == "number" ? {
            from: e,
            to: e
        }
         : e,
        c = !0,
        u = !0;
        if ((mit(s) ? s : [s]).forEach(p => {
                p.check(),
                c = c ? p.isText && p.marks.length === 0 : !1,
                u = u ? p.isBlock : !1
            }), a === l && u) {
            const {
                parent: p
            } = r.doc.resolve(a);
            p.isTextblock && !p.type.spec.code && !p.childCount && (a -= 1, l += 1)
        }
        c ? Array.isArray(t) ? r.insertText(t.map(p => p.text || "").join(""), a, l) : typeof t == "object" && t && t.text ? r.insertText(t.text, a, l) : r.insertText(t, a, l) : r.replaceWith(a, l, s),
        n.updateSelection && pit(r, r.steps.length - 1, -1)
    }
    return !0
}, vit = () => ({
    state: e,
    dispatch: t
}) => yot(e, t), yit = () => ({
    state: e,
    dispatch: t
}) => wot(e, t), wit = () => ({
    state: e,
    dispatch: t
}) => hot(e, t), bit = () => ({
    state: e,
    dispatch: t
}) => got(e, t);
function Xj() {
    return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1
}
function _it(e) {
    const t = e.split(/-(?!$)/);
    let n = t[t.length - 1];
    n === "Space" && (n = " ");
    let r,
    o,
    i,
    s;
    for (let a = 0; a < t.length - 1; a += 1) {
        const l = t[a];
        if (/^(cmd|meta|m)$/i.test(l))
            s = !0;
        else if (/^a(lt)?$/i.test(l))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(l))
            o = !0;
        else if (/^s(hift)?$/i.test(l))
            i = !0;
        else if (/^mod$/i.test(l))
            AT() || Xj() ? s = !0 : o = !0;
        else
            throw new Error(`Unrecognized modifier name: ${l}`)
    }
    return r && (n = `Alt-${n}`),
    o && (n = `Ctrl-${n}`),
    s && (n = `Meta-${n}`),
    i && (n = `Shift-${n}`),
    n
}
const kit = e => ({
    editor: t,
    view: n,
    tr: r,
    dispatch: o
}) => {
    const i = _it(e).split(/-(?!$)/),
    s = i.find(c => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)),
    a = new KeyboardEvent("keydown", {
        key: s === "Space" ? " " : s,
        altKey: i.includes("Alt"),
        ctrlKey: i.includes("Ctrl"),
        metaKey: i.includes("Meta"),
        shiftKey: i.includes("Shift"),
        bubbles: !0,
        cancelable: !0
    }),
    l = t.captureTransaction(() => {
        n.someProp("handleKeyDown", c => c(n, a))
    });
    return l?.steps.forEach(c => {
        const u = c.map(r.mapping);
        u && o && r.maybeStep(u)
    }),
    !0
};
function Wm(e, t, n = {}) {
    const {
        from: r,
        to: o,
        empty: i
    } = e.selection,
    s = t ? Hr(t, e.schema) : null,
    a = [];
    e.doc.nodesBetween(r, o, (f, p) => {
        if (f.isText)
            return;
        const m = Math.max(r, p),
        v = Math.min(o, p + f.nodeSize);
        a.push({
            node: f,
            from: m,
            to: v
        })
    });
    const l = o - r,
    c = a.filter(f => s ? s.name === f.node.type.name : !0).filter(f => s1(f.node.attrs, n, {
                strict: !1
            }));
    return i ? !!c.length : c.reduce((f, p) => f + p.to - p.from, 0) >= l
}
const xit = (e, t = {}) => ({
    state: n,
    dispatch: r
}) => {
    const o = Hr(e, n.schema);
    return Wm(n, o, t) ? bot(n, r) : !1
}, Sit = () => ({
    state: e,
    dispatch: t
}) => Sot(e, t), Cit = e => ({
    state: t,
    dispatch: n
}) => {
    const r = Hr(e, t.schema);
    return $ot(r)(t, n)
}, Iit = () => ({
    state: e,
    dispatch: t
}) => _ot(e, t);
function lb(e, t) {
    return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null
}
function O5(e, t) {
    const n = typeof t == "string" ? [t] : t;
    return Object.keys(e).reduce((r, o) => (n.includes(o) || (r[o] = e[o]), r), {})
}
const Tit = (e, t) => ({
    tr: n,
    state: r,
    dispatch: o
}) => {
    let i = null,
    s = null;
    const a = lb(typeof e == "string" ? e : e.name, r.schema);
    return a ? (a === "node" && (i = Hr(e, r.schema)), a === "mark" && (s = bc(e, r.schema)), o && n.selection.ranges.forEach(l => {
            r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
                i && i === c.type && n.setNodeMarkup(u, void 0, O5(c.attrs, t)),
                s && c.marks.length && c.marks.forEach(f => {
                    s === f.type && n.addMark(u, u + c.nodeSize, s.create(O5(f.attrs, t)))
                })
            })
        }), !0) : !1
}, Mit = () => ({
    tr: e,
    dispatch: t
}) => (t && e.scrollIntoView(), !0), Pit = () => ({
    tr: e,
    commands: t
}) => t.setTextSelection({
    from: 0,
    to: e.doc.content.size
}), Eit = () => ({
    state: e,
    dispatch: t
}) => pot(e, t), Oit = () => ({
    state: e,
    dispatch: t
}) => vot(e, t), $it = () => ({
    state: e,
    dispatch: t
}) => Cot(e, t), Ait = () => ({
    state: e,
    dispatch: t
}) => Mot(e, t), Dit = () => ({
    state: e,
    dispatch: t
}) => Tot(e, t);
function Jj(e, t, n = {}) {
    return a1(e, t, {
        slice: !1,
        parseOptions: n
    })
}
const Nit = (e, t = !1, n = {}) => ({
    tr: r,
    editor: o,
    dispatch: i
}) => {
    const {
        doc: s
    } = r,
    a = Jj(e, o.schema, n);
    return i && r.replaceWith(0, s.content.size, a).setMeta("preventUpdate", !t),
    !0
};
function Rit(e, t) {
    const n = new oj(e);
    return t.forEach(r => {
        r.steps.forEach(o => {
            n.step(o)
        })
    }),
    n
}
function Lit(e) {
    for (let t = 0; t < e.edgeCount; t += 1) {
        const {
            type: n
        } = e.edge(t);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
function Bit(e, t, n) {
    const r = [];
    return e.nodesBetween(t.from, t.to, (o, i) => {
        n(o) && r.push({
            node: o,
            pos: i
        })
    }),
    r
}
function Vit(e, t) {
    for (let n = e.depth; n > 0; n -= 1) {
        const r = e.node(n);
        if (t(r))
            return {
                pos: n > 0 ? e.before(n) : 0,
                start: e.start(n),
                depth: n,
                node: r
            }
    }
}
function DT(e) {
    return t => Vit(t.$from, e)
}
function Fit(e, t) {
    const n = ta.fromSchema(t).serializeFragment(e),
    o = document.implementation.createHTMLDocument().createElement("div");
    return o.appendChild(n),
    o.innerHTML
}
function jit(e, t) {
    const n = {
        from: 0,
        to: e.content.size
    };
    return qj(e, n, t)
}
function cb(e, t) {
    const n = bc(t, e.schema), {
        from: r,
        to: o,
        empty: i
    } = e.selection,
    s = [];
    i ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, o, l => {
        s.push(...l.marks)
    });
    const a = s.find(l => l.type.name === n.name);
    return a ? {
        ...a.attrs
    }
     : {}
}
function Wit(e, t) {
    const n = Hr(t, e.schema), {
        from: r,
        to: o
    } = e.selection,
    i = [];
    e.doc.nodesBetween(r, o, a => {
        i.push(a)
    });
    const s = i.reverse().find(a => a.type.name === n.name);
    return s ? {
        ...s.attrs
    }
     : {}
}
function NT(e, t) {
    const n = lb(typeof t == "string" ? t : t.name, e.schema);
    return n === "node" ? Wit(e, t) : n === "mark" ? cb(e, t) : {}
}
function zit(e, t = JSON.stringify) {
    const n = {};
    return e.filter(r => {
        const o = t(r);
        return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0
    })
}
function Hit(e) {
    const t = zit(e);
    return t.length === 1 ? t : t.filter((n, r) => !t.filter((i, s) => s !== r).some(i => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to))
}
function Uit(e) {
    const {
        mapping: t,
        steps: n
    } = e,
    r = [];
    return t.maps.forEach((o, i) => {
        const s = [];
        if (o.ranges.length)
            o.forEach((a, l) => {
                s.push({
                    from: a,
                    to: l
                })
            });
        else {
            const {
                from: a,
                to: l
            } = n[i];
            if (a === void 0 || l === void 0)
                return;
            s.push({
                from: a,
                to: l
            })
        }
        s.forEach(({
                from: a,
                to: l
            }) => {
            const c = t.slice(i).map(a, -1),
            u = t.slice(i).map(l),
            f = t.invert().map(c, -1),
            p = t.invert().map(u);
            r.push({
                oldRange: {
                    from: f,
                    to: p
                },
                newRange: {
                    from: c,
                    to: u
                }
            })
        })
    }),
    Hit(r)
}
function l1(e, t, n) {
    const r = [];
    return e === t ? n.resolve(e).marks().forEach(o => {
        const i = n.resolve(e - 1),
        s = $T(i, o.type);
        s && r.push({
            mark: o,
            ...s
        })
    }) : n.nodesBetween(e, t, (o, i) => {
        r.push(...o.marks.map(s => ({
                    from: i,
                    to: i + o.nodeSize,
                    mark: s
                })))
    }),
    r
}
function b0(e, t, n) {
    return Object.fromEntries(Object.entries(n).filter(([r]) => {
            const o = e.find(i => i.type === t && i.name === r);
            return o ? o.attribute.keepOnSplit : !1
        }))
}
function pS(e, t, n = {}) {
    const {
        empty: r,
        ranges: o
    } = e.selection,
    i = t ? bc(t, e.schema) : null;
    if (r)
        return !!(e.storedMarks || e.selection.$from.marks()).filter(f => i ? i.name === f.type.name : !0).find(f => s1(f.attrs, n, {
                strict: !1
            }));
    let s = 0;
    const a = [];
    if (o.forEach(({
                $from: f,
                $to: p
            }) => {
            const m = f.pos,
            v = p.pos;
            e.doc.nodesBetween(m, v, (y, b) => {
                if (!y.isText && !y.marks.length)
                    return;
                const w = Math.max(m, b),
                k = Math.min(v, b + y.nodeSize),
                C = k - w;
                s += C,
                a.push(...y.marks.map(x => ({
                            mark: x,
                            from: w,
                            to: k
                        })))
            })
        }), s === 0)
        return !1;
    const l = a.filter(f => i ? i.name === f.mark.type.name : !0).filter(f => s1(f.mark.attrs, n, {
                strict: !1
            })).reduce((f, p) => f + p.to - p.from, 0),
    c = a.filter(f => i ? f.mark.type !== i && f.mark.type.excludes(i) : !0).reduce((f, p) => f + p.to - p.from, 0);
    return (l > 0 ? l + c : l) >= s
}
function qit(e, t, n = {}) {
    if (!t)
        return Wm(e, null, n) || pS(e, null, n);
    const r = lb(t, e.schema);
    return r === "node" ? Wm(e, t, n) : r === "mark" ? pS(e, t, n) : !1
}
function $5(e, t) {
    const {
        nodeExtensions: n
    } = ib(t),
    r = n.find(s => s.name === e);
    if (!r)
        return !1;
    const o = {
        name: r.name,
        options: r.options,
        storage: r.storage
    },
    i = jt(lt(r, "group", o));
    return typeof i != "string" ? !1 : i.split(" ").includes("list")
}
function Yit(e) {
    var t;
    const n = (t = e.type.createAndFill()) === null || t === void 0 ? void 0 : t.toJSON(),
    r = e.toJSON();
    return JSON.stringify(n) === JSON.stringify(r)
}
function Kit(e, t, n) {
    var r;
    const {
        selection: o
    } = t;
    let i = null;
    if (Kj(o) && (i = o.$cursor), i) {
        const a = (r = e.storedMarks) !== null && r !== void 0 ? r : i.marks();
        return !!n.isInSet(a) || !a.some(l => l.type.excludes(n))
    }
    const {
        ranges: s
    } = o;
    return s.some(({
            $from: a,
            $to: l
        }) => {
        let c = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
        return e.doc.nodesBetween(a.pos, l.pos, (u, f, p) => {
            if (c)
                return !1;
            if (u.isInline) {
                const m = !p || p.type.allowsMarkType(n),
                v = !!n.isInSet(u.marks) || !u.marks.some(y => y.type.excludes(n));
                c = m && v
            }
            return !c
        }),
        c
    })
}
const Git = (e, t = {}) => ({
    tr: n,
    state: r,
    dispatch: o
}) => {
    const {
        selection: i
    } = n, {
        empty: s,
        ranges: a
    } = i,
    l = bc(e, r.schema);
    if (o)
        if (s) {
            const c = cb(r, l);
            n.addStoredMark(l.create({
                    ...c,
                    ...t
                }))
        } else
            a.forEach(c => {
                const u = c.$from.pos,
                f = c.$to.pos;
                r.doc.nodesBetween(u, f, (p, m) => {
                    const v = Math.max(m, u),
                    y = Math.min(m + p.nodeSize, f);
                    p.marks.find(w => w.type === l) ? p.marks.forEach(w => {
                        l === w.type && n.addMark(v, y, l.create({
                                ...w.attrs,
                                ...t
                            }))
                    }) : n.addMark(v, y, l.create(t))
                })
            });
    return Kit(r, n, l)
}, Xit = (e, t) => ({
    tr: n
}) => (n.setMeta(e, t), !0), Jit = (e, t = {}) => ({
    state: n,
    dispatch: r,
    chain: o
}) => {
    const i = Hr(e, n.schema);
    return i.isTextblock ? o().command(({
            commands: s
        }) => I5(i, t)(n) ? !0 : s.clearNodes()).command(({
            state: s
        }) => I5(i, t)(s, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1)
}, Zit = e => ({
    tr: t,
    dispatch: n
}) => {
    if (n) {
        const {
            doc: r
        } = t,
        o = eu(e, 0, r.content.size),
        i = Pt.create(r, o);
        t.setSelection(i)
    }
    return !0
}, Qit = e => ({
    tr: t,
    dispatch: n
}) => {
    if (n) {
        const {
            doc: r
        } = t, {
            from: o,
            to: i
        } = typeof e == "number" ? {
            from: e,
            to: e
        }
         : e,
        s = qt.atStart(r).from,
        a = qt.atEnd(r).to,
        l = eu(o, s, a),
        c = eu(i, s, a),
        u = qt.create(r, l, c);
        t.setSelection(u)
    }
    return !0
}, est = e => ({
    state: t,
    dispatch: n
}) => {
    const r = Hr(e, t.schema);
    return Not(r)(t, n)
};
function A5(e, t) {
    const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
    if (n) {
        const r = n.filter(o => t?.includes(o.type.name));
        e.tr.ensureMarks(r)
    }
}
const tst = ({
    keepMarks: e = !0
} = {}) => ({
    tr: t,
    state: n,
    dispatch: r,
    editor: o
}) => {
    const {
        selection: i,
        doc: s
    } = t, {
        $from: a,
        $to: l
    } = i,
    c = o.extensionManager.attributes,
    u = b0(c, a.node().type.name, a.node().attrs);
    if (i instanceof Pt && i.node.isBlock)
        return !a.parentOffset || !cf(s, a.pos) ? !1 : (r && (e && A5(n, o.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
    if (!a.parent.isBlock)
        return !1;
    if (r) {
        const f = l.parentOffset === l.parent.content.size;
        i instanceof qt && t.deleteSelection();
        const p = a.depth === 0 ? void 0 : Lit(a.node(-1).contentMatchAt(a.indexAfter(-1)));
        let m = f && p ? [{
                    type: p,
                    attrs: u
                }
            ] : void 0,
        v = cf(t.doc, t.mapping.map(a.pos), 1, m);
        if (!m && !v && cf(t.doc, t.mapping.map(a.pos), 1, p ? [{
                        type: p
                    }
                ] : void 0) && (v = !0, m = p ? [{
                            type: p,
                            attrs: u
                        }
                    ] : void 0), v && (t.split(t.mapping.map(a.pos), 1, m), p && !f && !a.parentOffset && a.parent.type !== p)) {
            const y = t.mapping.map(a.before()),
            b = t.doc.resolve(y);
            a.node(-1).canReplaceWith(b.index(), b.index() + 1, p) && t.setNodeMarkup(t.mapping.map(a.before()), p)
        }
        e && A5(n, o.extensionManager.splittableMarks),
        t.scrollIntoView()
    }
    return !0
}, nst = e => ({
    tr: t,
    state: n,
    dispatch: r,
    editor: o
}) => {
    var i;
    const s = Hr(e, n.schema), {
        $from: a,
        $to: l
    } = n.selection,
    c = n.selection.node;
    if (c && c.isBlock || a.depth < 2 || !a.sameParent(l))
        return !1;
    const u = a.node(-1);
    if (u.type !== s)
        return !1;
    const f = o.extensionManager.attributes;
    if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
        if (a.depth === 2 || a.node(-3).type !== s || a.index(-2) !== a.node(-2).childCount - 1)
            return !1;
        if (r) {
            let b = Ne.empty;
            const w = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
            for (let E = a.depth - w; E >= a.depth - 3; E -= 1)
                b = Ne.from(a.node(E).copy(b));
            const k = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3,
            C = b0(f, a.node().type.name, a.node().attrs),
            x = ((i = s.contentMatch.defaultType) === null || i === void 0 ? void 0 : i.createAndFill(C)) || void 0;
            b = b.append(Ne.from(s.createAndFill(null, x) || void 0));
            const S = a.before(a.depth - (w - 1));
            t.replace(S, a.after(-k), new nt(b, 4 - w, 0));
            let T = -1;
            t.doc.nodesBetween(S, t.doc.content.size, (E, M) => {
                if (T > -1)
                    return !1;
                E.isTextblock && E.content.size === 0 && (T = M + 1)
            }),
            T > -1 && t.setSelection(qt.near(t.doc.resolve(T))),
            t.scrollIntoView()
        }
        return !0
    }
    const p = l.pos === a.end() ? u.contentMatchAt(0).defaultType : null,
    m = b0(f, u.type.name, u.attrs),
    v = b0(f, a.node().type.name, a.node().attrs);
    t.delete(a.pos, l.pos);
    const y = p ? [{
                type: s,
                attrs: m
            }, {
                type: p,
                attrs: v
            }
        ] : [{
                type: s,
                attrs: m
            }
        ];
    if (!cf(t.doc, a.pos, 2))
        return !1;
    if (r) {
        const {
            selection: b,
            storedMarks: w
        } = n, {
            splittableMarks: k
        } = o.extensionManager,
        C = w || b.$to.parentOffset && b.$from.marks();
        if (t.split(a.pos, 2, y).scrollIntoView(), !C || !r)
            return !0;
        const x = C.filter(S => k.includes(S.type.name));
        t.ensureMarks(x)
    }
    return !0
}, nk = (e, t) => {
    const n = DT(s => s.type === t)(e.selection);
    if (!n)
        return !0;
    const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
    if (r === void 0)
        return !0;
    const o = e.doc.nodeAt(r);
    return n.node.type === o?.type && yc(e.doc, n.pos) && e.join(n.pos),
    !0
}, rk = (e, t) => {
    const n = DT(s => s.type === t)(e.selection);
    if (!n)
        return !0;
    const r = e.doc.resolve(n.start).after(n.depth);
    if (r === void 0)
        return !0;
    const o = e.doc.nodeAt(r);
    return n.node.type === o?.type && yc(e.doc, r) && e.join(r),
    !0
}, rst = (e, t, n, r = {}) => ({
    editor: o,
    tr: i,
    state: s,
    dispatch: a,
    chain: l,
    commands: c,
    can: u
}) => {
    const {
        extensions: f,
        splittableMarks: p
    } = o.extensionManager,
    m = Hr(e, s.schema),
    v = Hr(t, s.schema), {
        selection: y,
        storedMarks: b
    } = s, {
        $from: w,
        $to: k
    } = y,
    C = w.blockRange(k),
    x = b || y.$to.parentOffset && y.$from.marks();
    if (!C)
        return !1;
    const S = DT(T => $5(T.type.name, f))(y);
    if (C.depth >= 1 && S && C.depth - S.depth <= 1) {
        if (S.node.type === m)
            return c.liftListItem(v);
        if ($5(S.node.type.name, f) && m.validContent(S.node.content) && a)
            return l().command(() => (i.setNodeMarkup(S.pos, m), !0)).command(() => nk(i, m)).command(() => rk(i, m)).run()
    }
    return !n || !x || !a ? l().command(() => u().wrapInList(m, r) ? !0 : c.clearNodes()).wrapInList(m, r).command(() => nk(i, m)).command(() => rk(i, m)).run() : l().command(() => {
        const T = u().wrapInList(m, r),
        E = x.filter(M => p.includes(M.type.name));
        return i.ensureMarks(E),
        T ? !0 : c.clearNodes()
    }).wrapInList(m, r).command(() => nk(i, m)).command(() => rk(i, m)).run()
}, ost = (e, t = {}, n = {}) => ({
    state: r,
    commands: o
}) => {
    const {
        extendEmptyMarkRange: i = !1
    } = n,
    s = bc(e, r.schema);
    return pS(r, s, t) ? o.unsetMark(s, {
        extendEmptyMarkRange: i
    }) : o.setMark(s, t)
}, ist = (e, t, n = {}) => ({
    state: r,
    commands: o
}) => {
    const i = Hr(e, r.schema),
    s = Hr(t, r.schema);
    return Wm(r, i, n) ? o.setNode(s) : o.setNode(i, n)
}, sst = (e, t = {}) => ({
    state: n,
    commands: r
}) => {
    const o = Hr(e, n.schema);
    return Wm(n, o, t) ? r.lift(o) : r.wrapIn(o, t)
}, ast = () => ({
    state: e,
    dispatch: t
}) => {
    const n = e.plugins;
    for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        let i;
        if (o.spec.isInputRules && (i = o.getState(e))) {
            if (t) {
                const s = e.tr,
                a = i.transform;
                for (let l = a.steps.length - 1; l >= 0; l -= 1)
                    s.step(a.steps[l].invert(a.docs[l]));
                if (i.text) {
                    const l = s.doc.resolve(i.from).marks();
                    s.replaceWith(i.from, i.to, e.schema.text(i.text, l))
                } else
                    s.delete(i.from, i.to)
            }
            return !0
        }
    }
    return !1
}, lst = () => ({
    tr: e,
    dispatch: t
}) => {
    const {
        selection: n
    } = e, {
        empty: r,
        ranges: o
    } = n;
    return r || t && o.forEach(i => {
        e.removeMark(i.$from.pos, i.$to.pos)
    }),
    !0
}, cst = (e, t = {}) => ({
    tr: n,
    state: r,
    dispatch: o
}) => {
    var i;
    const {
        extendEmptyMarkRange: s = !1
    } = t, {
        selection: a
    } = n,
    l = bc(e, r.schema), {
        $from: c,
        empty: u,
        ranges: f
    } = a;
    if (!o)
        return !0;
    if (u && s) {
        let {
            from: p,
            to: m
        } = a;
        const v = (i = c.marks().find(b => b.type === l)) === null || i === void 0 ? void 0 : i.attrs,
        y = $T(c, l, v);
        y && (p = y.from, m = y.to),
        n.removeMark(p, m, l)
    } else
        f.forEach(p => {
            n.removeMark(p.$from.pos, p.$to.pos, l)
        });
    return n.removeStoredMark(l),
    !0
}, ust = (e, t = {}) => ({
    tr: n,
    state: r,
    dispatch: o
}) => {
    let i = null,
    s = null;
    const a = lb(typeof e == "string" ? e : e.name, r.schema);
    return a ? (a === "node" && (i = Hr(e, r.schema)), a === "mark" && (s = bc(e, r.schema)), o && n.selection.ranges.forEach(l => {
            const c = l.$from.pos,
            u = l.$to.pos;
            r.doc.nodesBetween(c, u, (f, p) => {
                i && i === f.type && n.setNodeMarkup(p, void 0, {
                    ...f.attrs,
                    ...t
                }),
                s && f.marks.length && f.marks.forEach(m => {
                    if (s === m.type) {
                        const v = Math.max(p, c),
                        y = Math.min(p + f.nodeSize, u);
                        n.addMark(v, y, s.create({
                                ...m.attrs,
                                ...t
                            }))
                    }
                })
            })
        }), !0) : !1
}, dst = (e, t = {}) => ({
    state: n,
    dispatch: r
}) => {
    const o = Hr(e, n.schema);
    return Pot(o, t)(n, r)
}, fst = (e, t = {}) => ({
    state: n,
    dispatch: r
}) => {
    const o = Hr(e, n.schema);
    return Eot(o, t)(n, r)
};
var hst = Object.freeze({
    __proto__: null,
    blur: Jot,
    clearContent: Zot,
    clearNodes: Qot,
    command: eit,
    createParagraphNear: tit,
    deleteCurrentNode: nit,
    deleteNode: rit,
    deleteRange: oit,
    deleteSelection: iit,
    enter: sit,
    exitCode: ait,
    extendMarkRange: cit,
    first: uit,
    focus: dit,
    forEach: fit,
    insertContent: hit,
    insertContentAt: git,
    joinUp: vit,
    joinDown: yit,
    joinBackward: wit,
    joinForward: bit,
    keyboardShortcut: kit,
    lift: xit,
    liftEmptyBlock: Sit,
    liftListItem: Cit,
    newlineInCode: Iit,
    resetAttributes: Tit,
    scrollIntoView: Mit,
    selectAll: Pit,
    selectNodeBackward: Eit,
    selectNodeForward: Oit,
    selectParentNode: $it,
    selectTextblockEnd: Ait,
    selectTextblockStart: Dit,
    setContent: Nit,
    setMark: Git,
    setMeta: Xit,
    setNode: Jit,
    setNodeSelection: Zit,
    setTextSelection: Qit,
    sinkListItem: est,
    splitBlock: tst,
    splitListItem: nst,
    toggleList: rst,
    toggleMark: ost,
    toggleNode: ist,
    toggleWrap: sst,
    undoInputRule: ast,
    unsetAllMarks: lst,
    unsetMark: cst,
    updateAttributes: ust,
    wrapIn: dst,
    wrapInList: fst
});
const pst = oi.create({
    name: "commands",
    addCommands() {
        return {
            ...hst
        }
    }
}), mst = oi.create({
    name: "editable",
    addProseMirrorPlugins() {
        return [new go({
                key: new ps("editable"),
                props: {
                    editable: () => this.editor.options.editable
                }
            })]
    }
}), gst = oi.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
        const {
            editor: e
        } = this;
        return [new go({
                key: new ps("focusEvents"),
                props: {
                    handleDOMEvents: {
                        focus: (t, n) => {
                            e.isFocused = !0;
                            const r = e.state.tr.setMeta("focus", {
                                event: n
                            }).setMeta("addToHistory", !1);
                            return t.dispatch(r),
                            !1
                        },
                        blur: (t, n) => {
                            e.isFocused = !1;
                            const r = e.state.tr.setMeta("blur", {
                                event: n
                            }).setMeta("addToHistory", !1);
                            return t.dispatch(r),
                            !1
                        }
                    }
                }
            })]
    }
}), vst = oi.create({
    name: "keymap",
    addKeyboardShortcuts() {
        const e = () => this.editor.commands.first(({
                commands: s
            }) => [() => s.undoInputRule(), () => s.command(({
                        tr: a
                    }) => {
                    const {
                        selection: l,
                        doc: c
                    } = a, {
                        empty: u,
                        $anchor: f
                    } = l, {
                        pos: p,
                        parent: m
                    } = f,
                    v = Wt.atStart(c).from === p;
                    return !u || !v || !m.type.isTextblock || m.textContent.length ? !1 : s.clearNodes()
                }), () => s.deleteSelection(), () => s.joinBackward(), () => s.selectNodeBackward()]),
        t = () => this.editor.commands.first(({
                commands: s
            }) => [() => s.deleteSelection(), () => s.deleteCurrentNode(), () => s.joinForward(), () => s.selectNodeForward()]),
        r = {
            Enter: () => this.editor.commands.first(({
                    commands: s
                }) => [() => s.newlineInCode(), () => s.createParagraphNear(), () => s.liftEmptyBlock(), () => s.splitBlock()]),
            "Mod-Enter": () => this.editor.commands.exitCode(),
            Backspace: e,
            "Mod-Backspace": e,
            "Shift-Backspace": e,
            Delete: t,
            "Mod-Delete": t,
            "Mod-a": () => this.editor.commands.selectAll()
        },
        o = {
            ...r
        },
        i = {
            ...r,
            "Ctrl-h": e,
            "Alt-Backspace": e,
            "Ctrl-d": t,
            "Ctrl-Alt-Backspace": t,
            "Alt-Delete": t,
            "Alt-d": t,
            "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
            "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        return AT() || Xj() ? i : o
    },
    addProseMirrorPlugins() {
        return [new go({
                key: new ps("clearDocument"),
                appendTransaction: (e, t, n) => {
                    if (!(e.some(v => v.docChanged) && !t.doc.eq(n.doc)))
                        return;
                    const {
                        empty: o,
                        from: i,
                        to: s
                    } = t.selection,
                    a = Wt.atStart(t.doc).from,
                    l = Wt.atEnd(t.doc).to;
                    if (o || !(i === a && s === l) || !(n.doc.textBetween(0, n.doc.content.size, " ", " ").length === 0))
                        return;
                    const f = n.tr,
                    p = rb({
                        state: n,
                        transaction: f
                    }), {
                        commands: m
                    } = new ob({
                        editor: this.editor,
                        state: p
                    });
                    if (m.clearNodes(), !!f.steps.length)
                        return f
                }
            })]
    }
}), yst = oi.create({
    name: "tabindex",
    addProseMirrorPlugins() {
        return [new go({
                key: new ps("tabindex"),
                props: {
                    attributes: this.editor.isEditable ? {
                        tabindex: "0"
                    }
                     : {}
                }
            })]
    }
});
var wst = Object.freeze({
    __proto__: null,
    ClipboardTextSerializer: Xot,
    Commands: pst,
    Editable: mst,
    FocusEvents: gst,
    Keymap: vst,
    Tabindex: yst
});
const bst = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function _st(e, t) {
    const n = document.querySelector("style[data-tiptap-style]");
    if (n !== null)
        return n;
    const r = document.createElement("style");
    return t && r.setAttribute("nonce", t),
    r.setAttribute("data-tiptap-style", ""),
    r.innerHTML = e,
    document.getElementsByTagName("head")[0].appendChild(r),
    r
}
let kst = class extends Rot {
    constructor(t = {}) {
        super(),
        this.isFocused = !1,
        this.extensionStorage = {},
        this.options = {
            element: document.createElement("div"),
            content: "",
            injectCSS: !0,
            injectNonce: void 0,
            extensions: [],
            autofocus: !1,
            editable: !0,
            editorProps: {},
            parseOptions: {},
            enableInputRules: !0,
            enablePasteRules: !0,
            enableCoreExtensions: !0,
            onBeforeCreate: () => null,
            onCreate: () => null,
            onUpdate: () => null,
            onSelectionUpdate: () => null,
            onTransaction: () => null,
            onFocus: () => null,
            onBlur: () => null,
            onDestroy: () => null
        },
        this.isCapturingTransaction = !1,
        this.capturedTransaction = null,
        this.setOptions(t),
        this.createExtensionManager(),
        this.createCommandManager(),
        this.createSchema(),
        this.on("beforeCreate", this.options.onBeforeCreate),
        this.emit("beforeCreate", {
            editor: this
        }),
        this.createView(),
        this.injectCSS(),
        this.on("create", this.options.onCreate),
        this.on("update", this.options.onUpdate),
        this.on("selectionUpdate", this.options.onSelectionUpdate),
        this.on("transaction", this.options.onTransaction),
        this.on("focus", this.options.onFocus),
        this.on("blur", this.options.onBlur),
        this.on("destroy", this.options.onDestroy),
        window.setTimeout(() => {
            this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", {
                    editor: this
                }))
        }, 0)
    }
    get storage() {
        return this.extensionStorage
    }
    get commands() {
        return this.commandManager.commands
    }
    chain() {
        return this.commandManager.chain()
    }
    can() {
        return this.commandManager.can()
    }
    injectCSS() {
        this.options.injectCSS && document && (this.css = _st(bst, this.options.injectNonce))
    }
    setOptions(t = {}) {
        this.options = {
            ...this.options,
            ...t
        },
        !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state))
    }
    setEditable(t, n = !0) {
        this.setOptions({
            editable: t
        }),
        n && this.emit("update", {
            editor: this,
            transaction: this.state.tr
        })
    }
    get isEditable() {
        return this.options.editable && this.view && this.view.editable
    }
    get state() {
        return this.view.state
    }
    registerPlugin(t, n) {
        const r = Uj(n) ? n(t, [...this.state.plugins]) : [...this.state.plugins, t],
        o = this.state.reconfigure({
            plugins: r
        });
        this.view.updateState(o)
    }
    unregisterPlugin(t) {
        if (this.isDestroyed)
            return;
        const n = typeof t == "string" ? `${t}$` : t.key,
        r = this.state.reconfigure({
            plugins: this.state.plugins.filter(o => !o.key.startsWith(n))
        });
        this.view.updateState(r)
    }
    createExtensionManager() {
        const n = [...this.options.enableCoreExtensions ? Object.values(wst) : [], ...this.options.extensions].filter(r => ["extension", "node", "mark"].includes(r?.type));
        this.extensionManager = new Ud(n, this)
    }
    createCommandManager() {
        this.commandManager = new ob({
            editor: this
        })
    }
    createSchema() {
        this.schema = this.extensionManager.schema
    }
    createView() {
        const t = Jj(this.options.content, this.schema, this.options.parseOptions),
        n = Gj(t, this.options.autofocus);
        this.view = new eot(this.options.element, {
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: zd.create({
                doc: t,
                selection: n || void 0
            })
        });
        const r = this.state.reconfigure({
            plugins: this.extensionManager.plugins
        });
        this.view.updateState(r),
        this.createNodeViews();
        const o = this.view.dom;
        o.editor = this
    }
    createNodeViews() {
        this.view.setProps({
            nodeViews: this.extensionManager.nodeViews
        })
    }
    captureTransaction(t) {
        this.isCapturingTransaction = !0,
        t(),
        this.isCapturingTransaction = !1;
        const n = this.capturedTransaction;
        return this.capturedTransaction = null,
        n
    }
    dispatchTransaction(t) {
        if (this.view.isDestroyed)
            return;
        if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
                this.capturedTransaction = t;
                return
            }
            t.steps.forEach(s => {
                var a;
                return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s)
            });
            return
        }
        const n = this.state.apply(t),
        r = !this.state.selection.eq(n.selection);
        this.view.updateState(n),
        this.emit("transaction", {
            editor: this,
            transaction: t
        }),
        r && this.emit("selectionUpdate", {
            editor: this,
            transaction: t
        });
        const o = t.getMeta("focus"),
        i = t.getMeta("blur");
        o && this.emit("focus", {
            editor: this,
            event: o.event,
            transaction: t
        }),
        i && this.emit("blur", {
            editor: this,
            event: i.event,
            transaction: t
        }),
        !(!t.docChanged || t.getMeta("preventUpdate")) && this.emit("update", {
            editor: this,
            transaction: t
        })
    }
    getAttributes(t) {
        return NT(this.state, t)
    }
    isActive(t, n) {
        const r = typeof t == "string" ? t : null,
        o = typeof t == "string" ? n : t;
        return qit(this.state, r, o)
    }
    getJSON() {
        return this.state.doc.toJSON()
    }
    getHTML() {
        return Fit(this.state.doc.content, this.schema)
    }
    getText(t) {
        const {
            blockSeparator: n = `

`,
            textSerializers: r = {}
        } = t || {};
        return jit(this.state.doc, {
            blockSeparator: n,
            textSerializers: {
                ...Yj(this.schema),
                ...r
            }
        })
    }
    get isEmpty() {
        return Yit(this.state.doc)
    }
    getCharacterCount() {
        return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'),
        this.state.doc.content.size - 2
    }
    destroy() {
        this.emit("destroy"),
        this.view && this.view.destroy(),
        this.removeAllListeners()
    }
    get isDestroyed() {
        var t;
        return !(!((t = this.view) === null || t === void 0) && t.docView)
    }
};
function qf(e) {
    return new sb({
        find: e.find,
        handler: ({
            state: t,
            range: n,
            match: r
        }) => {
            const o = jt(e.getAttributes, void 0, r);
            if (o === !1 || o === null)
                return null;
            const {
                tr: i
            } = t,
            s = r[r.length - 1],
            a = r[0];
            let l = n.to;
            if (s) {
                const c = a.search(/\S/),
                u = n.from + a.indexOf(s),
                f = u + s.length;
                if (l1(n.from, n.to, t.doc).filter(m => m.mark.type.excluded.find(y => y === e.type && y !== m.mark.type)).filter(m => m.to > u).length)
                    return null;
                f < n.to && i.delete(f, n.to),
                u > n.from && i.delete(n.from + c, u),
                l = n.from + c + s.length,
                i.addMark(n.from + c, l, e.type.create(o || {})),
                i.removeStoredMark(e.type)
            }
        }
    })
}
function xst(e) {
    return new sb({
        find: e.find,
        handler: ({
            state: t,
            range: n,
            match: r
        }) => {
            const o = jt(e.getAttributes, void 0, r) || {}, {
                tr: i
            } = t,
            s = n.from;
            let a = n.to;
            if (r[1]) {
                const l = r[0].lastIndexOf(r[1]);
                let c = s + l;
                c > a ? c = a : a = c + r[1].length;
                const u = r[0][r[0].length - 1];
                i.insertText(u, s + r[0].length - 1),
                i.replaceWith(c, a, e.type.create(o))
            } else
                r[0] && i.replaceWith(s, a, e.type.create(o))
        }
    })
}
function mS(e) {
    return new sb({
        find: e.find,
        handler: ({
            state: t,
            range: n,
            match: r
        }) => {
            const o = t.doc.resolve(n.from),
            i = jt(e.getAttributes, void 0, r) || {};
            if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), e.type))
                return null;
            t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, i)
        }
    })
}
function zm(e) {
    return new sb({
        find: e.find,
        handler: ({
            state: t,
            range: n,
            match: r,
            chain: o
        }) => {
            const i = jt(e.getAttributes, void 0, r) || {},
            s = t.tr.delete(n.from, n.to),
            l = s.doc.resolve(n.from).blockRange(),
            c = l && wT(l, e.type, i);
            if (!c)
                return null;
            if (s.wrap(l, c), e.keepMarks && e.editor) {
                const {
                    selection: f,
                    storedMarks: p
                } = t, {
                    splittableMarks: m
                } = e.editor.extensionManager,
                v = p || f.$to.parentOffset && f.$from.marks();
                if (v) {
                    const y = v.filter(b => m.includes(b.type.name));
                    s.ensureMarks(y)
                }
            }
            if (e.keepAttributes) {
                const f = e.type.name === "bulletList" || e.type.name === "orderedList" ? "listItem" : "taskList";
                o().updateAttributes(f, i).run()
            }
            const u = s.doc.resolve(n.from - 1).nodeBefore;
            u && u.type === e.type && yc(s.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, u)) && s.join(n.from - 1)
        }
    })
}
class ls {
    constructor(t = {}) {
        this.type = "mark",
        this.name = "mark",
        this.parent = null,
        this.child = null,
        this.config = {
            name: this.name,
            defaultOptions: {}
        },
        this.config = {
            ...this.config,
            ...t
        },
        this.name = this.config.name,
        t.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
        this.options = this.config.defaultOptions,
        this.config.addOptions && (this.options = jt(lt(this, "addOptions", {
                        name: this.name
                    }))),
        this.storage = jt(lt(this, "addStorage", {
                    name: this.name,
                    options: this.options
                })) || {}
    }
    static create(t = {}) {
        return new ls(t)
    }
    configure(t = {}) {
        const n = this.extend();
        return n.options = ab(this.options, t),
        n.storage = jt(lt(n, "addStorage", {
                    name: n.name,
                    options: n.options
                })),
        n
    }
    extend(t = {}) {
        const n = new ls(t);
        return n.parent = this,
        this.child = n,
        n.name = t.name ? t.name : n.parent.name,
        t.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
        n.options = jt(lt(n, "addOptions", {
                    name: n.name
                })),
        n.storage = jt(lt(n, "addStorage", {
                    name: n.name,
                    options: n.options
                })),
        n
    }
    static handleExit({
        editor: t,
        mark: n
    }) {
        const {
            tr: r
        } = t.state,
        o = t.state.selection.$from;
        if (o.pos === o.end()) {
            const s = o.marks();
            if (!!!s.find(c => c?.type.name === n.name))
                return !1;
            const l = s.find(c => c?.type.name === n.name);
            return l && r.removeStoredMark(l),
            r.insertText(" ", o.pos),
            t.view.dispatch(r),
            !0
        }
        return !1
    }
}
let Ei = class gS {
    constructor(t = {}) {
        this.type = "node",
        this.name = "node",
        this.parent = null,
        this.child = null,
        this.config = {
            name: this.name,
            defaultOptions: {}
        },
        this.config = {
            ...this.config,
            ...t
        },
        this.name = this.config.name,
        t.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
        this.options = this.config.defaultOptions,
        this.config.addOptions && (this.options = jt(lt(this, "addOptions", {
                        name: this.name
                    }))),
        this.storage = jt(lt(this, "addStorage", {
                    name: this.name,
                    options: this.options
                })) || {}
    }
    static create(t = {}) {
        return new gS(t)
    }
    configure(t = {}) {
        const n = this.extend();
        return n.options = ab(this.options, t),
        n.storage = jt(lt(n, "addStorage", {
                    name: n.name,
                    options: n.options
                })),
        n
    }
    extend(t = {}) {
        const n = new gS(t);
        return n.parent = this,
        this.child = n,
        n.name = t.name ? t.name : n.parent.name,
        t.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
        n.options = jt(lt(n, "addOptions", {
                    name: n.name
                })),
        n.storage = jt(lt(n, "addStorage", {
                    name: n.name,
                    options: n.options
                })),
        n
    }
};
function Fu(e) {
    return new Hot({
        find: e.find,
        handler: ({
            state: t,
            range: n,
            match: r
        }) => {
            const o = jt(e.getAttributes, void 0, r);
            if (o === !1 || o === null)
                return null;
            const {
                tr: i
            } = t,
            s = r[r.length - 1],
            a = r[0];
            let l = n.to;
            if (s) {
                const c = a.search(/\S/),
                u = n.from + a.indexOf(s),
                f = u + s.length;
                if (l1(n.from, n.to, t.doc).filter(m => m.mark.type.excluded.find(y => y === e.type && y !== m.mark.type)).filter(m => m.to > u).length)
                    return null;
                f < n.to && i.delete(f, n.to),
                u > n.from && i.delete(n.from + c, u),
                l = n.from + c + s.length,
                i.addMark(n.from + c, l, e.type.create(o || {})),
                i.removeStoredMark(e.type)
            }
        }
    })
}
var Zo = "top", cs = "bottom", us = "right", Qo = "left", RT = "auto", Cg = [Zo, cs, us, Qo], Yf = "start", Hm = "end", Sst = "clippingParents", Zj = "viewport", rp = "popper", Cst = "reference", D5 = Cg.reduce(function (e, t) {
    return e.concat([t + "-" + Yf, t + "-" + Hm])
}, []), Qj = [].concat(Cg, [RT]).reduce(function (e, t) {
    return e.concat([t, t + "-" + Yf, t + "-" + Hm])
}, []), Ist = "beforeRead", Tst = "read", Mst = "afterRead", Pst = "beforeMain", Est = "main", Ost = "afterMain", $st = "beforeWrite", Ast = "write", Dst = "afterWrite", Nst = [Ist, Tst, Mst, Pst, Est, Ost, $st, Ast, Dst];
function ya(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function ms(e) {
    if (e == null)
        return window;
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t && t.defaultView || window
    }
    return e
}
function ju(e) {
    var t = ms(e).Element;
    return e instanceof t || e instanceof Element
}
function Qi(e) {
    var t = ms(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}
function LT(e) {
    if (typeof ShadowRoot > "u")
        return !1;
    var t = ms(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}
function Rst(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function (n) {
        var r = t.styles[n] || {},
        o = t.attributes[n] || {},
        i = t.elements[n];
        !Qi(i) || !ya(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function (s) {
                var a = o[s];
                a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a)
            }))
    })
}
function Lst(e) {
    var t = e.state,
    n = {
        popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(t.elements.popper.style, n.popper),
    t.styles = n,
    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
    function () {
        Object.keys(t.elements).forEach(function (r) {
            var o = t.elements[r],
            i = t.attributes[r] || {},
            s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]),
            a = s.reduce(function (l, c) {
                return l[c] = "",
                l
            }, {});
            !Qi(o) || !ya(o) || (Object.assign(o.style, a), Object.keys(i).forEach(function (l) {
                    o.removeAttribute(l)
                }))
        })
    }
}
const Bst = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: Rst,
    effect: Lst,
    requires: ["computeStyles"]
};
function la(e) {
    return e.split("-")[0]
}
var yu = Math.max, c1 = Math.min, Kf = Math.round;
function vS() {
    var e = navigator.userAgentData;
    return e != null && e.brands ? e.brands.map(function (t) {
        return t.brand + "/" + t.version
    }).join(" ") : navigator.userAgent
}
function eW() {
    return !/^((?!chrome|android).)*safari/i.test(vS())
}
function Gf(e, t, n) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !1);
    var r = e.getBoundingClientRect(),
    o = 1,
    i = 1;
    t && Qi(e) && (o = e.offsetWidth > 0 && Kf(r.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && Kf(r.height) / e.offsetHeight || 1);
    var s = ju(e) ? ms(e) : window,
    a = s.visualViewport,
    l = !eW() && n,
    c = (r.left + (l && a ? a.offsetLeft : 0)) / o,
    u = (r.top + (l && a ? a.offsetTop : 0)) / i,
    f = r.width / o,
    p = r.height / i;
    return {
        width: f,
        height: p,
        top: u,
        right: c + f,
        bottom: u + p,
        left: c,
        x: c,
        y: u
    }
}
function BT(e) {
    var t = Gf(e),
    n = e.offsetWidth,
    r = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width),
    Math.abs(t.height - r) <= 1 && (r = t.height), {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: n,
        height: r
    }
}
function tW(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t))
        return !0;
    if (n && LT(n)) {
        var r = t;
        do {
            if (r && e.isSameNode(r))
                return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}
function el(e) {
    return ms(e).getComputedStyle(e)
}
function Vst(e) {
    return ["table", "td", "th"].indexOf(ya(e)) >= 0
}
function _c(e) {
    return ((ju(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function ub(e) {
    return ya(e) === "html" ? e : e.assignedSlot || e.parentNode || (LT(e) ? e.host : null) || _c(e)
}
function N5(e) {
    return !Qi(e) || el(e).position === "fixed" ? null : e.offsetParent
}
function Fst(e) {
    var t = /firefox/i.test(vS()),
    n = /Trident/i.test(vS());
    if (n && Qi(e)) {
        var r = el(e);
        if (r.position === "fixed")
            return null
    }
    var o = ub(e);
    for (LT(o) && (o = o.host); Qi(o) && ["html", "body"].indexOf(ya(o)) < 0; ) {
        var i = el(o);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || t && i.willChange === "filter" || t && i.filter && i.filter !== "none")
            return o;
        o = o.parentNode
    }
    return null
}
function Ig(e) {
    for (var t = ms(e), n = N5(e); n && Vst(n) && el(n).position === "static"; )
        n = N5(n);
    return n && (ya(n) === "html" || ya(n) === "body" && el(n).position === "static") ? t : n || Fst(e) || t
}
function VT(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function qp(e, t, n) {
    return yu(e, c1(t, n))
}
function jst(e, t, n) {
    var r = qp(e, t, n);
    return r > n ? n : r
}
function nW() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function rW(e) {
    return Object.assign({}, nW(), e)
}
function oW(e, t) {
    return t.reduce(function (n, r) {
        return n[r] = e,
        n
    }, {})
}
var Wst = function (t, n) {
    return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
                placement: n.placement
            })) : t,
    rW(typeof t != "number" ? t : oW(t, Cg))
};
function zst(e) {
    var t,
    n = e.state,
    r = e.name,
    o = e.options,
    i = n.elements.arrow,
    s = n.modifiersData.popperOffsets,
    a = la(n.placement),
    l = VT(a),
    c = [Qo, us].indexOf(a) >= 0,
    u = c ? "height" : "width";
    if (!(!i || !s)) {
        var f = Wst(o.padding, n),
        p = BT(i),
        m = l === "y" ? Zo : Qo,
        v = l === "y" ? cs : us,
        y = n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u],
        b = s[l] - n.rects.reference[l],
        w = Ig(i),
        k = w ? l === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0,
        C = y / 2 - b / 2,
        x = f[m],
        S = k - p[u] - f[v],
        T = k / 2 - p[u] / 2 + C,
        E = qp(x, T, S),
        M = l;
        n.modifiersData[r] = (t = {}, t[M] = E, t.centerOffset = E - T, t)
    }
}
function Hst(e) {
    var t = e.state,
    n = e.options,
    r = n.element,
    o = r === void 0 ? "[data-popper-arrow]" : r;
    o != null && (typeof o == "string" && (o = t.elements.popper.querySelector(o), !o) || tW(t.elements.popper, o) && (t.elements.arrow = o))
}
const Ust = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: zst,
    effect: Hst,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function Xf(e) {
    return e.split("-")[1]
}
var qst = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function Yst(e) {
    var t = e.x,
    n = e.y,
    r = window,
    o = r.devicePixelRatio || 1;
    return {
        x: Kf(t * o) / o || 0,
        y: Kf(n * o) / o || 0
    }
}
function R5(e) {
    var t,
    n = e.popper,
    r = e.popperRect,
    o = e.placement,
    i = e.variation,
    s = e.offsets,
    a = e.position,
    l = e.gpuAcceleration,
    c = e.adaptive,
    u = e.roundOffsets,
    f = e.isFixed,
    p = s.x,
    m = p === void 0 ? 0 : p,
    v = s.y,
    y = v === void 0 ? 0 : v,
    b = typeof u == "function" ? u({
        x: m,
        y
    }) : {
        x: m,
        y
    };
    m = b.x,
    y = b.y;
    var w = s.hasOwnProperty("x"),
    k = s.hasOwnProperty("y"),
    C = Qo,
    x = Zo,
    S = window;
    if (c) {
        var T = Ig(n),
        E = "clientHeight",
        M = "clientWidth";
        if (T === ms(n) && (T = _c(n), el(T).position !== "static" && a === "absolute" && (E = "scrollHeight", M = "scrollWidth")), T = T, o === Zo || (o === Qo || o === us) && i === Hm) {
            x = cs;
            var N = f && T === S && S.visualViewport ? S.visualViewport.height : T[E];
            y -= N - r.height,
            y *= l ? 1 : -1
        }
        if (o === Qo || (o === Zo || o === cs) && i === Hm) {
            C = us;
            var F = f && T === S && S.visualViewport ? S.visualViewport.width : T[M];
            m -= F - r.width,
            m *= l ? 1 : -1
        }
    }
    var K = Object.assign({
        position: a
    }, c && qst),
    j = u === !0 ? Yst({
        x: m,
        y
    }) : {
        x: m,
        y
    };
    if (m = j.x, y = j.y, l) {
        var G;
        return Object.assign({}, K, (G = {}, G[x] = k ? "0" : "", G[C] = w ? "0" : "", G.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + y + "px)" : "translate3d(" + m + "px, " + y + "px, 0)", G))
    }
    return Object.assign({}, K, (t = {}, t[x] = k ? y + "px" : "", t[C] = w ? m + "px" : "", t.transform = "", t))
}
function Kst(e) {
    var t = e.state,
    n = e.options,
    r = n.gpuAcceleration,
    o = r === void 0 ? !0 : r,
    i = n.adaptive,
    s = i === void 0 ? !0 : i,
    a = n.roundOffsets,
    l = a === void 0 ? !0 : a,
    c = {
        placement: la(t.placement),
        variation: Xf(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: o,
        isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, R5(Object.assign({}, c, {
                        offsets: t.modifiersData.popperOffsets,
                        position: t.options.strategy,
                        adaptive: s,
                        roundOffsets: l
                    })))),
    t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, R5(Object.assign({}, c, {
                        offsets: t.modifiersData.arrow,
                        position: "absolute",
                        adaptive: !1,
                        roundOffsets: l
                    })))),
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
const Gst = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: Kst,
    data: {}
};
var Gv = {
    passive: !0
};
function Xst(e) {
    var t = e.state,
    n = e.instance,
    r = e.options,
    o = r.scroll,
    i = o === void 0 ? !0 : o,
    s = r.resize,
    a = s === void 0 ? !0 : s,
    l = ms(t.elements.popper),
    c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return i && c.forEach(function (u) {
        u.addEventListener("scroll", n.update, Gv)
    }),
    a && l.addEventListener("resize", n.update, Gv),
    function () {
        i && c.forEach(function (u) {
            u.removeEventListener("scroll", n.update, Gv)
        }),
        a && l.removeEventListener("resize", n.update, Gv)
    }
}
const Jst = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: Xst,
    data: {}
};
var Zst = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function _0(e) {
    return e.replace(/left|right|bottom|top/g, function (t) {
        return Zst[t]
    })
}
var Qst = {
    start: "end",
    end: "start"
};
function L5(e) {
    return e.replace(/start|end/g, function (t) {
        return Qst[t]
    })
}
function FT(e) {
    var t = ms(e),
    n = t.pageXOffset,
    r = t.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}
function jT(e) {
    return Gf(_c(e)).left + FT(e).scrollLeft
}
function eat(e, t) {
    var n = ms(e),
    r = _c(e),
    o = n.visualViewport,
    i = r.clientWidth,
    s = r.clientHeight,
    a = 0,
    l = 0;
    if (o) {
        i = o.width,
        s = o.height;
        var c = eW();
        (c || !c && t === "fixed") && (a = o.offsetLeft, l = o.offsetTop)
    }
    return {
        width: i,
        height: s,
        x: a + jT(e),
        y: l
    }
}
function tat(e) {
    var t,
    n = _c(e),
    r = FT(e),
    o = (t = e.ownerDocument) == null ? void 0 : t.body,
    i = yu(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0),
    s = yu(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0),
    a = -r.scrollLeft + jT(e),
    l = -r.scrollTop;
    return el(o || n).direction === "rtl" && (a += yu(n.clientWidth, o ? o.clientWidth : 0) - i), {
        width: i,
        height: s,
        x: a,
        y: l
    }
}
function WT(e) {
    var t = el(e),
    n = t.overflow,
    r = t.overflowX,
    o = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + o + r)
}
function iW(e) {
    return ["html", "body", "#document"].indexOf(ya(e)) >= 0 ? e.ownerDocument.body : Qi(e) && WT(e) ? e : iW(ub(e))
}
function Yp(e, t) {
    var n;
    t === void 0 && (t = []);
    var r = iW(e),
    o = r === ((n = e.ownerDocument) == null ? void 0 : n.body),
    i = ms(r),
    s = o ? [i].concat(i.visualViewport || [], WT(r) ? r : []) : r,
    a = t.concat(s);
    return o ? a : a.concat(Yp(ub(s)))
}
function yS(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}
function nat(e, t) {
    var n = Gf(e, !1, t === "fixed");
    return n.top = n.top + e.clientTop,
    n.left = n.left + e.clientLeft,
    n.bottom = n.top + e.clientHeight,
    n.right = n.left + e.clientWidth,
    n.width = e.clientWidth,
    n.height = e.clientHeight,
    n.x = n.left,
    n.y = n.top,
    n
}
function B5(e, t, n) {
    return t === Zj ? yS(eat(e, n)) : ju(t) ? nat(t, n) : yS(tat(_c(e)))
}
function rat(e) {
    var t = Yp(ub(e)),
    n = ["absolute", "fixed"].indexOf(el(e).position) >= 0,
    r = n && Qi(e) ? Ig(e) : e;
    return ju(r) ? t.filter(function (o) {
        return ju(o) && tW(o, r) && ya(o) !== "body"
    }) : []
}
function oat(e, t, n, r) {
    var o = t === "clippingParents" ? rat(e) : [].concat(t),
    i = [].concat(o, [n]),
    s = i[0],
    a = i.reduce(function (l, c) {
        var u = B5(e, c, r);
        return l.top = yu(u.top, l.top),
        l.right = c1(u.right, l.right),
        l.bottom = c1(u.bottom, l.bottom),
        l.left = yu(u.left, l.left),
        l
    }, B5(e, s, r));
    return a.width = a.right - a.left,
    a.height = a.bottom - a.top,
    a.x = a.left,
    a.y = a.top,
    a
}
function sW(e) {
    var t = e.reference,
    n = e.element,
    r = e.placement,
    o = r ? la(r) : null,
    i = r ? Xf(r) : null,
    s = t.x + t.width / 2 - n.width / 2,
    a = t.y + t.height / 2 - n.height / 2,
    l;
    switch (o) {
    case Zo:
        l = {
            x: s,
            y: t.y - n.height
        };
        break;
    case cs:
        l = {
            x: s,
            y: t.y + t.height
        };
        break;
    case us:
        l = {
            x: t.x + t.width,
            y: a
        };
        break;
    case Qo:
        l = {
            x: t.x - n.width,
            y: a
        };
        break;
    default:
        l = {
            x: t.x,
            y: t.y
        }
    }
    var c = o ? VT(o) : null;
    if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (i) {
        case Yf:
            l[c] = l[c] - (t[u] / 2 - n[u] / 2);
            break;
        case Hm:
            l[c] = l[c] + (t[u] / 2 - n[u] / 2);
            break
        }
    }
    return l
}
function Um(e, t) {
    t === void 0 && (t = {});
    var n = t,
    r = n.placement,
    o = r === void 0 ? e.placement : r,
    i = n.strategy,
    s = i === void 0 ? e.strategy : i,
    a = n.boundary,
    l = a === void 0 ? Sst : a,
    c = n.rootBoundary,
    u = c === void 0 ? Zj : c,
    f = n.elementContext,
    p = f === void 0 ? rp : f,
    m = n.altBoundary,
    v = m === void 0 ? !1 : m,
    y = n.padding,
    b = y === void 0 ? 0 : y,
    w = rW(typeof b != "number" ? b : oW(b, Cg)),
    k = p === rp ? Cst : rp,
    C = e.rects.popper,
    x = e.elements[v ? k : p],
    S = oat(ju(x) ? x : x.contextElement || _c(e.elements.popper), l, u, s),
    T = Gf(e.elements.reference),
    E = sW({
        reference: T,
        element: C,
        strategy: "absolute",
        placement: o
    }),
    M = yS(Object.assign({}, C, E)),
    N = p === rp ? M : T,
    F = {
        top: S.top - N.top + w.top,
        bottom: N.bottom - S.bottom + w.bottom,
        left: S.left - N.left + w.left,
        right: N.right - S.right + w.right
    },
    K = e.modifiersData.offset;
    if (p === rp && K) {
        var j = K[o];
        Object.keys(F).forEach(function (G) {
            var Y = [us, cs].indexOf(G) >= 0 ? 1 : -1,
            ue = [Zo, cs].indexOf(G) >= 0 ? "y" : "x";
            F[G] += j[ue] * Y
        })
    }
    return F
}
function iat(e, t) {
    t === void 0 && (t = {});
    var n = t,
    r = n.placement,
    o = n.boundary,
    i = n.rootBoundary,
    s = n.padding,
    a = n.flipVariations,
    l = n.allowedAutoPlacements,
    c = l === void 0 ? Qj : l,
    u = Xf(r),
    f = u ? a ? D5 : D5.filter(function (v) {
        return Xf(v) === u
    }) : Cg,
    p = f.filter(function (v) {
        return c.indexOf(v) >= 0
    });
    p.length === 0 && (p = f);
    var m = p.reduce(function (v, y) {
        return v[y] = Um(e, {
            placement: y,
            boundary: o,
            rootBoundary: i,
            padding: s
        })[la(y)],
        v
    }, {});
    return Object.keys(m).sort(function (v, y) {
        return m[v] - m[y]
    })
}
function sat(e) {
    if (la(e) === RT)
        return [];
    var t = _0(e);
    return [L5(e), t, L5(t)]
}
function aat(e) {
    var t = e.state,
    n = e.options,
    r = e.name;
    if (!t.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, f = n.rootBoundary, p = n.altBoundary, m = n.flipVariations, v = m === void 0 ? !0 : m, y = n.allowedAutoPlacements, b = t.options.placement, w = la(b), k = w === b, C = l || (k || !v ? [_0(b)] : sat(b)), x = [b].concat(C).reduce(function (at, le) {
                return at.concat(la(le) === RT ? iat(t, {
                        placement: le,
                        boundary: u,
                        rootBoundary: f,
                        padding: c,
                        flipVariations: v,
                        allowedAutoPlacements: y
                    }) : le)
            }, []), S = t.rects.reference, T = t.rects.popper, E = new Map, M = !0, N = x[0], F = 0; F < x.length; F++) {
            var K = x[F],
            j = la(K),
            G = Xf(K) === Yf,
            Y = [Zo, cs].indexOf(j) >= 0,
            ue = Y ? "width" : "height",
            re = Um(t, {
                placement: K,
                boundary: u,
                rootBoundary: f,
                altBoundary: p,
                padding: c
            }),
            de = Y ? G ? us : Qo : G ? cs : Zo;
            S[ue] > T[ue] && (de = _0(de));
            var Se = _0(de),
            Pe = [];
            if (i && Pe.push(re[j] <= 0), a && Pe.push(re[de] <= 0, re[Se] <= 0), Pe.every(function (at) {
                    return at
                })) {
                N = K,
                M = !1;
                break
            }
            E.set(K, Pe)
        }
        if (M)
            for (var je = v ? 3 : 1, Ke = function (le) {
                var ye = x.find(function (ge) {
                    var pe = E.get(ge);
                    if (pe)
                        return pe.slice(0, le)
                            .every(function (xe) {
                                return xe
                            })
                    });
                if (ye)
                    return N = ye, "break"
            }, Ue = je; Ue > 0; Ue--) {
                var yt = Ke(Ue);
                if (yt === "break")
                    break
            }
    t.placement !== N && (t.modifiersData[r]._skip = !0, t.placement = N, t.reset = !0)
}
}
const lat = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: aat,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function V5(e, t, n) {
    return n === void 0 && (n = {
            x: 0,
            y: 0
        }), {
        top: e.top - t.height - n.y,
        right: e.right - t.width + n.x,
        bottom: e.bottom - t.height + n.y,
        left: e.left - t.width - n.x
    }
}
function F5(e) {
    return [Zo, us, cs, Qo].some(function (t) {
        return e[t] >= 0
    })
}
function cat(e) {
    var t = e.state,
    n = e.name,
    r = t.rects.reference,
    o = t.rects.popper,
    i = t.modifiersData.preventOverflow,
    s = Um(t, {
        elementContext: "reference"
    }),
    a = Um(t, {
        altBoundary: !0
    }),
    l = V5(s, r),
    c = V5(a, o, i),
    u = F5(l),
    f = F5(c);
    t.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: f
    },
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": f
    })
}
const uat = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: cat
};
function dat(e, t, n) {
    var r = la(e),
    o = [Qo, Zo].indexOf(r) >= 0 ? -1 : 1,
    i = typeof n == "function" ? n(Object.assign({}, t, {
                placement: e
            })) : n,
    s = i[0],
    a = i[1];
    return s = s || 0,
    a = (a || 0) * o,
    [Qo, us].indexOf(r) >= 0 ? {
        x: a,
        y: s
    }
     : {
        x: s,
        y: a
    }
}
function fat(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.offset,
    i = o === void 0 ? [0, 0] : o,
    s = Qj.reduce(function (u, f) {
        return u[f] = dat(f, t.rects, i),
        u
    }, {}),
    a = s[t.placement],
    l = a.x,
    c = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c),
    t.modifiersData[r] = s
}
const hat = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: fat
};
function pat(e) {
    var t = e.state,
    n = e.name;
    t.modifiersData[n] = sW({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
    })
}
const mat = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: pat,
    data: {}
};
function gat(e) {
    return e === "x" ? "y" : "x"
}
function vat(e) {
    var t = e.state,
    n = e.options,
    r = e.name,
    o = n.mainAxis,
    i = o === void 0 ? !0 : o,
    s = n.altAxis,
    a = s === void 0 ? !1 : s,
    l = n.boundary,
    c = n.rootBoundary,
    u = n.altBoundary,
    f = n.padding,
    p = n.tether,
    m = p === void 0 ? !0 : p,
    v = n.tetherOffset,
    y = v === void 0 ? 0 : v,
    b = Um(t, {
        boundary: l,
        rootBoundary: c,
        padding: f,
        altBoundary: u
    }),
    w = la(t.placement),
    k = Xf(t.placement),
    C = !k,
    x = VT(w),
    S = gat(x),
    T = t.modifiersData.popperOffsets,
    E = t.rects.reference,
    M = t.rects.popper,
    N = typeof y == "function" ? y(Object.assign({}, t.rects, {
                placement: t.placement
            })) : y,
    F = typeof N == "number" ? {
        mainAxis: N,
        altAxis: N
    }
     : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, N),
    K = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
    j = {
        x: 0,
        y: 0
    };
    if (T) {
        if (i) {
            var G,
            Y = x === "y" ? Zo : Qo,
            ue = x === "y" ? cs : us,
            re = x === "y" ? "height" : "width",
            de = T[x],
            Se = de + b[Y],
            Pe = de - b[ue],
            je = m ? -M[re] / 2 : 0,
            Ke = k === Yf ? E[re] : M[re],
            Ue = k === Yf ? -M[re] : -E[re],
            yt = t.elements.arrow,
            at = m && yt ? BT(yt) : {
                width: 0,
                height: 0
            },
            le = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : nW(),
            ye = le[Y],
            ge = le[ue],
            pe = qp(0, E[re], at[re]),
            xe = C ? E[re] / 2 - je - pe - ye - F.mainAxis : Ke - pe - ye - F.mainAxis,
            et = C ? -E[re] / 2 + je + pe + ge + F.mainAxis : Ue + pe + ge + F.mainAxis,
            Xe = t.elements.arrow && Ig(t.elements.arrow),
            W = Xe ? x === "y" ? Xe.clientTop || 0 : Xe.clientLeft || 0 : 0,
            R = (G = K?.[x]) != null ? G : 0,
            X = de + xe - R - W,
            Q = de + et - R,
            Z = qp(m ? c1(Se, X) : Se, de, m ? yu(Pe, Q) : Pe);
            T[x] = Z,
            j[x] = Z - de
        }
        if (a) {
            var fe,
            be = x === "x" ? Zo : Qo,
            Ee = x === "x" ? cs : us,
            Me = T[S],
            we = S === "y" ? "height" : "width",
            He = Me + b[be],
            We = Me - b[Ee],
            Je = [Zo, Qo].indexOf(w) !== -1,
            qe = (fe = K?.[S]) != null ? fe : 0,
            wt = Je ? He : Me - E[we] - M[we] - qe + F.altAxis,
            Et = Je ? Me + E[we] + M[we] - qe - F.altAxis : We,
            bt = m && Je ? jst(wt, Me, Et) : qp(m ? wt : He, Me, m ? Et : We);
            T[S] = bt,
            j[S] = bt - Me
        }
        t.modifiersData[r] = j
    }
}
const yat = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: vat,
    requiresIfExists: ["offset"]
};
function wat(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}
function bat(e) {
    return e === ms(e) || !Qi(e) ? FT(e) : wat(e)
}
function _at(e) {
    var t = e.getBoundingClientRect(),
    n = Kf(t.width) / e.offsetWidth || 1,
    r = Kf(t.height) / e.offsetHeight || 1;
    return n !== 1 || r !== 1
}
function kat(e, t, n) {
    n === void 0 && (n = !1);
    var r = Qi(t),
    o = Qi(t) && _at(t),
    i = _c(t),
    s = Gf(e, o, n),
    a = {
        scrollLeft: 0,
        scrollTop: 0
    },
    l = {
        x: 0,
        y: 0
    };
    return (r || !r && !n) && ((ya(t) !== "body" || WT(i)) && (a = bat(t)), Qi(t) ? (l = Gf(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : i && (l.x = jT(i))), {
        x: s.left + a.scrollLeft - l.x,
        y: s.top + a.scrollTop - l.y,
        width: s.width,
        height: s.height
    }
}
function xat(e) {
    var t = new Map,
    n = new Set,
    r = [];
    e.forEach(function (i) {
        t.set(i.name, i)
    });
    function o(i) {
        n.add(i.name);
        var s = [].concat(i.requires || [], i.requiresIfExists || []);
        s.forEach(function (a) {
            if (!n.has(a)) {
                var l = t.get(a);
                l && o(l)
            }
        }),
        r.push(i)
    }
    return e.forEach(function (i) {
        n.has(i.name) || o(i)
    }),
    r
}
function Sat(e) {
    var t = xat(e);
    return Nst.reduce(function (n, r) {
        return n.concat(t.filter(function (o) {
                return o.phase === r
            }))
    }, [])
}
function Cat(e) {
    var t;
    return function () {
        return t || (t = new Promise(function (n) {
                Promise.resolve().then(function () {
                    t = void 0,
                    n(e())
                })
            })),
        t
    }
}
function Iat(e) {
    var t = e.reduce(function (n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, r, {
            options: Object.assign({}, o.options, r.options),
            data: Object.assign({}, o.data, r.data)
        }) : r,
        n
    }, {});
    return Object.keys(t).map(function (n) {
        return t[n]
    })
}
var j5 = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function W5() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return !t.some(function (r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}
function Tat(e) {
    e === void 0 && (e = {});
    var t = e,
    n = t.defaultModifiers,
    r = n === void 0 ? [] : n,
    o = t.defaultOptions,
    i = o === void 0 ? j5 : o;
    return function (a, l, c) {
        c === void 0 && (c = i);
        var u = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, j5, i),
            modifiersData: {},
            elements: {
                reference: a,
                popper: l
            },
            attributes: {},
            styles: {}
        },
        f = [],
        p = !1,
        m = {
            state: u,
            setOptions: function (w) {
                var k = typeof w == "function" ? w(u.options) : w;
                y(),
                u.options = Object.assign({}, i, u.options, k),
                u.scrollParents = {
                    reference: ju(a) ? Yp(a) : a.contextElement ? Yp(a.contextElement) : [],
                    popper: Yp(l)
                };
                var C = Sat(Iat([].concat(r, u.options.modifiers)));
                return u.orderedModifiers = C.filter(function (x) {
                    return x.enabled
                }),
                v(),
                m.update()
            },
            forceUpdate: function () {
                if (!p) {
                    var w = u.elements,
                    k = w.reference,
                    C = w.popper;
                    if (W5(k, C)) {
                        u.rects = {
                            reference: kat(k, Ig(C), u.options.strategy === "fixed"),
                            popper: BT(C)
                        },
                        u.reset = !1,
                        u.placement = u.options.placement,
                        u.orderedModifiers.forEach(function (F) {
                            return u.modifiersData[F.name] = Object.assign({}, F.data)
                        });
                        for (var x = 0; x < u.orderedModifiers.length; x++) {
                            if (u.reset === !0) {
                                u.reset = !1,
                                x = -1;
                                continue
                            }
                            var S = u.orderedModifiers[x],
                            T = S.fn,
                            E = S.options,
                            M = E === void 0 ? {}
                             : E,
                            N = S.name;
                            typeof T == "function" && (u = T({
                                    state: u,
                                    options: M,
                                    name: N,
                                    instance: m
                                }) || u)
                        }
                    }
                }
            },
            update: Cat(function () {
                return new Promise(function (b) {
                    m.forceUpdate(),
                    b(u)
                })
            }),
            destroy: function () {
                y(),
                p = !0
            }
        };
        if (!W5(a, l))
            return m;
        m.setOptions(c).then(function (b) {
            !p && c.onFirstUpdate && c.onFirstUpdate(b)
        });
        function v() {
            u.orderedModifiers.forEach(function (b) {
                var w = b.name,
                k = b.options,
                C = k === void 0 ? {}
                 : k,
                x = b.effect;
                if (typeof x == "function") {
                    var S = x({
                        state: u,
                        name: w,
                        instance: m,
                        options: C
                    }),
                    T = function () {};
                    f.push(S || T)
                }
            })
        }
        function y() {
            f.forEach(function (b) {
                return b()
            }),
            f = []
        }
        return m
    }
}
var Mat = [Jst, mat, Gst, Bst, hat, lat, yat, Ust, uat], Pat = Tat({
    defaultModifiers: Mat
});
function z5(e) {
    return qR((t, n) => ({
            get() {
                return t(),
                e
            },
            set(r) {
                e = r,
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        n()
                    })
                })
            }
        }))
}
class Eat extends kst {
    constructor(t = {}) {
        return super(t),
        this.vueRenderers = es(new Map),
        this.contentComponent = null,
        this.reactiveState = z5(this.view.state),
        this.reactiveExtensionStorage = z5(this.extensionStorage),
        this.on("transaction", () => {
            this.reactiveState.value = this.view.state,
            this.reactiveExtensionStorage.value = this.extensionStorage
        }),
        oa(this)
    }
    get state() {
        return this.reactiveState ? this.reactiveState.value : this.view.state
    }
    get storage() {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage
    }
    registerPlugin(t, n) {
        super.registerPlugin(t, n),
        this.reactiveState.value = this.view.state
    }
    unregisterPlugin(t) {
        super.unregisterPlugin(t),
        this.reactiveState.value = this.view.state
    }
}
const Oat = Fe({
    name: "EditorContent",
    props: {
        editor: {
        default:
            null,
            type: Object
        }
    },
    setup(e) {
        const t = De(),
        n = ii();
        return t4(() => {
            const r = e.editor;
            r && r.options.element && t.value && Ci(() => {
                if (!t.value || !r.options.element.firstChild)
                    return;
                const o = ke(t.value);
                t.value.append(...r.options.element.childNodes),
                r.contentComponent = n.ctx._,
                r.setOptions({
                    element: o
                }),
                r.createNodeViews()
            })
        }),
        Rs(() => {
            const r = e.editor;
            if (!r || (r.isDestroyed || r.view.setProps({
                        nodeViews: {}
                    }), r.contentComponent = null, !r.options.element.firstChild))
                return;
            const o = document.createElement("div");
            o.append(...r.options.element.childNodes),
            r.setOptions({
                element: o
            })
        }), {
            rootEl: t
        }
    },
    render() {
        const e = [];
        return this.editor && this.editor.vueRenderers.forEach(t => {
            const n = dt(H1, {
                to: t.teleportElement,
                key: t.id
            }, dt(t.component, {
                        ref: t.id,
                        ...t.props
                    }));
            e.push(n)
        }),
        dt("div", {
            ref: t => {
                this.rootEl = t
            }
        }, ...e)
    }
}), $at = (e = {}) => {
    const t = _u();
    return Ur(() => {
        t.value = new Eat(e)
    }),
    Rs(() => {
        var n;
        (n = t.value) === null || n === void 0 || n.destroy()
    }),
    t
}, Aat = ls.create({
    name: "underline",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
                tag: "u"
            }, {
                style: "text-decoration",
                consuming: !1,
                getAttrs: e => e.includes("underline") ? {}
                 : !1
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["u", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setUnderline: () => ({
                commands: e
            }) => e.setMark(this.name),
            toggleUnderline: () => ({
                commands: e
            }) => e.toggleMark(this.name),
            unsetUnderline: () => ({
                commands: e
            }) => e.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-u": () => this.editor.commands.toggleUnderline(),
            "Mod-U": () => this.editor.commands.toggleUnderline()
        }
    }
}), Dat = /^\s*>\s$/, Nat = Ei.create({
    name: "blockquote",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "block+",
    group: "block",
    defining: !0,
    parseHTML() {
        return [{
                tag: "blockquote"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["blockquote", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setBlockquote: () => ({
                commands: e
            }) => e.wrapIn(this.name),
            toggleBlockquote: () => ({
                commands: e
            }) => e.toggleWrap(this.name),
            unsetBlockquote: () => ({
                commands: e
            }) => e.lift(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        }
    },
    addInputRules() {
        return [zm({
                find: Dat,
                type: this.type
            })]
    }
}), Rat = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/, Lat = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g, Bat = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/, Vat = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g, Fat = ls.create({
    name: "bold",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
                tag: "strong"
            }, {
                tag: "b",
                getAttrs: e => e.style.fontWeight !== "normal" && null
            }, {
                style: "font-weight",
                getAttrs: e => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["strong", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setBold: () => ({
                commands: e
            }) => e.setMark(this.name),
            toggleBold: () => ({
                commands: e
            }) => e.toggleMark(this.name),
            unsetBold: () => ({
                commands: e
            }) => e.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-b": () => this.editor.commands.toggleBold(),
            "Mod-B": () => this.editor.commands.toggleBold()
        }
    },
    addInputRules() {
        return [qf({
                find: Rat,
                type: this.type
            }), qf({
                find: Bat,
                type: this.type
            })]
    },
    addPasteRules() {
        return [Fu({
                find: Lat,
                type: this.type
            }), Fu({
                find: Vat,
                type: this.type
            })]
    }
}), jat = Ei.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
                tag: "li"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["li", xr(this.options.HTMLAttributes, e), 0]
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
}), H5 = ls.create({
    name: "textStyle",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
                tag: "span",
                getAttrs: e => e.hasAttribute("style") ? {}
                 : !1
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["span", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            removeEmptyTextStyle: () => ({
                state: e,
                commands: t
            }) => {
                const n = cb(e, this.type);
                return Object.entries(n).some(([, o]) => !!o) ? !0 : t.unsetMark(this.name)
            }
        }
    }
}), U5 = /^\s*([-+*])\s$/, Wat = Ei.create({
    name: "bulletList",
    addOptions() {
        return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: !1,
            keepAttributes: !1
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    parseHTML() {
        return [{
                tag: "ul"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["ul", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            toggleBulletList: () => ({
                commands: e,
                chain: t
            }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(jat.name, this.editor.getAttributes(H5.name)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        }
    },
    addInputRules() {
        let e = zm({
            find: U5,
            type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (e = zm({
                find: U5,
                type: this.type,
                keepMarks: this.options.keepMarks,
                keepAttributes: this.options.keepAttributes,
                getAttributes: () => this.editor.getAttributes(H5.name),
                editor: this.editor
            })),
        [e]
    }
}), zat = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/, Hat = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g, Uat = ls.create({
    name: "code",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    excludes: "_",
    code: !0,
    exitable: !0,
    parseHTML() {
        return [{
                tag: "code"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["code", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setCode: () => ({
                commands: e
            }) => e.setMark(this.name),
            toggleCode: () => ({
                commands: e
            }) => e.toggleMark(this.name),
            unsetCode: () => ({
                commands: e
            }) => e.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-e": () => this.editor.commands.toggleCode()
        }
    },
    addInputRules() {
        return [qf({
                find: zat,
                type: this.type
            })]
    },
    addPasteRules() {
        return [Fu({
                find: Hat,
                type: this.type
            })]
    }
}), qat = /^```([a-z]+)?[\s\n]$/, Yat = /^~~~([a-z]+)?[\s\n]$/, Kat = Ei.create({
    name: "codeBlock",
    addOptions() {
        return {
            languageClassPrefix: "language-",
            exitOnTripleEnter: !0,
            exitOnArrowDown: !0,
            HTMLAttributes: {}
        }
    },
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    addAttributes() {
        return {
            language: {
            default:
                null,
                parseHTML: e => {
                    var t;
                    const {
                        languageClassPrefix: n
                    } = this.options,
                    i = [...((t = e.firstElementChild) === null || t === void 0 ? void 0 : t.classList) || []].filter(s => s.startsWith(n)).map(s => s.replace(n, ""))[0];
                    return i || null
                },
                rendered: !1
            }
        }
    },
    parseHTML() {
        return [{
                tag: "pre",
                preserveWhitespace: "full"
            }
        ]
    },
    renderHTML({
        node: e,
        HTMLAttributes: t
    }) {
        return ["pre", xr(this.options.HTMLAttributes, t), ["code", {
                    class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null
                }, 0]]
    },
    addCommands() {
        return {
            setCodeBlock: e => ({
                commands: t
            }) => t.setNode(this.name, e),
            toggleCodeBlock: e => ({
                commands: t
            }) => t.toggleNode(this.name, "paragraph", e)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
            Backspace: () => {
                const {
                    empty: e,
                    $anchor: t
                } = this.editor.state.selection,
                n = t.pos === 1;
                return !e || t.parent.type.name !== this.name ? !1 : n || !t.parent.textContent.length ? this.editor.commands.clearNodes() : !1
            },
            Enter: ({
                editor: e
            }) => {
                if (!this.options.exitOnTripleEnter)
                    return !1;
                const {
                    state: t
                } = e, {
                    selection: n
                } = t, {
                    $from: r,
                    empty: o
                } = n;
                if (!o || r.parent.type !== this.type)
                    return !1;
                const i = r.parentOffset === r.parent.nodeSize - 2,
                s = r.parent.textContent.endsWith(`

`);
                return !i || !s ? !1 : e.chain().command(({
                        tr: a
                    }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run()
            },
            ArrowDown: ({
                editor: e
            }) => {
                if (!this.options.exitOnArrowDown)
                    return !1;
                const {
                    state: t
                } = e, {
                    selection: n,
                    doc: r
                } = t, {
                    $from: o,
                    empty: i
                } = n;
                if (!i || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
                    return !1;
                const a = o.after();
                return a === void 0 || r.nodeAt(a) ? !1 : e.commands.exitCode()
            }
        }
    },
    addInputRules() {
        return [mS({
                find: qat,
                type: this.type,
                getAttributes: e => ({
                    language: e[1]
                })
            }), mS({
                find: Yat,
                type: this.type,
                getAttributes: e => ({
                    language: e[1]
                })
            })]
    },
    addProseMirrorPlugins() {
        return [new go({
                key: new ps("codeBlockVSCodeHandler"),
                props: {
                    handlePaste: (e, t) => {
                        if (!t.clipboardData || this.editor.isActive(this.type.name))
                            return !1;
                        const n = t.clipboardData.getData("text/plain"),
                        r = t.clipboardData.getData("vscode-editor-data"),
                        o = r ? JSON.parse(r) : void 0,
                        i = o?.mode;
                        if (!n || !i)
                            return !1;
                        const {
                            tr: s
                        } = e.state;
                        return s.replaceSelectionWith(this.type.create({
                                language: i
                            })),
                        s.setSelection(qt.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))),
                        s.insertText(n.replace(/\r\n?/g, `
`)),
                        s.setMeta("paste", !0),
                        e.dispatch(s),
                        !0
                    }
                }
            })]
    }
}), Gat = Ei.create({
    name: "doc",
    topNode: !0,
    content: "block+"
});
function Xat(e = {}) {
    return new go({
        view(t) {
            return new Jat(t, e)
        }
    })
}
class Jat {
    constructor(t, n) {
        var r;
        this.editorView = t,
        this.cursorPos = null,
        this.element = null,
        this.timeout = -1,
        this.width = (r = n.width) !== null && r !== void 0 ? r : 1,
        this.color = n.color === !1 ? void 0 : n.color || "black",
        this.class = n.class,
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(o => {
            let i = s => {
                this[o](s)
            };
            return t.dom.addEventListener(o, i), {
                name: o,
                handler: i
            }
        })
    }
    destroy() {
        this.handlers.forEach(({
                name: t,
                handler: n
            }) => this.editorView.dom.removeEventListener(t, n))
    }
    update(t, n) {
        this.cursorPos != null && n.doc != t.state.doc && (this.cursorPos > t.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
    }
    setCursor(t) {
        t != this.cursorPos && (this.cursorPos = t, t == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay())
    }
    updateOverlay() {
        let t = this.editorView.state.doc.resolve(this.cursorPos),
        n = !t.parent.inlineContent,
        r;
        if (n) {
            let a = t.nodeBefore,
            l = t.nodeAfter;
            if (a || l) {
                let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
                if (c) {
                    let u = c.getBoundingClientRect(),
                    f = a ? u.bottom : u.top;
                    a && l && (f = (f + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2),
                    r = {
                        left: u.left,
                        right: u.right,
                        top: f - this.width / 2,
                        bottom: f + this.width / 2
                    }
                }
            }
        }
        if (!r) {
            let a = this.editorView.coordsAtPos(this.cursorPos);
            r = {
                left: a.left - this.width / 2,
                right: a.left + this.width / 2,
                top: a.top,
                bottom: a.bottom
            }
        }
        let o = this.editorView.dom.offsetParent;
        this.element || (this.element = o.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)),
        this.element.classList.toggle("prosemirror-dropcursor-block", n),
        this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
        let i,
        s;
        if (!o || o == document.body && getComputedStyle(o).position == "static")
            i = -pageXOffset, s = -pageYOffset;
        else {
            let a = o.getBoundingClientRect();
            i = a.left - o.scrollLeft,
            s = a.top - o.scrollTop
        }
        this.element.style.left = r.left - i + "px",
        this.element.style.top = r.top - s + "px",
        this.element.style.width = r.right - r.left + "px",
        this.element.style.height = r.bottom - r.top + "px"
    }
    scheduleRemoval(t) {
        clearTimeout(this.timeout),
        this.timeout = setTimeout(() => this.setCursor(null), t)
    }
    dragover(t) {
        if (!this.editorView.editable)
            return;
        let n = this.editorView.posAtCoords({
            left: t.clientX,
            top: t.clientY
        }),
        r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
        o = r && r.type.spec.disableDropCursor,
        i = typeof o == "function" ? o(this.editorView, n, t) : o;
        if (n && !i) {
            let s = n.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
                let a = QF(this.editorView.state.doc, s, this.editorView.dragging.slice);
                a != null && (s = a)
            }
            this.setCursor(s),
            this.scheduleRemoval(5e3)
        }
    }
    dragend() {
        this.scheduleRemoval(20)
    }
    drop() {
        this.scheduleRemoval(20)
    }
    dragleave(t) {
        (t.target == this.editorView.dom || !this.editorView.dom.contains(t.relatedTarget)) && this.setCursor(null)
    }
}
const Zat = oi.create({
    name: "dropCursor",
    addOptions() {
        return {
            color: "currentColor",
            width: 1,
            class: void 0
        }
    },
    addProseMirrorPlugins() {
        return [Xat(this.options)]
    }
});
class cr extends Wt {
    constructor(t) {
        super(t, t)
    }
    map(t, n) {
        let r = t.resolve(n.map(this.head));
        return cr.valid(r) ? new cr(r) : Wt.near(r)
    }
    content() {
        return nt.empty
    }
    eq(t) {
        return t instanceof cr && t.head == this.head
    }
    toJSON() {
        return {
            type: "gapcursor",
            pos: this.head
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new cr(t.resolve(n.pos))
    }
    getBookmark() {
        return new zT(this.anchor)
    }
    static valid(t) {
        let n = t.parent;
        if (n.isTextblock || !Qat(t) || !elt(t))
            return !1;
        let r = n.type.spec.allowGapCursor;
        if (r != null)
            return r;
        let o = n.contentMatchAt(t.index()).defaultType;
        return o && o.isTextblock
    }
    static findGapCursorFrom(t, n, r = !1) {
        e: for (; ; ) {
            if (!r && cr.valid(t))
                return t;
            let o = t.pos,
            i = null;
            for (let s = t.depth; ; s--) {
                let a = t.node(s);
                if (n > 0 ? t.indexAfter(s) < a.childCount : t.index(s) > 0) {
                    i = a.child(n > 0 ? t.indexAfter(s) : t.index(s) - 1);
                    break
                } else if (s == 0)
                    return null;
                o += n;
                let l = t.doc.resolve(o);
                if (cr.valid(l))
                    return l
            }
            for (; ; ) {
                let s = n > 0 ? i.firstChild : i.lastChild;
                if (!s) {
                    if (i.isAtom && !i.isText && !Pt.isSelectable(i)) {
                        t = t.doc.resolve(o + i.nodeSize * n),
                        r = !1;
                        continue e
                    }
                    break
                }
                i = s,
                o += n;
                let a = t.doc.resolve(o);
                if (cr.valid(a))
                    return a
            }
            return null
        }
    }
}
cr.prototype.visible = !1;
cr.findFrom = cr.findGapCursorFrom;
Wt.jsonID("gapcursor", cr);
class zT {
    constructor(t) {
        this.pos = t
    }
    map(t) {
        return new zT(t.map(this.pos))
    }
    resolve(t) {
        let n = t.resolve(this.pos);
        return cr.valid(n) ? new cr(n) : Wt.near(n)
    }
}
function Qat(e) {
    for (let t = e.depth; t >= 0; t--) {
        let n = e.index(t),
        r = e.node(t);
        if (n == 0) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let o = r.child(n - 1); ; o = o.lastChild) {
            if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
                return !0;
            if (o.inlineContent)
                return !1
        }
    }
    return !0
}
function elt(e) {
    for (let t = e.depth; t >= 0; t--) {
        let n = e.indexAfter(t),
        r = e.node(t);
        if (n == r.childCount) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let o = r.child(n); ; o = o.firstChild) {
            if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
                return !0;
            if (o.inlineContent)
                return !1
        }
    }
    return !0
}
function tlt() {
    return new go({
        props: {
            decorations: ilt,
            createSelectionBetween(e, t, n) {
                return t.pos == n.pos && cr.valid(n) ? new cr(n) : null
            },
            handleClick: rlt,
            handleKeyDown: nlt,
            handleDOMEvents: {
                beforeinput: olt
            }
        }
    })
}
const nlt = Bj({
    ArrowLeft: Xv("horiz", -1),
    ArrowRight: Xv("horiz", 1),
    ArrowUp: Xv("vert", -1),
    ArrowDown: Xv("vert", 1)
});
function Xv(e, t) {
    const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
    return function (r, o, i) {
        let s = r.selection,
        a = t > 0 ? s.$to : s.$from,
        l = s.empty;
        if (s instanceof qt) {
            if (!i.endOfTextblock(n) || a.depth == 0)
                return !1;
            l = !1,
            a = r.doc.resolve(t > 0 ? a.after() : a.before())
        }
        let c = cr.findGapCursorFrom(a, t, l);
        return c ? (o && o(r.tr.setSelection(new cr(c))), !0) : !1
    }
}
function rlt(e, t, n) {
    if (!e || !e.editable)
        return !1;
    let r = e.state.doc.resolve(t);
    if (!cr.valid(r))
        return !1;
    let o = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
    });
    return o && o.inside > -1 && Pt.isSelectable(e.state.doc.nodeAt(o.inside)) ? !1 : (e.dispatch(e.state.tr.setSelection(new cr(r))), !0)
}
function olt(e, t) {
    if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof cr))
        return !1;
    let {
        $from: n
    } = e.state.selection,
    r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
    if (!r)
        return !1;
    let o = Ne.empty;
    for (let s = r.length - 1; s >= 0; s--)
        o = Ne.from(r[s].createAndFill(null, o));
    let i = e.state.tr.replace(n.pos, n.pos, new nt(o, 0, 0));
    return i.setSelection(qt.near(i.doc.resolve(n.pos + 1))),
    e.dispatch(i),
    !1
}
function ilt(e) {
    if (!(e.selection instanceof cr))
        return null;
    let t = document.createElement("div");
    return t.className = "ProseMirror-gapcursor",
    Ar.create(e.doc, [Xi.widget(e.selection.head, t, {
                key: "gapcursor"
            })])
}
const slt = oi.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
        return [tlt()]
    },
    extendNodeSchema(e) {
        var t;
        const n = {
            name: e.name,
            options: e.options,
            storage: e.storage
        };
        return {
            allowGapCursor: (t = jt(lt(e, "allowGapCursor", n))) !== null && t !== void 0 ? t : null
        }
    }
}), alt = Ei.create({
    name: "hardBreak",
    addOptions() {
        return {
            keepMarks: !0,
            HTMLAttributes: {}
        }
    },
    inline: !0,
    group: "inline",
    selectable: !1,
    parseHTML() {
        return [{
                tag: "br"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["br", xr(this.options.HTMLAttributes, e)]
    },
    renderText() {
        return `
`
    },
    addCommands() {
        return {
            setHardBreak: () => ({
                commands: e,
                chain: t,
                state: n,
                editor: r
            }) => e.first([() => e.exitCode(), () => e.command(() => {
                        const {
                            selection: o,
                            storedMarks: i
                        } = n;
                        if (o.$from.parent.type.spec.isolating)
                            return !1;
                        const {
                            keepMarks: s
                        } = this.options, {
                            splittableMarks: a
                        } = r.extensionManager,
                        l = i || o.$to.parentOffset && o.$from.marks();
                        return t().insertContent({
                            type: this.name
                        }).command(({
                                tr: c,
                                dispatch: u
                            }) => {
                            if (u && l && s) {
                                const f = l.filter(p => a.includes(p.type.name));
                                c.ensureMarks(f)
                            }
                            return !0
                        }).run()
                    })])
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Enter": () => this.editor.commands.setHardBreak(),
            "Shift-Enter": () => this.editor.commands.setHardBreak()
        }
    }
}), llt = Ei.create({
    name: "heading",
    addOptions() {
        return {
            levels: [1, 2, 3, 4, 5, 6],
            HTMLAttributes: {}
        }
    },
    content: "inline*",
    group: "block",
    defining: !0,
    addAttributes() {
        return {
            level: {
            default:
                1,
                rendered: !1
            }
        }
    },
    parseHTML() {
        return this.options.levels.map(e => ({
                tag: `h${e}`,
                attrs: {
                    level: e
                }
            }))
    },
    renderHTML({
        node: e,
        HTMLAttributes: t
    }) {
        return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, xr(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setHeading: e => ({
                commands: t
            }) => this.options.levels.includes(e.level) ? t.setNode(this.name, e) : !1,
            toggleHeading: e => ({
                commands: t
            }) => this.options.levels.includes(e.level) ? t.toggleNode(this.name, "paragraph", e) : !1
        }
    },
    addKeyboardShortcuts() {
        return this.options.levels.reduce((e, t) => ({
                ...e,
                [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({
                    level: t
                })
            }), {})
    },
    addInputRules() {
        return this.options.levels.map(e => mS({
                find: new RegExp(`^(#{1,${e}})\\s$`),
                type: this.type,
                getAttributes: {
                    level: e
                }
            }))
    }
});
var u1 = 200, eo = function () {};
eo.prototype.append = function (t) {
    return t.length ? (t = eo.from(t), !this.length && t || t.length < u1 && this.leafAppend(t) || this.length < u1 && t.leafPrepend(this) || this.appendInner(t)) : this
};
eo.prototype.prepend = function (t) {
    return t.length ? eo.from(t).append(this) : this
};
eo.prototype.appendInner = function (t) {
    return new clt(this, t)
};
eo.prototype.slice = function (t, n) {
    return t === void 0 && (t = 0),
    n === void 0 && (n = this.length),
    t >= n ? eo.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n))
};
eo.prototype.get = function (t) {
    if (!(t < 0 || t >= this.length))
        return this.getInner(t)
};
eo.prototype.forEach = function (t, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0)
};
eo.prototype.map = function (t, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length);
    var o = [];
    return this.forEach(function (i, s) {
        return o.push(t(i, s))
    }, n, r),
    o
};
eo.from = function (t) {
    return t instanceof eo ? t : t && t.length ? new aW(t) : eo.empty
};
var aW = function (e) {
    function t(r) {
        e.call(this),
        this.values = r
    }
    e && (t.__proto__ = e),
    t.prototype = Object.create(e && e.prototype),
    t.prototype.constructor = t;
    var n = {
        length: {
            configurable: !0
        },
        depth: {
            configurable: !0
        }
    };
    return t.prototype.flatten = function () {
        return this.values
    },
    t.prototype.sliceInner = function (o, i) {
        return o == 0 && i == this.length ? this : new t(this.values.slice(o, i))
    },
    t.prototype.getInner = function (o) {
        return this.values[o]
    },
    t.prototype.forEachInner = function (o, i, s, a) {
        for (var l = i; l < s; l++)
            if (o(this.values[l], a + l) === !1)
                return !1
    },
    t.prototype.forEachInvertedInner = function (o, i, s, a) {
        for (var l = i - 1; l >= s; l--)
            if (o(this.values[l], a + l) === !1)
                return !1
    },
    t.prototype.leafAppend = function (o) {
        if (this.length + o.length <= u1)
            return new t(this.values.concat(o.flatten()))
    },
    t.prototype.leafPrepend = function (o) {
        if (this.length + o.length <= u1)
            return new t(o.flatten().concat(this.values))
    },
    n.length.get = function () {
        return this.values.length
    },
    n.depth.get = function () {
        return 0
    },
    Object.defineProperties(t.prototype, n),
    t
}
(eo);
eo.empty = new aW([]);
var clt = function (e) {
    function t(n, r) {
        e.call(this),
        this.left = n,
        this.right = r,
        this.length = n.length + r.length,
        this.depth = Math.max(n.depth, r.depth) + 1
    }
    return e && (t.__proto__ = e),
    t.prototype = Object.create(e && e.prototype),
    t.prototype.constructor = t,
    t.prototype.flatten = function () {
        return this.left.flatten().concat(this.right.flatten())
    },
    t.prototype.getInner = function (r) {
        return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
    },
    t.prototype.forEachInner = function (r, o, i, s) {
        var a = this.left.length;
        if (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === !1 || i > a && this.right.forEachInner(r, Math.max(o - a, 0), Math.min(this.length, i) - a, s + a) === !1)
            return !1
    },
    t.prototype.forEachInvertedInner = function (r, o, i, s) {
        var a = this.left.length;
        if (o > a && this.right.forEachInvertedInner(r, o - a, Math.max(i, a) - a, s + a) === !1 || i < a && this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === !1)
            return !1
    },
    t.prototype.sliceInner = function (r, o) {
        if (r == 0 && o == this.length)
            return this;
        var i = this.left.length;
        return o <= i ? this.left.slice(r, o) : r >= i ? this.right.slice(r - i, o - i) : this.left.slice(r, i).append(this.right.slice(0, o - i))
    },
    t.prototype.leafAppend = function (r) {
        var o = this.right.leafAppend(r);
        if (o)
            return new t(this.left, o)
    },
    t.prototype.leafPrepend = function (r) {
        var o = this.left.leafPrepend(r);
        if (o)
            return new t(o, this.right)
    },
    t.prototype.appendInner = function (r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new t(this.left, new t(this.right, r)) : new t(this, r)
    },
    t
}
(eo), lW = eo;
const ult = 500;
class xs {
    constructor(t, n) {
        this.items = t,
        this.eventCount = n
    }
    popEvent(t, n) {
        if (this.eventCount == 0)
            return null;
        let r = this.items.length;
        for (; ; r--)
            if (this.items.get(r - 1).selection) {
                --r;
                break
            }
        let o,
        i;
        n && (o = this.remapping(r, this.items.length), i = o.maps.length);
        let s = t.tr,
        a,
        l,
        c = [],
        u = [];
        return this.items.forEach((f, p) => {
            if (!f.step) {
                o || (o = this.remapping(r, p + 1), i = o.maps.length),
                i--,
                u.push(f);
                return
            }
            if (o) {
                u.push(new js(f.map));
                let m = f.step.map(o.slice(i)),
                v;
                m && s.maybeStep(m).doc && (v = s.mapping.maps[s.mapping.maps.length - 1], c.push(new js(v, void 0, void 0, c.length + u.length))),
                i--,
                v && o.appendMap(v, i)
            } else
                s.maybeStep(f.step);
            if (f.selection)
                return a = o ? f.selection.map(o.slice(i)) : f.selection, l = new xs(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1
        }, this.items.length, 0), {
            remaining: l,
            transform: s,
            selection: a
        }
    }
    addTransform(t, n, r, o) {
        let i = [],
        s = this.eventCount,
        a = this.items,
        l = !o && a.length ? a.get(a.length - 1) : null;
        for (let u = 0; u < t.steps.length; u++) {
            let f = t.steps[u].invert(t.docs[u]),
            p = new js(t.mapping.maps[u], f, n),
            m;
            (m = l && l.merge(p)) && (p = m, u ? i.pop() : a = a.slice(0, a.length - 1)),
            i.push(p),
            n && (s++, n = void 0),
            o || (l = p)
        }
        let c = s - r.depth;
        return c > flt && (a = dlt(a, c), s -= c),
        new xs(a.append(i), s)
    }
    remapping(t, n) {
        let r = new lf;
        return this.items.forEach((o, i) => {
            let s = o.mirrorOffset != null && i - o.mirrorOffset >= t ? r.maps.length - o.mirrorOffset : void 0;
            r.appendMap(o.map, s)
        }, t, n),
        r
    }
    addMaps(t) {
        return this.eventCount == 0 ? this : new xs(this.items.append(t.map(n => new js(n))), this.eventCount)
    }
    rebased(t, n) {
        if (!this.eventCount)
            return this;
        let r = [],
        o = Math.max(0, this.items.length - n),
        i = t.mapping,
        s = t.steps.length,
        a = this.eventCount;
        this.items.forEach(p => {
            p.selection && a--
        }, o);
        let l = n;
        this.items.forEach(p => {
            let m = i.getMirror(--l);
            if (m == null)
                return;
            s = Math.min(s, m);
            let v = i.maps[m];
            if (p.step) {
                let y = t.steps[m].invert(t.docs[m]),
                b = p.selection && p.selection.map(i.slice(l + 1, m));
                b && a++,
                r.push(new js(v, y, b))
            } else
                r.push(new js(v))
        }, o);
        let c = [];
        for (let p = n; p < s; p++)
            c.push(new js(i.maps[p]));
        let u = this.items.slice(0, o).append(c).append(r),
        f = new xs(u, a);
        return f.emptyItemCount() > ult && (f = f.compress(this.items.length - r.length)),
        f
    }
    emptyItemCount() {
        let t = 0;
        return this.items.forEach(n => {
            n.step || t++
        }),
        t
    }
    compress(t = this.items.length) {
        let n = this.remapping(0, t),
        r = n.maps.length,
        o = [],
        i = 0;
        return this.items.forEach((s, a) => {
            if (a >= t)
                o.push(s), s.selection && i++;
            else if (s.step) {
                let l = s.step.map(n.slice(r)),
                c = l && l.getMap();
                if (r--, c && n.appendMap(c, r), l) {
                    let u = s.selection && s.selection.map(n.slice(r));
                    u && i++;
                    let f = new js(c.invert(), l, u),
                    p,
                    m = o.length - 1;
                    (p = o.length && o[m].merge(f)) ? o[m] = p : o.push(f)
                }
            } else
                s.map && r--
        }, this.items.length, 0),
        new xs(lW.from(o.reverse()), i)
    }
}
xs.empty = new xs(lW.empty, 0);
function dlt(e, t) {
    let n;
    return e.forEach((r, o) => {
        if (r.selection && t-- == 0)
            return n = o, !1
    }),
    e.slice(n)
}
class js {
    constructor(t, n, r, o) {
        this.map = t,
        this.step = n,
        this.selection = r,
        this.mirrorOffset = o
    }
    merge(t) {
        if (this.step && t.step && !t.selection) {
            let n = t.step.merge(this.step);
            if (n)
                return new js(n.getMap().invert(), n, this.selection)
        }
    }
}
class $l {
    constructor(t, n, r, o) {
        this.done = t,
        this.undone = n,
        this.prevRanges = r,
        this.prevTime = o
    }
}
const flt = 20;
function hlt(e, t, n, r) {
    let o = n.getMeta(Jl),
    i;
    if (o)
        return o.historyState;
    n.getMeta(mlt) && (e = new $l(e.done, e.undone, null, 0));
    let s = n.getMeta("appendedTransaction");
    if (n.steps.length == 0)
        return e;
    if (s && s.getMeta(Jl))
        return s.getMeta(Jl).redo ? new $l(e.done.addTransform(n, void 0, r, k0(t)), e.undone, q5(n.mapping.maps[n.steps.length - 1]), e.prevTime) : new $l(e.done, e.undone.addTransform(n, void 0, r, k0(t)), null, e.prevTime);
    if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
        let a = e.prevTime == 0 || !s && (e.prevTime < (n.time || 0) - r.newGroupDelay || !plt(n, e.prevRanges)),
        l = s ? ok(e.prevRanges, n.mapping) : q5(n.mapping.maps[n.steps.length - 1]);
        return new $l(e.done.addTransform(n, a ? t.selection.getBookmark() : void 0, r, k0(t)), xs.empty, l, n.time)
    } else
        return (i = n.getMeta("rebased")) ? new $l(e.done.rebased(n, i), e.undone.rebased(n, i), ok(e.prevRanges, n.mapping), e.prevTime) : new $l(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), ok(e.prevRanges, n.mapping), e.prevTime)
}
function plt(e, t) {
    if (!t)
        return !1;
    if (!e.docChanged)
        return !0;
    let n = !1;
    return e.mapping.maps[0].forEach((r, o) => {
        for (let i = 0; i < t.length; i += 2)
            r <= t[i + 1] && o >= t[i] && (n = !0)
    }),
    n
}
function q5(e) {
    let t = [];
    return e.forEach((n, r, o, i) => t.push(o, i)),
    t
}
function ok(e, t) {
    if (!e)
        return null;
    let n = [];
    for (let r = 0; r < e.length; r += 2) {
        let o = t.map(e[r], 1),
        i = t.map(e[r + 1], -1);
        o <= i && n.push(o, i)
    }
    return n
}
function cW(e, t, n, r) {
    let o = k0(t),
    i = Jl.get(t).spec.config,
    s = (r ? e.undone : e.done).popEvent(t, o);
    if (!s)
        return;
    let a = s.selection.resolve(s.transform.doc),
    l = (r ? e.done : e.undone).addTransform(s.transform, t.selection.getBookmark(), i, o),
    c = new $l(r ? l : s.remaining, r ? s.remaining : l, null, 0);
    n(s.transform.setSelection(a).setMeta(Jl, {
            redo: r,
            historyState: c
        }).scrollIntoView())
}
let ik = !1, Y5 = null;
function k0(e) {
    let t = e.plugins;
    if (Y5 != t) {
        ik = !1,
        Y5 = t;
        for (let n = 0; n < t.length; n++)
            if (t[n].spec.historyPreserveItems) {
                ik = !0;
                break
            }
    }
    return ik
}
const Jl = new ps("history"), mlt = new ps("closeHistory");
function glt(e = {}) {
    return e = {
        depth: e.depth || 100,
        newGroupDelay: e.newGroupDelay || 500
    },
    new go({
        key: Jl,
        state: {
            init() {
                return new $l(xs.empty, xs.empty, null, 0)
            },
            apply(t, n, r) {
                return hlt(n, r, t, e)
            }
        },
        config: e,
        props: {
            handleDOMEvents: {
                beforeinput(t, n) {
                    let r = n.inputType,
                    o = r == "historyUndo" ? uW : r == "historyRedo" ? dW : null;
                    return o ? (n.preventDefault(), o(t.state, t.dispatch)) : !1
                }
            }
        }
    })
}
const uW = (e, t) => {
    let n = Jl.getState(e);
    return !n || n.done.eventCount == 0 ? !1 : (t && cW(n, e, t, !1), !0)
}, dW = (e, t) => {
    let n = Jl.getState(e);
    return !n || n.undone.eventCount == 0 ? !1 : (t && cW(n, e, t, !0), !0)
}, vlt = oi.create({
    name: "history",
    addOptions() {
        return {
            depth: 100,
            newGroupDelay: 500
        }
    },
    addCommands() {
        return {
            undo: () => ({
                state: e,
                dispatch: t
            }) => uW(e, t),
            redo: () => ({
                state: e,
                dispatch: t
            }) => dW(e, t)
        }
    },
    addProseMirrorPlugins() {
        return [glt(this.options)]
    },
    addKeyboardShortcuts() {
        return {
            "Mod-z": () => this.editor.commands.undo(),
            "Mod-y": () => this.editor.commands.redo(),
            "Shift-Mod-z": () => this.editor.commands.redo(),
            "Mod-я": () => this.editor.commands.undo(),
            "Shift-Mod-я": () => this.editor.commands.redo()
        }
    }
}), ylt = Ei.create({
    name: "horizontalRule",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    group: "block",
    parseHTML() {
        return [{
                tag: "hr"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["hr", xr(this.options.HTMLAttributes, e)]
    },
    addCommands() {
        return {
            setHorizontalRule: () => ({
                chain: e
            }) => e().insertContent({
                type: this.name
            }).command(({
                    tr: t,
                    dispatch: n
                }) => {
                var r;
                if (n) {
                    const {
                        $to: o
                    } = t.selection,
                    i = o.end();
                    if (o.nodeAfter)
                        t.setSelection(qt.create(t.doc, o.pos));
                    else {
                        const s = (r = o.parent.type.contentMatch.defaultType) === null || r === void 0 ? void 0 : r.create();
                        s && (t.insert(i, s), t.setSelection(qt.create(t.doc, i)))
                    }
                    t.scrollIntoView()
                }
                return !0
            }).run()
        }
    },
    addInputRules() {
        return [xst({
                find: /^(?:---|—-|___\s|\*\*\*\s)$/,
                type: this.type
            })]
    }
}), wlt = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/, blt = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g, _lt = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/, klt = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g, xlt = ls.create({
    name: "italic",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
                tag: "em"
            }, {
                tag: "i",
                getAttrs: e => e.style.fontStyle !== "normal" && null
            }, {
                style: "font-style=italic"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["em", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setItalic: () => ({
                commands: e
            }) => e.setMark(this.name),
            toggleItalic: () => ({
                commands: e
            }) => e.toggleMark(this.name),
            unsetItalic: () => ({
                commands: e
            }) => e.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-i": () => this.editor.commands.toggleItalic(),
            "Mod-I": () => this.editor.commands.toggleItalic()
        }
    },
    addInputRules() {
        return [qf({
                find: wlt,
                type: this.type
            }), qf({
                find: _lt,
                type: this.type
            })]
    },
    addPasteRules() {
        return [Fu({
                find: blt,
                type: this.type
            }), Fu({
                find: klt,
                type: this.type
            })]
    }
}), Slt = Ei.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
                tag: "li"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["li", xr(this.options.HTMLAttributes, e), 0]
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
}), Clt = Ei.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
                tag: "li"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["li", xr(this.options.HTMLAttributes, e), 0]
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
}), K5 = ls.create({
    name: "textStyle",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
                tag: "span",
                getAttrs: e => e.hasAttribute("style") ? {}
                 : !1
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["span", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            removeEmptyTextStyle: () => ({
                state: e,
                commands: t
            }) => {
                const n = cb(e, this.type);
                return Object.entries(n).some(([, o]) => !!o) ? !0 : t.unsetMark(this.name)
            }
        }
    }
}), G5 = /^(\d+)\.\s$/, Ilt = Ei.create({
    name: "orderedList",
    addOptions() {
        return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: !1,
            keepAttributes: !1
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    addAttributes() {
        return {
            start: {
            default:
                1,
                parseHTML: e => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1
            }
        }
    },
    parseHTML() {
        return [{
                tag: "ol"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        const {
            start: t,
            ...n
        } = e;
        return t === 1 ? ["ol", xr(this.options.HTMLAttributes, n), 0] : ["ol", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            toggleOrderedList: () => ({
                commands: e,
                chain: t
            }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Clt.name, this.editor.getAttributes(K5.name)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        }
    },
    addInputRules() {
        let e = zm({
            find: G5,
            type: this.type,
            getAttributes: t => ({
                start: +t[1]
            }),
            joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (e = zm({
                find: G5,
                type: this.type,
                keepMarks: this.options.keepMarks,
                keepAttributes: this.options.keepAttributes,
                getAttributes: t => ({
                    start: +t[1],
                    ...this.editor.getAttributes(K5.name)
                }),
                joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
                editor: this.editor
            })),
        [e]
    }
}), fW = Ei.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    group: "block",
    content: "inline*",
    parseHTML() {
        return [{
                tag: "p"
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["p", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setParagraph: () => ({
                commands: e
            }) => e.setNode(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Alt-0": () => this.editor.commands.setParagraph()
        }
    }
}), Tlt = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/, Mlt = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g, Plt = ls.create({
    name: "strike",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
                tag: "s"
            }, {
                tag: "del"
            }, {
                tag: "strike"
            }, {
                style: "text-decoration",
                consuming: !1,
                getAttrs: e => e.includes("line-through") ? {}
                 : !1
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["s", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setStrike: () => ({
                commands: e
            }) => e.setMark(this.name),
            toggleStrike: () => ({
                commands: e
            }) => e.toggleMark(this.name),
            unsetStrike: () => ({
                commands: e
            }) => e.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-x": () => this.editor.commands.toggleStrike()
        }
    },
    addInputRules() {
        return [qf({
                find: Tlt,
                type: this.type
            })]
    },
    addPasteRules() {
        return [Fu({
                find: Mlt,
                type: this.type
            })]
    }
}), Elt = Ei.create({
    name: "text",
    group: "inline"
}), Olt = oi.create({
    name: "starterKit",
    addExtensions() {
        var e,
        t,
        n,
        r,
        o,
        i,
        s,
        a,
        l,
        c,
        u,
        f,
        p,
        m,
        v,
        y,
        b,
        w;
        const k = [];
        return this.options.blockquote !== !1 && k.push(Nat.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)),
        this.options.bold !== !1 && k.push(Fat.configure((t = this.options) === null || t === void 0 ? void 0 : t.bold)),
        this.options.bulletList !== !1 && k.push(Wat.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)),
        this.options.code !== !1 && k.push(Uat.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)),
        this.options.codeBlock !== !1 && k.push(Kat.configure((o = this.options) === null || o === void 0 ? void 0 : o.codeBlock)),
        this.options.document !== !1 && k.push(Gat.configure((i = this.options) === null || i === void 0 ? void 0 : i.document)),
        this.options.dropcursor !== !1 && k.push(Zat.configure((s = this.options) === null || s === void 0 ? void 0 : s.dropcursor)),
        this.options.gapcursor !== !1 && k.push(slt.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)),
        this.options.hardBreak !== !1 && k.push(alt.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)),
        this.options.heading !== !1 && k.push(llt.configure((c = this.options) === null || c === void 0 ? void 0 : c.heading)),
        this.options.history !== !1 && k.push(vlt.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)),
        this.options.horizontalRule !== !1 && k.push(ylt.configure((f = this.options) === null || f === void 0 ? void 0 : f.horizontalRule)),
        this.options.italic !== !1 && k.push(xlt.configure((p = this.options) === null || p === void 0 ? void 0 : p.italic)),
        this.options.listItem !== !1 && k.push(Slt.configure((m = this.options) === null || m === void 0 ? void 0 : m.listItem)),
        this.options.orderedList !== !1 && k.push(Ilt.configure((v = this.options) === null || v === void 0 ? void 0 : v.orderedList)),
        this.options.paragraph !== !1 && k.push(fW.configure((y = this.options) === null || y === void 0 ? void 0 : y.paragraph)),
        this.options.strike !== !1 && k.push(Plt.configure((b = this.options) === null || b === void 0 ? void 0 : b.strike)),
        this.options.text !== !1 && k.push(Elt.configure((w = this.options) === null || w === void 0 ? void 0 : w.text)),
        k
    }
}), $lt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Alt = P("path", {
    d: "M9.5 27.528h7.669c1.155 0 2.195-.13 3.12-.39.924-.26 1.708-.65 2.354-1.17a5.176 5.176 0 0 0 1.487-1.935c.347-.77.52-1.661.52-2.672 0-.53-.072-1.04-.217-1.53a4.538 4.538 0 0 0-.635-1.387 4.44 4.44 0 0 0-1.04-1.04c-.404-.299-.953-.544-1.646-.737v-.014c.356-.135.679-.299.967-.491.299-.193.564-.405.795-.636.423-.423.741-.914.953-1.473.221-.568.337-1.17.346-1.805 0-.982-.182-1.834-.548-2.556A4.738 4.738 0 0 0 22.094 7.9c-.665-.472-1.469-.823-2.412-1.054-.934-.231-1.974-.347-3.12-.347H9.5v21.028ZM21.042 16.653h-12"
}, null, -1), Dlt = [Alt];
function Nlt(e, t) {
    return _(),
    O("svg", $lt, Dlt)
}
const Rlt = {
    render: Nlt
}, Llt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Blt = P("path", {
    d: "M6 26.5h15M13.5 26.6l3.916-21.144M10 5.5h15"
}, null, -1), Vlt = [Blt];
function Flt(e, t) {
    return _(),
    O("svg", Llt, Vlt)
}
const jlt = {
    render: Flt
}, Wlt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, zlt = P("path", {
    d: "M10.839 5v12.902c0 1.72 1.032 5.162 5.161 5.162s5.161-3.441 5.161-5.162V5M8 26.75h16"
}, null, -1), Hlt = [zlt];
function Ult(e, t) {
    return _(),
    O("svg", Wlt, Hlt)
}
const qlt = {
    render: Ult
}, Ylt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Klt = P("path", {
    "stroke-linejoin": "round",
    d: "M30 9.46H14M10 5.46H2v8h8v-8ZM30 22.647H14M10 18.5H2v8h8v-8Z"
}, null, -1), Glt = [Klt];
function Xlt(e, t) {
    return _(),
    O("svg", Ylt, Glt)
}
const Jlt = {
    render: Xlt
}, Zlt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Qlt = P("path", {
    d: "M3 6.483 6.707 5v8.155"
}, null, -1), ect = P("path", {
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    d: "M23.017 11.85h-10M29.017 7.92h-16M23.017 26.195h-10M29.017 22.266h-16"
}, null, -1), tct = P("path", {
    "stroke-linejoin": "round",
    d: "M6.707 23.052C5.966 23.793 3.989 26.264 3 27.5h5.19"
}, null, -1), nct = P("path", {
    d: "M7.448 21.569c0-.741-.445-2.224-2.224-2.224M7.448 21.569c0 .247-.148.89-.741 1.483M3 21.569c0-.741.445-2.224 2.224-2.224"
}, null, -1), rct = [Qlt, ect, tct, nct];
function oct(e, t) {
    return _(),
    O("svg", Zlt, rct)
}
const ict = {
    render: oct
}, sct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, act = P("path", {
    d: "M4 7h24M4 19h24M4 13h13M4 25h13"
}, null, -1), lct = [act];
function cct(e, t) {
    return _(),
    O("svg", sct, lct)
}
const uct = {
    render: cct
}, dct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, fct = P("path", {
    d: "M4 7h24M4 19h24M9 13h14M9 25h14"
}, null, -1), hct = [fct];
function pct(e, t) {
    return _(),
    O("svg", dct, hct)
}
const mct = {
    render: pct
}, gct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, vct = P("path", {
    d: "M4 7h24M4 19h24M15 13h13M15 25h13"
}, null, -1), yct = [vct];
function wct(e, t) {
    return _(),
    O("svg", gct, yct)
}
const bct = {
    render: wct
}, _ct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, kct = P("path", {
    d: "M1 27.5 9.5 6 18 27.5M4 20h11m6.438-3.062c0-1.313.962-3.938 4.812-3.938 3.85 0 4.813 2.625 4.813 3.938v7c0 .729.087 2.862.437 3.562"
}, null, -1), xct = P("path", {
    d: "M31.063 19.256c-4.604-.445-9.625.09-9.625 4.003 0 3.914 3.905 4.003 5.858 3.558 1.349-.307 2.762-1.423 3.767-3.558"
}, null, -1), Sct = [kct, xct];
function Cct(e, t) {
    return _(),
    O("svg", _ct, Sct)
}
const Ict = {
    render: Cct
}, Tct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Mct = P("path", {
    d: "M9 7h13M9 19h16M9 13h19M9 25h12M4.5 6v20"
}, null, -1), Pct = [Mct];
function Ect(e, t) {
    return _(),
    O("svg", Tct, Pct)
}
const Oct = {
    render: Ect
}, $ct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Act = P("path", {
    d: "M11.189 23.689 3.5 16l7.689-7.689m9.622 0L28.5 16l-7.689 7.689M18.82 4.693l-5.64 22.614"
}, null, -1), Dct = [Act];
function Nct(e, t) {
    return _(),
    O("svg", $ct, Dct)
}
const Rct = {
    render: Nct
}, Lct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, Bct = P("path", {
    d: "M4 16h24m-18 3.543c0 .954.222 1.803.667 2.546.435.754 1.068 1.341 1.898 1.763.82.432 1.823.648 3.01.648 1.185 0 2.183-.186 2.994-.558.8-.361 1.408-.848 1.823-1.461A3.538 3.538 0 0 0 21 20.462c0-.522-.099-1.004-.297-1.446-.197-.432-.518-.84-.963-1.22a6.167 6.167 0 0 0-.74-.514m2-4.475c0-.925-.202-1.748-.607-2.469-.395-.73-.97-1.3-1.724-1.71C17.923 8.21 17.01 8 15.933 8c-1.079 0-1.986.18-2.723.54-.728.351-1.28.824-1.657 1.418A3.596 3.596 0 0 0 11 11.916c0 .507.09.974.27 1.403.18.419.471.813.876 1.183.195.17.419.336.672.498 0 0 1.182.75 2.182 1"
}, null, -1), Vct = [Bct];
function Fct(e, t) {
    return _(),
    O("svg", Lct, Vct)
}
const jct = {
    render: Fct
}, Wct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    viewBox: "0 0 32 32"
}, zct = P("path", {
    d: "M10 20h12m-12 4h12M10 8h12m-12 4h12M4 16h4m1 0h4m1 0h4m1 0h4m1 0h4"
}, null, -1), Hct = [zct];
function Uct(e, t) {
    return _(),
    O("svg", Wct, Hct)
}
const qct = {
    render: Uct
}, X5 = e => {
    for (let n = 1; n <= 6; n++)
        if (e.isActive("heading", {
                level: n
            })) {
            e.chain().focus().toggleHeading({
                level: n
            }).run();
            break
        }
}, Yct = (e, t) => ({
    item: {
        text: `Heading ${e}`
    },
    id: e,
    hotkey: ["Ctrl", "Alt", `${e}`],
    active: () => t().isActive("heading", {
        level: e
    })
}), Kct = e => ({
    children: [{
            item: {
                text: "Standard"
            },
            id: "standard",
            hotkey: ["Ctrl", "Alt", "0"]
        }, {
            item: {
                text: "Small text"
            },
            id: "small",
            hotkey: ["Ctrl", "Alt", "−"],
            active: () => e().isActive({
                smallText: !0
            })
        }, ...Array.from({
            length: 6
        }, (t, n) => Yct(n + 1, e))],
    onChildClick: t => {
        const n = e();
        if (t === "standard") {
            X5(n),
            n.chain().focus().unsetSmallText().run();
            return
        }
        if (t === "small") {
            X5(n),
            n.chain().focus().setSmallText().run();
            return
        }
        n.chain().focus().toggleHeading({
            level: t
        }).run()
    }
}), Gct = Fe({
    __name: "RichTextEditorBaseToolbar",
    props: {
        editor: {},
        baseExtensions: {}
    },
    setup(e) {
        const t = e,
        n = (s, a) => "all" in t.baseExtensions ? [a] : t.baseExtensions[s] ? [a] : [],
        r = s => "all" in t.baseExtensions ? !0 : Boolean(t.baseExtensions[s]),
        o = () => t.editor.isActive("orderedList") || t.editor.isActive("bulletList"),
        i = [...n("bold", {
                id: "bold",
                name: "Bold",
                hotkey: ["Ctrl", "B"],
                icon: Rlt,
                active: () => t.editor.isActive("bold"),
                onClick: () => t.editor.chain().focus().toggleBold().run()
            }), ...n("italic", {
                id: "italic",
                name: "Italic",
                icon: jlt,
                hotkey: ["Ctrl", "I"],
                active: () => t.editor.isActive("italic"),
                onClick: () => t.editor.chain().focus().toggleItalic().run()
            }), ...n("underline", {
                id: "underline",
                name: "Underline",
                icon: qlt,
                hotkey: ["Ctrl", "U"],
                active: () => t.editor.isActive("underline"),
                onClick: () => t.editor.chain().focus().toggleUnderline().run()
            }), ...n("bulletList", {
                id: "bulletList",
                name: "Bullet list",
                icon: Jlt,
                hotkey: ["Ctrl", "Shift", "8"],
                active: () => t.editor.isActive("bulletList"),
                onClick: () => {
                    const s = t.editor.chain().focus();
                    r("textAlign") && s.setTextAlign("left"),
                    s.toggleBulletList().run()
                }
            }), ...n("orderedList", {
                id: "orderedList",
                name: "Ordered list",
                icon: ict,
                hotkey: ["Ctrl", "Shift", "7"],
                active: () => t.editor.isActive("orderedList"),
                onClick: () => {
                    const s = t.editor.chain().focus();
                    r("textAlign") && s.setTextAlign("left"),
                    s.toggleOrderedList().run()
                }
            }), ...n("textAlign", {
                id: "align-left",
                icon: uct,
                name: "Align left",
                hotkey: ["Ctrl", "Shift", "L"],
                active: () => !o() && t.editor.isActive({
                    textAlign: "left"
                }),
                onClick: () => t.editor.chain().focus().setTextAlign("left").run(),
                disabled: () => o()
            }), ...n("textAlign", {
                id: "align-center",
                icon: mct,
                name: "Align center",
                hotkey: ["Ctrl", "Shift", "E"],
                active: () => !o() && t.editor.isActive({
                    textAlign: "center"
                }),
                onClick: () => t.editor.chain().focus().setTextAlign("center").run(),
                disabled: () => o()
            }), ...n("textAlign", {
                id: "align-right",
                icon: bct,
                name: "Align right",
                hotkey: ["Ctrl", "Shift", "R"],
                active: () => !o() && t.editor.isActive({
                    textAlign: "right"
                }),
                onClick: () => t.editor.chain().focus().setTextAlign("right").run(),
                disabled: () => o()
            }), ...n("paragraphTextStyle", {
                id: "paragraphTextStyle",
                icon: Ict,
                name: "Text style",
                secondary: !0,
                ...Kct(() => t.editor)
            }), ...n("blockquote", {
                id: "blockquote",
                icon: Oct,
                name: "Blockquote",
                active: () => t.editor.isActive("blockquote"),
                onClick: () => t.editor.chain().focus().toggleBlockquote().run(),
                secondary: !0
            }), ...n("codeBlock", {
                id: "codeBlock",
                icon: Rct,
                name: "Code block",
                hotkey: ["Ctrl", "Alt", "C"],
                active: () => t.editor.isActive("codeBlock"),
                onClick: () => t.editor.chain().focus().toggleCodeBlock().run(),
                secondary: !0
            }), ...n("strike", {
                id: "strikethrough",
                icon: jct,
                name: "Strikethrough",
                hotkey: ["Ctrl", "Shift", "X"],
                active: () => t.editor.isActive("strike"),
                onClick: () => t.editor.chain().focus().toggleStrike().run(),
                secondary: !0
            }), ...n("horizontalRule", {
                id: "horizontalRule",
                icon: qct,
                name: "Divider",
                active: () => !1,
                onClick: () => t.editor.chain().focus().setHorizontalRule().run(),
                secondary: !0
            })];
        return (s, a) => Ye(s.$slots, "default", {
            tools: i
        })
    }
}), Xct = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linecap": "round",
    viewBox: "0 0 32 32"
}, Jct = P("path", {
    "stroke-width": "3",
    d: "M16 8h0M16 16h0M16 24h0"
}, null, -1), Zct = [Jct];
function Qct(e, t) {
    return _(),
    O("svg", Xct, Zct)
}
const hW = {
    render: Qct
}, eut = {
    class: "tools"
}, tut = Fe({
    __name: "RichTextEditorToolbar",
    props: {
        editor: {},
        tools: {},
        hotkeyFormatter: {
            type: Function
        }
    },
    setup(e) {
        const t = e,
        n = ne(() => t.tools.filter(({
                        secondary: s
                    }) => !s)),
        r = ne(() => t.tools.filter(({
                        secondary: s
                    }) => s)),
        o = ne(() => r.value.map(s => ({
                        text: s.name,
                        disabled: s.disabled?.(),
                        hotkeyText: t.hotkeyFormatter(s.hotkey ?? []),
                        icon: s.icon,
                        id: s.id,
                        selected: s.active?.(),
                        children: s.children?.map(({
                                item: a,
                                id: l,
                                active: c,
                                hotkey: u
                            }) => ({
                                ...a,
                                id: {
                                    toolId: s.id,
                                    childId: l
                                },
                                selected: c?.(),
                                hotkeyText: t.hotkeyFormatter(u ?? [])
                            })) ?? []
                    }))),
        i = (s, {
            id: a
        }) => {
            const l = typeof a == "object",
            c = l ? a.toolId : a,
            u = r.value.find(f => f.id === c);
            l ? u?.onChildClick?.(a.childId) : u?.onClick?.()
        };
        return (s, a) => (_(), O("div", eut, [(_(!0), O(Le, null, $t(n.value, l => (_(), H(ti, {
                                        key: l.id,
                                        class: "tool",
                                        "data-testid": l.id,
                                        disabled: l.disabled?.(),
                                        active: l.active?.(),
                                        title: s.hotkeyFormatter(l.hotkey ?? []),
                                        compact: "",
                                        onKeydown: Rt(ve(l.onClick, ["prevent"]), ["enter"]),
                                        onClick: ve(l.onClick, ["stop"])
                                    }, {
                                    default:
                                        oe(() => [(_(), H(Kt(l.icon)))]),
                                        _: 2
                                    }, 1032, ["data-testid", "disabled", "active", "title", "onKeydown", "onClick"]))), 128)), r.value.length > 0 ? (_(), H(Vf, {
                            key: 0,
                            items: o.value,
                            orientation: "left",
                            onItemClick: i
                        }, {
                        default:
                            oe(() => [z(ke(hW))]),
                            _: 1
                        }, 8, ["items"])) : J("", !0)]))
    }
});
const nut = te(tut, [["__scopeId", "data-v-acd8db4f"]]), rut = oi.create({
    name: "textAlign",
    addOptions() {
        return {
            types: [],
            alignments: ["left", "center", "right", "justify"],
            defaultAlignment: "left"
        }
    },
    addGlobalAttributes() {
        return [{
                types: this.options.types,
                attributes: {
                    textAlign: {
                    default:
                        this.options.defaultAlignment,
                        parseHTML: e => e.style.textAlign || this.options.defaultAlignment,
                        renderHTML: e => e.textAlign === this.options.defaultAlignment ? {}
                         : {
                            style: `text-align: ${e.textAlign}`
                        }
                    }
                }
            }
        ]
    },
    addCommands() {
        return {
            setTextAlign: e => ({
                commands: t
            }) => this.options.alignments.includes(e) ? this.options.types.every(n => t.updateAttributes(n, {
                    textAlign: e
                })) : !1,
            unsetTextAlign: () => ({
                commands: e
            }) => this.options.types.every(t => e.resetAttributes(t, "textAlign"))
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
            "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
            "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
            "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
        }
    }
}), out = rut.extend({
    addKeyboardShortcuts() {
        const e = () => !(this.editor.isActive("bulletList") || this.editor.isActive("orderedList"));
        return {
            "Mod-Shift-l": () => e() && this.editor.commands.setTextAlign("left"),
            "Mod-Shift-e": () => e() && this.editor.commands.setTextAlign("center"),
            "Mod-Shift-r": () => e() && this.editor.commands.setTextAlign("right")
        }
    }
}), iut = fW.extend({
    addAttributes() {
        const e = "small-text";
        return {
            ...this.parent?.(),
            smallText: {
            default:
                !1,
                parseHTML: t => t.className === e,
                renderHTML: t => t.smallText ? {
                    class: e
                }
                 : {}
            }
        }
    },
    addCommands() {
        return {
            ...this.parent?.(),
            setSmallText: () => ({
                commands: e
            }) => e.toggleNode(this.name, "paragraph", {
                smallText: !0
            }),
            unsetSmallText: () => ({
                chain: e
            }) => e().updateAttributes(this.name, {
                smallText: !1
            }).run()
        }
    },
    addKeyboardShortcuts() {
        return {
            ...this.parent?.(),
            "Mod-Alt--": () => this.editor.commands.setSmallText()
        }
    }
}), sut = Fe({
    __name: "RichTextEditor",
    props: {
        modelValue: {},
        editable: {
            type: Boolean,
        default:
            !0
        },
        minHeight: {
        default:
            null
        },
        maxHeight: {
        default:
            null
        },
        baseExtensions: {
        default:
            () => ({})
        },
        hotkeyFormatter: {
            type: Function,
        default:
            e => {
                const t = () => navigator?.userAgent?.toLowerCase()?.includes("mac"),
                n = {
                    Shift: "⇧",
                    Ctrl: "⌘",
                    Alt: "⌥"
                },
                r = i => n[i] || i,
                o = i => i;
                return e.map(t() ? r : o).join(" ")
            }
        },
        customExtensions: {
        default:
            () => []
        },
        autofocus: {
            type: Boolean,
        default:
            !1
        },
        withBorder: {
            type: Boolean,
        default:
            !0
        },
        disabled: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["update:modelValue", "blur"],
    setup(e, {
        expose: t,
        emit: n
    }) {
        const r = e;
        to(x => ({
                "98d745b0": w.value,
                "3cc118d4": y.value
            }));
        const o = z1(), {
            modelValue: i,
            editable: s,
            disabled: a,
            baseExtensions: l,
            customExtensions: c,
            autofocus: u
        } = nl(r),
        f = x => "all" in l.value ? !0 : Boolean(l.value[x]),
        p = x => f(x) ? void 0 : !1,
        m = [Olt.configure({
                bold: p("bold"),
                italic: p("italic"),
                bulletList: p("bulletList"),
                orderedList: p("orderedList"),
                heading: p("heading"),
                blockquote: p("blockquote"),
                code: p("code"),
                codeBlock: p("codeBlock"),
                horizontalRule: p("horizontalRule"),
                strike: p("strike"),
                ...f("paragraphTextStyle") && {
                    paragraph: !1
                }
            }), ...f("underline") ? [Aat] : [], ...f("paragraphTextStyle") ? [iut] : [], ...f("textAlign") ? [out.configure({
                    types: [l.value.heading ? "heading" : "", "paragraph"].filter(Boolean),
                    alignments: ["left", "right", "center"]
                })] : [], ...c.value],
        v = $at({
            content: i.value,
            editable: s.value && !a.value,
            autofocus: u.value,
            extensions: m,
            onUpdate: () => n("update:modelValue", v.value?.getHTML() ?? ""),
            onBlur: () => n("blur")
        }),
        y = ne(() => r.minHeight ? `${r.minHeight}px` : "initial"),
        b = () => {
            v.value?.commands?.focus?.()
        };
        t({
            focus: b
        });
        const w = ne(() => r.maxHeight ? `${r.maxHeight}px` : "initial");
        Ht(i, x => {
            !v.value || v.value.getHTML() === x || v.value.commands.setContent(x)
        }),
        Ht([s, a], ([x, S], [T, E]) => {
            if (!v.value)
                return;
            const M = T && !E,
            N = x && !S;
            M !== N && (v.value.setEditable(N), r.autofocus && b())
        }),
        Ur(async() => {
            r.editable && r.autofocus && (await Ci(), b())
        });
        const k = o.customToolbar,
        C = ne(() => Object.keys(r.baseExtensions).length);
        return (x, S) => (_(), O("div", {
                class: he(["editor-wrapper", {
                            "with-border": x.withBorder,
                            disabled: ke(a)
                        }
                    ])
            }, [C.value ? (_(), H(ho, {
                            key: 0,
                            name: "expand",
                            css: !ke(k)
                        }, {
                        default:
                            oe(() => [ke(v) && ke(s) && !ke(a) ? (_(), O("div", {
                                            key: 0,
                                            class: he({
                                                "embedded-toolbar": !ke(k)
                                            })
                                        }, [z(Gct, {
                                                    editor: ke(v),
                                                    "base-extensions": ke(l)
                                                }, {
                                                default:
                                                    oe(({
                                                            tools: T
                                                        }) => [Ye(x.$slots, "customToolbar", {
                                                                editor: ke(v),
                                                                tools: T
                                                            }, () => [z(nut, {
                                                                        editor: ke(v),
                                                                        tools: T,
                                                                        "hotkey-formatter": x.hotkeyFormatter
                                                                    }, null, 8, ["editor", "tools", "hotkey-formatter"])], !0)]),
                                                    _: 3
                                                }, 8, ["editor", "base-extensions"])], 2)) : J("", !0)]),
                            _: 3
                        }, 8, ["css"])) : J("", !0), z(ke(Oat), {
                        class: he(["rich-text-editor", {
                                    editable: ke(s) && !ke(a)
                                }
                            ]),
                        editor: ke(v)
                    }, null, 8, ["editor", "class"])], 2))
    }
});
const aut = te(sut, [["__scopeId", "data-v-f66e6cbc"]]), pW = (e = !1) => {
    const t = "(http://www\\.|https://www\\.|http://|https://)",
    n = "[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(/.*)?";
    return new RegExp(`^${t}${e ? "" : "?"}${n}$`)
}, lut = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, cut = P("path", {
    d: "M14.539 18.62c-1.442-1.442-1.252-3.971.424-5.647l6.107-6.107c1.677-1.677 4.205-1.866 5.647-.424l1.699 1.699c1.442 1.442 1.252 3.971-.424 5.647l-6.107 6.107c-1.217 1.217-2.884 1.651-4.258 1.245m-.166-7.345c1.442 1.442 1.252 3.971-.424 5.647l-6.107 6.107c-1.677 1.677-4.205 1.866-5.647.424l-1.699-1.699c-1.442-1.442-1.252-3.971.424-5.647l6.107-6.107c1.217-1.217 2.884-1.651 4.258-1.245"
}, null, -1), uut = [cut];
function dut(e, t) {
    return _(),
    O("svg", lut, uut)
}
const fut = {
    render: dut
}, hut = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, put = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), mut = P("path", {
    d: "m6.748 6.867 18.385 18.386"
}, null, -1), gut = [put, mut];
function vut(e, t) {
    return _(),
    O("svg", hut, gut)
}
const yut = {
    render: vut
}, wut = ["stroke", "fill"], but = Fe({
    __name: "ColorIcon",
    props: {
        color: {},
        filled: {
            type: Boolean,
        default:
            !1
        }
    },
    setup(e) {
        const t = e,
        n = ne(() => t.color === af.None);
        return (r, o) => n.value ? (_(), H(ke(yut), Bt({
                    key: 0,
                    class: "none"
                }, r.$attrs), null, 16)) : (_(), O("svg", Bt({
                    key: 1,
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 32 32",
                    fill: "none",
                    stroke: "#000"
                }, r.$attrs), [P("circle", {
                        cx: "16",
                        cy: "16",
                        r: "13",
                        stroke: r.color,
                        fill: r.filled ? r.color : "white",
                        "stroke-width": "4"
                    }, null, 8, wut)], 16))
    }
});
const mW = te(but, [["__scopeId", "data-v-db818ab2"]]), _ut = Fe({
    __name: "RichTextAnnotationToolbarDialog",
    props: {
        isOpen: {
            type: Boolean
        }
    },
    setup(e) {
        const t = e, {
            isOpen: n
        } = nl(t),
        r = De(null),
        o = De(null),
        i = De(null),
        s = () => {
            i.value = Pat(r.value, o.value, {
                placement: "bottom",
                strategy: "absolute",
                modifiers: [{
                        name: "preventOverflow"
                    }, {
                        name: "offset",
                        options: {
                            offset: [0, 20]
                        }
                    }
                ]
            })
        },
        a = () => {
            i.value && i.value.destroy()
        };
        return Ht(n, async() => {
            const l = n.value ? s : a;
            await Ci(),
            l()
        }),
        (l, c) => (_(), O(Le, null, [P("div", {
                        ref_key: "toolbarElement",
                        ref: r
                    }, [Ye(l.$slots, "toggle", {}, void 0, !0)], 512), ke(n) ? (_(), O("div", {
                            key: 0,
                            ref_key: "toolbarDialogElement",
                            ref: o,
                            class: "dialog"
                        }, [Ye(l.$slots, "content", {}, void 0, !0)], 512)) : J("", !0)], 64))
    }
});
const kut = te(_ut, [["__scopeId", "data-v-38134178"]]), xut = {
    class: "color-selection-container"
}, Sut = Fe({
    __name: "ColorSelectionDialog",
    props: {
        activeColor: {}
    },
    emits: ["hoverColor", "selectColor"],
    setup(e, {
        emit: t
    }) {
        const n = e;
        to(a => ({
                "723d627f": ke(r)
            }));
        const r = Object.keys(af).length,
        o = a => a === af.None,
        i = a => {
            t("selectColor", a)
        },
        s = a => n.activeColor ? n.activeColor === a : !1;
        return (a, l) => (_(), O("div", xut, [(_(!0), O(Le, null, $t(ke(af), (c, u, f) => (_(), H(ti, {
                                        key: f,
                                        class: he(["color-button", {
                                                    none: o(c)
                                                }
                                            ]),
                                        active: s(c),
                                        title: o(c) ? "None" : u,
                                        onMouseenter: ve(p => t("hoverColor", c), ["stop"]),
                                        onMouseleave: l[0] || (l[0] = ve(p => t("hoverColor", null), ["stop"])),
                                        onClick: ve(p => i(c), ["stop"])
                                    }, {
                                    default:
                                        oe(() => [z(mW, {
                                                    color: c,
                                                    filled: ""
                                                }, null, 8, ["color"])]),
                                        _: 2
                                    }, 1032, ["class", "active", "title", "onMouseenter", "onClick"]))), 128))]))
    }
});
const Cut = te(Sut, [["__scopeId", "data-v-01f8dbe3"]]), HT = e => (ir("data-v-fde280e3"), e = e(), sr(), e), Iut = {
    key: 0,
    class: "item-error"
}, Tut = HT(() => P("span", null, "Invalid URL", -1)), Mut = [Tut], Put = HT(() => P("strong", null, "Cancel", -1)), Eut = {
    class: "controls-apply-group"
}, Out = HT(() => P("strong", null, "Remove URL", -1)), $ut = Fe({
    __name: "CreateLinkModal",
    props: {
        text: {},
        url: {},
        isActive: {
            type: Boolean
        },
        isEdit: {
            type: Boolean
        }
    },
    emits: ["addLink", "removeLink", "cancelAddLink"],
    setup(e, {
        emit: t
    }) {
        const n = e,
        r = pW(),
        o = De(null),
        i = De(n.text),
        s = De(n.url);
        Ht(n, () => {
            i.value = n.text,
            s.value = n.url,
            setTimeout(() => {
                o.value?.focus()
            }, 200)
        }, {
            deep: !0
        });
        const a = () => {
            t("cancelAddLink")
        },
        l = () => {
            t("addLink", i.value, s.value)
        },
        c = () => {
            const p = r.test(s.value);
            return !s.value || p
        },
        u = ne(() => {
            const p = i.value !== n.text,
            m = s.value !== n.url,
            v = s.value !== "";
            return (p || m) && c() && v
        }),
        f = p => {
            p.key === "Enter" && u.value && l()
        };
        return (p, m) => Cn((_(), H(Q6, {
                    active: p.isActive,
                    title: p.isEdit ? "Edit link" : "Add a link",
                    "style-type": "info",
                    class: "modal",
                    onCancel: a
                }, {
                    confirmation: oe(() => [z(Xn, {
                                text: "Text",
                                compact: "",
                                class: "text-input"
                            }, {
                            default:
                                oe(() => [P("div", null, [z(wf, {
                                                    ref_key: "inputRef",
                                                    ref: o,
                                                    modelValue: i.value,
                                                    "onUpdate:modelValue": m[0] || (m[0] = v => i.value = v),
                                                    type: "text",
                                                    title: "Text",
                                                    onKeyup: f
                                                }, null, 8, ["modelValue"])])]),
                                _: 1
                            }), z(Xn, {
                                text: "URL",
                                compact: ""
                            }, {
                            default:
                                oe(() => [P("div", null, [z(wf, {
                                                    modelValue: s.value,
                                                    "onUpdate:modelValue": m[1] || (m[1] = v => s.value = v),
                                                    type: "text",
                                                    title: "URL",
                                                    onKeyup: f
                                                }, null, 8, ["modelValue"]), c() ? J("", !0) : (_(), O("div", Iut, Mut))])]),
                                _: 1
                            })]),
                    controls: oe(() => [z(Pr, {
                                "with-border": "",
                                onClick: a
                            }, {
                            default:
                                oe(() => [Put]),
                                _: 1
                            }), P("div", Eut, [p.isEdit ? (_(), H(Pr, {
                                            key: 0,
                                            "with-border": "",
                                            onClick: m[2] || (m[2] = v => t("removeLink"))
                                        }, {
                                        default:
                                            oe(() => [Out]),
                                            _: 1
                                        })) : J("", !0), z(Pr, {
                                        primary: "",
                                        disabled: !u.value,
                                        onClick: l
                                    }, {
                                    default:
                                        oe(() => [P("strong", null, Re(p.isEdit ? "Apply" : "Add link"), 1)]),
                                        _: 1
                                    }, 8, ["disabled"])])]),
                    _: 1
                }, 8, ["active", "title"])), [[Kn, p.isActive]])
    }
});
const Aut = te($ut, [["__scopeId", "data-v-fde280e3"]]), Dut = "aaa1rp3barth4b0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re2s2c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y0eats7k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking0channel11l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t0isalat7u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0at2delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d0network8tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0eles2s3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster5ia3d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0cys3drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7serati6ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic3tual5v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rthwesternmutual14on4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cher3ks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w0time7i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0channel7ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u0elos6wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Nut = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Jf = (e, t) => {
    for (const n in t)
        e[n] = t[n];
    return e
}, wS = "numeric", bS = "ascii", _S = "alpha", x0 = "asciinumeric", Jv = "alphanumeric", kS = "domain", gW = "emoji", Rut = "scheme", Lut = "slashscheme", J5 = "whitespace";
function But(e, t) {
    return e in t || (t[e] = []),
    t[e]
}
function tu(e, t, n) {
    t[wS] && (t[x0] = !0, t[Jv] = !0),
    t[bS] && (t[x0] = !0, t[_S] = !0),
    t[x0] && (t[Jv] = !0),
    t[_S] && (t[Jv] = !0),
    t[Jv] && (t[kS] = !0),
    t[gW] && (t[kS] = !0);
    for (const r in t) {
        const o = But(r, n);
        o.indexOf(e) < 0 && o.push(e)
    }
}
function Vut(e, t) {
    const n = {};
    for (const r in t)
        t[r].indexOf(e) >= 0 && (n[r] = !0);
    return n
}
function jo(e) {
    e === void 0 && (e = null),
    this.j = {},
    this.jr = [],
    this.jd = null,
    this.t = e
}
jo.groups = {};
jo.prototype = {
    accepts() {
        return !!this.t
    },
    go(e) {
        const t = this,
        n = t.j[e];
        if (n)
            return n;
        for (let r = 0; r < t.jr.length; r++) {
            const o = t.jr[r][0],
            i = t.jr[r][1];
            if (i && o.test(e))
                return i
        }
        return t.jd
    },
    has(e, t) {
        return t === void 0 && (t = !1),
        t ? e in this.j : !!this.go(e)
    },
    ta(e, t, n, r) {
        for (let o = 0; o < e.length; o++)
            this.tt(e[o], t, n, r)
    },
    tr(e, t, n, r) {
        r = r || jo.groups;
        let o;
        return t && t.j ? o = t : (o = new jo(t), n && r && tu(t, n, r)),
        this.jr.push([e, o]),
        o
    },
    ts(e, t, n, r) {
        let o = this;
        const i = e.length;
        if (!i)
            return o;
        for (let s = 0; s < i - 1; s++)
            o = o.tt(e[s]);
        return o.tt(e[i - 1], t, n, r)
    },
    tt(e, t, n, r) {
        r = r || jo.groups;
        const o = this;
        if (t && t.j)
            return o.j[e] = t, t;
        const i = t;
        let s,
        a = o.go(e);
        if (a ? (s = new jo, Jf(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new jo, i) {
            if (r)
                if (s.t && typeof s.t == "string") {
                    const l = Jf(Vut(s.t, r), n);
                    tu(i, l, r)
                } else
                    n && tu(i, n, r);
            s.t = i
        }
        return o.j[e] = s,
        s
    }
};
const pt = (e, t, n, r, o) => e.ta(t, n, r, o), Fi = (e, t, n, r, o) => e.tr(t, n, r, o), Z5 = (e, t, n, r, o) => e.ts(t, n, r, o), Be = (e, t, n, r, o) => e.tt(t, n, r, o), La = "WORD", xS = "UWORD", qm = "LOCALHOST", SS = "TLD", CS = "UTLD", S0 = "SCHEME", Bd = "SLASH_SCHEME", UT = "NUM", vW = "WS", qT = "NL", qd = "OPENBRACE", Kp = "OPENBRACKET", Gp = "OPENANGLEBRACKET", Xp = "OPENPAREN", Kc = "CLOSEBRACE", Yd = "CLOSEBRACKET", Kd = "CLOSEANGLEBRACKET", Gc = "CLOSEPAREN", d1 = "AMPERSAND", f1 = "APOSTROPHE", h1 = "ASTERISK", Al = "AT", p1 = "BACKSLASH", m1 = "BACKTICK", g1 = "CARET", Nl = "COLON", YT = "COMMA", v1 = "DOLLAR", Ws = "DOT", y1 = "EQUALS", KT = "EXCLAMATION", zs = "HYPHEN", w1 = "PERCENT", b1 = "PIPE", _1 = "PLUS", k1 = "POUND", x1 = "QUERY", GT = "QUOTE", XT = "SEMI", Hs = "SLASH", Jp = "TILDE", S1 = "UNDERSCORE", yW = "EMOJI", C1 = "SYM";
var wW = Object.freeze({
    __proto__: null,
    WORD: La,
    UWORD: xS,
    LOCALHOST: qm,
    TLD: SS,
    UTLD: CS,
    SCHEME: S0,
    SLASH_SCHEME: Bd,
    NUM: UT,
    WS: vW,
    NL: qT,
    OPENBRACE: qd,
    OPENBRACKET: Kp,
    OPENANGLEBRACKET: Gp,
    OPENPAREN: Xp,
    CLOSEBRACE: Kc,
    CLOSEBRACKET: Yd,
    CLOSEANGLEBRACKET: Kd,
    CLOSEPAREN: Gc,
    AMPERSAND: d1,
    APOSTROPHE: f1,
    ASTERISK: h1,
    AT: Al,
    BACKSLASH: p1,
    BACKTICK: m1,
    CARET: g1,
    COLON: Nl,
    COMMA: YT,
    DOLLAR: v1,
    DOT: Ws,
    EQUALS: y1,
    EXCLAMATION: KT,
    HYPHEN: zs,
    PERCENT: w1,
    PIPE: b1,
    PLUS: _1,
    POUND: k1,
    QUERY: x1,
    QUOTE: GT,
    SEMI: XT,
    SLASH: Hs,
    TILDE: Jp,
    UNDERSCORE: S1,
    EMOJI: yW,
    SYM: C1
});
const Md = /[a-z]/, sk = /\p{L}/u, ak = /\p{Emoji}/u, lk = /\d/, Q5 = /\s/, eR = `
`, Fut = "️", jut = "‍";
let Zv = null, Qv = null;
function Wut(e) {
    e === void 0 && (e = []);
    const t = {};
    jo.groups = t;
    const n = new jo;
    Zv == null && (Zv = tR(Dut)),
    Qv == null && (Qv = tR(Nut)),
    Be(n, "'", f1),
    Be(n, "{", qd),
    Be(n, "[", Kp),
    Be(n, "<", Gp),
    Be(n, "(", Xp),
    Be(n, "}", Kc),
    Be(n, "]", Yd),
    Be(n, ">", Kd),
    Be(n, ")", Gc),
    Be(n, "&", d1),
    Be(n, "*", h1),
    Be(n, "@", Al),
    Be(n, "`", m1),
    Be(n, "^", g1),
    Be(n, ":", Nl),
    Be(n, ",", YT),
    Be(n, "$", v1),
    Be(n, ".", Ws),
    Be(n, "=", y1),
    Be(n, "!", KT),
    Be(n, "-", zs),
    Be(n, "%", w1),
    Be(n, "|", b1),
    Be(n, "+", _1),
    Be(n, "#", k1),
    Be(n, "?", x1),
    Be(n, '"', GT),
    Be(n, "/", Hs),
    Be(n, ";", XT),
    Be(n, "~", Jp),
    Be(n, "_", S1),
    Be(n, "\\", p1);
    const r = Fi(n, lk, UT, {
        [wS]: !0
    });
    Fi(r, lk, r);
    const o = Fi(n, Md, La, {
        [bS]: !0
    });
    Fi(o, Md, o);
    const i = Fi(n, sk, xS, {
        [_S]: !0
    });
    Fi(i, Md),
    Fi(i, sk, i);
    const s = Fi(n, Q5, vW, {
        [J5]: !0
    });
    Be(n, eR, qT, {
        [J5]: !0
    }),
    Be(s, eR),
    Fi(s, Q5, s);
    const a = Fi(n, ak, yW, {
        [gW]: !0
    });
    Fi(a, ak, a),
    Be(a, Fut, a);
    const l = Be(a, jut);
    Fi(l, ak, a);
    const c = [[Md, o]],
    u = [[Md, null], [sk, i]];
    for (let f = 0; f < Zv.length; f++)
        Il(n, Zv[f], SS, La, c);
    for (let f = 0; f < Qv.length; f++)
        Il(n, Qv[f], CS, xS, u);
    tu(SS, {
        tld: !0,
        ascii: !0
    }, t),
    tu(CS, {
        utld: !0,
        alpha: !0
    }, t),
    Il(n, "file", S0, La, c),
    Il(n, "mailto", S0, La, c),
    Il(n, "http", Bd, La, c),
    Il(n, "https", Bd, La, c),
    Il(n, "ftp", Bd, La, c),
    Il(n, "ftps", Bd, La, c),
    tu(S0, {
        scheme: !0,
        ascii: !0
    }, t),
    tu(Bd, {
        slashscheme: !0,
        ascii: !0
    }, t),
    e = e.sort((f, p) => f[0] > p[0] ? 1 : -1);
    for (let f = 0; f < e.length; f++) {
        const p = e[f][0],
        v = e[f][1] ? {
            [Rut]: !0
        }
         : {
            [Lut]: !0
        };
        p.indexOf("-") >= 0 ? v[kS] = !0 : Md.test(p) ? lk.test(p) ? v[x0] = !0 : v[bS] = !0 : v[wS] = !0,
        Z5(n, p, p, v)
    }
    return Z5(n, "localhost", qm, {
        ascii: !0
    }),
    n.jd = new jo(C1), {
        start: n,
        tokens: Jf({
            groups: t
        }, wW)
    }
}
function zut(e, t) {
    const n = Hut(t.replace(/[A-Z]/g, a => a.toLowerCase())),
    r = n.length,
    o = [];
    let i = 0,
    s = 0;
    for (; s < r; ) {
        let a = e,
        l = null,
        c = 0,
        u = null,
        f = -1,
        p = -1;
        for (; s < r && (l = a.go(n[s])); )
            a = l, a.accepts() ? (f = 0, p = 0, u = a) : f >= 0 && (f += n[s].length, p++), c += n[s].length, i += n[s].length, s++;
        i -= f,
        s -= p,
        c -= f,
        o.push({
            t: u.t,
            v: t.slice(i - c, i),
            s: i - c,
            e: i
        })
    }
    return o
}
function Hut(e) {
    const t = [],
    n = e.length;
    let r = 0;
    for (; r < n; ) {
        let o = e.charCodeAt(r),
        i,
        s = o < 55296 || o > 56319 || r + 1 === n || (i = e.charCodeAt(r + 1)) < 56320 || i > 57343 ? e[r] : e.slice(r, r + 2);
        t.push(s),
        r += s.length
    }
    return t
}
function Il(e, t, n, r, o) {
    let i;
    const s = t.length;
    for (let a = 0; a < s - 1; a++) {
        const l = t[a];
        e.j[l] ? i = e.j[l] : (i = new jo(r), i.jr = o.slice(), e.j[l] = i),
        e = i
    }
    return i = new jo(n),
    i.jr = o.slice(),
    e.j[t[s - 1]] = i,
    i
}
function tR(e) {
    const t = [],
    n = [];
    let r = 0,
    o = "0123456789";
    for (; r < e.length; ) {
        let i = 0;
        for (; o.indexOf(e[r + i]) >= 0; )
            i++;
        if (i > 0) {
            t.push(n.join(""));
            for (let s = parseInt(e.substring(r, r + i), 10); s > 0; s--)
                n.pop();
            r += i
        } else
            n.push(e[r]), r++
    }
    return t
}
const Ym = {
    defaultProtocol: "http",
    events: null,
    format: nR,
    formatHref: nR,
    nl2br: !1,
    tagName: "a",
    target: null,
    rel: null,
    validate: !0,
    truncate: 1 / 0,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null
};
function JT(e, t) {
    t === void 0 && (t = null);
    let n = Jf({}, Ym);
    e && (n = Jf(n, e instanceof JT ? e.o : e));
    const r = n.ignoreTags,
    o = [];
    for (let i = 0; i < r.length; i++)
        o.push(r[i].toUpperCase());
    this.o = n,
    t && (this.defaultRender = t),
    this.ignoreTags = o
}
JT.prototype = {
    o: Ym,
    ignoreTags: [],
    defaultRender(e) {
        return e
    },
    check(e) {
        return this.get("validate", e.toString(), e)
    },
    get(e, t, n) {
        const r = t != null;
        let o = this.o[e];
        return o && (typeof o == "object" ? (o = n.t in o ? o[n.t] : Ym[e], typeof o == "function" && r && (o = o(t, n))) : typeof o == "function" && r && (o = o(t, n.t, n)), o)
    },
    getObj(e, t, n) {
        let r = this.o[e];
        return typeof r == "function" && t != null && (r = r(t, n.t, n)),
        r
    },
    render(e) {
        const t = e.render(this);
        return (this.get("render", null, e) || this.defaultRender)(t, e.t, e)
    }
};
function nR(e) {
    return e
}
function bW(e, t) {
    this.t = "token",
    this.v = e,
    this.tk = t
}
bW.prototype = {
    isLink: !1,
    toString() {
        return this.v
    },
    toHref(e) {
        return this.toString()
    },
    toFormattedString(e) {
        const t = this.toString(),
        n = e.get("truncate", t, this),
        r = e.get("format", t, this);
        return n && r.length > n ? r.substring(0, n) + "…" : r
    },
    toFormattedHref(e) {
        return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this)
    },
    startIndex() {
        return this.tk[0].s
    },
    endIndex() {
        return this.tk[this.tk.length - 1].e
    },
    toObject(e) {
        return e === void 0 && (e = Ym.defaultProtocol), {
            type: this.t,
            value: this.toString(),
            isLink: this.isLink,
            href: this.toHref(e),
            start: this.startIndex(),
            end: this.endIndex()
        }
    },
    toFormattedObject(e) {
        return {
            type: this.t,
            value: this.toFormattedString(e),
            isLink: this.isLink,
            href: this.toFormattedHref(e),
            start: this.startIndex(),
            end: this.endIndex()
        }
    },
    validate(e) {
        return e.get("validate", this.toString(), this)
    },
    render(e) {
        const t = this,
        n = this.toHref(e.get("defaultProtocol")),
        r = e.get("formatHref", n, this),
        o = e.get("tagName", n, t),
        i = this.toFormattedString(e),
        s = {},
        a = e.get("className", n, t),
        l = e.get("target", n, t),
        c = e.get("rel", n, t),
        u = e.getObj("attributes", n, t),
        f = e.getObj("events", n, t);
        return s.href = r,
        a && (s.class = a),
        l && (s.target = l),
        c && (s.rel = c),
        u && Jf(s, u), {
            tagName: o,
            attributes: s,
            content: i,
            eventListeners: f
        }
    }
};
function db(e, t) {
    class n extends bW {
        constructor(o, i) {
            super(o, i),
            this.t = e
        }
    }
    for (const r in t)
        n.prototype[r] = t[r];
    return n.t = e,
    n
}
const rR = db("email", {
    isLink: !0,
    toHref() {
        return "mailto:" + this.toString()
    }
}), oR = db("text"), Uut = db("nl"), Rc = db("url", {
    isLink: !0,
    toHref(e) {
        return e === void 0 && (e = Ym.defaultProtocol),
        this.hasProtocol() ? this.v : `${e}://${this.v}`
    },
    hasProtocol() {
        const e = this.tk;
        return e.length >= 2 && e[0].t !== qm && e[1].t === Nl
    }
}), Vr = e => new jo(e);
function qut(e) {
    let {
        groups: t
    } = e;
    const n = t.domain.concat([d1, h1, Al, p1, m1, g1, v1, y1, zs, UT, w1, b1, _1, k1, Hs, C1, Jp, S1]),
    r = [f1, Kd, Kc, Yd, Gc, Nl, YT, Ws, KT, Gp, qd, Kp, Xp, x1, GT, XT],
    o = [d1, f1, h1, p1, m1, g1, Kc, v1, y1, zs, qd, w1, b1, _1, k1, x1, Hs, C1, Jp, S1],
    i = Vr(),
    s = Be(i, Jp);
    pt(s, o, s),
    pt(s, t.domain, s);
    const a = Vr(),
    l = Vr(),
    c = Vr();
    pt(i, t.domain, a),
    pt(i, t.scheme, l),
    pt(i, t.slashscheme, c),
    pt(a, o, s),
    pt(a, t.domain, a);
    const u = Be(a, Al);
    Be(s, Al, u),
    Be(l, Al, u),
    Be(c, Al, u);
    const f = Be(s, Ws);
    pt(f, o, s),
    pt(f, t.domain, s);
    const p = Vr();
    pt(u, t.domain, p),
    pt(p, t.domain, p);
    const m = Be(p, Ws);
    pt(m, t.domain, p);
    const v = Vr(rR);
    pt(m, t.tld, v),
    pt(m, t.utld, v),
    Be(u, qm, v);
    const y = Be(p, zs);
    pt(y, t.domain, p),
    pt(v, t.domain, p),
    Be(v, Ws, m),
    Be(v, zs, y);
    const b = Be(v, Nl);
    pt(b, t.numeric, rR);
    const w = Be(a, zs),
    k = Be(a, Ws);
    pt(w, t.domain, a),
    pt(k, o, s),
    pt(k, t.domain, a);
    const C = Vr(Rc);
    pt(k, t.tld, C),
    pt(k, t.utld, C),
    pt(C, t.domain, a),
    pt(C, o, s),
    Be(C, Ws, k),
    Be(C, zs, w),
    Be(C, Al, u);
    const x = Be(C, Nl),
    S = Vr(Rc);
    pt(x, t.numeric, S);
    const T = Vr(Rc),
    E = Vr();
    pt(T, n, T),
    pt(T, r, E),
    pt(E, n, T),
    pt(E, r, E),
    Be(C, Hs, T),
    Be(S, Hs, T);
    const M = Be(l, Nl),
    N = Be(c, Nl),
    F = Be(N, Hs),
    K = Be(F, Hs);
    pt(l, t.domain, a),
    Be(l, Ws, k),
    Be(l, zs, w),
    pt(c, t.domain, a),
    Be(c, Ws, k),
    Be(c, zs, w),
    pt(M, t.domain, T),
    Be(M, Hs, T),
    pt(K, t.domain, T),
    pt(K, n, T),
    Be(K, Hs, T);
    const j = Be(T, qd),
    G = Be(T, Kp),
    Y = Be(T, Gp),
    ue = Be(T, Xp);
    Be(E, qd, j),
    Be(E, Kp, G),
    Be(E, Gp, Y),
    Be(E, Xp, ue),
    Be(j, Kc, T),
    Be(G, Yd, T),
    Be(Y, Kd, T),
    Be(ue, Gc, T),
    Be(j, Kc, T);
    const re = Vr(Rc),
    de = Vr(Rc),
    Se = Vr(Rc),
    Pe = Vr(Rc);
    pt(j, n, re),
    pt(G, n, de),
    pt(Y, n, Se),
    pt(ue, n, Pe);
    const je = Vr(),
    Ke = Vr(),
    Ue = Vr(),
    yt = Vr();
    return pt(j, r),
    pt(G, r),
    pt(Y, r),
    pt(ue, r),
    pt(re, n, re),
    pt(de, n, de),
    pt(Se, n, Se),
    pt(Pe, n, Pe),
    pt(re, r, re),
    pt(de, r, de),
    pt(Se, r, Se),
    pt(Pe, r, Pe),
    pt(je, n, je),
    pt(Ke, n, de),
    pt(Ue, n, Se),
    pt(yt, n, Pe),
    pt(je, r, je),
    pt(Ke, r, Ke),
    pt(Ue, r, Ue),
    pt(yt, r, yt),
    Be(de, Yd, T),
    Be(Se, Kd, T),
    Be(Pe, Gc, T),
    Be(re, Kc, T),
    Be(Ke, Yd, T),
    Be(Ue, Kd, T),
    Be(yt, Gc, T),
    Be(je, Gc, T),
    Be(i, qm, C),
    Be(i, qT, Uut), {
        start: i,
        tokens: wW
    }
}
function Yut(e, t, n) {
    let r = n.length,
    o = 0,
    i = [],
    s = [];
    for (; o < r; ) {
        let a = e,
        l = null,
        c = null,
        u = 0,
        f = null,
        p = -1;
        for (; o < r && !(l = a.go(n[o].t)); )
            s.push(n[o++]);
        for (; o < r && (c = l || a.go(n[o].t)); )
            l = null, a = c, a.accepts() ? (p = 0, f = a) : p >= 0 && p++, o++, u++;
        if (p < 0)
            o -= u, o < r && (s.push(n[o]), o++);
        else {
            s.length > 0 && (i.push(ck(oR, t, s)), s = []),
            o -= p,
            u -= p;
            const m = f.t,
            v = n.slice(o - u, o);
            i.push(ck(m, t, v))
        }
    }
    return s.length > 0 && i.push(ck(oR, t, s)),
    i
}
function ck(e, t, n) {
    const r = n[0].s,
    o = n[n.length - 1].e,
    i = t.slice(r, o);
    return new e(i, n)
}
const Kut = typeof console < "u" && console && console.warn || (() => {}), Gut = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", tr = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1
};
function Xut() {
    jo.groups = {},
    tr.scanner = null,
    tr.parser = null,
    tr.tokenQueue = [],
    tr.pluginQueue = [],
    tr.customSchemes = [],
    tr.initialized = !1
}
function iR(e, t) {
    if (t === void 0 && (t = !1), tr.initialized && Kut(`linkifyjs: already initialized - will not register custom scheme "${e}" ${Gut}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
        throw new Error(`linkifyjs: incorrect scheme format.
 1. Must only contain digits, lowercase ASCII letters or "-"
 2. Cannot start or end with "-"
 3. "-" cannot repeat`);
    tr.customSchemes.push([e, t])
}
function Jut() {
    tr.scanner = Wut(tr.customSchemes);
    for (let e = 0; e < tr.tokenQueue.length; e++)
        tr.tokenQueue[e][1]({
            scanner: tr.scanner
        });
    tr.parser = qut(tr.scanner.tokens);
    for (let e = 0; e < tr.pluginQueue.length; e++)
        tr.pluginQueue[e][1]({
            scanner: tr.scanner,
            parser: tr.parser
        });
    tr.initialized = !0
}
function _W(e) {
    return tr.initialized || Jut(),
    Yut(tr.parser.start, e, zut(tr.scanner.start, e))
}
function ZT(e, t, n) {
    if (t === void 0 && (t = null), n === void 0 && (n = null), t && typeof t == "object") {
        if (n)
            throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
        n = t,
        t = null
    }
    const r = new JT(n),
    o = _W(e),
    i = [];
    for (let s = 0; s < o.length; s++) {
        const a = o[s];
        a.isLink && (!t || a.t === t) && i.push(a.toFormattedObject(r))
    }
    return i
}
function sR(e, t) {
    t === void 0 && (t = null);
    const n = _W(e);
    return n.length === 1 && n[0].isLink && (!t || n[0].t === t)
}
function Zut(e) {
    return new go({
        key: new ps("autolink"),
        appendTransaction: (t, n, r) => {
            const o = t.some(u => u.docChanged) && !n.doc.eq(r.doc),
            i = t.some(u => u.getMeta("preventAutolink"));
            if (!o || i)
                return;
            const {
                tr: s
            } = r,
            a = Rit(n.doc, [...t]), {
                mapping: l
            } = a;
            if (Uit(a).forEach(({
                        oldRange: u,
                        newRange: f
                    }) => {
                    l1(u.from, u.to, n.doc).filter(y => y.mark.type === e.type).forEach(y => {
                        const b = l.map(y.from),
                        w = l.map(y.to),
                        k = l1(b, w, r.doc).filter(M => M.mark.type === e.type);
                        if (!k.length)
                            return;
                        const C = k[0],
                        x = n.doc.textBetween(y.from, y.to, void 0, " "),
                        S = r.doc.textBetween(C.from, C.to, void 0, " "),
                        T = sR(x),
                        E = sR(S);
                        T && !E && s.removeMark(C.from, C.to, e.type)
                    });
                    const p = Bit(r.doc, f, y => y.isTextblock);
                    let m,
                    v;
                    if (p.length > 1 ? (m = p[0], v = r.doc.textBetween(m.pos, m.pos + m.node.nodeSize, void 0, " ")) : p.length && r.doc.textBetween(f.from, f.to, " ", " ").endsWith(" ") && (m = p[0], v = r.doc.textBetween(m.pos, f.to, void 0, " ")), m && v) {
                        const y = v.split(" ").filter(k => k !== "");
                        if (y.length <= 0)
                            return !1;
                        const b = y[y.length - 1],
                        w = m.pos + v.lastIndexOf(b);
                        if (!b)
                            return !1;
                        ZT(b).filter(k => k.isLink).filter(k => e.validate ? e.validate(k.value) : !0).map(k => ({
                                ...k,
                                from: w + k.start + 1,
                                to: w + k.end + 1
                            })).forEach(k => {
                            s.addMark(k.from, k.to, e.type.create({
                                    href: k.href
                                }))
                        })
                    }
                }), !!s.steps.length)
                return s
        }
    })
}
function Qut(e) {
    return new go({
        key: new ps("handleClickLink"),
        props: {
            handleClick: (t, n, r) => {
                var o,
                i,
                s;
                if (r.button !== 0)
                    return !1;
                const a = NT(t.state, e.type.name),
                l = (o = r.target) === null || o === void 0 ? void 0 : o.closest("a"),
                c = (i = l?.href) !== null && i !== void 0 ? i : a.href,
                u = (s = l?.target) !== null && s !== void 0 ? s : a.target;
                return l && c ? (window.open(c, u), !0) : !1
            }
        }
    })
}
function edt(e) {
    return new go({
        key: new ps("handlePasteLink"),
        props: {
            handlePaste: (t, n, r) => {
                const {
                    state: o
                } = t, {
                    selection: i
                } = o, {
                    empty: s
                } = i;
                if (s)
                    return !1;
                let a = "";
                r.content.forEach(c => {
                    a += c.textContent
                });
                const l = ZT(a).find(c => c.isLink && c.value === a);
                return !a || !l ? !1 : (e.editor.commands.setMark(e.type, {
                        href: l.href
                    }), !0)
            }
        }
    })
}
const tdt = ls.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: !1,
    onCreate() {
        this.options.protocols.forEach(e => {
            if (typeof e == "string") {
                iR(e);
                return
            }
            iR(e.scheme, e.optionalSlashes)
        })
    },
    onDestroy() {
        Xut()
    },
    inclusive() {
        return this.options.autolink
    },
    addOptions() {
        return {
            openOnClick: !0,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            HTMLAttributes: {
                target: "_blank",
                rel: "noopener noreferrer nofollow",
                class: null
            },
            validate: void 0
        }
    },
    addAttributes() {
        return {
            href: {
            default:
                null
            },
            target: {
            default:
                this.options.HTMLAttributes.target
            },
            class: {
            default:
                this.options.HTMLAttributes.class
            }
        }
    },
    parseHTML() {
        return [{
                tag: 'a[href]:not([href *= "javascript:" i])'
            }
        ]
    },
    renderHTML({
        HTMLAttributes: e
    }) {
        return ["a", xr(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setLink: e => ({
                chain: t
            }) => t().setMark(this.name, e).setMeta("preventAutolink", !0).run(),
            toggleLink: e => ({
                chain: t
            }) => t().toggleMark(this.name, e, {
                extendEmptyMarkRange: !0
            }).setMeta("preventAutolink", !0).run(),
            unsetLink: () => ({
                chain: e
            }) => e().unsetMark(this.name, {
                extendEmptyMarkRange: !0
            }).setMeta("preventAutolink", !0).run()
        }
    },
    addPasteRules() {
        return [Fu({
                find: e => ZT(e).filter(t => this.options.validate ? this.options.validate(t.value) : !0).filter(t => t.isLink).map(t => ({
                        text: t.value,
                        index: t.start,
                        data: t
                    })),
                type: this.type,
                getAttributes: e => {
                    var t;
                    return {
                        href: (t = e.data) === null || t === void 0 ? void 0 : t.href
                    }
                }
            })]
    },
    addProseMirrorPlugins() {
        const e = [];
        return this.options.autolink && e.push(Zut({
                type: this.type,
                validate: this.options.validate
            })),
        this.options.openOnClick && e.push(Qut({
                type: this.type
            })),
        this.options.linkOnPaste && e.push(edt({
                editor: this.editor,
                type: this.type
            })),
        e
    }
}), ndt = (e, {
    isEditing: t,
    url: n,
    urlText: r,
    text: o
}) => {
    if (t)
        e.chain().focus().setLink({
            href: n
        }).command(({
                tr: i
            }) => (i.insertText(o || r), !0)).run();
    else {
        const {
            view: i
        } = e, {
            from: s
        } = i.state.selection;
        e.chain().focus().insertContent([{
                    type: "text",
                    text: " "
                }
            ]).run(),
        e.chain().focus().insertContentAt(s, [{
                    type: "text",
                    text: o || r
                }
            ]).run();
        const {
            from: a
        } = i.state.selection;
        e.commands.setTextSelection({
            from: s,
            to: a
        }),
        e.chain().focus().setLink({
            href: n
        }).run()
    }
}, rdt = tdt.extend({
    addOptions() {
        return {
            ...this.parent?.(),
            openOnClick: !1
        }
    },
    addAttributes() {
        const e = Nu() ? "⌘" : "Ctrl +";
        return {
            ...this.parent?.(),
            draggable: {
            default:
                "false"
            },
            title: {
            default:
`Use "${e} click" to follow link`
            }
        }
    },
    addProseMirrorPlugins() {
        const e = this.parent?.() || [],
        t = new go({
            key: new ps("handleControlClick"),
            props: {
                handleClick(n, r, o) {
                    const i = NT(n.state, "link"),
                    s = o.target?.closest("a");
                    return o[ga()] && s && i.href ? (window.open(i.href, i.target), !0) : !1
                }
            }
        });
        return e.push(t),
        e
    }
}), odt = {
    class: "editor-toolbar"
}, idt = {
    class: "heading-current-text"
}, aR = 8, uk = 4, lR = 32, cR = 115, sdt = Fe({
    __name: "RichTextAnnotationToolbar",
    props: {
        editor: {},
        tools: {},
        annotationBounds: {},
        activeBorderColor: {}
    },
    emits: ["previewBorderColor", "changeBorderColor"],
    setup(e, {
        emit: t
    }) {
        const n = e;
        to(j => ({
                "301007fb": uk,
                "17b8ca94": aR,
                "2bf4c4fe": S,
                "5c12e908": lR,
                e5394774: cR
            }));
        const r = wa();
        let o = De(!1);
        const i = De(""),
        s = De(""),
        a = De(!1),
        l = () => {
            const {
                view: j,
                state: G
            } = n.editor, {
                from: Y,
                to: ue
            } = j.state.selection,
            re = n.editor.getAttributes("link").href;
            if (s.value = re || "", re) {
                if (Y !== ue) {
                    const je = Y + Math.floor((ue - Y) / 2);
                    n.editor.chain().focus().setTextSelection(je).run()
                }
                const Se = j.state.selection.$from.nodeBefore?.textContent ?? "",
                Pe = j.state.selection.$to.nodeAfter?.textContent ?? "";
                i.value = Se + Pe
            } else
                i.value = G.doc.textBetween(Y, ue, "");
            a.value = re || i.value,
            o.value = !0
        },
        c = () => {
            n.editor.chain().focus().extendMarkRange("link").unsetLink().run(),
            o.value = !1,
            a.value = !1
        },
        u = (j, G) => {
            if (n.editor.chain().focus().extendMarkRange("link").unsetLink().run(), G) {
                const ue = ["http://", "https://"].some(re => G.includes(re)) ? G : `https://${G}`;
                ndt(n.editor, {
                    isEditing: a.value,
                    urlText: G,
                    url: ue,
                    text: j
                })
            }
            o.value = !1,
            a.value = !1
        },
        f = () => {
            o.value = !1,
            a.value = !1
        },
        p = {
            id: "link",
            icon: fut,
            name: "Link",
            hotkey: ["Ctrl", "K"],
            active: () => n.editor.isActive("link"),
            onClick: () => l()
        },
        m = ne(() => n.tools.filter(({
                        secondary: j
                    }) => !j).concat(p)),
        v = ne(() => n.tools.filter(({
                        secondary: j
                    }) => j)),
        y = ne(() => v.value.map(j => ({
                        text: j.name,
                        disabled: j.disabled?.(),
                        hotkeyText: pp(j.hotkey ?? []),
                        icon: j.icon,
                        id: j.id
                    }))),
        b = (j, {
            id: G
        }) => {
            v.value.find(ue => ue.id === G)?.onClick()
        },
        w = ne(() => m.value.length + 2),
        k = ne(() => {
            const j = [1, 2, 3, 4, 5, 6],
            G = () => j.find(re => n.editor.isActive("heading", {
                    level: re
                })),
            Y = [{
                    text: "Normal text",
                    selected: !n.editor.isActive("heading"),
                    hotkeyText: pp(["Ctrl", "Alt", "0"]),
                    onClick: () => n.editor.chain().focus().toggleHeading({
                        level: G()
                    }).run()
                }
            ],
            ue = j.map(re => ({
                        text: `Heading ${re}`,
                        selected: n.editor.isActive("heading", {
                            level: re
                        }),
                        hotkeyText: pp(["Ctrl", "Alt", String(re)]),
                        onClick: () => n.editor.chain().focus().setHeading({
                            level: re
                        }).run()
                    }));
            return Y.concat(ue)
        }),
        C = ne(() => k.value.find(j => j.selected)?.text),
        x = ne(() => r.state.canvas.zoomFactor),
        S = aR * 2 + w.value * lR + (cR + uk) + uk * (w.value - 1),
        T = ne(() => {
            const j = n.annotationBounds.width / 2 - Math.ceil(S / 2 / x.value),
            G = n.annotationBounds.x + j,
            Y = n.annotationBounds.y - l8 / x.value;
            return {
                x: G,
                y: Y
            }
        }),
        E = De(!1),
        M = De(null),
        N = j => {
            M.value = j,
            t("previewBorderColor", j)
        },
        F = j => {
            E.value = !1,
            M.value = null,
            t("changeBorderColor", j)
        },
        K = j => {
            j[ga()] && j.key === "k" && l()
        };
        return Ur(() => {
            window.addEventListener("keydown", K)
        }),
        cc(() => {
            window.removeEventListener("keydown", K)
        }),
        (j, G) => (_(), O(Le, null, [z(qw, Bt({
                            "canvas-position": T.value,
                            "aria-label": "Annotation toolbar",
                            "prevent-overflow": !0
                        }, j.$attrs), {
                    default:
                        oe(() => [P("div", odt, [z(Vf, {
                                            items: k.value,
                                            orientation: "right",
                                            "teleport-to-body": !1,
                                            "positioning-strategy": "absolute",
                                            class: "heading-menu",
                                            onItemClick: G[0] || (G[0] = (Y, ue) => ue.onClick())
                                        }, {
                                        default:
                                            oe(() => [P("span", idt, Re(C.value), 1), z(ke(al))]),
                                            _: 1
                                        }, 8, ["items"]), (_(!0), O(Le, null, $t(m.value, Y => (_(), H(ti, {
                                                            key: Y.icon,
                                                            active: Y.active ? Y.active() : !1,
                                                            title: `${Y.name} – ${ke(pp)(Y.hotkey ?? [])}`,
                                                            disabled: Y.disabled?.(),
                                                            class: "toolbar-button",
                                                            onClick: ve(Y.onClick, ["stop"])
                                                        }, {
                                                        default:
                                                            oe(() => [(_(), H(Kt(Y.icon)))]),
                                                            _: 2
                                                        }, 1032, ["active", "title", "disabled", "onClick"]))), 128)), v.value.length > 0 ? (_(), H(Vf, {
                                                key: 0,
                                                items: y.value,
                                                orientation: "left",
                                                onItemClick: b
                                            }, {
                                            default:
                                                oe(() => [z(ke(hW))]),
                                                _: 1
                                            }, 8, ["items"])) : J("", !0), z(kut, {
                                            "is-open": E.value
                                        }, {
                                            toggle: oe(() => [z(ti, {
                                                        class: "border-color-tool",
                                                        onClick: G[1] || (G[1] = ve(Y => E.value = !E.value, ["stop"]))
                                                    }, {
                                                    default:
                                                        oe(() => [z(mW, {
                                                                    color: M.value || j.activeBorderColor
                                                                }, null, 8, ["color"])]),
                                                        _: 1
                                                    })]),
                                            content: oe(() => [z(Cut, {
                                                        "active-color": j.activeBorderColor,
                                                        onHoverColor: N,
                                                        onSelectColor: F
                                                    }, null, 8, ["active-color"])]),
                                            _: 1
                                        }, 8, ["is-open"])])]),
                        _: 1
                    }, 16, ["canvas-position"]), z(Aut, {
                        "is-active": ke(o),
                        text: i.value,
                        url: s.value,
                        "is-edit": s.value !== "",
                        onAddLink: u,
                        onCancelAddLink: f,
                        onRemoveLink: c
                    }, null, 8, ["is-active", "text", "url", "is-edit"])], 64))
    }
});
const adt = te(sdt, [["__scopeId", "data-v-b3a02483"]]), ldt = Fe({
    __name: "RichTextAnnotation",
    props: {
        id: {},
        editable: {
            type: Boolean
        },
        initialValue: {},
        annotationBounds: {},
        initialBorderColor: {}
    },
    emits: ["editStart", "change", "changeBorderColor", "blur"],
    setup(e, {
        emit: t
    }) {
        const n = e;
        to(l => ({
                d0d5145a: s.value
            }));
        const r = pW(), {
            initialValue: o
        } = nl(n),
        i = De(null),
        s = ne(() => i.value || n.initialBorderColor),
        a = [rdt.configure({
                validate: l => r.test(l)
            })];
        return (l, c) => {
            const u = B("Portal");
            return _(),
            O("div", {
                class: "annotation-editor-wrapper",
                onPointerdown: c[5] || (c[5] = f => l.editable && f.stopPropagation())
            }, [z(aut, {
                        class: "annotation-editor",
                        "model-value": ke(o),
                        editable: l.editable,
                        "with-border": !1,
                        "custom-extensions": a,
                        autofocus: "",
                        "base-extensions": {
                            bold: !0,
                            italic: !0,
                            underline: !0,
                            textAlign: !0,
                            bulletList: !0,
                            orderedList: !0,
                            heading: !0,
                            horizontalRule: !0,
                            strike: !0
                        },
                        "onUpdate:modelValue": c[2] || (c[2] = f => t("change", f)),
                        onDblclick: c[3] || (c[3] = f => !l.editable && t("editStart")),
                        onBlur: c[4] || (c[4] = f => t("blur"))
                    }, {
                        customToolbar: oe(({
                                editor: f,
                                tools: p
                            }) => [l.editable && f ? (_(), H(u, {
                                        key: 0,
                                        to: "annotation-editor-toolbar"
                                    }, {
                                    default:
                                        oe(() => [z(adt, {
                                                    "active-border-color": l.initialBorderColor,
                                                    editor: f,
                                                    tools: p,
                                                    "annotation-bounds": l.annotationBounds,
                                                    onChangeBorderColor: c[0] || (c[0] = m => t("changeBorderColor", m)),
                                                    onPreviewBorderColor: c[1] || (c[1] = m => i.value = m)
                                                }, null, 8, ["active-border-color", "editor", "tools", "annotation-bounds"])]),
                                        _: 2
                                    }, 1024)) : J("", !0)]),
                        _: 1
                    }, 8, ["model-value", "editable"])], 32)
        }
    }
});
const cdt = te(ldt, [["__scopeId", "data-v-e2c13afe"]]), udt = Fe({
    components: {
        LegacyAnnotation: Ltt,
        RichTextAnnotation: cdt,
        TransformControls: Dtt
    },
    mixins: [XI],
    inheritAttrs: !1,
    props: {
        annotation: {
            type: Object,
            required: !0
        }
    },
    emits: ["toggleEdit"],
    expose: ["setSelectionPreview"],
    data() {
        return {
            selectionPreview: null,
            hasEdited: !1,
            newAnnotationData: {
                richTextContent: "",
                borderColor: ""
            }
        }
    },
    computed: {
        ...ut("workflow", {
            projectId: e => e.activeWorkflow.projectId,
            activeWorkflowId: e => e.activeWorkflow.info.containerId,
            editableAnnotationId: e => e.editableAnnotationId,
            isDragging: e => e.isDragging
        }),
        ...ut("selection", ["selectedAnnotations"]),
        ...zt("workflow", ["isWritable"]),
        ...zt("selection", ["isAnnotationSelected", "selectedNodeIds", "selectedConnections", "selectedAnnotationIds"]),
        isSelected() {
            return this.isAnnotationSelected(this.annotation.id)
        },
        isEditing() {
            return this.annotation.id === this.editableAnnotationId
        },
        showSelectionPlane() {
            return this.isDragging ? !1 : this.selectionPreview === null ? this.isSelected : this.isSelected && this.selectionPreview === "hide" ? !1 : this.selectionPreview === "show" || this.isSelected
        },
        showTransformControls() {
            if (this.isDragging || !this.isWritable)
                return !1;
            const e = this.selectedAnnotationIds.length > 1,
            t = this.selectedNodeIds.length >= 1,
            n = this.selectedConnections.length >= 1;
            let r = e || t || n;
            return this.isSelected && !r && this.showSelectionPlane
        },
        isRichTextAnnotation() {
            return this.annotation.text.contentType === z0.ContentTypeEnum.Html
        },
        initialRichTextAnnotationValue() {
            return this.isRichTextAnnotation ? this.annotation.text.value : Stt(this.annotation.text.value)
        },
        initialBorderColor() {
            return this.isRichTextAnnotation ? this.annotation.borderColor : this.$colors.defaultAnnotationBorderColor
        }
    },
    mounted() {
        this.initializeData()
    },
    methods: {
        ...Er("selection", ["selectAnnotation", "deselectAnnotation", "deselectAllObjects"]),
        ...Er("application", ["toggleContextMenu"]),
        initializeData() {
            this.newAnnotationData = {
                richTextContent: this.initialRichTextAnnotationValue,
                borderColor: this.initialBorderColor
            }
        },
        async onLeftClick(e) {
            const t = ga(),
            n = e.shiftKey || e[t];
            await this.$store.dispatch("selection/toggleAnnotationSelection", {
                annotationId: this.annotation.id,
                isMultiselect: n,
                isSelected: this.isSelected
            })
        },
        onContextMenu(e) {
            const t = ga();
            !(e.shiftKey || e[t]) && !this.isSelected && this.deselectAllObjects(),
            this.selectAnnotation(this.annotation.id),
            this.toggleContextMenu({
                event: e
            })
        },
        setSelectionPreview(e) {
            this.selectionPreview = e
        },
        transformAnnotation(e) {
            this.$store.dispatch("workflow/transformWorkflowAnnotation", {
                bounds: e,
                annotationId: this.annotation.id
            })
        },
        toggleEdit() {
            this.isWritable && this.$store.dispatch("workflow/setEditableAnnotationId", this.isEditing ? null : this.annotation.id)
        },
        async updateAnnotation() {
            await this.$store.dispatch("workflow/updateAnnotation", {
                annotationId: this.annotation.id,
                text: this.newAnnotationData.richTextContent,
                borderColor: this.newAnnotationData.borderColor
            })
        },
        async onClickAway() {
            window.getSelection().toString() === "" && this.isEditing && (this.hasEdited && await this.updateAnnotation(), this.toggleEdit())
        },
        onBlur() {
            this.hasEdited && this.updateAnnotation()
        },
        onAnnotationChange(e) {
            this.hasEdited = !0,
            this.newAnnotationData.richTextContent = e
        },
        setColor(e) {
            this.hasEdited = !0,
            this.newAnnotationData.borderColor = e
        }
    }
});
const ddt = ["x", "y", "width", "height"];
function fdt(e, t, n, r, o, i) {
    const s = B("LegacyAnnotation"),
    a = B("RichTextAnnotation"),
    l = B("TransformControls"),
    c = W1("click-away");
    return Cn((_(), H(l, {
                "show-transform-controls": e.showTransformControls,
                "show-selection": e.showSelectionPlane,
                "initial-value": e.annotation.bounds,
                onTransformEnd: t[0] || (t[0] = u => e.transformAnnotation(u.bounds)),
                onClick: e.onLeftClick,
                onPointerdown: ve(e.onContextMenu, ["right", "stop"])
            }, {
            default:
                oe(({
                        transformedBounds: u
                    }) => [(_(), O("foreignObject", {
                                x: u.x,
                                y: u.y,
                                width: u.width,
                                height: u.height
                            }, [!e.isRichTextAnnotation && !e.isEditing ? (_(), H(s, {
                                            key: 0,
                                            annotation: e.annotation,
                                            onEditStart: e.toggleEdit
                                        }, null, 8, ["annotation", "onEditStart"])) : J("", !0), e.isRichTextAnnotation || e.isEditing ? (_(), H(a, {
                                            key: 1,
                                            id: e.annotation.id,
                                            "initial-value": e.initialRichTextAnnotationValue,
                                            "initial-border-color": e.initialBorderColor,
                                            editable: e.isEditing,
                                            "annotation-bounds": u,
                                            onChange: e.onAnnotationChange,
                                            onChangeBorderColor: e.setColor,
                                            onEditStart: e.toggleEdit,
                                            onBlur: e.onBlur
                                        }, null, 8, ["id", "initial-value", "initial-border-color", "editable", "annotation-bounds", "onChange", "onChangeBorderColor", "onEditStart", "onBlur"])) : J("", !0)], 8, ddt))]),
                _: 1
            }, 8, ["show-transform-controls", "show-selection", "initial-value", "onClick", "onPointerdown"])), [[c, e.onClickAway]])
}
const hdt = te(udt, [["render", fdt], ["__scopeId", "data-v-4c18f40c"]]), pdt = ["transform"], mdt = Fe({
    __name: "MoveableAnnotationContainer",
    props: {
        id: {},
        bounds: {}
    },
    setup(e) {
        const t = e,
        n = po(),
        r = ne(() => n.state.workflow.movePreviewDelta),
        o = ne(() => n.state.workflow.isDragging),
        i = ne(() => n.state.canvas.isMoveLocked),
        s = ne(() => n.getters["selection/isAnnotationSelected"]),
        a = De(null),
        l = ne(() => s.value(t.id) ? r.value : {
            x: 0,
            y: 0
        });
        Ht(ca(t, "bounds"), () => {
            o.value && n.dispatch("workflow/resetDragState")
        }, {
            deep: !0
        });
        const c = ne(() => ({
                    x: t.bounds.x,
                    y: t.bounds.y
                })), {
            createPointerDownHandler: u
        } = Yw({
            objectElement: ne(() => a.value),
            onMoveStartCallback: () => {
                s.value(t.id) || n.dispatch("selection/deselectAllObjects"),
                n.dispatch("selection/selectAnnotation", t.id)
            }
        }),
        f = p => {
            if (i.value) {
                n.commit("selection/setStartedSelectionFromAnnotationId", t.id);
                return
            }
            u(c)(p)
        };
        return lg({
            group: "OBJECT_DRAG",
            alwaysActive: !0,
            onEscape: () => {
                o.value && n.dispatch("workflow/abortDrag")
            }
        }),
        (p, m) => (_(), O("g", {
                ref_key: "container",
                ref: a,
                transform: `translate(${l.value.x}, ${l.value.y})`,
                class: he([[{
                                dragging: o.value && s.value(p.id)
                            }
                        ], "annotation"]),
                onPointerdown: m[0] || (m[0] = ve(v => f(v), ["left"]))
            }, [Ye(p.$slots, "default", {}, void 0, !0)], 42, pdt))
    }
});
const gdt = te(mdt, [["__scopeId", "data-v-dea9bd32"]]), vdt = ["transform", "onConnectorEnter", "onConnectorLeave", "onConnectorMove", "onConnectorDrop"], ydt = ["width", "height", "x"], wdt = ["width", "height", "x", "fill"], bdt = ["width", "stroke", "height", "x"], _dt = Fe({
    __name: "MetaNodePortBar",
    props: {
        ports: {},
        type: {
        default:
            "in"
        },
        containerId: {}
    },
    setup(e) {
        const t = e, {
            portBarXPos: n,
            portBarYPos: r,
            portBarHeight: o,
            portBarWidth: i,
            getPortBarPortYPosition: s
        } = dT(),
        a = ne(() => t.type === "out"),
        l = po(),
        c = ne(() => l.getters["selection/isMetaNodePortBarSelected"](t.type)),
        u = ne(() => ({
                    x: n(a.value),
                    y: r(a.value)
                }));
        iu("anchorPoint", u);
        const f = ne(() => a.value ? "in" : "out"),
        p = ne(() => {
            const y = _i / 2,
            b = a.value ? -y : y,
            w = t.ports.map(k => [b, s(k.index, a.value, !1)]);
            return {
                in: f.value === "in" ? w : [],
                out: f.value === "out" ? w : []
            }
        }),
        m = ne(() => a.value ? 0 : -i(a.value)),
        v = () => {
            l.dispatch("selection/selectMetanodePortBar", t.type)
        };
        return (y, b) => (_(), H(kF, {
                id: y.containerId,
                "disable-valid-target-check": !0,
                position: u.value,
                "port-positions": p.value
            }, {
            default:
                oe(({
                        targetPort: w,
                        on: {
                            onConnectorEnter: k,
                            onConnectorLeave: C,
                            onConnectorMove: x,
                            onConnectorDrop: S
                        }
                    }) => [P("g", {
                            transform: `translate(${u.value.x}, ${u.value.y})`,
                            onConnectorEnter: ve(k, ["stop"]),
                            onConnectorLeave: ve(C, ["stop"]),
                            onConnectorMove: ve(T => x(T, {
                                    inPorts: f.value === "in" ? y.ports : [],
                                    outPorts: f.value === "out" ? y.ports : []
                                }), ["stop"]),
                            onConnectorDrop: ve(S, ["stop"])
                        }, [P("rect", {
                                    class: "hover-area",
                                    width: ke(i)(a.value) + y.$shapes.metaNodeBarHorizontalPadding * 2,
                                    height: ke(o)(a.value),
                                    x: m.value - y.$shapes.metaNodeBarHorizontalPadding,
                                    "data-hide-in-workflow-preview": "",
                                    onClick: v
                                }, null, 8, ydt), P("rect", {
                                    class: "port-bar",
                                    width: ke(i)(a.value),
                                    height: ke(o)(a.value),
                                    x: m.value,
                                    fill: y.$colors.Yellow
                                }, null, 8, wdt), c.value ? (_(), O("rect", {
                                        key: 0,
                                        class: "port-bar-selected",
                                        width: ke(i)(a.value) + y.$shapes.metaNodeBarHorizontalPadding * 2,
                                        stroke: y.$colors.Cornflower,
                                        "stroke-width": "2",
                                        rx: "2",
                                        fill: "transparent",
                                        height: ke(o)(a.value),
                                        x: m.value - y.$shapes.metaNodeBarHorizontalPadding
                                    }, null, 8, bdt)) : J("", !0), (_(!0), O(Le, null, $t(y.ports, T => (_(), H(_F, {
                                                    key: T.index,
                                                    "relative-position": p.value[f.value][T.index],
                                                    port: T,
                                                    direction: f.value,
                                                    "node-id": y.containerId,
                                                    targeted: w ? w.index === T.index : !1,
                                                    "disable-quick-node-add": !0
                                                }, null, 8, ["relative-position", "port", "direction", "node-id", "targeted"]))), 128))], 40, vdt)]),
                _: 1
            }, 8, ["id", "position", "port-positions"]))
    }
});
const uR = te(_dt, [["__scopeId", "data-v-0adbf4b9"]]), kdt = ["transform"], xdt = Fe({
    __name: "MoveableMetaNodePortBarContainer",
    props: {
        type: {}
    },
    setup(e) {
        const t = e, {
            getBounds: n
        } = dT(),
        r = ne(() => n(t.type === "out")),
        o = po(),
        i = ne(() => o.state.workflow.movePreviewDelta),
        s = ne(() => o.state.workflow.isDragging),
        a = ne(() => o.state.canvas.isMoveLocked),
        l = ne(() => o.state.workflow.activeWorkflow),
        c = ne(() => t.type === "out" ? l.value.metaOutPorts?.bounds : l.value.metaInPorts?.bounds),
        u = ne(() => o.getters["selection/isMetaNodePortBarSelected"]),
        f = De(null),
        p = ne(() => u.value(t.type) ? i.value : {
            x: 0,
            y: 0
        });
        Ht(r, (b, w) => {
            w.x === b.x && w.y === b.y || s.value && o.dispatch("workflow/resetDragState")
        }, {
            deep: !0
        });
        const m = ne(() => ({
                    x: r.value.x,
                    y: r.value.y
                })), {
            createPointerDownHandler: v
        } = Yw({
            objectElement: ne(() => f.value),
            onMoveStartCallback: b => {
                !u.value(t.type) && !b.ctrlKey && o.dispatch("selection/deselectAllObjects"),
                o.dispatch("selection/selectMetanodePortBar", t.type)
            },
            onMoveEndCallback: async() => {
                if (!c.value && !(i.value.x === 0 && i.value.y === 0)) {
                    const {
                        type: b
                    } = t;
                    await o.dispatch("workflow/transformMetaNodePortBar", {
                        bounds: {
                            ...r.value,
                            width: 50
                        },
                        type: b
                    })
                }
                return !0
            }
        }),
        y = b => {
            if (a.value)
                return;
            v(m)(b)
        };
        return lg({
            group: "OBJECT_DRAG",
            alwaysActive: !0,
            onEscape: () => {
                s.value && o.dispatch("workflow/abortDrag")
            }
        }),
        (b, w) => (_(), O("g", {
                ref_key: "container",
                ref: f,
                transform: `translate(${p.value.x}, ${p.value.y})`,
                class: he([[{
                                dragging: s.value && u.value(b.type)
                            }
                        ], "annotation"]),
                onPointerdown: w[0] || (w[0] = ve(k => y(k), ["left"]))
            }, [Ye(b.$slots, "default", {}, void 0, !0)], 42, kdt))
    }
});
const dR = te(xdt, [["__scopeId", "data-v-9a9e702d"]]), Sdt = Fe({
    __name: "MetaNodePortBars",
    setup(e) {
        const t = po(),
        n = ne(() => t.state.workflow.activeWorkflow),
        r = ne(() => n.value.metaInPorts?.ports?.length),
        o = ne(() => n.value.metaOutPorts?.ports?.length);
        return (i, s) => (_(), O("g", null, [r.value ? (_(), H(dR, {
                            key: 0,
                            type: "in"
                        }, {
                        default:
                            oe(() => [z(uR, {
                                        type: "in",
                                        ports: n.value.metaInPorts.ports,
                                        "container-id": n.value.info.containerId
                                    }, null, 8, ["ports", "container-id"])]),
                            _: 1
                        })) : J("", !0), o.value ? (_(), H(dR, {
                            key: 1,
                            type: "out"
                        }, {
                        default:
                            oe(() => [z(uR, {
                                        type: "out",
                                        ports: n.value.metaOutPorts.ports,
                                        "container-id": n.value.info.containerId
                                    }, null, 8, ["ports", "container-id"])]),
                            _: 1
                        })) : J("", !0)]))
    }
}), Cdt = ["transform"], Idt = {
    class: "text-wrapper"
}, Tdt = {
    class: "streaming-label"
}, fR = 1e3, hR = 60, Mdt = 16, Pdt = Fe({
    __name: "ConnectorLabel",
    props: {
        sourceNode: {},
        sourcePort: {},
        destNode: {},
        destPort: {},
        absolutePoint: {},
        interactive: {
            type: Boolean
        },
        id: {},
        flowVariableConnection: {
            type: Boolean
        },
        streaming: {
            type: Boolean
        },
        label: {
        default:
            ""
        },
        allowedActions: {},
        bendpoints: {
        default:
            () => []
        }
    },
    setup(e) {
        const t = e,
        n = po(),
        r = ne(() => n.state.workflow.isDragging),
        o = ne(() => n.state.workflow.movePreviewDelta),
        i = ne(() => n.getters["selection/isNodeSelected"]), {
            sourceNode: s,
            sourcePort: a,
            destNode: l,
            destPort: c,
            absolutePoint: u,
            bendpoints: f
        } = nl(t), {
            pathSegments: p,
            startSegmentPosition: m,
            endSegmentPosition: v
        } = yF({
            id: t.id,
            sourceNode: s,
            sourcePort: a,
            destNode: l,
            destPort: c,
            absolutePoint: u,
            bendpoints: f
        }),
        y = (k, C, x) => {
            const {
                x: S,
                y: T
            } = k, {
                x: E,
                y: M
            } = C;
            return {
                x: S + (E - S + x.x) / 2 - fR / 2,
                y: T + (M - T + x.y) / 2 - Mdt - hR / 2
            }
        },
        b = ne(() => r.value && (i.value(t.sourceNode) || i.value(t.destNode))),
        w = ne(() => {
            const k = m.value.x,
            C = m.value.y,
            x = v.value.x,
            S = v.value.y;
            if (f.value.length > 0) {
                const E = br.utils.getCenterPoint({
                    x: k,
                    y: C
                }, {
                    x,
                    y: S
                }), {
                    index: M
                } = p.value.reduce((F, K, j) => {
                    const G = br.utils.getCenterPoint(K.start, K.end),
                    Y = br.utils.distanceBetweenPoints(E.x, E.y, G.x, G.y),
                    ue = Math.min(Y);
                    return ue < F.x && (F.index = j, F.x = ue),
                    F
                }, {
                    x: 1 / 0,
                    index: -1
                }),
                N = p.value[M];
                return y(N.start, N.end, {
                    x: 0,
                    y: 0
                })
            }
            const T = b.value ? o.value : {
                x: 0,
                y: 0
            };
            return y({
                x: k,
                y: C
            }, {
                x,
                y: S
            }, T)
        });
        return (k, C) => k.label.length > 0 ? (_(), O("foreignObject", {
                key: 0,
                class: "foreign-object",
                width: fR,
                height: hR,
                transform: `translate(${w.value.x}, ${w.value.y})`
            }, [P("p", Idt, [P("span", Tdt, Re(k.label), 1)])], 8, Cdt)) : J("", !0)
    }
});
const Edt = te(Pdt, [["__scopeId", "data-v-475f0648"]]), Odt = {};
function $dt(e, t) {
    const n = B("PortalTarget");
    return _(),
    O(Le, null, [Ye(e.$slots, "workflowAnnotation"), z(n, {
                tag: "g",
                name: "node-select"
            }), Ye(e.$slots, "metaNodePortBars"), Ye(e.$slots, "nodes"), Ye(e.$slots, "connector"), z(n, {
                tag: "g",
                name: "node-text-editor"
            }), z(n, {
                tag: "g",
                name: "node-actions"
            }), Ye(e.$slots, "connectorLabel"), z(n, {
                tag: "g",
                name: "selected-port"
            }), z(n, {
                tag: "g",
                name: "editable-annotation"
            }), z(n, {
                tag: "g",
                name: "annotation-transform"
            }), z(n, {
                tag: "g",
                name: "drag-connector"
            })], 64)
}
const kW = te(Odt, [["render", $dt]]), Adt = Fe({
    components: {
        WorkflowPortalLayers: kW,
        Node: wtt,
        Connector: wF,
        WorkflowAnnotation: hdt,
        MetaNodePortBars: Sdt,
        ConnectorLabel: Edt,
        MoveableNodeContainer: xtt,
        MoveableAnnotationContainer: gdt
    },
    expose: ["applyNodeSelectionPreview", "applyAnnotationSelectionPreview"],
    computed: {
        ...ut("workflow", {
            workflow: "activeWorkflow",
            editableAnnotationId: "editableAnnotationId"
        }),
        ...zt("selection", ["isNodeSelected"]),
        ...zt("application", ["hasAnnotationModeEnabled"]),
        sortedNodes() {
            let e = [],
            t = [];
            for (const n of Object.keys(this.workflow.nodes))
                this.isNodeSelected(n) ? e.push(this.workflow.nodes[n]) : t.push(this.workflow.nodes[n]);
            return [...t, ...e]
        }
    },
    methods: {
        applyNodeSelectionPreview({
            nodeId: e,
            type: t
        }) {
            this.$refs[`node-${e}`][0].setSelectionPreview(t)
        },
        applyAnnotationSelectionPreview({
            annotationId: e,
            type: t
        }) {
            this.$refs[`annotation-${e}`][0].setSelectionPreview(t)
        }
    }
});
const Ddt = {
    class: "workflow"
};
function Ndt(e, t, n, r, o, i) {
    const s = B("WorkflowAnnotation"),
    a = B("Portal"),
    l = B("MoveableAnnotationContainer"),
    c = B("Connector"),
    u = B("MetaNodePortBars"),
    f = B("Node"),
    p = B("MoveableNodeContainer"),
    m = B("ConnectorLabel"),
    v = B("WorkflowPortalLayers");
    return _(),
    O("g", Ddt, [z(v, null, {
                workflowAnnotation: oe(() => [(_(!0), O(Le, null, $t(e.workflow.workflowAnnotations, y => (_(), H(l, {
                                            id: y.id,
                                            key: `annotation-${y.id}`,
                                            class: he({
                                                disabled: e.hasAnnotationModeEnabled
                                            }),
                                            bounds: y.bounds
                                        }, {
                                        default:
                                            oe(() => [e.editableAnnotationId !== y.id ? (_(), H(s, {
                                                            key: 0,
                                                            ref_for: !0,
                                                            ref: `annotation-${y.id}`,
                                                            annotation: y
                                                        }, null, 8, ["annotation"])) : (_(), H(a, {
                                                            key: 1,
                                                            to: "editable-annotation"
                                                        }, {
                                                        default:
                                                            oe(() => [z(s, {
                                                                        ref_for: !0,
                                                                        ref: `annotation-${y.id}`,
                                                                        annotation: y
                                                                    }, null, 8, ["annotation"])]),
                                                            _: 2
                                                        }, 1024))]),
                                            _: 2
                                        }, 1032, ["id", "class", "bounds"]))), 128))]),
                connector: oe(() => [(_(!0), O(Le, null, $t(e.workflow.connections, y => (_(), H(c, Bt({
                                                key: `connector-${y.sourceNode}-${y.sourcePort}-${y.destNode}-${y.destPort}`,
                                                ref_for: !0,
                                                ref: `connector-${y.id}`,
                                                class: {
                                                    disabled: e.hasAnnotationModeEnabled
                                                }
                                            }, y), null, 16, ["class"]))), 128))]),
                metaNodePortBars: oe(() => [e.workflow.info.containerType === "metanode" ? (_(), H(u, {
                                key: 0,
                                class: he({
                                    disabled: e.hasAnnotationModeEnabled
                                })
                            }, null, 8, ["class"])) : J("", !0)]),
                nodes: oe(() => [(_(!0), O(Le, null, $t(e.sortedNodes, y => (_(), H(p, {
                                            id: y.id,
                                            key: `node-${y.id}`,
                                            class: he({
                                                disabled: e.hasAnnotationModeEnabled
                                            }),
                                            position: y.position,
                                            kind: y.kind
                                        }, {
                                        default:
                                            oe(({
                                                    position: b
                                                }) => [z(f, Bt({
                                                            ref_for: !0,
                                                            ref: `node-${y.id}`,
                                                            class: {
                                                                disabled: e.hasAnnotationModeEnabled
                                                            }
                                                        }, y, {
                                                            icon: e.$store.getters["workflow/getNodeIcon"](y.id),
                                                            name: e.$store.getters["workflow/getNodeName"](y.id),
                                                            type: e.$store.getters["workflow/getNodeType"](y.id),
                                                            position: b
                                                        }), null, 16, ["class", "icon", "name", "type", "position"])]),
                                            _: 2
                                        }, 1032, ["id", "class", "position", "kind"]))), 128))]),
                connectorLabel: oe(() => [(_(!0), O(Le, null, $t(e.workflow.connections, (y, b) => (_(), H(m, Bt({
                                                key: `connector-label-${b}`
                                            }, y), null, 16))), 128))]),
                _: 1
            })])
}
const Rdt = te(Adt, [["render", Ndt], ["__scopeId", "data-v-df3f5a7b"]]);
const Ldt = 100, Bdt = {
    emits: ["containerSizeChanged"],
    data() {
        return {
            isPanning: !1,
            useMoveCursor: !1,
            isHoldingDownSpace: !1,
            isHoldingDownMiddleClick: !1,
            isHoldingDownRightClick: !1
        }
    },
    computed: {
        ...zt("canvas", ["canvasSize", "viewBox", "contentBounds"]),
        ...zt("application", ["hasPanModeEnabled"]),
        ...zt("workflow", ["isWorkflowEmpty"]),
        ...ut("canvas", ["zoomFactor", "interactionsEnabled"]),
        ...ut("application", ["scrollToZoomEnabled"]),
        ...ut("workflow", ["isDragging"])
    },
    watch: {
        contentBounds(...e) {
            this.contentBoundsChanged(e)
        }
    },
    mounted() {
        this.initScrollContainerElement(this.$el),
        this.initResizeObserver(),
        this.$el.focus(),
        document.addEventListener("keypress", this.onPressSpace),
        document.addEventListener("keyup", this.onReleaseKey),
        document.addEventListener("keydown", this.onDownShiftOrControl),
        this.windowBlurListener = () => {
            this.useMoveCursor = !1,
            this.isPanning = !1,
            this.isHoldingDownSpace = !1,
            this.setIsMoveLocked(!1)
        },
        window.addEventListener("blur", this.windowBlurListener)
    },
    beforeUnmount() {
        this.stopResizeObserver(),
        this.clearScrollContainerElement(),
        window.removeEventListener("blur", this.windowBlurListener),
        document.removeEventListener("keypress", this.onPressSpace),
        document.removeEventListener("keyup", this.onReleaseKey),
        document.removeEventListener("keydown", this.onDownShiftOrControl)
    },
    methods: {
        ...Er("canvas", ["initScrollContainerElement", "updateContainerSize", "zoomAroundPointer", "contentBoundsChanged"]),
        ...eg("canvas", ["clearScrollContainerElement", "setIsMoveLocked"]),
        initResizeObserver() {
            const e = Za.debounce(() => {
                this.updateContainerSize(),
                this.$nextTick(() => {
                    this.$emit("containerSizeChanged")
                })
            }, Ldt);
            this.resizeObserver = new ResizeObserver(t => {
                t.find(({
                        target: r
                    }) => r === this.$el) && e()
            }),
            this.stopResizeObserver = () => {
                this.resizeObserver && this.resizeObserver.disconnect()
            },
            this.resizeObserver.observe(this.$el)
        },
        zoom: Ds(function (e) {
            let t = Math.sign(-e.deltaY),
            r = this.$el.getBoundingClientRect(),
            o = e.clientX - r.x,
            i = e.clientY - r.y;
            this.zoomAroundPointer({
                delta: t,
                cursorX: o,
                cursorY: i
            })
        }),
        onMouseWheel(e) {
            !this.interactionsEnabled || this.isWorkflowEmpty || !(this.scrollToZoomEnabled || e.ctrlKey || Nu() && e.metaKey) || (e.preventDefault(), e.stopPropagation(), this.zoom(e))
        },
        onPressSpace(e) {
            Yk(e.target) || e.code === "Space" && (e.preventDefault(), e.stopPropagation(), this.isHoldingDownSpace || (this.useMoveCursor = !0), this.isHoldingDownSpace = !0)
        },
        onReleaseKey(e) {
            e.code === "Space" && (this.useMoveCursor = !1, this.isPanning = !1, this.isHoldingDownSpace = !1),
            e.code === "Escape" && (this.useMoveCursor = !1, this.isPanning = !1, this.$store.dispatch("application/resetCanvasMode"));
            const t = Nu() ? "Meta" : "Control";
            (e.key === "Shift" || e.key === t) && this.setIsMoveLocked(!1)
        },
        beginPan(e) {
            if (!this.interactionsEnabled || this.isWorkflowEmpty)
                return;
            const t = 1,
            n = 2;
            this.isHoldingDownMiddleClick = e.button === t,
            this.isHoldingDownRightClick = e.button === n,
            (this.isHoldingDownMiddleClick || this.isHoldingDownSpace || this.hasPanModeEnabled) && (this.isPanning = !0, this.useMoveCursor = !0, this.panningOffset = [e.screenX, e.screenY], this.$el.setPointerCapture(e.pointerId)),
            this.isHoldingDownRightClick && (this.maybePanning = !0, this.initialRightClickPosition = [e.screenX, e.screenY])
        },
        movePan: Ds(function (e) {
            if (this.isPanning) {
                const t = [e.screenX - this.panningOffset[0], e.screenY - this.panningOffset[1]];
                this.panningOffset = [e.screenX, e.screenY],
                this.$el.scrollLeft -= t[0],
                this.$el.scrollTop -= t[1]
            }
            if (this.maybePanning) {
                const n = Math.abs(e.screenX - this.initialRightClickPosition[0]),
                r = Math.abs(e.screenY - this.initialRightClickPosition[1]);
                (n >= 15 || r >= 15) && (this.isPanning = !0, this.useMoveCursor = !0, this.panningOffset = [e.screenX, e.screenY], this.$el.setPointerCapture(e.pointerId), this.maybePanning = !1, this.initialRightClickPosition = null)
            }
        }),
        stopPan(e) {
            if (!this.isPanning && this.isHoldingDownRightClick) {
                this.$store.dispatch("application/toggleContextMenu", {
                    event: e,
                    deselectAllObjects: !0
                }),
                this.isHoldingDownRightClick = !1,
                this.maybePanning = !1,
                e.stopPropagation();
                return
            }
            this.isPanning && (this.isPanning = !1, this.panningOffset = null, this.$el.releasePointerCapture(e.pointerId), e.stopPropagation()),
            this.isHoldingDownRightClick = !1,
            this.isHoldingDownMiddleClick = !1,
            this.maybePanning = !1,
            this.useMoveCursor = this.isHoldingDownSpace
        },
        onDownShiftOrControl(e) {
            if (Yk(e.target))
                return;
            const t = ga();
            (e.shiftKey || e[t]) && !this.isDragging && this.setIsMoveLocked(!0)
        },
        startRectangleSelection(e) {
            const t = ga();
            (e.shiftKey || e[t]) && this.$bus.emit("selection-pointerdown", e)
        }
    }
}, Vdt = ["width", "height", "viewBox"];
function Fdt(e, t, n, r, o, i) {
    return _(),
    O("div", {
        tabindex: "0",
        class: he(["scroll-container", {
                    panning: o.useMoveCursor || e.hasPanModeEnabled,
                    empty: e.isWorkflowEmpty,
                    disabled: !e.interactionsEnabled
                }
            ]),
        onWheel: t[5] || (t[5] = (...s) => i.onMouseWheel && i.onMouseWheel(...s)),
        onPointerdown: [t[6] || (t[6] = ve((...s) => i.beginPan && i.beginPan(...s), ["middle"])), t[7] || (t[7] = ve((...s) => i.beginPan && i.beginPan(...s), ["prevent", "right"])), t[8] || (t[8] = ve((...s) => i.beginPan && i.beginPan(...s), ["left"]))],
        onPointerup: [t[9] || (t[9] = ve((...s) => i.stopPan && i.stopPan(...s), ["middle"])), t[10] || (t[10] = ve((...s) => i.stopPan && i.stopPan(...s), ["left"])), t[11] || (t[11] = ve((...s) => i.stopPan && i.stopPan(...s), ["prevent", "right"]))],
        onPointermove: t[12] || (t[12] = (...s) => i.movePan && i.movePan(...s))
    }, [(_(), O("svg", {
                    ref: "svg",
                    width: e.canvasSize.width,
                    height: e.canvasSize.height,
                    viewBox: e.viewBox.string,
                    onPointerdown: [t[0] || (t[0] = ve(s => e.$bus.emit("selection-pointerdown", s), ["left", "exact", "stop"])), t[1] || (t[1] = ve((...s) => i.startRectangleSelection && i.startRectangleSelection(...s), ["left", "stop"]))],
                    onPointerup: t[2] || (t[2] = ve(s => e.$bus.emit("selection-pointerup", s), ["left", "stop"])),
                    onPointermove: t[3] || (t[3] = s => e.$bus.emit("selection-pointermove", s)),
                    onLostpointercapture: t[4] || (t[4] = s => e.$bus.emit("selection-lostpointercapture", s))
                }, [Ye(e.$slots, "default", {}, void 0, !0)], 40, Vdt))], 34)
}
const jdt = te(Bdt, [["render", Fdt], ["__scopeId", "data-v-c48920e4"]]), Wdt = ({
    startPos: e,
    endPos: t,
    workflow: n
}) => {
    const r = {
        x1: Math.min(e.x, t.x),
        y1: Math.min(e.y, t.y),
        x2: Math.max(e.x, t.x),
        y2: Math.max(e.y, t.y)
    },
    o = [],
    i = [];
    Object.values(n.nodes).forEach(({
            position: u,
            id: f
        }) => {
        const {
            nodeSize: p
        } = dw,
        m = r.x1 <= u.x + p && r.x2 >= u.x,
        v = r.y1 <= u.y + p && r.y2 >= u.y;
        m && v ? o.push(f) : i.push(f)
    });
    const s = [],
    a = [];
    Object.values(n.workflowAnnotations).forEach(({
            bounds: u,
            id: f
        }) => {
        const p = u.x,
        m = u.x + u.width,
        v = u.y,
        y = u.y + u.height,
        b = p <= r.x1 && m >= r.x2 && v <= r.y1 && y >= r.y2,
        w = r.x1 <= m && r.x2 >= p,
        k = r.y1 <= y && r.y2 >= v;
        w && k && !b ? s.push(f) : a.push(f)
    });
    const l = [],
    c = [];
    return Object.values(n.connections).forEach(({
            bendpoints: u = [],
            id: f
        }) => {
        u.forEach(({
                x: p,
                y: m
            }, v) => {
            const y = r.x1 <= p && r.x2 >= p,
            b = r.y1 <= m && r.y2 >= m;
            y && b ? l.push(`${f}__${v}`) : c.push(`${f}__${v}`)
        })
    }), {
        nodesInside: o,
        nodesOutside: i,
        annotationsInside: s,
        annotationsOutside: a,
        bendpointsInside: l,
        bendpointsOutside: c
    }
}, zdt = Fe({
    emits: ["nodeSelectionPreview", "annotationSelectionPreview"],
    data: () => ({
        startPos: {
            x: 0,
            y: 0
        },
        endPos: {
            x: 0,
            y: 0
        },
        pointerId: null,
        nodeIdsToSelectOnEnd: [],
        nodeIdsToDeselectOnEnd: [],
        selectedNodeIdsAtStart: [],
        nodeIdsInsidePreviousSelection: [],
        annotationIdsToSelectOnEnd: [],
        annotationIdsToDeselectOnEnd: [],
        selectedAnnotationIdsAtStart: [],
        annotationIdsInsidePreviousSelection: []
    }),
    computed: {
        ...ut("workflow", ["activeWorkflow"]),
        ...zt("canvas", ["screenToCanvasCoordinates"]),
        ...zt("selection", ["selectedNodeIds", "selectedAnnotationIds"]),
        selectionBounds() {
            const {
                endPos: e,
                startPos: t
            } = this;
            return {
                x: Math.min(t.x, e.x),
                y: Math.min(t.y, e.y),
                width: Math.abs(t.x - e.x),
                height: Math.abs(t.y - e.y)
            }
        }
    },
    created() {
        this.$bus.on("selection-pointerdown", this.startRectangleSelection),
        this.$bus.on("selection-pointerup", this.stopRectangleSelection),
        this.$bus.on("selection-pointermove", this.updateRectangleSelection),
        this.$bus.on("selection-lostpointercapture", this.stopRectangleSelection)
    },
    beforeUnmount() {
        this.$bus.off("selection-pointerdown", this.startRectangleSelection),
        this.$bus.off("selection-pointerup", this.stopRectangleSelection),
        this.$bus.off("selection-pointermove", this.updateRectangleSelection),
        this.$bus.off("selection-lostpointercapture", this.stopRectangleSelection)
    },
    methods: {
        ...Er("selection", ["selectNodes", "deselectNodes", "deselectAllObjects", "selectAnnotations", "deselectAnnotations"]),
        startRectangleSelection(e) {
            this.pointerId = e.pointerId,
            e.target.setPointerCapture(e.pointerId),
            [this.startPos.x, this.startPos.y] = this.screenToCanvasCoordinates([e.clientX, e.clientY]),
            this.endPos = {
                ...this.startPos
            },
            this.nodeIdsToSelectOnEnd = [],
            this.nodeIdsToDeselectOnEnd = [],
            this.annotationIdsToSelectOnEnd = [],
            this.annotationIdsToDeselectOnEnd = [],
            e.shiftKey || e.ctrlKey || e.metaKey ? (this.selectedNodeIdsAtStart = [...this.selectedNodeIds], this.selectedAnnotationIdsAtStart = [...this.selectedAnnotationIds]) : (this.deselectAllObjects(), this.selectedNodeIdsAtStart = [], this.selectedAnnotationIdsAtStart = [])
        },
        stopRectangleSelection: Ds(function (e) {
            this.pointerId === e.pointerId && (e.target.releasePointerCapture(this.pointerId), this.pointerId = null, setTimeout(() => {
                    this.nodeIdsToSelectOnEnd.length > 0 && this.selectNodes(this.nodeIdsToSelectOnEnd),
                    this.nodeIdsToDeselectOnEnd.length > 0 && this.deselectNodes(this.nodeIdsToDeselectOnEnd),
                    this.annotationIdsToSelectOnEnd.length > 0 && this.selectAnnotations(this.annotationIdsToSelectOnEnd),
                    this.annotationIdsToDeselectOnEnd.length > 0 && this.deselectAnnotations(this.annotationIdsToDeselectOnEnd),
                    [...this.nodeIdsToSelectOnEnd, ...this.nodeIdsToDeselectOnEnd].forEach(t => {
                        this.$emit("nodeSelectionPreview", {
                            type: "clear",
                            nodeId: t
                        })
                    }),
                    [...this.annotationIdsToSelectOnEnd, ...this.annotationIdsToDeselectOnEnd].forEach(t => {
                        this.$emit("annotationSelectionPreview", {
                            type: null,
                            annotationId: t
                        })
                    }),
                    this.nodeIdsToSelectOnEnd = [],
                    this.nodeIdsToDeselectOnEnd = [],
                    this.selectedNodeIdsAtStart = [],
                    this.annotationIdsToSelectOnEnd = [],
                    this.annotationIdsToDeselectOnEnd = [],
                    this.selectedAnnotationIdsAtStart = [],
                    this.$store.commit("selection/setDidStartRectangleSelection", !1)
                }, 0))
        }),
        updateRectangleSelection: Ds(function (e) {
            this.pointerId === e.pointerId && (this.$store.commit("selection/setDidStartRectangleSelection", !0), [this.endPos.x, this.endPos.y] = this.screenToCanvasCoordinates([e.clientX, e.clientY]), this.previewSelectionForItemsInRectangle(this.startPos, this.endPos))
        }),
        previewSelectionForItemsInRectangle(e, t) {
            let {
                nodesInside: n,
                nodesOutside: r,
                annotationsInside: o,
                annotationsOutside: i
            } = Wdt({
                startPos: e,
                endPos: t,
                workflow: this.activeWorkflow
            }),
            s = [],
            a = [],
            l = [],
            c = [];
            n.forEach(u => {
                this.selectedNodeIdsAtStart?.includes(u) ? (this.$emit("nodeSelectionPreview", {
                        type: "hide",
                        nodeId: u
                    }), a.push(u)) : (this.$emit("nodeSelectionPreview", {
                        type: "show",
                        nodeId: u
                    }), s.push(u))
            }),
            r.forEach(u => {
                this.nodeIdsInsidePreviousSelection?.includes(u) && this.$emit("nodeSelectionPreview", {
                    type: "clear",
                    nodeId: u
                })
            }),
            o.forEach(u => {
                this.selectedAnnotationIdsAtStart?.includes(u) ? (this.$emit("annotationSelectionPreview", {
                        type: "hide",
                        annotationId: u
                    }), c.push(u)) : (this.$emit("annotationSelectionPreview", {
                        type: "show",
                        annotationId: u
                    }), l.push(u))
            }),
            i.forEach(u => {
                this.annotationIdsInsidePreviousSelection?.includes(u) && this.$emit("annotationSelectionPreview", {
                    type: null,
                    annotationId: u
                })
            }),
            this.nodeIdsInsidePreviousSelection = n,
            this.nodeIdsToSelectOnEnd = s,
            this.nodeIdsToDeselectOnEnd = a,
            this.annotationIdsInsidePreviousSelection = o,
            this.annotationIdsToSelectOnEnd = l,
            this.annotationIdsToDeselectOnEnd = c
        }
    }
});
const Hdt = ["x", "y", "width", "height", "stroke"];
function Udt(e, t, n, r, o, i) {
    return Cn((_(), O("rect", {
                x: e.selectionBounds.x,
                y: e.selectionBounds.y,
                width: e.selectionBounds.width,
                height: e.selectionBounds.height,
                stroke: e.$colors.selection.activeBorder,
                "stroke-dasharray": "5",
                "vector-effect": "non-scaling-stroke"
            }, null, 8, Hdt)), [[Kn, e.pointerId !== null]])
}
const qdt = te(zdt, [["render", Udt], ["__scopeId", "data-v-6266f8ab"]]), Ydt = ["x", "y", "width", "height", "stroke"], Kdt = Fe({
    __name: "AnnotationRectangle",
    setup(e) {
        const t = es({
            x: 0,
            y: 0
        }),
        n = es({
            x: 0,
            y: 0
        }),
        r = De(null),
        o = pF(),
        i = wa(),
        s = ne(() => i.getters["canvas/screenToCanvasCoordinates"]),
        a = ne(() => ({
                    x: Math.min(t.x, n.x),
                    y: Math.min(t.y, n.y),
                    width: Math.abs(t.x - n.x),
                    height: Math.abs(t.y - n.y)
                })),
        l = f => {
            r.value = f.pointerId,
            f.target.setPointerCapture(f.pointerId),
            [t.x, t.y] = s.value([f.clientX, f.clientY]),
            n.x = t.x,
            n.y = t.y
        },
        c = Ds(function (f) {
            r.value === f.pointerId && ([n.x, n.y] = s.value([f.clientX, f.clientY]))
        }),
        u = Ds(function (f) {
            r.value === f.pointerId && (f.target.releasePointerCapture(r.value), r.value = null, setTimeout(() => {
                    const {
                        x: p,
                        y: m,
                        width: v,
                        height: y
                    } = a.value;
                    o.dispatch("addWorkflowAnnotation", {
                        event: f,
                        metadata: {
                            position: {
                                x: p,
                                y: m
                            },
                            width: v,
                            height: y
                        }
                    }),
                    i.dispatch("application/switchCanvasMode", "selection")
                }, 0))
        });
        return Ir.on("selection-pointerdown", l),
        Ir.on("selection-pointerup", u),
        Ir.on("selection-pointermove", c),
        Ir.on("selection-lostpointercapture", u),
        Rs(() => {
            Ir.off("selection-pointerdown", l),
            Ir.off("selection-pointerup", u),
            Ir.off("selection-pointermove", c),
            Ir.off("selection-lostpointercapture", u)
        }),
        (f, p) => Cn((_(), O("rect", {
                    x: a.value.x,
                    y: a.value.y,
                    width: a.value.width,
                    height: a.value.height,
                    stroke: f.$colors.Cornflower,
                    "vector-effect": "non-scaling-stroke"
                }, null, 8, Ydt)), [[Kn, r.value !== null]])
    }
});
const Gdt = te(Kdt, [["__scopeId", "data-v-1ca1931e"]]), Xdt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Jdt = P("path", {
    d: "m27 17.1-11 11-11-11m11 11V3.9"
}, null, -1), Zdt = [Jdt];
function Qdt(e, t) {
    return _(),
    O("svg", Xdt, Zdt)
}
const eft = {
    render: Qdt
};
const tft = {
    components: {
        ArrowDown: eft,
        WorkflowPortalLayers: kW
    },
    computed: {
        ...ut("canvas", ["containerSize"]),
        bounds() {
            const {
                height: e,
                width: t
            } = this.containerSize;
            return {
                left: -t / 2,
                top: -e / 2,
                width: t,
                height: e
            }
        },
        rectangleBounds() {
            return {
                left: this.bounds.left + 25,
                top: this.bounds.top + 25,
                height: Math.max(this.bounds.height - 2 * 25, 0),
                width: Math.max(this.bounds.width - 2 * 25, 0)
            }
        }
    }
}, xW = e => (ir("data-v-10e9c97b"), e = e(), sr(), e), nft = ["x", "y", "width", "height"], rft = xW(() => P("text", {
            y: "-9"
        }, "Start building your workflow by dropping", -1)), oft = xW(() => P("text", {
            y: "27"
        }, " your data or nodes here.", -1));
function ift(e, t, n, r, o, i) {
    const s = B("ArrowDown"),
    a = B("WorkflowPortalLayers");
    return _(),
    O("g", null, [P("rect", {
                x: i.rectangleBounds.left,
                y: i.rectangleBounds.top,
                width: i.rectangleBounds.width,
                height: i.rectangleBounds.height
            }, null, 8, nft), z(s, {
                height: "64",
                width: "64",
                x: "-32",
                y: "-99"
            }), rft, oft, z(a)])
}
const sft = te(tft, [["render", ift], ["__scopeId", "data-v-10e9c97b"]]), aft = {}, lft = P("filter", {
    id: "node-action-button-shadow",
    height: "200%",
    width: "200%",
    x: "-50%",
    y: "-50%"
}, [P("feDropShadow", {
            dx: "0",
            dy: "2",
            stdDeviation: "5",
            "flood-color": "rgba(0,0,0,0.15)"
        })], -1), cft = P("filter", {
        id: "node-torso-shadow",
        height: "300%",
        width: "300%",
        x: "-100%",
        y: "-100%"
    }, [P("feDropShadow", {
                dx: "0",
                dy: "1",
                stdDeviation: "8",
                "flood-color": "rgba(0,0,0,0.15)"
            })], -1), uft = P("filter", {
        id: "node-state-shadow",
        height: "300%",
        width: "300%",
        x: "-100%",
        y: "-100%"
    }, [P("feDropShadow", {
                dx: "0",
                dy: "1",
                stdDeviation: "6",
                "flood-color": "rgba(0,0,0,0.15)"
            })], -1), dft = [lft, cft, uft];
function fft(e, t) {
    return _(),
    O("defs", null, dft)
}
const hft = te(aft, [["render", fft]]);
const pft = {
    components: {
        Workflow: Rdt,
        Kanvas: jdt,
        SelectionRectangle: qdt,
        AnnotationRectangle: Gdt,
        WorkflowEmpty: sft,
        KanvasFilters: hft
    },
    mixins: [AXe],
    computed: {
        ...zt("application", ["workflowCanvasState", "hasAnnotationModeEnabled"]),
        ...zt("canvas", ["contentBounds"]),
        ...zt("workflow", ["isWorkflowEmpty"]),
        ...ut("nodeRepository", {
            isDraggingNodeFromRepository: "isDraggingNode"
        }),
        ...ut("canvas", ["zoomFactor"]),
        ...ut("workflow", ["activeWorkflow"])
    },
    watch: {
        isWorkflowEmpty: {
            immediate: !0,
            async handler(e) {
                e && (await this.$nextTick(), this.fillScreen())
            }
        }
    },
    mounted() {
        this.$nextTick(() => {
            this.workflowCanvasState || this.fillScreen()
        })
    },
    methods: {
        ...Er("canvas", ["fillScreen"]),
        ...Er("application", ["resetCanvasMode"]),
        onNodeSelectionPreview(e) {
            this.$refs.workflow.applyNodeSelectionPreview(e)
        },
        onAnnotationPreview(e) {
            this.$refs.workflow.applyAnnotationSelectionPreview(e)
        },
        async onContainerSizeUpdated() {
            this.isWorkflowEmpty && (await this.$nextTick(), this.fillScreen())
        }
    }
};
function mft(e, t, n, r, o, i) {
    const s = B("KanvasFilters"),
    a = B("WorkflowEmpty"),
    l = B("Workflow"),
    c = B("AnnotationRectangle"),
    u = B("SelectionRectangle"),
    f = B("Kanvas");
    return _(),
    H(f, {
        id: "kanvas",
        ref: "kanvas",
        class: he({
            "indicate-node-drag": e.isWorkflowEmpty && e.isDraggingNodeFromRepository
        }),
        onDrop: ve(e.onDrop, ["stop"]),
        onDragover: ve(e.onDragOver, ["prevent", "stop"]),
        onContainerSizeChanged: i.onContainerSizeUpdated
    }, {
    default:
        oe(() => [z(s), e.isWorkflowEmpty ? (_(), H(a, {
                        key: 0
                    })) : (_(), H(l, {
                        key: 1,
                        ref: "workflow"
                    }, null, 512)), e.hasAnnotationModeEnabled ? (_(), H(c, {
                        key: 2
                    })) : (_(), H(u, {
                        key: 3,
                        onNodeSelectionPreview: i.onNodeSelectionPreview,
                        onAnnotationSelectionPreview: i.onAnnotationPreview
                    }, null, 8, ["onNodeSelectionPreview", "onAnnotationSelectionPreview"]))]),
        _: 1
    }, 8, ["class", "onDrop", "onDragover", "onContainerSizeChanged"])
}
const gft = te(pft, [["render", mft], ["__scopeId", "data-v-c457387c"]]), vft = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, yft = P("path", {
    d: "M11.772 22.665 3.5 14.393l8.272-8.272M3.5 14.393h18.256m0 0a6.744 6.744 0 0 1 6.744 6.744v4.741"
}, null, -1), wft = [yft];
function bft(e, t) {
    return _(),
    O("svg", vft, wft)
}
const _ft = {
    render: bft
};
function tl(e) {
    return Array.isArray ? Array.isArray(e) : IW(e) === "[object Array]"
}
const kft = 1 / 0;
function xft(e) {
    if (typeof e == "string")
        return e;
    let t = e + "";
    return t == "0" && 1 / e == -kft ? "-0" : t
}
function Sft(e) {
    return e == null ? "" : xft(e)
}
function ra(e) {
    return typeof e == "string"
}
function SW(e) {
    return typeof e == "number"
}
function Cft(e) {
    return e === !0 || e === !1 || Ift(e) && IW(e) == "[object Boolean]"
}
function CW(e) {
    return typeof e == "object"
}
function Ift(e) {
    return CW(e) && e !== null
}
function bi(e) {
    return e != null
}
function dk(e) {
    return !e.trim().length
}
function IW(e) {
    return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
}
const Tft = "Incorrect 'index' type", Mft = e => `Invalid value for key ${e}`, Pft = e => `Pattern length exceeds max of ${e}.`, Eft = e => `Missing ${e} property in key`, Oft = e => `Property 'weight' in key '${e}' must be a positive integer`, pR = Object.prototype.hasOwnProperty;
class $ft {
    constructor(t) {
        this._keys = [],
        this._keyMap = {};
        let n = 0;
        t.forEach(r => {
            let o = TW(r);
            n += o.weight,
            this._keys.push(o),
            this._keyMap[o.id] = o,
            n += o.weight
        }),
        this._keys.forEach(r => {
            r.weight /= n
        })
    }
    get(t) {
        return this._keyMap[t]
    }
    keys() {
        return this._keys
    }
    toJSON() {
        return JSON.stringify(this._keys)
    }
}
function TW(e) {
    let t = null,
    n = null,
    r = null,
    o = 1,
    i = null;
    if (ra(e) || tl(e))
        r = e, t = mR(e), n = IS(e);
    else {
        if (!pR.call(e, "name"))
            throw new Error(Eft("name"));
        const s = e.name;
        if (r = s, pR.call(e, "weight") && (o = e.weight, o <= 0))
            throw new Error(Oft(s));
        t = mR(s),
        n = IS(s),
        i = e.getFn
    }
    return {
        path: t,
        id: n,
        weight: o,
        src: r,
        getFn: i
    }
}
function mR(e) {
    return tl(e) ? e : e.split(".")
}
function IS(e) {
    return tl(e) ? e.join(".") : e
}
function Aft(e, t) {
    let n = [],
    r = !1;
    const o = (i, s, a) => {
        if (bi(i))
            if (!s[a])
                n.push(i);
            else {
                let l = s[a];
                const c = i[l];
                if (!bi(c))
                    return;
                if (a === s.length - 1 && (ra(c) || SW(c) || Cft(c)))
                    n.push(Sft(c));
                else if (tl(c)) {
                    r = !0;
                    for (let u = 0, f = c.length; u < f; u += 1)
                        o(c[u], s, a + 1)
                } else
                    s.length && o(c, s, a + 1)
            }
    };
    return o(e, ra(t) ? t.split(".") : t, 0),
    r ? n : n[0]
}
const Dft = {
    includeMatches: !1,
    findAllMatches: !1,
    minMatchCharLength: 1
}, Nft = {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: (e, t) => e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1
}, Rft = {
    location: 0,
    threshold: .6,
    distance: 100
}, Lft = {
    useExtendedSearch: !1,
    getFn: Aft,
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1
};
var At = {
    ...Nft,
    ...Dft,
    ...Rft,
    ...Lft
};
const Bft = /[^ ]+/g;
function Vft(e = 1, t = 3) {
    const n = new Map,
    r = Math.pow(10, t);
    return {
        get(o) {
            const i = o.match(Bft).length;
            if (n.has(i))
                return n.get(i);
            const s = 1 / Math.pow(i, .5 * e),
            a = parseFloat(Math.round(s * r) / r);
            return n.set(i, a),
            a
        },
        clear() {
            n.clear()
        }
    }
}
class QT {
    constructor({
        getFn: t = At.getFn,
        fieldNormWeight: n = At.fieldNormWeight
    } = {}) {
        this.norm = Vft(n, 3),
        this.getFn = t,
        this.isCreated = !1,
        this.setIndexRecords()
    }
    setSources(t = []) {
        this.docs = t
    }
    setIndexRecords(t = []) {
        this.records = t
    }
    setKeys(t = []) {
        this.keys = t,
        this._keysMap = {},
        t.forEach((n, r) => {
            this._keysMap[n.id] = r
        })
    }
    create() {
        this.isCreated || !this.docs.length || (this.isCreated = !0, ra(this.docs[0]) ? this.docs.forEach((t, n) => {
                this._addString(t, n)
            }) : this.docs.forEach((t, n) => {
                this._addObject(t, n)
            }), this.norm.clear())
    }
    add(t) {
        const n = this.size();
        ra(t) ? this._addString(t, n) : this._addObject(t, n)
    }
    removeAt(t) {
        this.records.splice(t, 1);
        for (let n = t, r = this.size(); n < r; n += 1)
            this.records[n].i -= 1
    }
    getValueForItemAtKeyId(t, n) {
        return t[this._keysMap[n]]
    }
    size() {
        return this.records.length
    }
    _addString(t, n) {
        if (!bi(t) || dk(t))
            return;
        let r = {
            v: t,
            i: n,
            n: this.norm.get(t)
        };
        this.records.push(r)
    }
    _addObject(t, n) {
        let r = {
            i: n,
            $: {}
        };
        this.keys.forEach((o, i) => {
            let s = o.getFn ? o.getFn(t) : this.getFn(t, o.path);
            if (bi(s)) {
                if (tl(s)) {
                    let a = [];
                    const l = [{
                            nestedArrIndex: -1,
                            value: s
                        }
                    ];
                    for (; l.length; ) {
                        const {
                            nestedArrIndex: c,
                            value: u
                        } = l.pop();
                        if (bi(u))
                            if (ra(u) && !dk(u)) {
                                let f = {
                                    v: u,
                                    i: c,
                                    n: this.norm.get(u)
                                };
                                a.push(f)
                            } else
                                tl(u) && u.forEach((f, p) => {
                                    l.push({
                                        nestedArrIndex: p,
                                        value: f
                                    })
                                })
                    }
                    r.$[i] = a
                } else if (ra(s) && !dk(s)) {
                    let a = {
                        v: s,
                        n: this.norm.get(s)
                    };
                    r.$[i] = a
                }
            }
        }),
        this.records.push(r)
    }
    toJSON() {
        return {
            keys: this.keys,
            records: this.records
        }
    }
}
function MW(e, t, {
    getFn: n = At.getFn,
    fieldNormWeight: r = At.fieldNormWeight
} = {}) {
    const o = new QT({
        getFn: n,
        fieldNormWeight: r
    });
    return o.setKeys(e.map(TW)),
    o.setSources(t),
    o.create(),
    o
}
function Fft(e, {
    getFn: t = At.getFn,
    fieldNormWeight: n = At.fieldNormWeight
} = {}) {
    const {
        keys: r,
        records: o
    } = e,
    i = new QT({
        getFn: t,
        fieldNormWeight: n
    });
    return i.setKeys(r),
    i.setIndexRecords(o),
    i
}
function e0(e, {
    errors: t = 0,
    currentLocation: n = 0,
    expectedLocation: r = 0,
    distance: o = At.distance,
    ignoreLocation: i = At.ignoreLocation
} = {}) {
    const s = t / e.length;
    if (i)
        return s;
    const a = Math.abs(r - n);
    return o ? s + a / o : a ? 1 : s
}
function jft(e = [], t = At.minMatchCharLength) {
    let n = [],
    r = -1,
    o = -1,
    i = 0;
    for (let s = e.length; i < s; i += 1) {
        let a = e[i];
        a && r === -1 ? r = i : !a && r !== -1 && (o = i - 1, o - r + 1 >= t && n.push([r, o]), r = -1)
    }
    return e[i - 1] && i - r >= t && n.push([r, i - 1]),
    n
}
const Xc = 32;
function Wft(e, t, n, {
    location: r = At.location,
    distance: o = At.distance,
    threshold: i = At.threshold,
    findAllMatches: s = At.findAllMatches,
    minMatchCharLength: a = At.minMatchCharLength,
    includeMatches: l = At.includeMatches,
    ignoreLocation: c = At.ignoreLocation
} = {}) {
    if (t.length > Xc)
        throw new Error(Pft(Xc));
    const u = t.length,
    f = e.length,
    p = Math.max(0, Math.min(r, f));
    let m = i,
    v = p;
    const y = a > 1 || l,
    b = y ? Array(f) : [];
    let w;
    for (; (w = e.indexOf(t, v)) > -1; ) {
        let E = e0(t, {
            currentLocation: w,
            expectedLocation: p,
            distance: o,
            ignoreLocation: c
        });
        if (m = Math.min(E, m), v = w + u, y) {
            let M = 0;
            for (; M < u; )
                b[w + M] = 1, M += 1
        }
    }
    v = -1;
    let k = [],
    C = 1,
    x = u + f;
    const S = 1 << u - 1;
    for (let E = 0; E < u; E += 1) {
        let M = 0,
        N = x;
        for (; M < N; )
            e0(t, {
                errors: E,
                currentLocation: p + N,
                expectedLocation: p,
                distance: o,
                ignoreLocation: c
            }) <= m ? M = N : x = N, N = Math.floor((x - M) / 2 + M);
        x = N;
        let F = Math.max(1, p - N + 1),
        K = s ? f : Math.min(p + N, f) + u,
        j = Array(K + 2);
        j[K + 1] = (1 << E) - 1;
        for (let Y = K; Y >= F; Y -= 1) {
            let ue = Y - 1,
            re = n[e.charAt(ue)];
            if (y && (b[ue] =  + !!re), j[Y] = (j[Y + 1] << 1 | 1) & re, E && (j[Y] |= (k[Y + 1] | k[Y]) << 1 | 1 | k[Y + 1]), j[Y] & S && (C = e0(t, {
                        errors: E,
                        currentLocation: ue,
                        expectedLocation: p,
                        distance: o,
                        ignoreLocation: c
                    }), C <= m)) {
                if (m = C, v = ue, v <= p)
                    break;
                F = Math.max(1, 2 * p - v)
            }
        }
        if (e0(t, {
                errors: E + 1,
                currentLocation: p,
                expectedLocation: p,
                distance: o,
                ignoreLocation: c
            }) > m)
            break;
        k = j
    }
    const T = {
        isMatch: v >= 0,
        score: Math.max(.001, C)
    };
    if (y) {
        const E = jft(b, a);
        E.length ? l && (T.indices = E) : T.isMatch = !1
    }
    return T
}
function zft(e) {
    let t = {};
    for (let n = 0, r = e.length; n < r; n += 1) {
        const o = e.charAt(n);
        t[o] = (t[o] || 0) | 1 << r - n - 1
    }
    return t
}
class PW {
    constructor(t, {
        location: n = At.location,
        threshold: r = At.threshold,
        distance: o = At.distance,
        includeMatches: i = At.includeMatches,
        findAllMatches: s = At.findAllMatches,
        minMatchCharLength: a = At.minMatchCharLength,
        isCaseSensitive: l = At.isCaseSensitive,
        ignoreLocation: c = At.ignoreLocation
    } = {}) {
        if (this.options = {
                location: n,
                threshold: r,
                distance: o,
                includeMatches: i,
                findAllMatches: s,
                minMatchCharLength: a,
                isCaseSensitive: l,
                ignoreLocation: c
            }, this.pattern = l ? t : t.toLowerCase(), this.chunks = [], !this.pattern.length)
            return;
        const u = (p, m) => {
            this.chunks.push({
                pattern: p,
                alphabet: zft(p),
                startIndex: m
            })
        },
        f = this.pattern.length;
        if (f > Xc) {
            let p = 0;
            const m = f % Xc,
            v = f - m;
            for (; p < v; )
                u(this.pattern.substr(p, Xc), p), p += Xc;
            if (m) {
                const y = f - Xc;
                u(this.pattern.substr(y), y)
            }
        } else
            u(this.pattern, 0)
    }
    searchIn(t) {
        const {
            isCaseSensitive: n,
            includeMatches: r
        } = this.options;
        if (n || (t = t.toLowerCase()), this.pattern === t) {
            let v = {
                isMatch: !0,
                score: 0
            };
            return r && (v.indices = [[0, t.length - 1]]),
            v
        }
        const {
            location: o,
            distance: i,
            threshold: s,
            findAllMatches: a,
            minMatchCharLength: l,
            ignoreLocation: c
        } = this.options;
        let u = [],
        f = 0,
        p = !1;
        this.chunks.forEach(({
                pattern: v,
                alphabet: y,
                startIndex: b
            }) => {
            const {
                isMatch: w,
                score: k,
                indices: C
            } = Wft(t, v, y, {
                location: o + b,
                distance: i,
                threshold: s,
                findAllMatches: a,
                minMatchCharLength: l,
                includeMatches: r,
                ignoreLocation: c
            });
            w && (p = !0),
            f += k,
            w && C && (u = [...u, ...C])
        });
        let m = {
            isMatch: p,
            score: p ? f / this.chunks.length : 1
        };
        return p && r && (m.indices = u),
        m
    }
}
class kc {
    constructor(t) {
        this.pattern = t
    }
    static isMultiMatch(t) {
        return gR(t, this.multiRegex)
    }
    static isSingleMatch(t) {
        return gR(t, this.singleRegex)
    }
    search() {}
}
function gR(e, t) {
    const n = e.match(t);
    return n ? n[1] : null
}
class Hft extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "exact"
    }
    static get multiRegex() {
        return /^="(.*)"$/
    }
    static get singleRegex() {
        return /^=(.*)$/
    }
    search(t) {
        const n = t === this.pattern;
        return {
            isMatch: n,
            score: n ? 0 : 1,
            indices: [0, this.pattern.length - 1]
        }
    }
}
class Uft extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "inverse-exact"
    }
    static get multiRegex() {
        return /^!"(.*)"$/
    }
    static get singleRegex() {
        return /^!(.*)$/
    }
    search(t) {
        const r = t.indexOf(this.pattern) === -1;
        return {
            isMatch: r,
            score: r ? 0 : 1,
            indices: [0, t.length - 1]
        }
    }
}
class qft extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "prefix-exact"
    }
    static get multiRegex() {
        return /^\^"(.*)"$/
    }
    static get singleRegex() {
        return /^\^(.*)$/
    }
    search(t) {
        const n = t.startsWith(this.pattern);
        return {
            isMatch: n,
            score: n ? 0 : 1,
            indices: [0, this.pattern.length - 1]
        }
    }
}
class Yft extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "inverse-prefix-exact"
    }
    static get multiRegex() {
        return /^!\^"(.*)"$/
    }
    static get singleRegex() {
        return /^!\^(.*)$/
    }
    search(t) {
        const n = !t.startsWith(this.pattern);
        return {
            isMatch: n,
            score: n ? 0 : 1,
            indices: [0, t.length - 1]
        }
    }
}
class Kft extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "suffix-exact"
    }
    static get multiRegex() {
        return /^"(.*)"\$$/
    }
    static get singleRegex() {
        return /^(.*)\$$/
    }
    search(t) {
        const n = t.endsWith(this.pattern);
        return {
            isMatch: n,
            score: n ? 0 : 1,
            indices: [t.length - this.pattern.length, t.length - 1]
        }
    }
}
class Gft extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "inverse-suffix-exact"
    }
    static get multiRegex() {
        return /^!"(.*)"\$$/
    }
    static get singleRegex() {
        return /^!(.*)\$$/
    }
    search(t) {
        const n = !t.endsWith(this.pattern);
        return {
            isMatch: n,
            score: n ? 0 : 1,
            indices: [0, t.length - 1]
        }
    }
}
class EW extends kc {
    constructor(t, {
        location: n = At.location,
        threshold: r = At.threshold,
        distance: o = At.distance,
        includeMatches: i = At.includeMatches,
        findAllMatches: s = At.findAllMatches,
        minMatchCharLength: a = At.minMatchCharLength,
        isCaseSensitive: l = At.isCaseSensitive,
        ignoreLocation: c = At.ignoreLocation
    } = {}) {
        super(t),
        this._bitapSearch = new PW(t, {
            location: n,
            threshold: r,
            distance: o,
            includeMatches: i,
            findAllMatches: s,
            minMatchCharLength: a,
            isCaseSensitive: l,
            ignoreLocation: c
        })
    }
    static get type() {
        return "fuzzy"
    }
    static get multiRegex() {
        return /^"(.*)"$/
    }
    static get singleRegex() {
        return /^(.*)$/
    }
    search(t) {
        return this._bitapSearch.searchIn(t)
    }
}
class OW extends kc {
    constructor(t) {
        super(t)
    }
    static get type() {
        return "include"
    }
    static get multiRegex() {
        return /^'"(.*)"$/
    }
    static get singleRegex() {
        return /^'(.*)$/
    }
    search(t) {
        let n = 0,
        r;
        const o = [],
        i = this.pattern.length;
        for (; (r = t.indexOf(this.pattern, n)) > -1; )
            n = r + i, o.push([r, n - 1]);
        const s = !!o.length;
        return {
            isMatch: s,
            score: s ? 0 : 1,
            indices: o
        }
    }
}
const TS = [Hft, OW, qft, Yft, Gft, Kft, Uft, EW], vR = TS.length, Xft = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, Jft = "|";
function Zft(e, t = {}) {
    return e.split(Jft).map(n => {
        let r = n.trim().split(Xft).filter(i => i && !!i.trim()),
        o = [];
        for (let i = 0, s = r.length; i < s; i += 1) {
            const a = r[i];
            let l = !1,
            c = -1;
            for (; !l && ++c < vR; ) {
                const u = TS[c];
                let f = u.isMultiMatch(a);
                f && (o.push(new u(f, t)), l = !0)
            }
            if (!l)
                for (c = -1; ++c < vR; ) {
                    const u = TS[c];
                    let f = u.isSingleMatch(a);
                    if (f) {
                        o.push(new u(f, t));
                        break
                    }
                }
        }
        return o
    })
}
const Qft = new Set([EW.type, OW.type]);
class eht {
    constructor(t, {
        isCaseSensitive: n = At.isCaseSensitive,
        includeMatches: r = At.includeMatches,
        minMatchCharLength: o = At.minMatchCharLength,
        ignoreLocation: i = At.ignoreLocation,
        findAllMatches: s = At.findAllMatches,
        location: a = At.location,
        threshold: l = At.threshold,
        distance: c = At.distance
    } = {}) {
        this.query = null,
        this.options = {
            isCaseSensitive: n,
            includeMatches: r,
            minMatchCharLength: o,
            findAllMatches: s,
            ignoreLocation: i,
            location: a,
            threshold: l,
            distance: c
        },
        this.pattern = n ? t : t.toLowerCase(),
        this.query = Zft(this.pattern, this.options)
    }
    static condition(t, n) {
        return n.useExtendedSearch
    }
    searchIn(t) {
        const n = this.query;
        if (!n)
            return {
                isMatch: !1,
                score: 1
            };
        const {
            includeMatches: r,
            isCaseSensitive: o
        } = this.options;
        t = o ? t : t.toLowerCase();
        let i = 0,
        s = [],
        a = 0;
        for (let l = 0, c = n.length; l < c; l += 1) {
            const u = n[l];
            s.length = 0,
            i = 0;
            for (let f = 0, p = u.length; f < p; f += 1) {
                const m = u[f], {
                    isMatch: v,
                    indices: y,
                    score: b
                } = m.search(t);
                if (v) {
                    if (i += 1, a += b, r) {
                        const w = m.constructor.type;
                        Qft.has(w) ? s = [...s, ...y] : s.push(y)
                    }
                } else {
                    a = 0,
                    i = 0,
                    s.length = 0;
                    break
                }
            }
            if (i) {
                let f = {
                    isMatch: !0,
                    score: a / i
                };
                return r && (f.indices = s),
                f
            }
        }
        return {
            isMatch: !1,
            score: 1
        }
    }
}
const MS = [];
function tht(...e) {
    MS.push(...e)
}
function PS(e, t) {
    for (let n = 0, r = MS.length; n < r; n += 1) {
        let o = MS[n];
        if (o.condition(e, t))
            return new o(e, t)
    }
    return new PW(e, t)
}
const I1 = {
    AND: "$and",
    OR: "$or"
}, ES = {
    PATH: "$path",
    PATTERN: "$val"
}, OS = e => !!(e[I1.AND] || e[I1.OR]), nht = e => !!e[ES.PATH], rht = e => !tl(e) && CW(e) && !OS(e), yR = e => ({
    [I1.AND]: Object.keys(e).map(t => ({
            [t]: e[t]
        }))
});
function $W(e, t, {
    auto: n = !0
} = {}) {
    const r = o => {
        let i = Object.keys(o);
        const s = nht(o);
        if (!s && i.length > 1 && !OS(o))
            return r(yR(o));
        if (rht(o)) {
            const l = s ? o[ES.PATH] : i[0],
            c = s ? o[ES.PATTERN] : o[l];
            if (!ra(c))
                throw new Error(Mft(l));
            const u = {
                keyId: IS(l),
                pattern: c
            };
            return n && (u.searcher = PS(c, t)),
            u
        }
        let a = {
            children: [],
            operator: i[0]
        };
        return i.forEach(l => {
            const c = o[l];
            tl(c) && c.forEach(u => {
                a.children.push(r(u))
            })
        }),
        a
    };
    return OS(e) || (e = yR(e)),
    r(e)
}
function oht(e, {
    ignoreFieldNorm: t = At.ignoreFieldNorm
}) {
    e.forEach(n => {
        let r = 1;
        n.matches.forEach(({
                key: o,
                norm: i,
                score: s
            }) => {
            const a = o ? o.weight : null;
            r *= Math.pow(s === 0 && a ? Number.EPSILON : s, (a || 1) * (t ? 1 : i))
        }),
        n.score = r
    })
}
function iht(e, t) {
    const n = e.matches;
    t.matches = [],
    bi(n) && n.forEach(r => {
        if (!bi(r.indices) || !r.indices.length)
            return;
        const {
            indices: o,
            value: i
        } = r;
        let s = {
            indices: o,
            value: i
        };
        r.key && (s.key = r.key.src),
        r.idx > -1 && (s.refIndex = r.idx),
        t.matches.push(s)
    })
}
function sht(e, t) {
    t.score = e.score
}
function aht(e, t, {
    includeMatches: n = At.includeMatches,
    includeScore: r = At.includeScore
} = {}) {
    const o = [];
    return n && o.push(iht),
    r && o.push(sht),
    e.map(i => {
        const {
            idx: s
        } = i,
        a = {
            item: t[s],
            refIndex: s
        };
        return o.length && o.forEach(l => {
            l(i, a)
        }),
        a
    })
}
class yh {
    constructor(t, n = {}, r) {
        this.options = {
            ...At,
            ...n
        },
        this.options.useExtendedSearch,
        this._keyStore = new $ft(this.options.keys),
        this.setCollection(t, r)
    }
    setCollection(t, n) {
        if (this._docs = t, n && !(n instanceof QT))
            throw new Error(Tft);
        this._myIndex = n || MW(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
        })
    }
    add(t) {
        bi(t) && (this._docs.push(t), this._myIndex.add(t))
    }
    remove(t = () => !1) {
        const n = [];
        for (let r = 0, o = this._docs.length; r < o; r += 1) {
            const i = this._docs[r];
            t(i, r) && (this.removeAt(r), r -= 1, o -= 1, n.push(i))
        }
        return n
    }
    removeAt(t) {
        this._docs.splice(t, 1),
        this._myIndex.removeAt(t)
    }
    getIndex() {
        return this._myIndex
    }
    search(t, {
        limit: n = -1
    } = {}) {
        const {
            includeMatches: r,
            includeScore: o,
            shouldSort: i,
            sortFn: s,
            ignoreFieldNorm: a
        } = this.options;
        let l = ra(t) ? ra(this._docs[0]) ? this._searchStringList(t) : this._searchObjectList(t) : this._searchLogical(t);
        return oht(l, {
            ignoreFieldNorm: a
        }),
        i && l.sort(s),
        SW(n) && n > -1 && (l = l.slice(0, n)),
        aht(l, this._docs, {
            includeMatches: r,
            includeScore: o
        })
    }
    _searchStringList(t) {
        const n = PS(t, this.options), {
            records: r
        } = this._myIndex,
        o = [];
        return r.forEach(({
                v: i,
                i: s,
                n: a
            }) => {
            if (!bi(i))
                return;
            const {
                isMatch: l,
                score: c,
                indices: u
            } = n.searchIn(i);
            l && o.push({
                item: i,
                idx: s,
                matches: [{
                        score: c,
                        value: i,
                        norm: a,
                        indices: u
                    }
                ]
            })
        }),
        o
    }
    _searchLogical(t) {
        const n = $W(t, this.options),
        r = (a, l, c) => {
            if (!a.children) {
                const {
                    keyId: f,
                    searcher: p
                } = a,
                m = this._findMatches({
                    key: this._keyStore.get(f),
                    value: this._myIndex.getValueForItemAtKeyId(l, f),
                    searcher: p
                });
                return m && m.length ? [{
                        idx: c,
                        item: l,
                        matches: m
                    }
                ] : []
            }
            const u = [];
            for (let f = 0, p = a.children.length; f < p; f += 1) {
                const m = a.children[f],
                v = r(m, l, c);
                if (v.length)
                    u.push(...v);
                else if (a.operator === I1.AND)
                    return []
            }
            return u
        },
        o = this._myIndex.records,
        i = {},
        s = [];
        return o.forEach(({
                $: a,
                i: l
            }) => {
            if (bi(a)) {
                let c = r(n, a, l);
                c.length && (i[l] || (i[l] = {
                            idx: l,
                            item: a,
                            matches: []
                        }, s.push(i[l])), c.forEach(({
                            matches: u
                        }) => {
                        i[l].matches.push(...u)
                    }))
            }
        }),
        s
    }
    _searchObjectList(t) {
        const n = PS(t, this.options), {
            keys: r,
            records: o
        } = this._myIndex,
        i = [];
        return o.forEach(({
                $: s,
                i: a
            }) => {
            if (!bi(s))
                return;
            let l = [];
            r.forEach((c, u) => {
                l.push(...this._findMatches({
                        key: c,
                        value: s[u],
                        searcher: n
                    }))
            }),
            l.length && i.push({
                idx: a,
                item: s,
                matches: l
            })
        }),
        i
    }
    _findMatches({
        key: t,
        value: n,
        searcher: r
    }) {
        if (!bi(n))
            return [];
        let o = [];
        if (tl(n))
            n.forEach(({
                    v: i,
                    i: s,
                    n: a
                }) => {
                if (!bi(i))
                    return;
                const {
                    isMatch: l,
                    score: c,
                    indices: u
                } = r.searchIn(i);
                l && o.push({
                    score: c,
                    key: t,
                    value: i,
                    idx: s,
                    norm: a,
                    indices: u
                })
            });
        else {
            const {
                v: i,
                n: s
            } = n, {
                isMatch: a,
                score: l,
                indices: c
            } = r.searchIn(i);
            a && o.push({
                score: l,
                key: t,
                value: i,
                norm: s,
                indices: c
            })
        }
        return o
    }
}
yh.version = "6.6.2";
yh.createIndex = MW;
yh.parseIndex = Fft;
yh.config = At;
yh.parseQuery = $W;
tht(eht);
const lht = {
    shouldSort: !0,
    isCaseSensitive: !1,
    minMatchCharLength: 0
}, cht = (e, t = "name") => {
    const n = [];
    return e.filter(o => n.includes(o[t]) ? !1 : (n.push(o[t]), !0))
}, uht = ({
    availablePortTypes: e,
    typeIds: t,
    suggestedTypeIds: n = [],
    showHidden: r = !1
}) => {
    const i = n.map(ri(e, !1)),
    s = t.map(ri(e, !1)).sort((c, u) => c.name.localeCompare(u.name)),
    a = cht(i.concat(s).filter(c => r || !c.hidden)),
    l = new yh(a, {
        keys: ["name"],
        ...lht
    });
    return function (u = "", f) {
        return u === "" ? a : l.search(u, f).map(m => m.item)
    }
};
const dht = {
    components: {
        FunctionButton: ti,
        CloseIcon: qu,
        LensIcon: O9
    },
    props: {
        modelValue: {
            type: String,
        default:
            ""
        },
        placeholder: {
            type: String,
        default:
            null
        }
    },
    emits: ["clear", "update:modelValue"],
    expose: ["focus"],
    methods: {
        clearSearch() {
            this.$emit("clear"),
            this.$emit("update:modelValue", ""),
            this.$refs.searchInput.focus()
        },
        focus() {
            this.$refs.searchInput.focus()
        }
    }
}, fht = {
    id: "node-search",
    class: "node-search"
}, hht = {
    class: "lens-icon"
}, pht = ["value", "placeholder"];
function mht(e, t, n, r, o, i) {
    const s = B("LensIcon"),
    a = B("CloseIcon"),
    l = B("FunctionButton");
    return _(),
    O("div", fht, [P("div", hht, [z(s)]), P("input", {
                ref: "searchInput",
                value: n.modelValue,
                placeholder: n.placeholder,
                type: "text",
                onInput: t[0] || (t[0] = c => e.$emit("update:modelValue", c.target.value))
            }, null, 40, pht), z(l, {
                class: "clear-search",
                "data-test-clear-search": "",
                onClick: i.clearSearch
            }, {
            default:
                oe(() => [z(a)]),
                _: 1
            }, 8, ["onClick"])])
}
const ght = te(dht, [["render", mht], ["__scopeId", "data-v-ed2cc348"]]), vht = (e, t) => e[t].supportedPortTypeIds.length === 1, yht = 20, wht = Fe({
    components: {
        FloatingMenu: qw,
        MenuItems: cT,
        SearchBar: ght,
        ReturnIcon: _ft
    },
    props: {
        position: {
            type: Object,
            required: !0,
            validator: e => typeof e.x == "number" && typeof e.y == "number"
        },
        side: {
            type: String,
            required: !0,
            validator: e => ["input", "output"].includes(e)
        },
        portGroups: {
            type: Object,
        default:
            null
        }
    },
    emits: ["itemClick", "itemActive", "menuClose"],
    data: () => ({
        searchQuery: "",
        selectedPortGroup: null,
        ariaActiveDescendant: null
    }),
    computed: {
        ...ut("canvas", ["zoomFactor"]),
        ...ut("application", ["availablePortTypes", "suggestedPortTypes"]),
        headerMargin() {
            return `${this.$shapes.portSize * Math.pow(this.zoomFactor, .8) + 1}px`
        },
        headerText() {
            return this.portGroups && !this.selectedPortGroup ? "Select port group" : `Add ${this.side === "input" ? "Input" : "Output"} Port`
        },
        adjustedPosition() {
            const e = this.zoomFactor > 1 ? this.$shapes.portSize / 2 * Math.log(this.zoomFactor) / 1.2 : 0;
            return {
                y: this.position.y + e,
                x: this.position.x
            }
        },
        searchPortsFunction() {
            const e = this.portTypesInSelectedGroup ? this.portTypesInSelectedGroup : Object.keys(this.availablePortTypes),
            t = this.portTypesInSelectedGroup ? this.suggestedPortTypes.filter(n => this.portTypesInSelectedGroup.includes(n)) : this.suggestedPortTypes;
            return uht({
                typeIds: e,
                availablePortTypes: this.availablePortTypes,
                suggestedTypeIds: t
            })
        },
        searchResults() {
            return this.searchPortsFunction(this.searchQuery)
        },
        sidePortGroups() {
            return this.portGroups ? Object.entries(this.portGroups).filter(([e, t]) => this.side === "input" ? t.canAddInPort : t.canAddOutPort) : null
        },
        menuItems() {
            return this.portGroups && !this.selectedPortGroup ? this.sidePortGroups.map(([e]) => ({
                    text: e
                })) : this.searchResults.map(({
                    typeId: e,
                    name: t
                }) => ({
                    port: {
                        typeId: e
                    },
                    text: t,
                    icon: km({
                        typeId: e
                    }),
                    title: t.length > yht ? t : null
                }))
        },
        portTypesInSelectedGroup() {
            return !this.portGroups || !this.selectedPortGroup ? null : this.portGroups[this.selectedPortGroup].supportedPortTypeIds
        },
        shouldDisplaySearchBar() {
            return this.portGroups ? Boolean(this.selectedPortGroup) : !0
        }
    },
    watch: {
        portGroups: {
            immediate: !0,
            handler() {
                if (this.sidePortGroups?.length === 1) {
                    const [e] = this.sidePortGroups[0];
                    this.selectedPortGroup = e
                }
            }
        }
    },
    mounted() {
        this.$refs.searchBar?.focus()
    },
    methods: {
        emitPortClick({
            typeId: e,
            portGroup: t
        }) {
            this.$emit("itemClick", {
                typeId: e,
                portGroup: t
            }),
            this.$emit("menuClose", {
                typeId: e,
                portGroup: t
            })
        },
        onMenuItemClick(e, t) {
            if (t.port) {
                const {
                    typeId: n
                } = t.port;
                this.emitPortClick({
                    typeId: n,
                    portGroup: this.selectedPortGroup
                })
            } else {
                if (vht(this.portGroups, t.text)) {
                    const [n] = this.portGroups[t.text].supportedPortTypeIds;
                    this.emitPortClick({
                        typeId: n,
                        portGroup: t.text
                    });
                    return
                }
                this.selectedPortGroup = t.text
            }
        },
        onSearchBarKeyDown(e) {
            const t = this.$refs.searchResults;
            t && t.onKeydown(e)
        },
        setActiveDescendant(e, t) {
            this.ariaActiveDescendant = e === null ? void 0 : e,
            this.$emit("itemActive", t)
        }
    }
});
const bht = {
    class: "search"
}, _ht = {
    key: 2,
    class: "placeholder"
};
function kht(e, t, n, r, o, i) {
    const s = B("ReturnIcon"),
    a = B("SearchBar"),
    l = B("MenuItems"),
    c = B("FloatingMenu");
    return _(),
    H(c, {
        ref: "floatingMenu",
        anchor: e.side === "input" ? "top-right" : "top-left",
        "canvas-position": e.adjustedPosition,
        onMenuClose: t[3] || (t[3] = u => e.$emit("menuClose"))
    }, {
    default:
        oe(() => [P("div", {
                    class: he(["header", e.side]),
                    style: Yt({
                        "--margin": e.headerMargin
                    })
                }, Re(e.headerText), 7), e.selectedPortGroup && Object.keys(e.sidePortGroups).length > 1 ? (_(), O("div", {
                        key: 0,
                        class: "return-button",
                        onClick: t[0] || (t[0] = u => e.selectedPortGroup = null)
                    }, [z(s)])) : J("", !0), P("div", bht, [e.shouldDisplaySearchBar ? (_(), H(a, {
                                key: 0,
                                ref: "searchBar",
                                modelValue: e.searchQuery,
                                "onUpdate:modelValue": t[1] || (t[1] = u => e.searchQuery = u),
                                placeholder: "Search port type",
                                class: "search-bar",
                                "aria-owns": e.ariaActiveDescendant,
                                "aria-activedescendant": e.ariaActiveDescendant,
                                onKeydown: e.onSearchBarKeyDown
                            }, null, 8, ["modelValue", "aria-owns", "aria-activedescendant", "onKeydown"])) : J("", !0), e.searchResults.length ? (_(), H(l, {
                                key: 1,
                                ref: "searchResults",
                                items: e.menuItems,
                                class: "search-results",
                                "menu-aria-label": "Port Type Menu",
                                "disable-space-to-click": "",
                                onItemClick: e.onMenuItemClick,
                                onItemHovered: t[2] || (t[2] = u => e.$emit("itemActive", u)),
                                onItemFocused: e.setActiveDescendant
                            }, null, 8, ["items", "onItemClick", "onItemFocused"])) : (_(), O("div", _ht, "No port matching"))])]),
        _: 1
    }, 8, ["anchor", "canvas-position"])
}
const xht = te(wht, [["render", kht], ["__scopeId", "data-v-29626def"]]), Sht = {
    components: {
        PortIcon: k7,
        NodeTorsoNormal: xF
    },
    props: {
        type: {
            type: String,
        default:
            null
        },
        isComponent: {
            type: Boolean,
        default:
            !1
        },
        inPorts: {
            type: Array,
        default:
            () => []
        },
        outPorts: {
            type: Array,
        default:
            () => []
        },
        hasDynPorts: {
            type: Boolean,
        default:
            !1
        },
        icon: {
            type: String,
        default:
            null,
            validator: e => e.startsWith("data:image/")
        }
    },
    data() {
        return {
            viewBox: "-19 -19 70 70"
        }
    },
    methods: {
        yPortShift(e, t) {
            let o = 1;
            t === 2 ? o = 12 : t === 3 && (o = 1.5);
            let s = (32 - (t * 9 + (t - 1) * o)) / 2;
            return (o + 9) * e + s + 9 / 2
        }
    }
}, Cht = ["viewBox"], Iht = {
    key: 0,
    stroke: "none"
}, Tht = P("circle", {
    r: "1.2",
    cx: "4",
    cy: "27"
}, null, -1), Mht = P("circle", {
    r: "1.2",
    cx: "9",
    cy: "27"
}, null, -1), Pht = P("circle", {
    r: "1.2",
    cx: "14",
    cy: "27"
}, null, -1), Eht = [Tht, Mht, Pht];
function Oht(e, t, n, r, o, i) {
    const s = B("NodeTorsoNormal"),
    a = B("PortIcon");
    return _(),
    O("svg", {
        viewBox: o.viewBox
    }, [z(s, {
                type: n.type,
                icon: n.icon,
                "is-component": n.isComponent
            }, null, 8, ["type", "icon", "is-component"]), (_(!0), O(Le, null, $t(n.inPorts, (l, c) => (_(), H(a, {
                                key: `in-${c}`,
                                color: l.color,
                                filled: !l.optional,
                                type: l.type,
                                transform: `translate(-4.5, ${i.yPortShift(c, n.inPorts.length)})`
                            }, null, 8, ["color", "filled", "type", "transform"]))), 128)), (_(!0), O(Le, null, $t(n.outPorts, (l, c) => (_(), H(a, {
                                key: `out-${c}`,
                                color: l.color,
                                filled: !l.optional,
                                type: l.type,
                                transform: `translate(36.5, ${i.yPortShift(c, n.outPorts.length)})`
                            }, null, 8, ["color", "filled", "type", "transform"]))), 128)), n.hasDynPorts ? (_(), O("g", Iht, Eht)) : J("", !0)], 8, Cht)
}
const $ht = te(Sht, [["render", Oht]]), Aht = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Dht = P("path", {
    d: "M21.56 9.24H10.44c-.66 0-1.2.54-1.2 1.2v11.12c0 .66.54 1.2 1.2 1.2h11.12c.66 0 1.2-.54 1.2-1.2V10.44c0-.66-.54-1.2-1.2-1.2zM12.547 16h6.906M16 12.547v6.906"
}, null, -1), Nht = P("circle", {
    cx: "16",
    cy: "16",
    r: "14.362",
    "stroke-dasharray": "1.0024 4.0097",
    transform: "rotate(-67.543 15.999 16)"
}, null, -1), Rht = P("path", {
    "stroke-linecap": "square",
    "stroke-width": "1.1",
    d: "M4.15 7.8h0M7.7 4.25h0M12.2 2.2h0M17.1 1.7h0M21.9 2.9h0M26.05 5.75h0M28.9 9.8h0M28.9 9.8h0M30.3 14.6h0M29.9 19.6h0M27.9 24.1h0M24.4 27.7h0M19.8 29.9h0M14.9 30.3h0M10 29.1h0M5.9 26.3h0M3.1 22.2h0M1.7 17.4h0M2.1 12.4h0"
}, null, -1), Lht = [Dht, Nht, Rht];
function Bht(e, t) {
    return _(),
    O("svg", Aht, Lht)
}
const AW = {
    render: Bht
}, Vht = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, Fht = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), jht = P("path", {
    d: "M16 19.5s-.2-2.1 2-3.8c1-.8 1.4-1.7 1.4-2.8 0-1.9-1.5-3.5-3.4-3.5s-3.4 1.5-3.4 3.4"
}, null, -1), Wht = P("path", {
    "stroke-linecap": "round",
    "stroke-width": "1.6",
    d: "M16 22.2h0"
}, null, -1), zht = [Fht, jht, Wht];
function Hht(e, t) {
    return _(),
    O("svg", Vht, zht)
}
const Uht = {
    render: Hht
}, qht = Fe({
    __name: "NodeTemplateHelpIcon",
    props: {
        isSelected: {
            type: Boolean
        },
        isHovered: {
            type: Boolean
        }
    },
    emits: ["helpIconClick"],
    setup(e, {
        emit: t
    }) {
        return (n, r) => (_(), H(ti, {
                class: he(["description-icon", {
                            "selected-icon": n.isSelected,
                            "hovered-icon": n.isHovered
                        }
                    ]),
                onClick: r[0] || (r[0] = o => t("helpIconClick")),
                onDblclick: r[1] || (r[1] = ve(() => {}, ["stop"]))
            }, {
            default:
                oe(() => [z(ke(Uht), {
                            class: "info-icon"
                        })]),
                _: 1
            }, 8, ["class"]))
    }
});
const DW = te(qht, [["__scopeId", "data-v-cb6adcaa"]]), Yht = ["title"], Kht = {
    class: "name-icon-wrapper"
}, Ght = {
    class: "name"
}, Xht = {
    class: "node-preview"
}, Jht = {
    class: "extension-info"
}, Zht = Fe({
    __name: "NodeTemplateIconMode",
    props: {
        nodeTemplate: {},
        isHovered: {
            type: Boolean
        },
        displayMode: {
        default:
            "icon"
        },
        showFloatingHelpIcon: {
            type: Boolean,
        default:
            !1
        },
        isSelected: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["helpIconClick"],
    setup(e, {
        emit: t
    }) {
        const n = e,
        r = ne(() => n.nodeTemplate.extension ? `
———
${n.nodeTemplate.extension.name}
by ${n.nodeTemplate.extension.vendor.name}` : "");
        return (o, i) => (_(), O("div", {
                class: "display-icon",
                title: `${o.nodeTemplate.name}${r.value}`
            }, [P("div", Kht, [P("span", Ght, Re(o.nodeTemplate.name), 1), P("div", Xht, [Ye(o.$slots, "node-preview", {}, void 0, !0)])]), o.showFloatingHelpIcon ? (_(), H(DW, {
                            key: 0,
                            class: "help-icon",
                            "is-selected": o.isSelected,
                            "is-hovered": o.isHovered,
                            onHelpIconClick: i[0] || (i[0] = s => t("helpIconClick"))
                        }, null, 8, ["is-selected", "is-hovered"])) : J("", !0), P("div", Jht, [o.nodeTemplate.extension && !o.nodeTemplate.extension.vendor?.isKNIME ? (_(), H(ke(AW), {
                                    key: 0,
                                    class: "extension-community-icon"
                                })) : J("", !0)])], 8, Yht))
    }
});
const Qht = te(Zht, [["__scopeId", "data-v-7bf3069d"]]), ept = ["title"], tpt = {
    class: "node-preview"
}, npt = {
    class: "content"
}, rpt = {
    class: "node-name"
}, opt = Fe({
    __name: "NodeTemplateListMode",
    props: {
        nodeTemplate: {},
        isHovered: {
            type: Boolean
        },
        displayMode: {
        default:
            "icon"
        },
        showFloatingHelpIcon: {
            type: Boolean,
        default:
            !1
        },
        isSelected: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["helpIconClick"],
    setup(e, {
        emit: t
    }) {
        return (n, r) => (_(), O("div", {
                class: "display-list",
                title: n.nodeTemplate.extension ? `${n.nodeTemplate.extension.name}
by “${n.nodeTemplate.extension.vendor.name}”` : null
            }, [P("div", tpt, [Ye(n.$slots, "node-preview", {}, void 0, !0)]), P("div", npt, [P("span", rpt, Re(n.nodeTemplate.name), 1)]), n.nodeTemplate.extension?.vendor?.isKNIME ? J("", !0) : (_(), H(ke(AW), {
                            key: 0,
                            class: "extension-community-icon"
                        })), n.showFloatingHelpIcon ? (_(), H(DW, {
                            key: 1,
                            class: "help-icon",
                            "is-selected": n.isSelected,
                            "is-hovered": n.isHovered,
                            onHelpIconClick: r[0] || (r[0] = o => t("helpIconClick"))
                        }, null, 8, ["is-selected", "is-hovered"])) : J("", !0)], 8, ept))
    }
});
const ipt = te(opt, [["__scopeId", "data-v-6a992f50"]]), spt = Fe({
    __name: "NodeTemplate",
    props: {
        nodeTemplate: {},
        displayMode: {
        default:
            "icon"
        },
        isSelected: {
            type: Boolean,
        default:
            !1
        },
        isHighlighted: {
            type: Boolean,
        default:
            !1
        },
        showFloatingHelpIcon: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["helpIconClick"],
    setup(e, {
        expose: t,
        emit: n
    }) {
        const r = e;
        to(u => ({
                "12d190b1": u.$shapes.selectedNodeStrokeWidth,
                "6402d98c": u.$shapes.selectedItemBorderRadius,
                "0fd0dbf6": u.$colors.selection.activeBorder,
                "076fc7f8": u.$colors.selection.activeBackground
            }));
        const o = De(!1),
        i = () => {
            o.value = !0
        },
        s = () => {
            o.value = !1
        },
        a = ne(() => r.displayMode === "icon" ? Qht : ipt),
        l = De(null);
        return t({
            getNodePreview: () => l.value
        }),
        (u, f) => (_(), H(Kt(a.value), {
                class: he(["node", {
                            selected: u.isSelected && !u.showFloatingHelpIcon,
                            highlighted: u.isHighlighted,
                            grabbable: u.showFloatingHelpIcon
                        }
                    ]),
                "node-template": u.nodeTemplate,
                "is-hovered": o.value,
                "display-mode": u.displayMode,
                "is-highlighted": u.isHighlighted,
                "show-floating-help-icon": u.showFloatingHelpIcon,
                "is-selected": u.isSelected,
                onPointerenter: i,
                onPointerleave: s,
                onHelpIconClick: f[0] || (f[0] = p => n("helpIconClick"))
            }, {
                "node-preview": oe(() => [z($ht, {
                            ref_key: "nodePreview",
                            ref: l,
                            type: u.nodeTemplate.type,
                            "in-ports": u.nodeTemplate.inPorts,
                            "out-ports": u.nodeTemplate.outPorts,
                            icon: u.nodeTemplate.icon
                        }, null, 8, ["type", "in-ports", "out-ports", "icon"])]),
                _: 1
            }, 40, ["class", "node-template", "is-hovered", "display-mode", "is-highlighted", "show-floating-help-icon", "is-selected"]))
    }
});
const eM = te(spt, [["__scopeId", "data-v-a50c3a63"]]), apt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, lpt = P("path", {
    d: "m20.85 11.47 7.14-7.65H2.09L12.35 15.1v12.34l2.27-1.42M18.3 21l3.33 3.09 5.13-6.08"
}, null, -1), cpt = P("circle", {
    cx: "22.45",
    cy: "21",
    r: "7.46"
}, null, -1), upt = [lpt, cpt];
function dpt(e, t) {
    return _(),
    O("svg", apt, upt)
}
const fpt = {
    render: dpt
};
const hpt = 100, ppt = {
    props: {
        initialPosition: {
            type: Number,
        default:
            0
        }
    },
    emits: ["savePosition", "scrollBottom"],
    data() {
        return {
            scrollPosition: this.initialPosition,
            lastScrollHeight: 0
        }
    },
    mounted() {
        this.$refs.scroller.scrollTop = this.initialPosition
    },
    beforeUnmount() {
        this.$emit("savePosition", this.scrollPosition)
    },
    methods: {
        onScroll: Za.throttle(function () {
            const {
                scroller: e
            } = this.$refs, {
                scrollTop: t,
                scrollHeight: n
            } = e;
            let r = e.getBoundingClientRect().height;
            this.scrollPosition = t;
            let o = n - t - r,
            i = n / 4;
            n > this.lastScrollHeight && o <= i && (this.lastScrollHeight = n, consola.debug("ScrollViewContainer: reached bottom boundary"), this.$emit("scrollBottom"))
        }, hpt)
    }
};
function mpt(e, t, n, r, o, i) {
    return _(),
    O("div", {
        ref: "scroller",
        class: "scroll-container",
        onScrollPassive: t[0] || (t[0] = (...s) => i.onScroll && i.onScroll(...s))
    }, [Ye(e.$slots, "default", {}, void 0, !0)], 544)
}
const gpt = te(ppt, [["render", mpt], ["__scopeId", "data-v-8709b135"]]), vpt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, ypt = P("circle", {
    cx: "16",
    cy: "16",
    r: "13"
}, null, -1), wpt = P("path", {
    d: "m16.6 9.2 6.8 6.8-6.8 6.8m6.8-6.8h-15"
}, null, -1), bpt = [ypt, wpt];
function _pt(e, t) {
    return _(),
    O("svg", vpt, bpt)
}
const kpt = {
    render: _pt
}, xpt = 3, Spt = 1, tM = Fe({
    components: {
        Button: Pr,
        CircleArrowIcon: kpt,
        NodeTemplate: eM
    },
    props: {
        nodes: {
            type: Array,
        default:
            () => []
        },
        hasMoreNodes: {
            type: Boolean,
        default:
            !1
        },
        displayMode: {
            type: String,
        default:
            "icon"
        },
        selectedNode: {
            type: [Object, null],
        default:
            null
        },
        highlightFirst: {
            type: Boolean,
        default:
            !1
        }
    },
    emits: ["enter-key", "showMore", "update:selectedNode", "navReachedTop", "navReachedEnd"],
    computed: {
        nodesPerRow() {
            return this.displayMode === "icon" ? xpt : Spt
        }
    },
    watch: {
        selectedNode: {
            immediate: !1,
            handler(e) {
                if (!e || !this.nodes)
                    return;
                const t = this.nodes.findIndex(n => n.id === e?.id);
                t >= 0 && this.domFocusNode(t)
            }
        }
    },
    expose: ["focusFirst", "focusLast"],
    methods: {
        nodeTemplateProps(e, t) {
            return {
                nodeTemplate: e,
                isHighlighted: this.selectedNode === null && t === 0 && this.highlightFirst,
                isSelected: this.selectedNode?.id === e.id,
                displayMode: this.displayMode
            }
        },
        focusLast() {
            this.focusItem(this.nodes?.at(-1))
        },
        focusFirst() {
            this.focusItem(this.nodes?.at(0))
        },
        focusItem(e) {
            e && !this.nodes.find(t => t.id === this.selectedNode?.id) && this.$emit("update:selectedNode", e)
        },
        domFocusNode(e) {
            this.$el.querySelector(`[data-index="${e}"]`)?.focus()
        },
        onKeyDown(e) {
            if (this.nodes.length < 1)
                return;
            const t = this.nodes.findIndex(r => r.id === this.selectedNode?.id);
            if (t < this.nodesPerRow && e === "up") {
                this.$emit("navReachedTop");
                return
            }
            if (t + this.nodesPerRow > this.nodes.length && e === "down") {
                this.$emit("navReachedEnd");
                return
            }
            const n = r => {
                const o = t + r;
                if (o >= this.nodes.length) {
                    this.$emit("navReachedEnd");
                    return
                }
                const i = this.nodes[o];
                i && this.$emit("update:selectedNode", i)
            };
            if (e === "up") {
                n(this.nodesPerRow * -1);
                return
            }
            if (e === "down") {
                n(this.nodesPerRow);
                return
            }
            if (e === "left") {
                n(-1);
                return
            }
            e === "right" && n(1)
        }
    }
}), wR = () => {
    to(e => ({
            "1df2ab09": e.nodesPerRow
        }))
}, bR = tM.setup;
tM.setup = bR ? (e, t) => (wR(), bR(e, t)) : wR;
const Cpt = e => (ir("data-v-3f695240"), e = e(), sr(), e), Ipt = {
    class: "nodes-container"
}, Tpt = ["data-index", "onKeydown"], Mpt = Cpt(() => P("br", null, null, -1));
function Ppt(e, t, n, r, o, i) {
    const s = B("NodeTemplate"),
    a = B("CircleArrowIcon"),
    l = B("Button");
    return _(),
    O("div", Ipt, [P("ul", {
                ref: "list",
                class: he(["nodes", `display-${e.displayMode}`]),
                tabindex: "-1",
                onKeydown: [t[1] || (t[1] = Rt(ve(c => e.onKeyDown("left"), ["stop"]), ["left"])), t[2] || (t[2] = Rt(ve(c => e.onKeyDown("up"), ["stop", "prevent"]), ["up"])), t[3] || (t[3] = Rt(ve(c => e.onKeyDown("down"), ["stop", "prevent"]), ["down"])), t[4] || (t[4] = Rt(ve(c => e.onKeyDown("right"), ["stop"]), ["right"]))]
            }, [(_(!0), O(Le, null, $t(e.nodes, (c, u) => (_(), O("li", {
                                        key: c.id,
                                        tabindex: "-1",
                                        "data-index": u,
                                        onKeydown: Rt(ve(f => e.$emit("enter-key", c), ["stop", "prevent"]), ["enter"])
                                    }, [Ye(e.$slots, "item", wu(tc(e.nodeTemplateProps(c, u))), () => [z(s, wu(tc(e.nodeTemplateProps(c, u))), null, 16)], !0)], 40, Tpt))), 128)), P("li", null, [e.hasMoreNodes ? (_(), H(l, {
                                    key: 0,
                                    compact: "",
                                    "without-border": "",
                                    class: "show-more",
                                    onClick: t[0] || (t[0] = c => e.$emit("showMore"))
                                }, {
                                default:
                                    oe(() => [Ye(e.$slots, "more-button", {}, void 0, !0), Mpt, z(a, {
                                                class: "icon"
                                            })]),
                                    _: 3
                                })) : J("", !0)])], 34)])
}
const NW = te(tM, [["render", Ppt], ["__scopeId", "data-v-3f695240"]]), RW = e => (ir("data-v-394c22dc"), e = e(), sr(), e), Ept = {
    class: "content"
}, Opt = {
    key: 0,
    class: "node-list-wrapper"
}, $pt = {
    key: 1,
    class: "filtered-nodes-wrapper"
}, Apt = {
    class: "filtered-nodes-content"
}, Dpt = RW(() => P("span", null, "Change filter settings to “All nodes“ to see more advanced nodes matching your search criteria.", -1)), Npt = {
    key: 2,
    class: "filtered-nodes-wrapper"
}, Rpt = {
    class: "filtered-nodes-content"
}, Lpt = RW(() => P("span", null, "There are no matching nodes.", -1)), Bpt = ["href"], Vpt = Fe({
    __name: "SearchResults",
    props: {
        nodes: {},
        query: {},
        selectedTags: {
        default:
            () => []
        },
        searchScrollPosition: {
        default:
            0
        },
        selectedNode: {},
        searchActions: {},
        numFilteredOutNodes: {},
        highlightFirst: {
            type: Boolean,
        default:
            !1
        },
        displayMode: {
        default:
            "icon"
        }
    },
    emits: ["navReachedTop", "update:searchScrollPosition", "update:selectedNode", "itemEnterKey", "openPreferences"],
    setup(e, {
        expose: t,
        emit: n
    }) {
        const r = e, {
            nodes: o,
            selectedNode: i,
            query: s,
            selectedTags: a,
            searchActions: l
        } = nl(r);
        let c = De(!1);
        const u = ne(() => o.value?.length === 0),
        f = ne({
            get() {
                return i.value
            },
            set(C) {
                n("update:selectedNode", C)
            }
        }),
        p = ne(() => `https://hub.knime.com/search?q=${encodeURIComponent(s.value)}&type=all&src=knimeappmodernui`),
        m = C => {
            n("update:searchScrollPosition", C)
        },
        v = De(null),
        y = async() => {
            await Ci(),
            v.value && (v.value.$el.scrollTop = 0)
        },
        b = () => {
            c.value = !0,
            l.value.searchNodesNextPage().then(() => {
                c.value = !1
            })
        },
        w = De(null),
        k = () => {
            w.value?.focusFirst()
        };
        return Ht(s, y),
        Ht(a, y),
        t({
            focusFirst: k
        }),
        (C, x) => (_(), H(gpt, {
                ref_key: "scroller",
                ref: v,
                class: "results",
                "initial-position": C.searchScrollPosition,
                onSavePosition: m,
                onScrollBottom: b
            }, {
            default:
                oe(() => [P("div", Ept, [u.value ? J("", !0) : (_(), O("div", Opt, [z(NW, {
                                                ref_key: "nodeList",
                                                ref: w,
                                                "selected-node": f.value,
                                                "onUpdate:selectedNode": x[0] || (x[0] = S => f.value = S),
                                                nodes: ke(o),
                                                "highlight-first": C.highlightFirst,
                                                "display-mode": C.displayMode,
                                                onNavReachedTop: x[1] || (x[1] = S => n("navReachedTop")),
                                                onEnterKey: x[2] || (x[2] = S => n("itemEnterKey", S))
                                            }, {
                                                item: oe(S => [Ye(C.$slots, "nodesTemplate", wu(tc(S)), void 0, !0)]),
                                                _: 3
                                            }, 8, ["selected-node", "nodes", "highlight-first", "display-mode"]), ke(c) ? (_(), H(ke(cg), {
                                                    key: 0,
                                                    class: "loading-indicator"
                                                })) : J("", !0)])), C.numFilteredOutNodes > 0 ? (_(), O("div", $pt, [z(ke(Dk), {
                                                class: "info-icon"
                                            }), P("div", Apt, [Dpt, z(Pr, {
                                                        primary: "",
                                                        compact: "",
                                                        class: "filtered-nodes-button",
                                                        onClick: x[3] || (x[3] = S => n("openPreferences"))
                                                    }, {
                                                    default:
                                                        oe(() => [z(ke(fpt)), mt("Change filter settings ")]),
                                                        _: 1
                                                    })])])) : u.value ? (_(), O("div", Npt, [z(ke(Dk), {
                                                class: "info-icon"
                                            }), P("div", Rpt, [Lpt, P("span", null, [mt("Search the "), P("a", {
                                                                href: p.value
                                                            }, "KNIME Community Hub", 8, Bpt), mt(" to find more nodes and extensions.")])])])) : J("", !0)])]),
                _: 3
            }, 8, ["initial-position"]))
    }
});
const Fpt = te(Vpt, [["__scopeId", "data-v-394c22dc"]]), jpt = Fe({
    components: {
        SearchResults: Fpt,
        NodeTemplate: eM
    },
    props: {
        selectedNode: {
            type: [Object, null],
            required: !0
        },
        displayMode: {
            type: String,
        default:
            "icon"
        }
    },
    emits: ["update:selectedNode", "addNode"],
    expose: ["focusFirst"],
    computed: {
        ...ut("quickAddNodes", ["nodes", "query", "totalNumFilteredNodesFound"]),
        searchActions() {
            return {
                searchNodesNextPage: this.searchNodesNextPage
            }
        }
    },
    methods: {
        ...Er("quickAddNodes", ["searchNodesNextPage"]),
        focusFirst() {
            return this.$refs.searchResults?.focusFirst()
        }
    }
});
function Wpt(e, t, n, r, o, i) {
    const s = B("NodeTemplate"),
    a = B("SearchResults");
    return _(),
    H(a, {
        ref: "searchResults",
        query: e.query,
        "search-actions": e.searchActions,
        "highlight-first": !0,
        "selected-node": e.selectedNode,
        "display-mode": e.displayMode,
        nodes: e.nodes,
        "num-filtered-out-nodes": e.totalNumFilteredNodesFound,
        "onUpdate:selectedNode": t[0] || (t[0] = l => e.$emit("update:selectedNode", l)),
        onItemEnterKey: t[1] || (t[1] = l => e.$emit("addNode", l))
    }, {
        nodesTemplate: oe(l => [z(s, Bt(l, {
                        onClick: c => e.$emit("addNode", l.nodeTemplate)
                    }), null, 16, ["onClick"])]),
        _: 1
    }, 8, ["query", "search-actions", "selected-node", "display-mode", "nodes", "num-filtered-out-nodes"])
}
const zpt = te(jpt, [["render", Wpt]]), Hpt = Fe({
    components: {
        NodeList: NW,
        NodeTemplate: eM
    },
    props: {
        selectedNode: {
            type: [Object, null],
            required: !0
        },
        disableRecommendations: {
            type: Boolean,
        default:
            !1
        },
        displayMode: {
            type: String,
        default:
            "icon"
        }
    },
    emits: ["update:selectedNode", "addNode", "navReachedTop"],
    expose: ["focusFirst"],
    computed: {
        ...ut("quickAddNodes", ["recommendedNodes"]),
        hasRecommendations() {
            return this.recommendedNodes?.length > 0
        }
    },
    methods: {
        focusFirst() {
            return this.$refs.recommendationResults?.focusFirst()
        }
    }
});
const Upt = {
    class: "recommendations"
}, qpt = {
    key: 1,
    class: "no-recommendations-message"
}, Ypt = P("br", null, null, -1), Kpt = {
    key: 2,
    class: "no-recommendations-message"
};
function Gpt(e, t, n, r, o, i) {
    const s = B("NodeTemplate"),
    a = B("NodeList");
    return _(),
    O("div", Upt, [e.hasRecommendations ? (_(), H(a, {
                    key: 0,
                    ref: "recommendationResults",
                    "selected-node": e.selectedNode,
                    nodes: e.recommendedNodes,
                    "display-mode": e.displayMode,
                    "highlight-first": !0,
                    onNavReachedTop: t[0] || (t[0] = l => e.$emit("navReachedTop")),
                    onEnterKey: t[1] || (t[1] = l => e.$emit("addNode", l)),
                    "onUpdate:selectedNode": t[2] || (t[2] = l => e.$emit("update:selectedNode", l))
                }, {
                    item: oe(l => [z(s, Bt(l, {
                                    onClick: c => e.$emit("addNode", l.nodeTemplate)
                                }), null, 16, ["onClick"])]),
                    _: 1
                }, 8, ["selected-node", "nodes", "display-mode"])) : e.disableRecommendations ? (_(), O("span", qpt, [mt(" There are no recommendations."), Ypt, mt(" Search to add compatible nodes. ")])) : (_(), O("span", Kpt, " The Workflow Coach cannot recommend any nodes to you yet. "))])
}
const Xpt = te(Hpt, [["render", Gpt]]), Jpt = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "316",
    height: "61",
    fill: "none"
}, Zpt = iC('<rect width="32" height="32" x="34" y="21" fill="#FFD800" rx="1"></rect><path fill="#000" d="m34 37-9 4.5v-9l9 4.5Zm41 0-9 4.5v-9l9 4.5Z"></path><path fill="#fff" d="M46 34h7v7h-7z"></path><path fill="#fff" stroke="#3E3A39" d="M46.5 34.5h6v6h-6z"></path><path stroke="#201E1E" d="M44.5 34v8.5H53M44.5 29v2"></path><path stroke="#201E1E" d="M42 32.5h12.5V45m1.5-2.5h2m-13.5 0 12-12"></path><rect width="32" height="32" x="140" y="21" fill="#C8E632" rx="1"></rect><path fill="#000" d="m140 37-9 4.5v-9l9 4.5Z"></path><path fill="#1469AF" d="M172 32.5h9v9h-9z"></path><rect width="32" height="32" x="246" y="21" fill="#2B94B1" rx="1"></rect><path fill="#000" d="m246 37-9 4.5v-9l9 4.5Z"></path><path fill="#fff" d="M254 29h16v16h-16z"></path><path fill="#3E3A39" d="M255 29v15h15v1h-16V29h1Z"></path><path stroke="#3E3A39" d="M256.5 44v-6m2 6V34m2 10v-4m2 4v-8m2 8V33m2 11v-2m2 2v-3"></path><path fill="#3E3A39" d="M157 29h2v3h5v6h-2v-4h-7v4h4v7h-2v-5h-7v5h-2v-7h5v-6h4v-3Z"></path><rect width="64" height="9" x="18" y="1" fill="#C0C4C6" fill-opacity=".5" rx="4.5"></rect><rect width="54" height="9" x="129" y="1" fill="#C0C4C6" fill-opacity=".5" rx="4.5"></rect><rect width="74" height="9" x="225" y="1" fill="#C0C4C6" fill-opacity=".5" rx="4.5"></rect>', 18), Qpt = [Zpt];
function emt(e, t) {
    return _(),
    O("svg", Jpt, Qpt)
}
const tmt = {
    render: emt
}, nmt = Fe({
    components: {
        Button: Pr,
        DummyNodes: tmt
    },
    methods: {
        openWorkflowCoachPreferencePage() {
            Oe.desktop.openWorkflowCoachPreferencePage()
        }
    }
});
const rmt = {
    class: "disabled-workflow-coach"
}, omt = P("span", null, [mt(" The "), P("strong", null, "workflow coach"), mt(" will help you build workflows by suggesting nodes. To activate this function change the settings in the preference page. ")], -1);
function imt(e, t, n, r, o, i) {
    const s = B("DummyNodes"),
    a = B("Button");
    return _(),
    O("div", rmt, [z(s, {
                class: "dummy-nodes"
            }), omt, z(a, {
                primary: "",
                class: "button",
                onClick: e.openWorkflowCoachPreferencePage
            }, {
            default:
                oe(() => [mt(" Open Preferences ")]),
                _: 1
            }, 8, ["onClick"])])
}
const smt = te(nmt, [["render", imt]]), amt = {
    class: "not-ready"
}, lmt = ["value"], cmt = {
    class: "progress-message"
}, umt = Fe({
    __name: "NodeRepositoryLoader",
    props: {
        progress: {
        default:
            0
        },
        extensionName: {
        default:
            ""
        }
    },
    setup(e) {
        const t = e,
        n = o => o.toFixed(),
        r = ne(() => n(t.progress * 100));
        return (o, i) => (_(), O("div", amt, [P("span", null, Re(r.value) + "%", 1), P("progress", {
                        value: r.value,
                        max: "100"
                    }, null, 8, lmt), P("div", cmt, [P("span", null, Re(o.extensionName), 1)])]))
    }
});
const dmt = te(umt, [["__scopeId", "data-v-cdd10a06"]]), fmt = ({
    targetPorts: e,
    sourcePort: t,
    availablePortTypes: n
}) => {
    const r = e.findIndex(s => Lm({
                fromPort: t,
                toPort: s,
                availablePortTypes: n
            })),
    o = e.length + 1,
    i = Ky({
        portCount: o
    });
    return r === -1 && t.index === 0 ? i[0] : i[r + 1]
}, nM = Fe({
    components: {
        QuickAddNodeDisabledWorkflowCoach: smt,
        QuickAddNodeRecommendations: Xpt,
        QuickAddNodeSearchResults: zpt,
        SearchBar: $9,
        NodePortActiveConnector: bF,
        FloatingMenu: qw,
        NodeRepositoryLoader: dmt
    },
    props: {
        nodeId: {
            type: [String, null],
        default:
            null
        },
        position: {
            type: Object,
            required: !0
        },
        port: {
            type: [Object, null],
        default:
            null
        }
    },
    emits: ["menuClose"],
    data() {
        return {
            selectedNode: null
        }
    },
    computed: {
        ...ut("application", ["hasNodeRecommendationsEnabled", "availablePortTypes", "nodeRepositoryLoaded", "nodeRepositoryLoadingProgress"]),
        ...ut("settings", {
            displayMode: e => e.settings.nodeRepositoryDisplayMode
        }),
        ...ut("canvas", ["zoomFactor"]),
        ...ut("quickAddNodes", ["recommendedNodes"]),
        ...zt("workflow", ["isWritable", "getNodeById"]),
        ...zt("quickAddNodes", ["searchIsActive", "getFirstResult"]),
        canvasPosition() {
            let e = {
                ...this.position
            };
            const t = this.$shapes.portSize / 2;
            return e.x += t,
            e
        },
        isContainerNode() {
            return ["metanode", "component"].includes(this.getNodeById(this.nodeId)?.kind)
        },
        fakePortConnector() {
            const t = this.availablePortTypes[this.port?.typeId]?.kind === "flowVariable";
            return {
                id: `quick-add-${this.nodeId}-${this.portIndex}`,
                flowVariableConnection: t,
                absolutePoint: [this.position.x, this.position.y],
                allowedActions: {
                    canDelete: !1
                },
                interactive: !1,
                sourceNode: this.nodeId,
                sourcePort: this.portIndex
            }
        },
        marginTop() {
            const e = this.$shapes.addNodeGhostSize * this.zoomFactor,
            t = Math.log(e) / 1.1;
            return `${e / 2 + t + 3}px`
        },
        portIndex() {
            return this.port ? this.port.index : null
        }
    },
    watch: {
        hasNodeRecommendationsEnabled: {
            immediate: !0,
            handler() {
                this.hasNodeRecommendationsEnabled && this.fetchNodeRecommendations()
            }
        },
        async port(e, t) {
            e?.index !== t?.index && (await this.$store.dispatch("quickAddNodes/clearSearchParams"), this.$store.commit("quickAddNodes/setPortTypeId", e.typeId), await this.fetchNodeRecommendations())
        }
    },
    mounted() {
        this.port && this.$store.commit("quickAddNodes/setPortTypeId", this.port.typeId),
        this.$refs.search?.focus(),
        this.$store.dispatch("application/subscribeToNodeRepositoryLoadingEvent")
    },
    beforeUnmount() {
        this.$store.dispatch("quickAddNodes/clearRecommendedNodesAndSearchParams")
    },
    methods: {
        ...Er("workflow", {
            addNodeToWorkflow: "addNode"
        }),
        ...Er("quickAddNodes", ["searchNodesNextPage"]),
        async fetchNodeRecommendations() {
            if (this.isContainerNode)
                return;
            const {
                nodeId: e,
                portIndex: t
            } = this;
            await this.$store.dispatch("quickAddNodes/getNodeRecommendations", {
                nodeId: e,
                portIdx: t
            })
        },
        async addNode(e) {
            if (!this.isWritable || e === null)
                return;
            const {
                nodeFactory: t,
                inPorts: n
            } = e,
            [r, o] = this.port ? fmt({
                targetPorts: n,
                sourcePort: this.port,
                availablePortTypes: this.availablePortTypes
            }) : [0, 0], {
                canvasPosition: {
                    x: i,
                    y: s
                }
            } = this;
            await this.$store.dispatch("workflow/addNode", {
                position: {
                    x: i - r,
                    y: s - o
                },
                nodeFactory: t,
                sourceNodeId: this.nodeId,
                sourcePortIdx: this.portIndex
            }),
            this.$emit("menuClose")
        },
        searchEnterKey() {
            this.addNode(this.getFirstResult())
        },
        searchDownKey() {
            this.$refs.recommendationResults?.focusFirst(),
            this.$refs.searchResults?.focusFirst()
        },
        searchHandleShortcuts(e) {
            let t = this.$shortcuts.findByHotkey(e);
            t === "quickAddNode" && this.$shortcuts.isEnabled(t) && (this.$shortcuts.dispatch(t), e.preventDefault(), e.stopPropagation())
        },
        openKnimeUIPreferencePage() {
            Oe.desktop.openWebUIPreferencePage()
        }
    }
}), _R = () => {
    to(e => ({
            "34c78df8": e.marginTop
        }))
}, kR = nM.setup;
nM.setup = kR ? (e, t) => (_R(), kR(e, t)) : _R;
const hmt = e => (ir("data-v-6e645115"), e = e(), sr(), e), pmt = {
    class: "wrapper"
}, mmt = {
    class: "header"
}, gmt = hmt(() => P("hr", null, null, -1));
function vmt(e, t, n, r, o, i) {
    const s = B("NodePortActiveConnector"),
    a = B("SearchBar"),
    l = B("QuickAddNodeDisabledWorkflowCoach"),
    c = B("QuickAddNodeSearchResults"),
    u = B("QuickAddNodeRecommendations"),
    f = B("NodeRepositoryLoader"),
    p = B("FloatingMenu");
    return _(),
    H(p, {
        class: "quick-add-node",
        "canvas-position": e.canvasPosition,
        "aria-label": "Quick add node",
        "prevent-overflow": !0,
        onMenuClose: t[8] || (t[8] = m => e.$emit("menuClose"))
    }, {
    default:
        oe(() => [z(s, {
                    port: e.port,
                    targeted: !1,
                    direction: "out",
                    "drag-connector": e.fakePortConnector,
                    "did-drag-to-compatible-target": !1,
                    "disable-quick-node-add": !1
                }, null, 8, ["port", "drag-connector"]), P("div", pmt, [P("div", mmt, [z(a, {
                                    ref: "search",
                                    disabled: !e.nodeRepositoryLoaded,
                                    "model-value": e.$store.state.quickAddNodes.query,
                                    placeholder: "Search compatible nodes",
                                    class: "search-bar",
                                    tabindex: "-1",
                                    "onUpdate:modelValue": t[0] || (t[0] = m => e.$store.dispatch("quickAddNodes/updateQuery", m)),
                                    onFocusin: t[1] || (t[1] = m => e.selectedNode = null),
                                    onKeydown: [Rt(ve(e.searchEnterKey, ["prevent", "stop"]), ["enter"]), Rt(ve(e.searchDownKey, ["prevent", "stop"]), ["down"]), e.searchHandleShortcuts]
                                }, null, 8, ["disabled", "model-value", "onKeydown"])]), gmt, e.nodeRepositoryLoaded ? (_(), O(Le, {
                                key: 0
                            }, [!e.hasNodeRecommendationsEnabled && !e.searchIsActive && !e.isContainerNode ? (_(), H(l, {
                                            key: 0
                                        })) : (_(), O(Le, {
                                            key: 1
                                        }, [e.searchIsActive ? (_(), H(c, {
                                                        key: 0,
                                                        ref: "searchResults",
                                                        "selected-node": e.selectedNode,
                                                        "onUpdate:selectedNode": t[2] || (t[2] = m => e.selectedNode = m),
                                                        "display-mode": e.displayMode,
                                                        onNavReachedTop: t[3] || (t[3] = m => e.$refs.search.focus()),
                                                        onAddNode: t[4] || (t[4] = m => e.addNode(m)),
                                                        onOpenPreferences: e.openKnimeUIPreferencePage
                                                    }, null, 8, ["selected-node", "display-mode", "onOpenPreferences"])) : (_(), H(u, {
                                                        key: 1,
                                                        ref: "recommendationResults",
                                                        "selected-node": e.selectedNode,
                                                        "onUpdate:selectedNode": t[5] || (t[5] = m => e.selectedNode = m),
                                                        "disable-recommendations": e.isContainerNode,
                                                        "display-mode": e.displayMode,
                                                        onNavReachedTop: t[6] || (t[6] = m => e.$refs.search.focus()),
                                                        onAddNode: t[7] || (t[7] = m => e.addNode(m))
                                                    }, null, 8, ["selected-node", "disable-recommendations", "display-mode"]))], 64))], 64)) : (_(), H(f, {
                                key: 1,
                                progress: e.nodeRepositoryLoadingProgress?.progress,
                                "extension-name": e.nodeRepositoryLoadingProgress?.extensionName
                            }, null, 8, ["progress", "extension-name"]))])]),
        _: 1
    }, 8, ["canvas-position"])
}
const ymt = te(nM, [["render", vmt], ["__scopeId", "data-v-6e645115"]]), wmt = {
    key: 0,
    class: "banner"
}, bmt = Fe({
    __name: "RemoteWorkflowInfo",
    setup(e) {
        to(l => ({
                "01a78abe": pI.warning
            }));
        const t = po(),
        n = ne(() => t.getters["application/isUnknownProject"]),
        r = ne(() => t.state.application.permissions),
        o = ne(() => t.getters["spaces/activeProjectProvider"]),
        i = ne(() => t.state.application.activeProjectId),
        s = ne(() => !n.value && o.value?.type === Cf.TypeEnum.SERVER),
        a = ne(() => W6 && !r.value.canEditWorkflow ? !1 : i.value && (n.value || s.value));
        return (l, c) => a.value ? (_(), O("div", wmt, [P("span", null, [n.value ? (_(), O(Le, {
                                    key: 0
                                }, [mt(" You have opened a workflow that is not part of your spaces. “Save” a local copy to keep your changes. ")], 64)) : J("", !0), s.value ? (_(), O(Le, {
                                    key: 1
                                }, [mt(" You have opened a workflow from a KNIME Server. “Save” the workflow back to KNIME Server to keep your changes. ")], 64)) : J("", !0)])])) : J("", !0)
    }
});
const _mt = te(bmt, [["__scopeId", "data-v-c847afe0"]]), kmt = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    stroke: "#000",
    "stroke-linejoin": "round",
    viewBox: "0 0 32 32"
}, xmt = P("path", {
    d: "M27.5 3.214h-7c-.825 0-1.5.675-1.5 1.5v7c0 .825.675 1.5 1.5 1.5h7c.825 0 1.5-.675 1.5-1.5v-7c0-.825-.675-1.5-1.5-1.5zm-16 15.572h-7c-.825 0-1.5.675-1.5 1.5v7c0 .825.675 1.5 1.5 1.5h7c.825 0 1.5-.675 1.5-1.5v-7c0-.825-.675-1.5-1.5-1.5zm-8.059.441 9.118 9.118m6.882-24.69 9.118 9.118"
}, null, -1), Smt = P("path", {
    "stroke-dasharray": "2 2",
    "stroke-dashoffset": ".35",
    d: "M12.991 24.223c6.08 0 11.009-4.929 11.009-11.009"
}, null, -1), Cmt = [xmt, Smt];
function Imt(e, t) {
    return _(),
    O("svg", kmt, Cmt)
}
const Tmt = {
    render: Imt
}, Mmt = {
    class: "streaming-indicator"
}, Pmt = Fe({
    __name: "StreamingInfo",
    setup(e) {
        return (t, n) => (_(), O("span", Mmt, [z(ke(Tmt), {
                        class: "icon"
                    }), mt(" Streaming ")]))
    }
});
const Emt = te(Pmt, [["__scopeId", "data-v-ce5aa6fe"]]), Omt = {
    class: "stack"
}, $mt = {
    key: 0,
    class: "workflow-info"
}, Amt = {
    key: 0,
    class: "linked"
}, Dmt = {
    key: 1,
    class: "linked"
}, Nmt = {
    key: 1,
    class: "workflow-info"
}, Rmt = Fe({
    __name: "WorkflowInfoBar",
    setup(e) {
        to(c => ({
                "459e6def": n.value,
                "7237ab05": pI.info
            }));
        const t = po(),
        n = ne(() => t.state.canvas.containerSize.width),
        r = ne(() => t.getters["workflow/isLinked"]),
        o = ne(() => t.getters["workflow/isInsideLinked"]),
        i = ne(() => t.getters["workflow/isStreaming"]),
        s = ne(() => t.getters["workflow/isRemoteWorkflow"]),
        a = ne(() => t.getters["workflow/insideLinkedType"]),
        l = ne(() => t.state.workflow.activeWorkflow.info.containerType);
        return (c, u) => (_(), O("div", Omt, [r.value || o.value ? (_(), O("div", $mt, [o.value ? (_(), O("span", Amt, " This is a " + Re(l.value) + " inside a linked " + Re(a.value) + " and cannot be edited. ", 1)) : r.value ? (_(), O("span", Dmt, " This is a linked " + Re(l.value) + " and therefore cannot be edited. ", 1)) : J("", !0)])) : J("", !0), s.value ? (_(), O("div", Nmt, [z(_mt)])) : J("", !0), i.value ? (_(), O("div", {
                            key: 2,
                            class: he(["workflow-info", {
                                        "only-streaming": i.value
                                    }
                                ])
                        }, [z(Emt)], 2)) : J("", !0)]))
    }
});
const Lmt = te(Rmt, [["__scopeId", "data-v-1acff400"]]), Bmt = Fe({
    components: {
        ContextMenu: yXe,
        WorkflowCanvas: gft,
        QuickAddNodeMenu: ymt,
        PortTypeMenu: xht,
        WorkflowInfoBar: Lmt
    },
    computed: {
        ...ut("workflow", {
            workflow: e => e.activeWorkflow,
            activeWorkflowId: e => e.activeWorkflow.info.containerId
        }),
        ...ut("workflow", ["portTypeMenu", "quickAddNodeMenu"]),
        ...ut("application", ["contextMenu"]),
        ...zt("workflow", ["isLinked", "isInsideLinked", "insideLinkedType", "isWritable", "isStreaming", "isRemoteWorkflow"]),
        ...zt("canvas", ["screenToCanvasCoordinates"]),
        ...zt("selection", ["selectedNodeIds"]),
        ...zt("application", ["hasActiveProjectAnOrigin", "hasAnnotationModeEnabled"])
    },
    watch: {
        selectedNodeIds() {
            this.quickAddNodeMenu.isOpen && this.quickAddNodeMenu.events.menuClose()
        }
    },
    methods: {
        toggleContextMenu(e) {
            this.$store.dispatch("application/toggleContextMenu", {
                event: e
            })
        },
        onContextMenu(e) {
            e.srcElement.classList.contains("native-context-menu") || e.preventDefault()
        },
        onSaveLocalCopy() {
            this.$store.dispatch("workflow/saveWorkflowAs")
        }
    }
});
function Vmt(e, t, n, r, o, i) {
    const s = B("ContextMenu"),
    a = B("PortTypeMenu"),
    l = B("QuickAddNodeMenu"),
    c = B("PortalTarget"),
    u = B("WorkflowInfoBar"),
    f = B("WorkflowCanvas");
    return _(),
    O("div", {
        class: he(["workflow-panel", {
                    "read-only": !e.isWritable
                }, {
                    "annotation-cursor": e.hasAnnotationModeEnabled
                }
            ]),
        onContextmenu: t[0] || (t[0] = ve((...p) => e.onContextMenu && e.onContextMenu(...p), ["stop"])),
        onPointerdown: t[1] || (t[1] = ve(p => e.contextMenu.isOpen && e.toggleContextMenu(p), ["right"]))
    }, [e.contextMenu.isOpen ? (_(), H(s, {
                    key: 0,
                    position: e.contextMenu.position,
                    onMenuClose: e.toggleContextMenu
                }, null, 8, ["position", "onMenuClose"])) : J("", !0), e.portTypeMenu.isOpen ? (_(), H(a, Bt({
                        key: 1
                    }, e.portTypeMenu.props, O0(e.portTypeMenu.events)), null, 16)) : J("", !0), e.quickAddNodeMenu.isOpen ? (_(), H(l, Bt({
                        key: 2
                    }, e.quickAddNodeMenu.props, O0(e.quickAddNodeMenu.events)), null, 16)) : J("", !0), z(c, {
                name: "annotation-editor-toolbar",
                tag: "div"
            }), z(u), (_(), H(f, {
                    key: `${e.workflow.projectId}-${e.activeWorkflowId}`
                }))], 34)
}
const Fmt = te(Bmt, [["render", Vmt], ["__scopeId", "data-v-bacce417"]]);
const jmt = {
    components: {
        Sidebar: mye,
        WorkflowPanel: Fmt,
        NodeOutput: IUe,
        SplitPanel: k0e,
        WorkflowToolbar: uXe,
        TooltipContainer: VUe
    },
    computed: {
        ...ut("workflow", {
            workflow: "activeWorkflow"
        }),
        savedSecondarySize: {
            get() {
                return this.$store.state.settings.settings.nodeOutputSize
            },
            set(e) {
                this.$store.dispatch("settings/updateSetting", {
                    key: "nodeOutputSize",
                    value: e
                })
            }
        }
    }
}, Wmt = {
    key: 0,
    id: "workflow-page"
}, zmt = {
    class: "workflow-area"
};
function Hmt(e, t, n, r, o, i) {
    const s = B("WorkflowToolbar"),
    a = B("TooltipContainer"),
    l = B("Sidebar"),
    c = B("WorkflowPanel"),
    u = B("NodeOutput"),
    f = B("SplitPanel");
    return e.workflow ? (_(), O("div", Wmt, [z(s, {
                    id: "toolbar"
                }), z(a, {
                    id: "tooltip-container"
                }), z(l, {
                    id: "sidebar"
                }), P("main", zmt, [z(f, {
                            id: "kanvasOutputSplitter",
                            "secondary-size": i.savedSecondarySize,
                            "onUpdate:secondarySize": t[0] || (t[0] = p => i.savedSecondarySize = p),
                            direction: "down"
                        }, {
                            secondary: oe(() => [z(u)]),
                        default:
                            oe(() => [z(c, {
                                        id: "workflow-panel"
                                    })]),
                            _: 1
                        }, 8, ["secondary-size"])])])) : J("", !0)
}
const Umt = te(jmt, [["render", Hmt], ["__scopeId", "data-v-166e49f7"]]), xR = (e, t) => e === hc ? [t] : [], $S = [{
        name: zo.WorkflowPage,
        path: "/workflow/:projectId/:workflowId",
        component: Umt
    }, ...xR("DESKTOP", {
        path: "/",
        component: () => Ks(() => import("./EntryPageLayout-099c4e53.js"), ["./EntryPageLayout-099c4e53.js", "./rocket-ea4b98d9.js", "./PageHeader-a42ebd51.js", "./PageHeader-7ef1c961.css", "./arrow-right-0785f3ac.js", "./EntryPageLayout-32ef1526.css"], import.meta.url),
        children: [{
                name: zo.EntryPage.GetStartedPage,
                path: "/get-started",
                component: () => Ks(() => import("./GetStartedPage-1a8d59cb.js"), ["./GetStartedPage-1a8d59cb.js", "./computer-desktop-f6256e82.js", "./GetStartedPage-65b67791.css"], import.meta.url),
                meta: {
                    showUpdateBanner: !0
                }
            }
        ]
    }), ...xR("DESKTOP", {
        name: zo.SpaceBrowsingPage,
        path: "/space-browsing",
        component: () => Ks(() => import("./SpaceBrowsingPage-3d07556a.js"), ["./SpaceBrowsingPage-3d07556a.js", "./computer-desktop-f6256e82.js", "./PageHeader-a42ebd51.js", "./PageHeader-7ef1c961.css", "./SpaceExplorer-8f8b6a5c.js", "./trash-c1de9387.js", "./pencil-ca93310a.js", "./house-1d05c0b5.js", "./house-ff15d853.css", "./SpaceExplorer-94ebb666.css", "./SpaceBrowsingPage-867d0892.css"], import.meta.url)
    })], mgt = e => {
    const t = (n, r, o = "") => {
        const i = n.find(a => a.name === r);
        if (i)
            return `${o}${i.path}`;
        let s = null;
        for (let a = 0; a < n.length; a++) {
            const l = n[a];
            l.children && (s = t($S[a].children, r, l.path))
        }
        return s
    };
    return t($S, e).replaceAll("//", "/")
}, SR = p0e({
    history: Eve(),
    routes: $S
}), qmt = Fe({
    props: {
        to: {
            type: String,
            required: !0
        }
    },
    data() {
        return {
            isMounted: !1
        }
    },
    mounted() {
        this.isMounted = !0
    }
});
function Ymt(e, t, n, r, o, i) {
    return e.isMounted ? (_(), H(H1, {
            key: 0,
            to: `#${e.to}`
        }, [Ye(e.$slots, "default")], 8, ["to"])) : J("", !0)
}
const Kmt = te(qmt, [["render", Ymt]]), Gmt = Fe({
    props: {
        tag: {
            type: String,
            required: !0,
            validator: e => ["g", "div"].includes(e)
        },
        name: {
            type: String,
            required: !0
        }
    }
});
function Xmt(e, t, n, r, o, i) {
    return _(),
    H(Kt(e.tag), {
        id: e.name,
        "data-portal-target": e.name
    }, null, 8, ["id", "data-portal-target"])
}
const Jmt = te(Gmt, [["render", Xmt]]), Zmt = ({
    app: e
}) => {
    e.config.globalProperties.$colors = Fme,
    e.config.globalProperties.$shapes = dw
};
function Qmt(e) {
    return new Promise(t => setTimeout(t, e))
}
const egt = 2e3, AS = De(!1), C0 = De(!1), rM = es({}), tgt = ne(() => Boolean(rM.disclaimer)), oM = async() => {
    if (!C0.value) {
        C0.value = !0;
        try {
            const e = await Oe.desktop.getUiStrings();
            Object.assign(rM, e),
            AS.value = !0
        } catch {
            await Qmt(egt),
            AS.value = !1
        }
        finally {
            C0.value = !1
        }
    }
};
oM();
const ggt = () => ({
    uiStrings: rM,
    hasDisclaimer: tgt,
    isLoading: C0,
    isServerAvailable: AS,
    fetchUiStrings: oM
}), ngt = ({
    $store: e,
    $router: t,
    $toast: n
}) => {
    Oe.event.registerEventHandlers({
        CompositeEvent({
            events: r,
            params: o,
            eventHandlers: i
        }) {
            r.forEach((s, a) => {
                const l = i.get(s);
                o[a] && l(o[a])
            })
        },
        WorkflowChangedEvent({
            patch: {
                ops: r
            },
            snapshotId: o
        }) {
            r.forEach(i => {
                i.path = `/activeWorkflow${i.path}`
            }),
            e.dispatch("workflow/patch.apply", r),
            o && tle(o)
        },
        ProjectDirtyStateEvent({
            dirtyProjectsMap: r,
            shouldReplace: o
        }) {
            o ? e.dispatch("application/setDirtyProjectsMap", r) : e.dispatch("application/updateDirtyProjectsMap", r)
        },
        AppStateChangedEvent({
            appState: r
        }) {
            e.dispatch("application/replaceApplicationState", r),
            r.openProjects && e.dispatch("application/setActiveProject", {
                $router: t
            }),
            e.dispatch("application/updateGlobalLoader", {
                loading: !1
            })
        },
        UpdateAvailableEvent({
            newReleases: r,
            bugfixes: o
        }) {
            (r || o) && e.commit("application/setAvailableUpdates", {
                newReleases: r,
                bugfixes: o
            })
        },
        NodeRepositoryLoadingProgressEvent({
            progress: r,
            extensionName: o
        }) {
            e.commit("application/setNodeRepositoryLoadingProgress", {
                progress: r,
                extensionName: o
            })
        },
        ShowToastEvent(r) {
            n.show(r)
        },
        ProjectDisposedEvent() {
            e.dispatch("application/updateGlobalLoader", {
                loading: !0,
                config: {
                    displayMode: "transparent"
                }
            }),
            n.show({
                headline: "Session expired",
                message: "Refresh the page to reactivate the session",
                type: "error",
                autoRemove: !1
            })
        }
    }),
    Oe.desktop.registerEventHandlers({
        async SaveAndCloseWorkflowsEvent({
            projectIds: r,
            params: o = []
        }) {
            await e.dispatch("application/updateGlobalLoader", {
                loading: !0
            });
            const i = async(l, c, u) => {
                try {
                    return c === u ? await l.dispatch("application/getActiveWorkflowSnapshot") : await l.dispatch("application/getRootWorkflowSnapshotByProjectId", {
                        projectId: c
                    })
                } catch (f) {
                    return consola.error(f),
                    null
                }
            },
            s = e.state.workflow.activeWorkflow?.projectId,
            a = r.map(l => i(e, l, s));
            try {
                const l = await Promise.all(a),
                c = r.length;
                await Oe.desktop.saveAndCloseWorkflows({
                    totalProjects: c,
                    projectIds: r,
                    svgSnapshots: l,
                    params: o
                })
            } catch {
                await e.dispatch("application/updateGlobalLoader", {
                    loading: !1
                }),
                n.show({
                    headline: "Error saving your work",
                    type: "error",
                    message: "There was a problem saving one of your workflows. Please try again or save them individually"
                })
            }
            try {
                for (const l of r)
                    await e.dispatch("application/removeCanvasState", l, {
                        root: !0
                    }), await e.dispatch("application/removeFromRootWorkflowSnapshots", {
                        projectId: l
                    }, {
                        root: !0
                    })
            } catch (l) {
                consola.error("Error tearing down canvas or workflow snapshot state", {
                    error: l
                })
            }
        },
        ImportURIEvent({
            x: r,
            y: o
        }) {
            const i = document.elementFromPoint(r, o);
            if (e.state.canvas.getScrollContainerElement().contains(i)) {
                const [a, l] = e.getters["canvas/screenToCanvasCoordinates"]([r, o]),
                c = e.state.workflow.activeWorkflow;
                Oe.desktop.importURIAtWorkflowCanvas({
                    uri: null,
                    projectId: c.projectId,
                    workflowId: c.info.containerId,
                    x: a - fr / 2,
                    y: l - fr / 2
                })
            }
        },
        ProgressEvent({
            status: r,
            text: o
        }) {
            const i = r === "STARTED",
            s = i ? {
                displayMode: "toast",
                loadingMode: "normal"
            }
             : null;
            e.dispatch("application/updateGlobalLoader", {
                loading: i,
                config: s,
                text: o
            })
        },
        AiAssistantEvent({
            chainType: r,
            data: o
        }) {
            e.dispatch("aiAssistant/handleAiAssistantEvent", {
                chainType: r,
                data: o
            })
        },
        AiAssistantServerChangedEvent() {
            e.dispatch("aiAssistant/getHubID"),
            oM()
        },
        DesktopAPIFunctionResultEvent(r) {
            Ir.emit(`desktop-api-function-result-${r.name}`, r.result)
        },
        SpaceProvidersChangedEvent(r) {
            if ("error" in r) {
                consola.error("Error fetching space providers", r.error),
                e.commit("spaces/setIsLoadingProvider", !1),
                e.commit("setHasLoadedProviders", !1);
                return
            }
            e.dispatch("spaces/setAllSpaceProviders", r.result)
        }
    })
}, rgt = ({
    app: e,
    store: t,
    router: n
}) => {
    const r = o => ({
        install(i) {
            o({
                app: i,
                $store: t,
                $router: n,
                $toast: i.config.globalProperties.$toast
            })
        }
    });
    e.use(r(eXe)),
    e.use(r(Zmt)),
    e.use(r(ngt)),
    e.use(r(sle)),
    e.use(r(Q0e)),
    e.component("Portal", Kmt),
    e.component("PortalTarget", Jmt)
};
_de();
window.Vue = oL;
const ogt = "KNIME_UI__AWAITING_CONNECTION_INFO", igt = "KNIME_UI__CONNECTION_INFO", sgt = "KNIME_UI__CONNECTION_FAIL", agt = e => e.includes("knime.com"), lgt = () => new Promise((e, t) => {
    if (Es) {
        e(null);
        return
    }
    if ({}
        .VITE_BROWSER_DEV_MODE) {
        e({
            url: {}
            .VITE_BROWSER_DEV_WS_URL,
            restApiBaseUrl: {}
            .VITE_BROWSER_DEV_REST_API_BASE_URL,
            jobId: "",
            sessionId: ""
        });
        return
    }
    window.addEventListener("message", n => {
        if (!agt(n.origin)) {
            consola.error(`invalid origin received: ${n.origin}`);
            return
        }
        if (n.data.type !== igt)
            return;
        const {
            data: r
        } = n;
        consola.log("received connection info message", r);
        const {
            payload: o
        } = r;
        (!o.url || !o.jobId || !o.sessionId) && (consola.error("incorrect connection info payload", r), t(new Error("incorrect connection info payload"))),
        e(r.payload)
    }, !1),
    consola.log("posting message to parent window"),
    window.parent.postMessage({
        type: ogt
    }, "*")
});
try {
    const e = fve(),
    n = ag().getToastServicePlugin(),
    r = await lgt();
    await Vae(hc, r, e);
    const o = nL(yde);
    o.use(n),
    ap({
        BROWSER: () => {
            e.commit("api/setRestApiBaseUrl", r.restApiBaseUrl)
        }
    }),
    q9.initStore(e),
    rgt({
        app: o,
        store: e,
        router: SR
    }),
    Jae(o),
    o.use(e),
    o.use(SR),
    o.mount("#app")
} catch (e) {
    consola.log("Could not initialize Application due to:", e),
    window.parent.postMessage({
        type: sgt,
        error: e
    }, "*")
}
export {
    to as $,
    zo as A,
    Pr as B,
    A0e as C,
    De as D,
    ZI as E,
    Le as F,
    Oe as G,
    Uht as H,
    hW as I,
    cg as J,
    Fce as K,
    kee as L,
    Q6 as M,
    nl as N,
    ne as O,
    hJe as P,
    ke as Q,
    AYe as R,
    Cf as S,
    ve as T,
    ti as U,
    Pye as V,
    Lje as W,
    Rct as X,
    $je as Y,
    Er as Z,
    te as _,
    P as a,
    W0 as a$,
    rWe as a0,
    Ace as a1,
    qu as a2,
    wa as a3,
    es as a4,
    Es as a5,
    Ht as a6,
    z0 as a7,
    Xt as a8,
    km as a9,
    Cn as aA,
    MYe as aB,
    Jlt as aC,
    fpt as aD,
    $9 as aE,
    wn as aF,
    Ur as aG,
    dmt as aH,
    ho as aI,
    F1e as aJ,
    vI as aK,
    nI as aL,
    NB as aM,
    LB as aN,
    mw as aO,
    MB as aP,
    cc as aQ,
    rF as aR,
    ca as aS,
    Kn as aT,
    x9 as aU,
    cT as aV,
    rde as aW,
    Ux as aX,
    Ci as aY,
    _ft as aZ,
    zk as a_,
    wf as aa,
    Xn as ab,
    P9 as ac,
    TB as ad,
    Vf as ae,
    al as af,
    r7 as ag,
    lI as ah,
    ag as ai,
    ri as aj,
    po as ak,
    wu as al,
    tc as am,
    $ht as an,
    Hk as ao,
    rh as ap,
    fgt as aq,
    Fpt as ar,
    Bt as as,
    NW as at,
    gpt as au,
    eg as av,
    Za as aw,
    w7 as ax,
    XI as ay,
    W1 as az,
    B as b,
    ade as b0,
    Ha as b1,
    Ks as b2,
    CYe as b3,
    dgt as b4,
    fr as b5,
    g0e as b6,
    w6 as b7,
    tC as b8,
    nue as b9,
    H1 as bA,
    oa as bB,
    HR as bC,
    O0 as bD,
    QX as bE,
    z1 as bF,
    ZS as bG,
    Rt as bH,
    Rs as bI,
    cgt as bJ,
    iC as ba,
    ggt as bb,
    b6 as bc,
    og as bd,
    E1 as be,
    OR as bf,
    ii as bg,
    Z1 as bh,
    gHe as bi,
    t4 as bj,
    oI as bk,
    am as bl,
    Dr as bm,
    cwe as bn,
    Z0e as bo,
    eM as bp,
    Ff as bq,
    br,
    pW as bs,
    k7 as bt,
    Wye as bu,
    bHe as bv,
    Rye as bw,
    mJ as bx,
    ap as by,
    Xw as bz,
    O as c,
    H as d,
    Kt as e,
    J as f,
    mt as g,
    $t as h,
    mgt as i,
    z as j,
    Yt as k,
    dt as l,
    ugt as m,
    he as n,
    _ as o,
    ut as p,
    wm as q,
    Ye as r,
    bm as s,
    Re as t,
    ir as u,
    sr as v,
    oe as w,
    Fe as x,
    zt as y,
    Ww as z
};
